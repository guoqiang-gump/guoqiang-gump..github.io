[{"title":"在线监控项目复盘-Qt知识点","date":"2021-09-19T12:41:54.000Z","path":"2021/09/19/在线监控项目复盘-Qt知识点/","text":"1. Qt对象的依附性和事务循环 (16条消息) Qt多线程中的信号与槽_echo_bright_的博客-CSDN博客_qt多线程信号与槽 (1)使用 继承自QThread类的子类，在run()函数里面代码属于子线程，比如程序运行时发送信号操作在子线程完成，对应的槽函数却是在main线程执行，究其原因，得从Qt对象的依附性说起。 在Qt编程中，默认情况下，对象依附于创建自身的线程，例如上面代码中TestThread对象t它是在main()函数中创建的，那么t依附于主线程，而槽函数在其所依附的线程中被调用执行，因此，槽函数TestThread_Slot()是在main线程中执行。 要想让TestThread_Slot()函数运行在main()创建的子线程中，可以使用moveToThread()函数更改TestThread对象所依附的线程： 12345bool QObject::connect (const QObject * sender, const char * signal, const QObject * receiver, const char * method, Qt::ConnectionType type &#x3D; Qt::AutoConnection) 其中第5个参数决定信号与槽的连接方式，用于决定槽函数被调用时的相关行为。 Qt::AutoConnection 默认连接Qt::DirectConnection 槽函数立即调用Qt::BlockingQueuedConnection 同步调用Qt::QueuedConnection 异步调用Qt::UniqueConnection 单一连接 (1) Qt::DirectConnection(立即调用) 直接在发送信号的线程中调用槽函数(发送信号和槽函数位于同一线程)，等价于槽函数的实时调用。 (2) Qt::QueuedConnection(异步调用) 信号发送至目标线程的事件队列(发送信号和槽函数位于不同线程)，交由目标线程处理，当前线程继续向下执行。 (3) Qt::BlockingQueuedConnection(同步调用) 信号发送至目标线程的事件队列，由牧宝想线程处理。当前线程阻塞等待槽函数的返回，之后向下执行。 (4) Qt::AutoConnection(默认连接) 当发送信号线程=槽函数线程时，效果等价于Qt::DirectConnection； 当发送信号线程!=槽函数线程时，效果等价于Qt::QueuedConnection。 Qt::AutoConnection是connect()函数第5个参数的默认值，也是实际开发中字常用的连接方式。 (5) Qt::UniqueConnection(单一连接) 功能和AutoConnection相同，同样能自动确定连接类型，但是加了限制：同一个信号和同一个槽函数之间只能有一个连接。","link":"","tags":[]},{"title":"在线监控项目复盘-项目难点和项目提高","date":"2021-09-19T12:16:55.000Z","path":"2021/09/19/在线监控项目复盘-项目难点和项目提高/","text":"\\项目存在问题和难点**： 1、环境配置。一开始在开发板上出厂系统没有nginx，自己编译的bulidroot文件系统不知道为什么不能识别出摄像头。只能硬着头皮编译移植nginx，搞了差不多两天才编译成功。所以感觉到bulidroot文件系统移植库真的太方便了。 发现imx6ull芯片的视频编码性能太弱了，而且开发板的文件系统移植库很麻烦，我就在win10下开发项目了。在win10配置环境也很麻烦，要用到cmake，我用cmake编译ffmpeg库和opencv库都没有成功，最后在网上下载别人编译好的库。 2、多线程通信。在拉流端，ffmpeg线程拉流获取音视频数据，opencv线程需要接受ffmpeg的数据。这里面就是线程同步问题。一开始两根线程都是继承qthread类，重写他们的run函数，然后绑定两个线程的信号和槽，但是发现解决不了这个问题。后面看帖子，发现还有另外一种qt多线程，将opencv类继承自qobject，在将opencv类对象移动到qthread里面。绑定ffmpeg的信号和opencv的槽，这样就解决线程的同步问题了。Ffmpeg线程拉流到数据后，发送信号，opencv线程的槽函数就开始执行 3、当加上识别人脸这个功能的时候，在qlable上显示的画面会花屏。还没处理掉这个问题，可能再开辟多一个线程识别人脸就不会出现这种问题了。 4、音频的录音和播放都比较拉跨，有些参数可能设置的不好， \\项目提高：** 1、可以优化对音频的采集和播放，开辟多一个线程处理音频，当然这里面又涉及到对线程的同步问题。看到网上不少项目使用sdl处理音频的，可以考虑用sdl库处理音频 2、优化拉流端的拉流。有时候拉流端拉流很久才成功，有时候很快，所以应该对拉流设置个时间，超时就重试。 3、优化人脸识别。一方面，人脸识别后的画面显示花瓶，需要修改。人脸识别模型库比较小，训练资源少，识别率一般。 4、可以加多几个功能，比如截图","link":"","tags":[]},{"title":"在线监控项目复盘-拉流端","date":"2021-09-19T12:11:45.000Z","path":"2021/09/19/在线监控项目复盘-拉流端/","text":"在线监控项目-拉流端拉流端工作流程： 视频获取前的相关操作：注册文件格式和解码器，注册设备，初始化网络流格式，设置视频和音频播放参数。 通过rtmp链接打开输入流 获取视频流编码格式 –》打开相应的解码器h264 获取音频流编码格式 –》打开相应的解码器AAC 设置解码参数 申请内存 从输入流中获取包数据 获取视频包–》解码视频–》将yuv420p转为RGB24格式–》通过信号发送到qlable显示和opencv线程人脸检测 获取音频包–》解码音频pcm–》播放音频 主线程主线程工作比较简单，用两个QLable分别显示ffmpeg拉流的视频数据和opencv人脸识别的数据。在主线程里面要显示两个视频QLable，相当于开两个视频，有点吃力。 ffmpeg线程ffmpeg线程开辟方式是先继承QThread然后重新run()函数，在 run()函数写线程需要执行的代码。 拉流端工作流程： 视频获取前的相关操作：注册文件格式和解码器，注册设备，初始化网络流格式，设置视频和音频播放参数。 通过rtmp链接打开输入流 获取视频流编码格式 –》打开相应的解码器h264 设置解码参数 申请内存 从输入流中获取包数据 获取视频包–》解码视频–》将yuv420p转为RGB24格式–》通过信号发送到qlable显示和opencv线程人脸检测 opencv线程opecv线程开辟的方式， 是把一个继承于QObject的类转移到一个Thread里 1thread_Opencv-&gt;moveToThread(&amp;thread); 加载人脸检查模型+加载人脸识别训练模型-》通过ffmpeg获取原图-》转换成灰度图-》直方图均匀化-》检测人脸-》识别人脸-》用矩形框出人脸并显示名字–》发送信号到qlable显示 多线程通信与同步ffmpeg线程开辟方式是先继承QThread然后重新run()函数，在 run()函数写线程需要执行的代码。 opecv线程开辟的方式， 是把一个继承于QObject的类转移到一个Thread里。 ffmpeg线程与opecv线程直接需要通信，即ffmpeg线程处理得到的视频数据需要给opecv线程，这里使用Qt的信号槽机制，只要ffmpeg线程发送了信号，opecv线程就会执行，很巧妙的实现了多线程的通信和同步。 12connect(thread_laliu, SIGNAL(ffmpeg2opencv(unsigned char *, int, int)), thread_Opencv, SLOT(ffmpegDateExchange(unsigned char *, int, int))); 在推流端中，主线程获取视频数据，而ffmpeg线程也需要这些视频数据，这里也是有线程通信的。在推流端我是使用共享资源的形式实现两个线程的通信，但是两个线程同时对同一个资源会产生竞争，所以使用了QMutex，这是Qt提供的互斥锁，实现多线程的互斥。","link":"","tags":[]},{"title":"在线监控项目复盘-RTMP","date":"2021-09-19T11:48:25.000Z","path":"2021/09/19/在线监控项目复盘-RTMP/","text":"现有的网络视音频服务主要包括两种方式：点播和直播。点播意即根据用户的需要播放相应的视频节目，这是互联网视音频服务最主要的方式。绝大部分视频网站都提供了点播服务。直播意即互联网视音频平台直接将视频内容实时发送给用户， 直播服务普遍采用了RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式。封装格式，视频编码，音频编码方面，无一例外的使用了FLV + H.264 + AAC的组合。FLV是RTMP使用的封装格式，H.264是当今实际应用中编码效率最高的视频编码标准，AAC则是当今实际应用中编码效率最高的音频编码标准。 点播服务普遍采用了HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式。采用HTTP作为点播协议有以下两点优势：一方面，HTTP是基于TCP协议的应用层协议，媒体传输过程中不会出现丢包等现象，从而保证了视频的质量；另一方面，HTTP被绝大部分的Web服务器支持，因而流媒体服务机构不必投资购买额外的流媒体服务器，从而节约了开支。点播服务采用的封装格式有多种：MP4，FLV，F4V等，它们之间的区别不是很大。视频编码标准和音频编码标准是H.264和AAC。 RTMP（Real Time Messaging Protocol）是基于TCP的，由Adobe公司为Flash播放器和服务器之间音频、视频传输开发的开放协议。 HLS（HTTP Live Streaming）是基于HTTP的，是Apple公司开放的音视频传输协议。 HTTP FLV则是将RTMP封装在HTTP协议之上的，可以更好的穿透防火墙等 RTMP协议是Real Time Message Protocol(实时信息传输协议)的缩写，它是由Adobe公司提出的一种应用层的协议，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题 RTMP协议是一个互联网TCP/IP五层体系结构中应用层的协议。RTMP协议中基本的数据单元称为消息（Message）。当RTMP协议在互联网中传输数据的时候，消息会被拆分成更小的单元，称为消息块（Chunk）。 RTMP传输媒体数据的过程中，发送端首先把媒体数据封装成消息，然后把消息分割成消息块，最后将分割后的消息块通过TCP协议发送出去。接收端在通过TCP协议收到数据后，首先把消息块重新组合成消息，然后通过对消息进行解封装处理就可以恢复出媒体数据。 RTMP协议规定，播放一个流媒体有两个前提步骤：第一步，建立一个网络连接（NetConnection）；第二步，建立一个网络流（NetStream）。其中，网络连接代表服务器端应用程序和客户端之间基础的连通关系。网络流代表了发送多媒体数据的通道。服务器和客户端之间只能建立一个网络连接，但是基于该连接可以创建很多网络流。","link":"","tags":[]},{"title":"在线监控项目复盘-推流端","date":"2021-09-19T04:13:47.000Z","path":"2021/09/19/在线监控项目复盘-推流端/","text":"在线监控项目-推流端主线程使用Qt获取摄像头数据+显示Qt提供了方便的类QCamera来控制摄像头获取数据。ffmpeg也提供了libavdevice相关的API函数来获取摄像头等设备的音视频的数据。opencv对ffmpeg的函数进行封装，提供了很方便的获取摄像头和设备数据的类。总结，难度从高到低分别是：ffmpeg &gt; QCamera &gt;opencv。 这里使用Qt提供的类来获取摄像头的视频数据。 在主线程使用QCamera类获取摄像头数据。摄像头获取到视频数据后，QVideoProbe类发送videoFrameProbed信号，可以创建一个槽函数处理信号函数发送过来的视频数据。 获取的原始视频像素格式为Format_YUV420P，转换成RGB格式后就可以在QLable上显示。 这视频数据是共享资源，由主线程和ffmpeg线程共享，所以对视频数据必须加互斥锁QMutex实现多线程的互斥。每次多视频数据的读写操作都要加锁，防止多线程的读写冲突。 子线程使用ffmpeg库的API实现推流ffmpeg线程通过继承自QThread类重写run()函数来开辟。 ffmpeg推流线程的工作流程大概为： 获取YUV420P格式视频像素数据–&gt;编码成h.264格式–&gt;封装成FLV格式–&gt;以rtmp协议推流到nginx服务器上。 在编码之前需要完成很多初始化工作，编码和封装也比较繁琐，推流就很简单一个函数搞定。 av_register_all()：注册FFmpeg所有编解码器。 avformat_alloc_output_context2()：初始化输出码流的AVFormatContext。 avio_open()：打开输出文件。 avformat_new_stream()：创建输出码流的AVStream。 avcodec_alloc_context3()：初始化AVCodecContext，设置编码器编码参数 avcodec_find_encoder()：查找编码器。 avcodec_open2()：打开编码器。 av_frame_alloc() + av_frame_get_buffer()：初始化AVFrame，为音频或视频AVFrame分配缓冲区。 avio_open()：打开输出URL avformat_write_header()：编写文件头（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。 avcodec_encode_video2()：编码一帧视频。即将AVFrame（存储YUV420P像素数据）编码为AVPacket（存储H.264等格式的码流数据）。 av_interleaved_write_frame()：将编码得到的AVPacket封装成FLV格式，然后向文件或网络输出一帧FLV数据 av_write_trailer()：写文件尾（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。","link":"","tags":[]},{"title":"在线监控项目复盘-YUV与RGB","date":"2021-09-19T03:22:38.000Z","path":"2021/09/19/在线监控项目复盘-YUV与RGB/","text":"YUV从采集的角度来说，一般的视频采集芯片输出的码流一般都是YUV数据流的形式，而从视频处理（例如H.264、MPEG视频编解码）的角度来说，也是在原始YUV码流进行编码和解析，所以，了解如何分析YUV数据流对于做视频领域的人而言，至关重要。YUV是指亮度参量和色度参量分开表示的像素格式，而这样分开的好处就是不但可以避免相互干扰，还可以降低色度的采样率而不会对图像质量影响太大。 人眼对色度的敏感程度要低于对亮度的敏感程度。 YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。与我们熟知的RGB类似，YUV也是一种颜色编码方法，主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。 YUV码流有多种不同的格式，要分析YUV码流，就必须搞清楚你面对的到底是哪一种格式，并且必须搞清楚这种格式的YUV采样和分布情况。 YUV格式有两大类：planar 平面格式 和packed数据包格式。对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。对于packed的YUV格式，每个像素点的Y,U,V是连续交叉存储的。 yuv420p：yyyyyyyy uuuuuuuu vvvvvyuv420： yuv yuv yuv 1. 采样方式 YUV码流的存储格式其实与其采样的方式密切相关，主流的采样方式有三种，YUV4:4:4，YUV4:2:2，YUV4:2:0，如何根据其采样格式来从码流中还原每个像素点的YUV值，因为只有正确地还原了每个像素点的YUV值，才能通过YUV与RGB的转换公式提取出每个像素点的RGB值，然后显示出来。 YUV 4:4:4采样，每一个Y对应一组UV分量。YUV 4:2:2采样，每两个Y共用一组UV分量。YUV 4:2:0采样，每四个Y共用一组UV分量。 RGB24使用24位来表示一个像素，RGB分量都用8位表示，取值范围为0-255。在一个2*2的像素区域，RRG暂用的字节数为2 * 2* 3=12字节。那么用yuv表示，占用的字节数为4(Y)+1(u)+1(v)=6字节,其中Y占用4个字节，U和V各占用1字节，比例为4:1:1 一般来说，直接采集到的视频数据是RGB24的格式，RGB24一帧的大小size＝width×heigth×3 Bit，RGB32的size＝width×heigth×4，如果是I420（即YUV标准格式4：2：0）的数据量是 size＝width×heigth×1.5 Bit。 YUV特点：也是一种颜色编码方法，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样 可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传 输，所以用YUV方式传送占用极少的频宽。 在传输时占⽤的带宽也会随之减少。 RGB — YUV 颜⾊编码转换对于图像显示器来说，它是通过RGB模型来显示图像的，⽽在传输图像数据时⼜是使⽤YUV模型，这是因为YUV模型可以节省带宽。因此就需要采集图像时将RGB模型转换到YUV模型，显示时再将YUV模型转换为RGB模型","link":"","tags":[]},{"title":"在线监控项目复盘-OPENCV","date":"2021-09-18T07:43:29.000Z","path":"2021/09/18/在线监控项目复盘-OPENCV/","text":"FaceRecognizer这个类目前包含三种人脸识别方法：基于PCA变换的人脸识别(EigenFaceRecognizer)、基于Fisher变换的人脸识别(FisherFaceRecognizer)、基于局部二值模式的人脸识别(LBPHFaceRecognizer)。 检测人脸流程： 建立级联分类器 CascadeClassifier 加载已经训练好的人脸检测模型 CascadeClassifier :: load( “.xml” ) ; 原图转换成灰度图 cvtColor( ); //BGR 转化为灰度图 灰度图的直方图均衡化 equalizeHist(); 检测图片中的人脸 CascadeClassifier :: detectMultiScale( ) 创建特征脸模型 EigenFaceRecognizer::create() 预测人脸 model-&gt;predict(); 用矩形框框出人脸 rectangle( ) Opencv人脸检测流程： 加载人脸检查模型+加载人脸识别训练模型-》通过ffmpeg获取原图-》转换成灰度图-》直方图均匀化-》检测人脸-》识别人脸-》用矩形框出人脸并显示名字–》发送信号到qlable显示 1234567891011&#x2F;*********************************** 训练人脸识别模型 ******************************&#x2F;&#x2F;&#x2F;1、创建训练样本：选用ORL人脸库，里面有40个的人脸图像，每人10张，然后再将自己的10张人脸照也放进去&#x2F;&#x2F;2、创建特征脸模型：通过样本和类别标签进行训练，最终得到训练好的主成分脸模型。Ptr&lt;FaceRecognizer&gt; model&#x3D;createEigenFaceRecognizer();&#x2F;&#x2F;3、训练人脸识别模型：通过样本和类别标签进行训练，最终得到训练好的主成分脸模型。model-&gt;train(images,labels); &#x2F;&#x2F;通过images和labels来训练人脸模型 &#x2F;&#x2F;4、保存人脸识别模型model-&gt;save(&quot;MyFacePcaModel.xml&quot;); &#x2F;&#x2F;将训练模型保存到MyFacePcaModel.xml 1234567891011121314151617181920212223&#x2F;*********************************** 1.原图获取与处理 ******************************&#x2F;&#x2F;&#x2F;1、打开摄像头，读取视频并初始化VideoCapture capture(0);&#x2F;&#x2F;2、原图转灰度图cvtColor(frame, frame_gray, CV_RGB2GRAY);&#x2F;&#x2F;3、灰度图的直方图均衡化equalizeHist(frame_gray, frame_gray);&#x2F;*********************************** 2.加载人脸检测模型 ******************************&#x2F;&#x2F;&#x2F;1、建立级联分类器CascadeClassifier cascade;cascade.load(&quot;.&#x2F;xml&#x2F;haarcascade_frontalface_alt.xml&quot;);&#x2F;&#x2F;2、检测图像中的人脸：将检测到的人脸放到faces中cascade.detectMultiScale(frame_gray, faces, 1.1, 2, 0|CASCADE_SCALE_IMAGE, Size(60, 60));&#x2F;*********************************** 3.预测人脸 ******************************&#x2F;&#x2F;&#x2F;1、加载人脸识别模型：创建特征脸模型model &#x3D; EigenFaceRecognizer::create();model-&gt;read(&quot;MyFaceRecognizer.xml&quot;);&#x2F;&#x2F;加载级联分类器&#x2F;&#x2F;2、预测检测到的人脸model-&gt;predict(face_test); 1234567891011121314151617void detectMultiScale( const Mat&amp; image, CV_OUT vector&lt;Rect&gt;&amp; objects, double scaleFactor &#x3D; 1.1, int minNeighbors &#x3D; 3, int flags &#x3D; 0, Size minSize &#x3D; Size(), Size maxSize &#x3D; Size() ); 函数介绍：功能：图像搜索参数1：image–待检测图片，一般为灰度图像加快检测速度；参数2：objects–被检测物体的矩形框向量组，即被成功定位后返回的目标边界矩阵变量；参数3：scaleFactor–检测尺度之间的跳变(默认1.1)。该值越大，检测速度越快，但会错过更多可能被检测到的目标；参数4：minNeighbors–对阻止错误检测的控制。例如该值为3，则在人脸检测时表示只有至少存在3个重叠的检测标记时，才认定有人脸的存在；参数5：flags–要么使用默认值，要么使用CV_HAAR_DO_CANNY_PRUNING，函数将会使用Canny边缘检测来排除边缘过多或过少的区域， 因为这些区域通常不会是人脸所在区域；参数6、7：minSize和maxSize用来限制得到的目标区域的范围。如果视频中误检到很多无用的小方框，那么就把minSize的尺寸改大一些，默认的为30*30。","link":"","tags":[]},{"title":"在线监控项目复盘-音视频压缩编码原理","date":"2021-09-16T06:50:20.000Z","path":"2021/09/16/在线监控项目复盘-音视频压缩编码原理/","text":"(16条消息) 视频压缩编码和音频压缩编码的基本原理_雷霄骅(leixiaohua1020)的专栏-CSDN博客 1.视频编码基本原理（1） 视频信号的冗余信息以记录数字视频的YUV分量格式为例，YUV分别代表亮度与两个色差信号。例如对于现有的PAL制电视系统，其亮度信号采样频率为13.5MHz；色度信号的频带通常为亮度信号的一半或更少，为6.75MHz或3.375MHz。以4：2：2的采样频率为例，Y信号采用13.5MHz，色度信号U和V采用6.75MHz采样，采样信号以8bit量化，则可以计算出数字视频的码率为： 13.58 + 6.758 + 6.75*8= 216Mbit/s 如此大的数据量如果直接进行存储或传输将会遇到很大困难，因此必须采用压缩技术以减少码率。数字化后的视频信号能进行压缩主要依据两个基本条件： l 数据冗余。例如如空间冗余、时间冗余、结构冗余、信息熵冗余等，即图像的各像素之间存在着很强的相关性。消除这些冗余并不会导致信息损失，属于无损压缩。 l 视觉冗余。人眼的一些特性比如亮度辨别阈值，视觉阈值，对亮度和色度的敏感度不同，使得在编码的时候引入适量的误差，也不会被察觉出来。可以利用人眼的视觉特性，以一定的客观失真换取数据压缩。这种压缩属于有损压缩。 数字视频信号的压缩正是基于上述两种条件，使得视频数据量得以极大的压缩，有利于传输和存储。一般的数字视频压缩编码方法都是混合编码，即将变换编码，运动估计和运动补偿，以及熵编码三种方式相结合来进行压缩编码。通常使用变换编码来消去除图像的帧内冗余，用运动估计和运动补偿来去除图像的帧间冗余，用熵编码来进一步提高压缩的效率。下文简单介绍这三种压缩编码方法。 （2） 压缩编码的方法（a） 变换编码变换编码的作用是将空间域描述的图像信号变换到频率域，然后对变换后的系数进行编码处理。一般来说，图像在空间上具有较强的相关性，变换到频率域可以实现去相关和能量集中。常用的正交变换有离散傅里叶变换，离散余弦变换等等。数字视频压缩过程中应用广泛的是离散余弦变换。 离散余弦变换简称为DCT变换。它可以将L* L的图像块从空间域变换为频率域。所以，在基于DCT的图像压缩编码过程中，首先需要将图像分成互不重叠的图像块。假设一帧图像的大小为1280 * 720，首先将其以网格状的形式分成160*90个尺寸为8 * 8的彼此没有重叠的图像块，接下来才能对每个图像块进行DCT变换。 经过分块以后，每个8 * 8点的图像块被送入DCT编码器，将8 * 8的图像块从空间域变换为频率域。下左图给出一个实际8*8的图像块例子，图中的数字代表了每个像素的亮度值。从图上可以看出，在这个图像块中各个像素亮度值比较均匀，特别是相邻像素亮度值变化不是很大，说明图像信号具有很强的相关性。 ——》 上右图是上图中图像块经过DCT变换后的结果。从图中可以看出经过DCT变换后，左上角的低频系数集中了大量能量，而右下角的高频系数上的能量很小。 信号经过DCT变换后需要进行量化。由于人的眼睛对图像的低频特性比如物体的总体亮度之类的信息很敏感，而对图像中的高频细节信息不敏感，因此在传送过程中可以少传或不传送高频信息，只传送低频部分。量化过程通过对低频区的系数进行细量化，高频区的系数进行粗量化，去除了人眼不敏感的高频信息，从而降低信息传送量。因此，量化是一个有损压缩的过程，而且是视频压缩编码中质量损伤的主要原因。 DCT系数经过量化之后大部分经变为0，而只有很少一部分系数为非零值，此时只需将这些非0值进行压缩编码即可。 （c） 运动估计和运动补偿运动估计（Motion Estimation）和运动补偿（Motion Compensation）是消除图像序列时间方向相关性的有效手段。上文介绍的DCT变换、量化、熵编码的方法是在一帧图像的基础上进行，通过这些方法可以消除图像内部各像素间在空间上的相关性。实际上图像信号除了空间上的相关性之外，还有时间上的相关性。例如对于像新闻联播这种背景静止，画面主体运动较小的数字视频，每一幅画面之间的区别很小，画面之间的相关性很大。对于这种情况我们没有必要对每一帧图像单独进行编码，而是可以只对相邻视频帧中变化的部分进行编码，从而进一步减小数据量，这方面的工作是由运动估计和运动补偿来实现的。 运动估计技术一般将当前的输入图像分割成若干彼此不相重叠的小图像子块，例如一帧图像的大小为1280*720，首先将其以网格状的形式分成40 * 45个尺寸为16*16的彼此没有重叠的图像块，然后在前一图像或者后一个图像某个搜索窗口的范围内为每一个图像块寻找一个与之最为相似的图像块。这个搜寻的过程叫做运动估计。通过计算最相似的图像块与该图像块之间的位置信息，可以得到一个运动矢量。这样在编码过程中就可以将当前图像中的块与参考图像运动矢量所指向的最相似的图像块相减，得到一个残差图像块，由于残差图像块中的每个像素值很小，所以在压缩编码中可以获得更高的压缩比。这个相减过程叫运动补偿。 由于编码过程中需要使用参考图像来进行运动估计和运动补偿，因此参考图像的选择显得很重要。一般情况下编码器的将输入的每一帧图像根据其参考图像的不同分成3种不同的类型：I（Intra）帧、B（Bidirection prediction）帧、P（Prediction）帧。如图所示。 如图所示，I帧只使用本帧内的数据进行编码，在编码过程中它不需要进行运动估计和运动补偿。显然，由于I帧没有消除时间方向的相关性，所以压缩比相对不高。P帧在编码过程中使用一个前面的I帧或P帧作为参考图像进行运动补偿，实际上是对当前图像与参考图像的差值进行编码。B帧的编码方式与P帧相似，惟一不同的地方是在编码过程中它要使用一个前面的I帧或P帧和一个后面的I帧或P帧进行预测。由此可见，每一个P帧的编码需要利用一帧图像作为参考图像，而B帧则需要两帧图像作为参考。相比之下，B帧比P帧拥有更高的压缩比。 2.音频编码基本原理（1） 音频信号的冗余信息数字音频信号如果不加压缩地直接进行传送，将会占用极大的带宽。数字音频压缩编码在保证信号在听觉方面不产生失真的前提下，对音频数据信号进行尽可能大的压缩。数字音频压缩编码采取去除声音信号中冗余成分的方法来实现。所谓冗余成分指的是音频中不能被人耳感知到的信号，它们对确定声音的音色，音调等信息没有任何的帮助。 冗余信号包含人耳听觉范围外的音频信号以及被掩蔽掉的音频信号等。例如，人耳所能察觉的声音信号的频率范围为20Hz～20KHz，除此之外的其它频率人耳无法察觉，都可视为冗余信号。此外，根据人耳听觉的生理和心理声学现象，当一个强音信号与一个弱音信号同时存在时，弱音信号将被强音信号所掩蔽而听不见，这样弱音信号就可以视为冗余信号而不用传送。这就是人耳听觉的掩蔽效应，主要表现在频谱掩蔽效应和时域掩蔽效应，现分别介绍如下： （a） 频谱掩蔽效应一个频率的声音能量小于某个阈值之后，人耳就会听不到，这个阈值称为最小可闻阈。当有另外能量较大的声音出现的时候，该声音频率附近的阈值会提高很多，即所谓的掩蔽效应。如图所示： 由图中我们可以看出人耳对2KHz～5KHz的声音最敏感，而对频率太低或太高的声音信号都很迟钝，当有一个频率为0.2KHz、强度为60dB的声音出现时，其附近的阈值提高了很多。由图中我们可以看出在0.1KHz以下、1KHz以上的部分,由于离0.2KHz强信号较远，不受0.2KHz强信号影响,阈值不受影响；而在0.1KHz～1KHz范围，由于0.2KHz强音的出现,阈值有较大的提升，人耳在此范围所能感觉到的最小声音强度大幅提升。如果0.1KHz～1KHz范围内的声音信号的强度在被提升的阈值曲线之下，由于它被0.2KHz强音信号所掩蔽，那么此时我们人耳只能听到0.2KHz的强音信号而根本听不见其它弱信号，这些与0.2KHz强音信号同时存在的弱音信号就可视为冗余信号而不必传送。 （b） 时域掩蔽效应当强音信号和弱音信号同时出现时，还存在时域掩蔽效应。即两者发生时间很接近的时候，也会发生掩蔽效应。时域掩蔽过程曲线如图所示，分为前掩蔽、同时掩蔽和后掩蔽三部分。 由图我们可以看出，时域掩蔽效应可以分成三种：前掩蔽，同时掩蔽，后掩蔽。前掩蔽是指人耳在听到强信号之前的短暂时间内，已经存在的弱信号会被掩蔽而听不到。同时掩蔽是指当强信号与弱信号同时存在时，弱信号会被强信号所掩蔽而听不到。后掩蔽是指当强信号消失后，需经过较长的一段时间才能重新听见弱信号，称为后掩蔽。这些被掩蔽的弱信号即可视为冗余信号。 （2） 压缩编码方法对每一个音频声道中的音频采样信号,首先都要将它们映射到频域中,这种时域到频域的映射可通过子带滤波器实现。每个声道中的音频采样块首先要根据心理声学模型来计算掩蔽门限值, 然后由计算出的掩蔽门限值决定从公共比特池中分配给该声道的不同频率域中多少比特数，接着进行量化以及编码工作，最后将控制参数及辅助数据加入数据之中，产生编码后的数据流。 H.264编码 H.264仅仅是一个编码标准，而不是一个具体的编码器，H.264只是给编码器的实现提供参照用的。 H264定义三种帧，完整的编码帧称为Ｉ帧,参考之前Ｉ帧生成的只包含差异部分的编码的帧叫P帧，还有一种参照前后帧编码的帧叫B帧。 H264采用的核心算法是帧内压缩和帧间压缩，帧内压缩是生成Ｉ帧的算法，帧间压缩是生成B帧和P帧的算法。 Ｉ帧：帧内编码帧，Ｉ帧表示关键帧，理解为这一阵的画面完整保留；解码时只需要本帧数据就可以完成（因为本帧包含完整画面） P帧：前向预测编码帧。P帧表示的是这一帧跟之前的关键帧（或P帧）的差别，解码是需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别真，P帧没有完整画面数据，只有与前一帧的画面差别的数据） Ｂ帧：双向预测内插编码帧。B帧就是双向差别帧，也就是B帧记录的是本帧与前后帧的差别。总而言之，要解码B帧，不仅要去的之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩效率高，但是解码时CPU会比较累。 帧内（Intraframe）压缩也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩是编码一个完整的图像，所以可以独立的解码、显示。 帧间（Interframe）压缩的原理是：相邻几帧的数据有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息,根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。","link":"","tags":[]},{"title":"在线监控项目复盘-nginx","date":"2021-09-16T04:24:31.000Z","path":"2021/09/16/在线监控项目复盘-nginx/","text":"Nginx是一套开源软件，纯C语言编写，效率高。是一个HTTP和反向代理web服务器，同时也是一个 IMAP、POP3、SMTP 代理服务器。具有稳定、高效，支持高并发的优点。在这项目中Nginx可以作为流体服务器，支持RTMP、HTTPFLV、HLS等协议。 在跟着韦东山做项目的时候，我使用的是正点原子的阿尔法开发板，而且也是正点原子出品的ov5460摄像头。当时脑抽了才买了这个摄像头，太垃圾了，还贼贵。应该买一个usb摄像头的，舍友买了一个海康的usb摄像头，价格低，拍照清晰，可以在开发板和电脑上都可以使用。肠子悔青了。 我的ov5460摄像头只能在阿尔法开发板的出厂系统可以读出来，如果是我自己的配置的buildroot根文件系统下就是没办法读出来。明明我都装了驱动了，还是识别不出来，白花一天时间搞这个buildroot根文件系统了。 nigix移植阿尔法开发板的出厂系统没有移植nginx，如果是buildroot系统，移植nginx很简单。但是，阿尔法开发板的出厂系统是基于yocto的，很难移植nginx库。 只能硬着头皮自己编译、移植nginx库。说实话，编译和移植nginx库对我这种新手来说，绝对是地狱级别的难度的。搞了整整两天才编译成功。自闭。 (16条消息) 移植 nginx_Gino的专栏-CSDN博客_nginx移植 arm linux 移植 Nginx - 黄树超 - 博客园 (cnblogs.com) 这两篇文章可以解决很多问题。还是踩了很多坑。 编译nginx需要用到zlib、pcre、openssl依赖库。这些依赖库不要去官网下载最新的。应该根据帖子里面的版本下载。新版本不一定能兼容旧版本，会编译出错。血泪，巨坑。 openssl依赖库的编译也是大坑。这个库编译不过去。自己摸索出一种方法。在nginx/objs/Makefile 中查找出openssl编译出来的地址，把这句编译的语句注释掉。然后自己手动编译openssl在那个地址里面。这样就可以编译通过。不然就是陷入一个死循环。心累啊，这里摸索了好久，真坑，真的劝退。 nigix配置和部署nginx version: nginx/1.16.1vi /etc/nginx/ngixn.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133 #user nobody;worker_processes auto;#error_log logs&#x2F;error.log;#error_log logs&#x2F;error.log notice;#error_log logs&#x2F;error.log info;#pid logs&#x2F;nginx.pid;events &#123; worker_connections 1024;&#125;rtmp&#123; server&#123; listen 1935; chunk_size 4096; application live&#123; allow publish 127.0.0.1; allow play all; live on ; record off; meta copy; &#125; &#125;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; #log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; # &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; # &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; #access_log logs&#x2F;access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs&#x2F;host.access.log main; location &#x2F; &#123; root html; index index.html index.htm; &#125; #error_page 404 &#x2F;404.html; # redirect server error pages to the static page &#x2F;50x.html error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root html; &#125; location &#x2F;test&#123; flv_live on; chunked_transfer_encoding on; add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http:&#x2F;&#x2F;127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME &#x2F;scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ &#x2F;\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location &#x2F; &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location &#x2F; &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125;","link":"","tags":[]},{"title":"在线监控项目复盘-ffmpeg命令","date":"2021-09-16T04:03:26.000Z","path":"2021/09/16/在线监控项目复盘-ffmpeg入门/","text":"ffmpeg主要组成部分 在这组成部分中，需要熟悉基础概念有 ffmpeg的解码到编码流程 1、FFmpeg程序把-i参数指定的若干文件内容读入到内存，按照输入的参数或者程序默认的参数来处理并且把结果写入到若干的文件中。输入和输出文件可以是计算机文件、管道、网络流、捕获设备等。 2、FFmpeg用libavformat包调用解复用器（demuxers）来读取输入文件中被编码的数据包(packets)，如果有多个输入文件，FFmpeg以有效输入流的最小时间戳来同步， 3、然后解码器（decoder）从已编码的数据包中产生未被压缩的帧（frame），在那之后调用可选的过滤器。 4、这些帧被传递到编码器，编码器会产生新的编码包 5、把新的编码包传递给复用器(muxer)处理并且把结果写入到输出文件中。 码率、帧率和文件大小码率和帧率是视频文件的最重要的基本特征，对于他们的特有设置会决定视频质量。如果我们知道码率和时长那么可以很容易计算出输出文件的大小。 帧率：帧率也叫帧频率，帧率是视频文件中每一秒的帧数，肉眼想看到连续移动图像至少需要15帧。码率：比特率(也叫码率，数据率)是一个确定整体视频/音频质量的参数，秒为单位处理的字节数，码率和视频质量成正比，在视频文件中中比特率用bps来表达。 ffmpeg常用命令参数 AVStream，AVCodecContext：视音频流对应的结构体，用于视音频编解码。 a) 解协议（http,rtsp,rtmp,mms） AVIOContext，URLProtocol，URLContext主要存储视音频使用的协议的类型以及状态。URLProtocol存储输入视音频使用的封装格式。每种协议都对应一个URLProtocol结构。（注意：FFMPEG中文件也被当做一种协议“file”） b) 解封装（flv,avi,rmvb,mp4） AVFormatContext：统领全局的基本结构体，主要存储视音频封装格式中包含的信息，用于处理封装格式（FLV/MKV/RMVB等）。 AVInputFormat/AVOutputFormat：输入输出对应的结构体，用于输入输出（读写文件，RTMP协议等），存储输入视音频使用的封装格式。每种视音频封装格式都对应一个AVInputFormat /AVOutputFormat结构。 c) 解码（h264,mpeg2,aac,mp3） 每个AVStream：视音频流对应的结构体，存储一个视频/音频流的相关数据； 每个AVStream对应一个AVCodecContext，AVCodecContext存储该视频/音频流使用解码方式的相关数据，用于视音频编解码； 每个AVCodecContext中对应一个AVCodec，AVCodec包含该视频/音频对应的解码器。每种解码器都对应一个AVCodec结构。 d) 存数据 解码前数据：AVPacket：存储压缩数据（视频对应H.264等码流数据，音频对应AAC/MP3等码流数据） 解码后数据：AVFrame ：存储非压缩的数据（视频对应RGB/YUV像素数据，音频对应PCM采样数据） av_register_all()：注册FFmpeg所有编解码器。 avformat_alloc_output_context2()：初始化输出码流的AVFormatContext。 avio_open()：打开输出文件。 av_new_stream()：创建输出码流的AVStream。 avcodec_find_encoder()：查找编码器。 avcodec_open2()：打开编码器。 avformat_write_header()：写文件头（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。 avcodec_encode_video2()：编码一帧视频。即将AVFrame（存储YUV像素数据）编码为AVPacket（存储H.264等格式的码流数据）。 av_write_frame()：将编码后的视频码流写入文件。 flush_encoder()：输入的像素数据读取完成后调用此函数。用于输出编码器中剩余的AVPacket。 av_write_trailer()：写文件尾（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。","link":"","tags":[]},{"title":"在线监控项目复盘-项目背景","date":"2021-09-16T03:22:29.000Z","path":"2021/09/16/在线监控项目复盘-项目背景/","text":"这个在线监控项目是七月底开始做的，做了差不多一个月，做的过程中没有记录什么笔记，而且做完了就急着刷题，没有做总结和复盘。现在在面试的时候，每当问道这个项目，我都很多答不上来，很打击我信心。舍友告诉我，让我把这个项目当作一个课程设计，做完了就要写一份报告，把写报告当作复盘，面试前多看看这个报告就可以了。我觉得很有道理，所以抽空几天，作深度的复盘。 项目已经做完半个多月了，现在复盘只能根据回忆来写，当然会深挖项目的技术点和原理。当初就不应该偷懒，做项目的过程中，应该随手做笔记，哎，还是得养成作笔记的习惯。 项目背景见过一个师兄做过在线监控项目，觉得很不错。后来在B站看到韦东山的在线监控小项目的视频，立马被震惊了。跟着韦东山作了那个小项目，受益匪浅。算是最低级最初级的音视频入门了。韦东山的项目是通过ffmpeg工具来实现音视频的推拉流的，所以很简单。我之前学了Qt，所以想结合Qt和ffmpeg开源库来实现推拉流的功能。 韦东山-基于ffmpeg和nginx的在线监控 ffmpeg是一套强大的开源软件：可以记录、转换音视频，可以从摄像头中记录视频，从声卡中记录音频，可以转换为各种格式，保存起来；还可以把各种格式的音视频，转换为流，供在线观看。其他功能：视频截图、加水印、裁剪等等。 Nginx是一套开源软件，纯C语言编写，效率高。是一个HTTP和反向代理web服务器，同时也是一个 IMAP、POP3、SMTP 代理服务器。具有稳定、高效，支持高并发的优点。在这项目中Nginx可以作为流体服务器，支持RTMP、HTTPFLV、HLS等协议。 avi，rmvb，mp4，flv，mkv等等（当然也使用不同的图标）。在这里需要注意的是，这些格式代表的是封装格式。何为封装格式？就是把视频数据和音频数据打包成一个文件的规范。仅仅靠看文件的后缀，很难能看出具体使用了什么视音频编码标准。总的来说，不同的封装格式之间差距不大，各有优劣。 从摄像头、声卡得到的原始数据太大，不易传输，需要压缩。音视频编码就相当于对音视频数据进行压缩。压缩的方法有很多种：格式不同，编码器不同，对应不同的音频、视频编码器。 H.264仅仅是一个编码标准，而不是一个具体的编码器，H.264只是给编码器的实现提供参照用的。 把这些压缩后，即编码后的视频数据、音频数据合并在一起：复用、MUX，就得到了MP4、FLV等文件 雷霄骅 的博主有很好的音视频入门博客：https://blog.csdn.net/leixiaohua1020/article/details/18893769；可惜这位大佬英年早逝，在这里感谢他的无私和开源精神，对我们这种小白真的太友好了。 推拉流ffmpeg -f v4l2 -framerate 10 -i /dev/video1 -q 10 -f flv rtmp://127.0.0.1/live/wei ffmpeg -re -i test.mp4 -vcodec copy -acodec copy -f flv rtmp://127.0.0.1/live/wei 使用RTMP协议拉流：VLC播放器中点击“媒体”-&gt;“打开网络串流”，输入：rtmp://192.168.1.6/live/wei ，就可以播放了使用HTTPFLV协议拉流：VLC播放器中点击“媒体”-&gt;“打开网络串流”，输入： http://192.168.1.6/test?app=live&amp;stream=wei ，就可以播放了 RTMP（Real Time Messaging Protocol）是基于TCP的，由Adobe公司为Flash播放器和服务器之间音频、视频传输开发的开放协议。 HLS（HTTP Live Streaming）是基于HTTP的，是Apple公司开放的音视频传输协议。 HTTP FLV则是将RTMP封装在HTTP协议之上的，可以更好的穿透防火墙等 Http_flv &amp; RTMP 这两个协议实际上传输数据是一样的，数据都是flv文件的tag。http_flv是一个无限大的http流的文件，相比rtmp就只能直播，而rtmp还可以推流和更多的操作。但是http有个好处，就是是以80http通信的，穿透性强，而且rtmp是非开放协议。 这两个协议是如今直播平台主选的直播方式，主要原因就是延时极低。","link":"","tags":[]},{"title":"C++_11","date":"2021-08-21T10:38:54.000Z","path":"2021/08/21/C-11/","text":"二十四 C++异常机制(exception)1 软件开发中的常见错误1）语法错误2）逻辑错误3）功能错误4）设计缺陷5）需求不符6）环境异常7）操作不当 2 传统C语言中的错误处理1）通过返回值表示错误优点：函数调用路径中的所有栈对象可以得到正确析构，内存管理安全。缺点：错误处理流程比较麻烦，需要逐层进行返回判断，代码臃肿。 2）通过远程跳转处理错误优点：错误处理流程比较简单，不需要逐层的返回值判断，一步到位的错误处理，代码精炼缺点：函数调用路径中的栈对象失去了被析构的机制，有内存泄漏的风险 3 C++异常语法1）异常抛出 throw 异常对象; 注：异常对象可以是基本类型的数据，也可以是类类型对象. 2）异常检测和捕获 try{ 可能引发异常的语句; } catch(异常类型1){ 针对异常类型1数据的处理. } catch(异常类型2){ 针对异常类型2数据的处理. } … 注：catch子句根据异常对象的类型自上而下顺序匹配，而不是最优匹配，因此对子类异常捕获语句要写在前面，否则会被基类异常捕获语句提前截获。 4 函数异常说明1）语法 返回类型 函数名(参数表) throw(异常类型表) {} 注：“throw(异常类型表)”即为异常说明表，用于说明该函数可能抛出的异常类型2）函数异常说明只是一种承诺，不是强制语法要求，如果函数抛出了异常说明以外的其它类型，则无法被函数的调用者正常检测和捕获，而会被系统捕获，导致进程终止。 3）函数异常说明的两种极端形式–》不写函数异常说明表，表示可以抛出任何异常。–》空异常说明，“throw()”，表示不可以抛出任何异常。 4）如果函数的声明和函数定义分开，要保证异常说明表中的类型一致，但是顺序无所谓。 5 标准异常类exception​ vi /usr/include/c++/编译器版本号/exception​ class exception{ public:​ exception() throw() { }​ virtual ~exception() throw();//虚函数覆盖时，子类中版本不能说明比基类版本抛出更多的异常。 /* Returns a C-style character string describing the general cause of the current error. */ virtual const char* what() const throw(); &#125;; 注：“_GLIBCXX_USE_NOEXCEPT”即为空异常说明“throw()” eg： try{ func(); … } catch(exception&amp; ex){//可以捕获exception所有子类类型异常对象 ex.what(); } 6 构造函数和析构函数中的异常 //了解1）构造函数可以抛出异常，但是对象将被不完整构造，这样的对象其析构不能再被自动调用执行，因此在构造函数抛出异常之前，需要手动清理之前所分配的动态资源.2）析构函数最好不要抛出异常，在析构函数中抛出异常很难被检测到。 二十五 I/O流 //了解1 主要的I/O流类 ios / istream ostream / | \\ / | \\istrstream ifstream iostream ofstream ostrstream 详细参考官方手册：http://www.cplusplus.com/reference/iolibrary/ 2 格式化I/O1）格式化函数(本质是成员函数) cout &lt;&lt; 100/3.0 &lt;&lt; endl;//33.3333 ​ cout.precision(10);//格式化函数​ cout &lt;&lt; 100/3.0 &lt;&lt; endl;//33.33333333 2）流控制符(本质是全局函数) cout &lt;&lt; 100/3.0 &lt;&lt; endl;//33.3333 —————— #include //流控制符 cout &lt;&lt; setprecision(10) &lt;&lt; 100/3.0 &lt;&lt; endl;//33.33333333 3 字符串流#include //过时，不推荐使用istrstream、ostrstream #include //推荐istringstream //类似sscanf()ostringstream //类似sprintf() 4 文件流#include ifstream //类似fscanfofstream //类似fprintf 5 二进制I/O//类似freadistream&amp; istream::read(char* buffer,streamsize num);//类似fwriteostream&amp; ostaream::write(const char* buffer,size_t num);","link":"","tags":[]},{"title":"C++_10","date":"2021-08-21T10:36:52.000Z","path":"2021/08/21/C-10/","text":"二十二 多态(polymorphic)1 虚函数覆盖(函数重写)、多态概念1）如果基类中某个成员函数被声明为虚函数，那么子类中和该函数具有相同的成员函数就也是虚函数，并且对基类中版本形成覆盖，即函数重写。2）满足虚函数覆盖关系后，这时通过指向子类对象的基类指针或者通过引用子类对象的基类引用，去调用虚函数，实际被执行的将是子类中的覆盖版本，而不是基类中的原始版本，这种语法现象被称为多态。 123456789101112class Base&#123;public: virtual void func(void)&#123;&#125;&#x2F;&#x2F;虚函数&#125;;class Derived:pubilc Base&#123; void func(void)&#123;&#125;&#x2F;&#x2F;也是虚函数&#125; Derived d;Base* pb &#x3D; &amp;d;&#x2F;&#x2F;pb指向子类对象的基类指针Base&amp; rb &#x3D; d;&#x2F;&#x2F;rb引用子类对象的基类引用pb-&gt;func();&#x2F;&#x2F;实际被执行的将是子类中的覆盖版本rb.func();&#x2F;&#x2F;实际被执行的将是子类中的覆盖版本 2 虚函数覆盖(函数重写)条件1）只有类中成员函数才能被声明为虚函数，而全局函数、静态成员函数、构造函数都不能声明为虚函数。 注：析构函数可以为虚函数(特殊，后面讲)2）只有在基类中以virtual关键字修饰的成员函数才能作为虚函数被子类中版本覆盖，而与子类中虚函数是否加virtual关键字无关。3）虚函数在基类中的原始版本和子类中的覆盖版本必须具有相同的函数签名，即函数名、参数表和常属性一致。4）如果基类中的虚函数返回基本类型的数据，那么该函数在子类中覆盖版本必须返回相同类型的数据；而如果基类中的虚函数返回类类型的指针(A*)或引用(A&amp;)，那么允许子类中的覆盖版本返回其子类类型的指针(B*)或引用(B&amp;)。 3 多态的条件1）多态的语法现象除了满足虚函数覆盖，还必须通过指针或引用调用虚函数才能表现出来。2）调用虚函数的指针也可以是this指针，如果通过子类对象调用基类中的成员函数，在该成员函数中的this指针将是一个指向子类对象的基类指针，再使用this去调用虚函数，也可以表现多态的语法现象。//重点掌握eg:Qt中的多线程 1234567891011121314151617class QThread&#123;&#x2F;&#x2F;线程类，官方写好的类 public: void start(void)&#123;&#x2F;&#x2F;开启线程 this-&gt;run(); &#125; protected: virtual void run(void)&#123;&#x2F;&#x2F;线程入口函数 &#125; &#125;; class MyThread:public QThread&#123; protected: void run(void)&#123;&#x2F;&#x2F;重写线程入口函数 &#x2F;&#x2F;需要放在线程执行的代码 &#125; &#125;; MyThread thread; thread.start();&#x2F;&#x2F;开启子线程，重写的run函数将在子线程中被执行 4 纯虚函数、抽象类和纯抽象类1）纯虚函数 virtual 返回类型 函数名(形参表)[const] = 0;2）抽象类 如果类中包含了纯虚函数，那么该类就是抽象类。 注：抽象类不能创建对象.3）纯抽象类(接口、接口类) 如果类中所有的成员函数都是纯虚函数，那么该类就是纯抽象类。 5 多态原理//了解 通过虚函数表和动态绑定实现了多态的语法//参考polymorphic.png 1）虚函数表会增加内存的开销 2）动态绑定有时间的开销 3）虚函数不能被内联优化 总结：实际开发中如果没有多态的语法要求，最好不要使用虚函数。 6 虚析构函数问题：基类析构函数不会调用子类的析构函数，如果对一个指向子类对象的基类指针使用delete运算，实际被执行的将是基类的析构函数，子类的析构函数不会被执行，有内存泄漏风险解决：如果将基类中的析构函数声明为虚函数，那么子类中的析构函数也就是一个虚析构函数，并且可以对基类中版本形成覆盖，可以表现多态的语法；这时如果对一个指向子类对象的基类指针使用delete运算符，实际被执行的将是子类的析构函数，子类的析构函数在执行结束后又会自动调用基类的析构函数，从而避免内存泄漏。","link":"","tags":[]},{"title":"C++_8","date":"2021-08-21T10:31:43.000Z","path":"2021/08/21/C-8/","text":"二十一 继承(Inheritance)1 继承的概念 //了解​ 通过一种机制描述类型之间共性和特性的方式，利用已有的数据类型定义新的数据类型，这种机制就是继承. 基类–派生–&gt;子类 子类–继承–&gt;基类 2 继承的语法​ class 子类:继承方式 基类1,继承方式 基类2,…{​ ……​ };​ 继承方式:​ –&gt; 公有继承(public)​ –&gt; 保护继承protected(protected修饰类的成员时，保护成员在类的内部和子类的内部可以使用，类的外部不可使用)​ –&gt; 私有继承(private) 3 公有继承(public)的语法特性1）子类对象会继承基类的属性和行为，通过子类对象可以访问基类中的成员，如同是基类对象在访问它们一样。 注：子类对象中包含的基类部分被称为“基类子对象”2）向上造型(upcast)//重点掌握 将子类类型的指针或引用转换为基类类型的指针或引用；这种操作性(可操作权限)缩小的类型转换，在编译器看来是安全的，可以直接隐式转换. 基 类 ↑ 子 类 1234567891011 class A&#123;&#125;;class B:public A&#123;&#125;;class C:public A&#123;&#125;;class D:public A&#123;&#125;;...void func1(A* pa)&#123;&#125;void func2(A&amp; ra)&#123;&#125;int main(void)&#123; func1(&amp;B&#x2F;&amp;C&#x2F;&amp;D...);&#x2F;&#x2F;向上造型 func2(B&#x2F;C&#x2F;D...);&#x2F;&#x2F;向上造型&#125; 3）向下造型(downcast) 将基类类型的指针或引用转换为子类类型的指针或引用；这种操作性(可操作权限)放大的类型转换，在编译器看来是危险的，不能隐式转换，但可以显式转换(推荐static_cast&lt;类型&gt;)。 基 类 ↓ 子 类 4）子类继承基类的成员–》在子类中，可以直接访问基类中的公有和保护成员，就如同是子类自己的成员一样。–》基类中的私有成员，子类也可以继承，但是受到访问控制属性的影响，无法直接访问；如果希望访问基类中的私有成员，可以让基类提供公有或保护的成员函数，来间接访问。 5）子类隐藏基类的成员–》如果子类和基类定义了同名的成员函数，因为所属作用域不同，不能构成有效的重载关系，而是一种隐藏关系；通过子类对象将会优先访问子类自己的成员，基类的成员无法被使用。–》如果希望访问基类中被隐藏的同名成员，可以通过”类名::”显式指明 //推荐，d.Base::func();–》如果同名的成员函数参数不同，也可以通过using声明，将基类中的成员函数引入子类的作用域中，让它们形成重载，通过函数重载的参数匹配来解决。//不推荐，在子类里面using Base::func; 4 访问控制属性和继承方式1）访问控制属性：影响类中成员的访问位置。 访问控制限定符 访问控制属性 内部访问 子类访问 外部访问 友元访问 public 公有成员 ok ok ok ok protected 保护成员 ok ok no ok private 私有成员 ok no no ok 2）继承方式：影响通过子类访问基类中成员的可访问性 基类中的成员 公有继承的子类 保护继承的子类 私有继承的子类 公有成员 公有成员 保护成员 私有成员 保护成员 保护成员 保护成员 私有成员 私有成员 私有成员 私有成员 私有成员 eg: //阻断继承，防止扩散 class _Base{ public: void func(void){…} }; class Base:private _Base{//ok }; class A:public Base{};//no class B:public A{};//no class C:public B{};//no … ——————————–eg: class Base{ public: void func(void){…} }; //class Derived:public Base{}; class Derived:private Base{};//保护继承 int main(void){ Derived d; Base* pb = &d;//向上造型，error pb-&gt;func(); } 注：向上造型语法特性在保护继承和私有继承不再适用。 5 子类的构造函数//重点掌握1）如果子类构造函数没有显式指明基类子对象的初始化方式，那么编译器将会自动调用基类的无参构造函数来初始化基类子对象。2）如果希望基类子对象以有参的方式被初始化，则需要在子类构造函数的初始化列表中指明基类子对象的初始化方式。Derived(int i):Base(i)，m_member(j){};//在子类构造函数的初始化列表中指明基类子对象的初始化方式和成员子对象(m_member是一个类)的初始化方式3）子类对象创建过程–》分配内存–》构造基类子对象（按继承表顺序）–》构造成员子对象（按声明顺序）–》子类构造函数代码 6 子类的析构函数//重点掌握1）子类的析构函数，无论是自定义的还是编译器缺省提供的，都会自动调用基类的析构函数，完成积累子对象的销毁。2）子类对象销毁过程：–》子类析构函数代码–》析构成员子对象（按声明逆序）–》析构基类子对象（按继承表逆序）–》释放内存3）基类析构函数不会调用子类的析构函数，如果对一个指向子类对象的基类指针使用delete运算，实际被执行的将是基类的析构函数，子类的析构函数不会被执行，有内存泄漏风险。 注：解决方法：虚析构函数（后面讲）eg: class A{}; class B:public A{}; A* pa = new B;//pa:指向子类对象的基类指针 delete pa;//实际被执行的是基类的析构函数，有内存泄漏风险 7 子类的拷贝构造和拷贝赋值1）子类的拷贝构造–》如果子类自己没有定义拷贝构造函数，那么编译器会为其提供缺省的拷贝构造函数，该函数会自动调用基类的拷贝构造函数，完成基类子对象的拷贝初始化。–》如果子类自己定义了拷贝构造函数，那么需要使用初始化列表，显式指明基类子对象也要以拷贝的方式进行初始化。 12345class Base&#123;&#125;;class Derived:public Base&#123; &#x2F;&#x2F;Base(that):显式指明基类子对象也要以拷贝的方式进行初始化 Derived(const Derived&amp; that):Base(that),…&#123;&#125;&#125;； 2）子类的拷贝赋值–》如果子类自己没有定义拷贝赋值函数，那么编译器会为其提供缺省的拷贝赋值函数，该函数会自动调用基类的拷贝赋值函数，完成基类子对象的赋值操作。–》如果子类自己定义了拷贝赋值函数，那么需要在其中显式调用基类的拷贝赋值函数，完成对基类子对象赋值操作。 1234567891011class Base&#123;&#125;;class Derived:public Base&#123; &#x2F;&#x2F;Base(that):显式指明基类子对象也要以拷贝的方式进行初始化 Derived&amp; operator&#x3D;(const Derived&amp; that)&#123; if(*that !&#x3D; this)&#123; ………… Base::operator&#x3D;(that); &#125; return this; &#125;&#125;; 8 子类的操作符重载//了解9 多重继承1）概念：一个子类可以同时继承多个基类，这样的继承方式就为多重继承。2）向上造型时，编译器会根据各个基类子对象的内存布局，自动进行偏移计算，以保证指针的类型和所指向的基类子对象类型一致。3）名字冲突问题–》一个子类的多个基类中如果存在相同 的名字，当通过子类访问这些名字时，编译器会报歧义错误，即名字冲突。–》解决名字冲突的通用做法，就是显式使用“类名：：”，指明要访问名字属于哪个基类//推荐–》如果形成冲突的名字是成员函数，并且参数不同，也可以通过using声明，让他们在子类中形成重载关系，通过函数的重载解析来解决 10 钻石继承和虚继承1）钻收继承–》概念：一个子类的多个基类源自共同的基类祖先，这样继承机构被称为钻石继承。（公共基类、中间类、末端子类）。–》问题：在创建末端子类对象时，会包含多个公共基类子对象，通过末端子类去访问公共基类的成员时，会因为继承路劲不同，而导致结果不同。–》解决：通过虚继承，可以让公共基类子对象在末端子类对象中实例唯一，并可以为所有中间类共享，这样即使沿着不同继承路径所访问的成员一定时一致的。2）虚继承(虚继承原理可以去了解下)–》中间类在继承表位置使用virtual修饰–》由末端子类负责构造公共基类子对象 A(int m_data) / B C //class B/C:virtual public A{…}; \\ / D //class D:pulic B, pulic C{…};负责构造公共基类子对象 123class D:pulic B, pulic C&#123; D(int data):B(data),C(data),A(data)&#123;&#125;&#125;; 使用虚继承语法后，创建末端子类(D)对象时，继承机构类似如下：B C A\\ | / B","link":"","tags":[]},{"title":"C++_7","date":"2021-08-21T10:24:18.000Z","path":"2021/08/21/C-7/","text":"二十 操作符重载(operator)1 双目操作符重载 L#R1.1 计算类双目操作符： + - …1）表达式结果是右值，不能对表达式结果再赋值2）左右操作数既可以是左值也可以是右值3）两种具体实现方式–》成员函数形式(左调右参) L#R的表达式可以被编译器处理为”L.operator#(R)”成员函数调用形式，该函数的返回就是表达式结果。c1+2c &lt;==&gt; c1.operator+(c2);第一个const：修饰返回值，禁止对表达式结果再赋值第二个const：常引用参数，修饰传入的参数c2，支持常量型右操作数，第三个const：常成员函数，修饰调用的对象c1，支持常量型左操作数 1const Complex operator+(const Complex&amp; c)const&#123;&#125;; –》全局函数形式(左右都参) L#R的表达式可以被编译器处理为”operator#(L,R)”全局函数调用形式，该函数的返回就是表达式结果。 注：通过friend关键字可以把一个全局函数声明为某个类的友元，对于友元函数可以访问类中的任何成员，可以定义在类的内部，但本质还是全局函数。c2-c1 ==&gt; operator-(c2, c1); 1friend const Complex operator-(const Complex&amp; l, const Complex&amp; r)&#123;&#125; 1.2 赋值类双目操作符： += -= …1）表达式结果是左值，就是左操作数的自身2）左操作数一定是左值，右操作数可以是左值也可以是右值3）两种具体实现方式–》成员函数形式(左调右参),L#R ==&gt; L.operator#(R)c1+=c2 ==&gt; c1.operator+=(c2) 1Complex&amp; operator+&#x3D;(const Complex&amp; c)&#123; ………… return *this;&#125;&#x2F;&#x2F;引用函数，返回自身 –》全局函数形式(左右都参),L#R ==&gt; operator#(L,R)c1-=c2 ==&gt; operator-=(c1, c2) 1friend Complex&amp; operator-&#x3D;(Complex&amp; l, const Complex&amp; r)&#123;…………return l;&#125;&#x2F;&#x2F;引用函数，返回第一个参数 2 单目操作符重载 #O1.1 计算类单目操作符：-(负) ~(位反) …1）表达式结果是右值，不能对表达式结果再赋值2）操作数既可以是左值也可以是右值3）两种具体实现方式–》成员函数形式：#O ==&gt; O.operator#()-i ==&gt; i.operator-() 1const Integer operator-(void) const&#123;&#125;; –》全局函数形式：#O ==&gt; operator#(O)i ==&gt; operator(i) 1friend const Integer operator~(const Integer&amp; i)&#123;&#125; 1.2 自增减单目操作符：++ – …1）前++、––》表达式结果是左值，就是操作数自身–》操作数一定是左值–》两种具体实现方式 成员函数形式：#O ==&gt; O.operator#() 1Integer&amp; operator++(void)&#123;………… return *this;&#125; ​ 全局函数形式：#O ==&gt; operator#(O) 1friend Integer&amp; operator++(Integer&amp; i)&#123;…………return i;&#125; 2）后++、––》表达式结果是右值，是操作数自增减前副本，不能对表达结果再赋值–》操作数一定是左值–》两种具体实现方式 成员函数形式：O# ==&gt; O.operator#(int/哑元/)//构成重载，编译器自动选择 1const Integer operator++(int)&#123;………………return old;&#125; ​ 全局函数形式：O# ==&gt; operator#(O,int /* 哑元 */) 1friend const Integer operator++(Integer&amp; i, int)&#123;………………return old;&#125; ​ 3 输出(插入)和输入(提取)操作符重载: &lt;&lt; &gt;&gt;功能：实现自定义类型对象的直接输出或输入注：只能使用全局函数形式，不能使用成员函数形式 #include &lt;iostream&gt; ostream //标准输出流类，cout就是该类实例化的对象 istream //标准输入流类，cin就是该类实例化的对象 //全局函数形式：operator&lt;&lt;(cout,a)//cout是左值，被改变，a是右值 cout &lt;&lt; a; //全局函数形式：operator&gt;&gt;(cin,a)//cin、a都是左值，都要被改变 cin &lt;&lt; b; ------------------------------------------------ friend ostream&amp; operator&lt;&lt;(ostream&amp; os,const Right&amp; right)&#123; ... return os; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; is,Right&amp; right)&#123; ... return is; &#125; 4 下标操作符重载 []功能：实现自定义类型对象能够像数组一样去使用注：非常对象返回左值，常对象返回右值 string s = “minwei”; s[0] = ‘M’;//s.operator = ‘M’ s[3] = ‘W’;//s.operator = ‘W’ cout &lt;&lt; s &lt;&lt; endl;//“MinWei” ​ const string s2 = “youchengwei”;​ cout &lt;&lt; s2[0] &lt;&lt; endl;//y​ s2[0] = ‘Y’;//errorint&amp; operator[](size_t i){ return m_arr[i]; }//非常函数，适用非常对象，返回左值const int&amp; operator[](size_t i)const{ return m_arr[i]; }//常函数，适用常对象，返回右值​ 5 函数操作符重载 ()功能：实现让自定义类型对象像函数一样使用//仿函数注：对于参数个数、参数类型和返回类型没有任何限制，只能声明为成员函数形式 A a(..); a(100,1.23);//a.operator()(100,1.23)int operator()(int a, int b){}int operator()(int a){} 6 new/delete操作符重载 //了解内存创建和销毁过程static void* operator new(size_t size){…}//1、A* pa = (A* )A::operator new(sizeof(A));//分配内存//2、构造成员子对象（按声明顺序）//3、pa调用自身构造函数A* pa = newA; static void operator delete(void* p){…}//1、pa调用自身析构函数//2、析构成员子对象（按对象逆序）//3、(A*)A::operator delete(pa);//释放内存A * pa = newA; 7 操作符重载限制1）不是所有操作符都能重载，下面几个操作符不能重载–》作用域限定操作符 “::”–》直接成员访问操作符 “.”–》直接成员指针解引用操作符 “.*”–》条件操作符 “?:”–》字节长度操作符 “sizeof”–》类型信息操作符 “typeid”//后面讲2）如果一个操作符所有的操作数都是基本类型，则无法重载3）操作符重载不会改变预定的优先级4）操作符重载不会改变操作数个数5）不能通过操作符重载发明新的操作符6）只能使用成员函数形式重载的操作符 = [] () -&gt;","link":"","tags":[]},{"title":"C++_6","date":"2021-08-21T04:00:17.000Z","path":"2021/08/21/C-6/","text":"十八 静态成员(static)1 静态成员变量1）语法 class 类名{ static 数据类型 变量名;//声明 }; 数据类型 类名::变量名 = 初值;//定义和初始化2）普通成员变量属于对象，而静态成员变量不属于对象，静态变量内存在全局区，可以把静态变量理解为被限制在类中使用的全局变量，属于公共资源.3）普通成员变量在对象构造时定义和初始化，而静态成员变量在类的外部单独定义和初始化，对象大小（类的类型的大小）不包括静态成员变量5）使用方法 类名::静态成员变量;//推荐 对象.静态成员变量;//和上面等价 2 静态成员函数1）语法 class 类名{ static 返回类型 函数名(参数表){…} };2）静态成员函数中没有this指针，也没有const属性，可以把静态成员函数理解为被限制在类作用域使用的全局函数.3）使用方法 类名::静态成员函数(实参表);//推荐 对象.静态成员函数(实参表);//和上面等价注：在静态成员函数中只能访问静态成员，不能访问非静态成员；在非静态成员函数既可以访问静态成员，也可以访问非静态成员. 3 单例模式1）概念 一个类只允许存在唯一的对象，并提供它的方法.2）实现思路–》禁止在类的外部创建对象：私有化构造函数即可–》类的内部维护唯一的对象：静态成员变量–》提供单例对象的访问方法：静态成员函数3）具体创建方式–》饿汉式：单例对象无论用或不用，程序启动即创建–》懒汉式：单例对象用时再创建，不用即销毁（多敲多背单例模式代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;class Singleton&#123;&#x2F;&#x2F;单例模式--饿汉式public: &#x2F;&#x2F;3)通过静态成员函数获取单例对象 static Singleton&amp; getInstance(void)&#123; return s_instance; &#125; void print(void)&#123; cout &lt;&lt; m_data &lt;&lt; endl; &#125;private: &#x2F;&#x2F;1)私有化构造函数(包括拷贝构造) Singleton(int data&#x3D;0):m_data(data)&#123; cout &lt;&lt; &quot;单例对象被创建了&quot; &lt;&lt; endl; &#125; Singleton(const Singleton&amp;); &#x2F;&#x2F;2)使用静态成员变量表示唯一的对象 static Singleton s_instance;private: int m_data;&#125;;Singleton Singleton::s_instance(123);int main(void)&#123; cout &lt;&lt; &quot;main函数开始执行&quot; &lt;&lt; endl; &#x2F;&#x2F;Singleton s(100);&#x2F;&#x2F;error &#x2F;&#x2F;Singleton* ps&#x3D;new Singleton(100);&#x2F;&#x2F;error Singleton&amp; s1&#x3D;Singleton::getInstance(); Singleton&amp; s2&#x3D;Singleton::getInstance(); Singleton&amp; s3&#x3D;Singleton::getInstance(); s1.print();&#x2F;&#x2F;123 s2.print();&#x2F;&#x2F;123 s3.print();&#x2F;&#x2F;123 cout &lt;&lt; &quot;&amp;s1:&quot; &lt;&lt; &amp;s1 &lt;&lt; endl; cout &lt;&lt; &quot;&amp;s2:&quot; &lt;&lt; &amp;s2 &lt;&lt; endl; cout &lt;&lt; &quot;&amp;s3:&quot; &lt;&lt; &amp;s3 &lt;&lt; endl; &#x2F;&#x2F;Singleton s4 &#x3D; s1;&#x2F;&#x2F;应该error &#x2F;&#x2F;cout &lt;&lt; &quot;&amp;s4:&quot; &lt;&lt; &amp;s4 &lt;&lt; endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;pthread.h&gt;using namespace std;class Singleton&#123;&#x2F;&#x2F;单例模式--懒汉式public: &#x2F;&#x2F;3)通过静态成员函数获取单例对象 static Singleton&amp; getInstance(void)&#123; pthread_mutex_lock(&amp;mutex); if(s_instance &#x3D;&#x3D; NULL)&#123; s_instance &#x3D; new Singleton(123); &#125; ++s_count; pthread_mutex_unlock(&amp;mutex); return *s_instance; &#125; &#x2F;&#x2F;单例对象不用即销毁,销毁时机? &#x2F;&#x2F;最后一个使用者不在使用才能真的销毁! void release(void)&#123; pthread_mutex_lock(&amp;mutex); if(--s_count &#x3D;&#x3D; 0)&#123; delete s_instance; s_instance &#x3D; NULL; &#125; pthread_mutex_unlock(&amp;mutex); &#125; void print(void)&#123; cout &lt;&lt; m_data &lt;&lt; endl; &#125;private: &#x2F;&#x2F;1)私有化构造函数(包括拷贝构造) Singleton(int data&#x3D;0):m_data(data)&#123; cout &lt;&lt; &quot;单例对象被创建了&quot; &lt;&lt; endl; &#125; Singleton(const Singleton&amp;); ~Singleton(void)&#123; cout &lt;&lt; &quot;单例对象被销毁了&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;2)使用静态成员变量维护唯一的对象 static Singleton* s_instance; &#x2F;&#x2F;计数:记录单例对象使用者个数 static int s_count; &#x2F;&#x2F;互斥所 static pthread_mutex_t mutex;private: int m_data;&#125;;Singleton* Singleton::s_instance&#x3D;NULL;int Singleton::s_count &#x3D; 0;pthread_mutex_t Singleton::mutex &#x3D; PTHREAD_MUTEX_INITIALIZER;int main(void)&#123; cout &lt;&lt; &quot;main函数开始执行&quot; &lt;&lt; endl; &#x2F;&#x2F;Singleton s(100);&#x2F;&#x2F;error &#x2F;&#x2F;Singleton* ps&#x3D;new Singleton(100);&#x2F;&#x2F;error Singleton&amp; s1&#x3D;Singleton::getInstance(); Singleton&amp; s2&#x3D;Singleton::getInstance(); Singleton&amp; s3&#x3D;Singleton::getInstance(); s1.print();&#x2F;&#x2F;123 s1.release();&#x2F;&#x2F;--s_count:2 s2.print();&#x2F;&#x2F;123 s3.print();&#x2F;&#x2F;123 cout &lt;&lt; &quot;&amp;s1:&quot; &lt;&lt; &amp;s1 &lt;&lt; endl; cout &lt;&lt; &quot;&amp;s2:&quot; &lt;&lt; &amp;s2 &lt;&lt; endl; cout &lt;&lt; &quot;&amp;s3:&quot; &lt;&lt; &amp;s3 &lt;&lt; endl; s2.release();&#x2F;&#x2F;--s_count:1 s3.release();&#x2F;&#x2F;--s_count:0,delete return 0;&#125; 十九 成员指针//了解1 成员变量指针1）定义 类型 类名::成员指针变量名 = &amp;类名::成员变量;2）使用 对象.*成员指针变量名; 对象指针-&gt;*成员指针变量名; 注：“.*”和“-&gt;*”是一个符号，不能写分家了int A::*pdata = &amp;A::m_data;//定义,pdata指向A::m_data,记录m_data在A里面的相对位置A a(100);//a.*pdata=100;A pa = new A(100);//pa-&gt;*pdata=200; 2 成员函数指针//了解1）定义 返回类型 (类名::成员函数指针)(参数表) = &amp;类名::成员函数名;2）使用 (对象.*成员函数指针)(实参表); (对象指针-&gt;*成员指针变量名)(实参表);void (A::*pfunc)(void) = &amp;A::print;A a(100);(a.*pfunc)();A pa = new A(100);(pa-&gt;*pfunc)();","link":"","tags":[]},{"title":"C++_5","date":"2021-08-21T03:56:19.000Z","path":"2021/08/21/C-5/","text":"十五 this指针和常成员函数1 this指针1）类中的成员函数(包括构造函数、析构函数)都有一个隐藏的当前类 类型的指针参数，名为this。在成员函数中访问类中其它成员，其本质都是通过this来实现的。2）对于普通的成员函数,this指针就是指向该成员函数的调用对象；对于构造函数,this指针就指向正在创建的对象。3）大多数情况，可以忽略this直接访问类中的成员，但是在以下几个特殊场景必须要显式使用this指针:–》区分作用域，(区分哪个是成员变量)–》从成员函数返回调用对象自身(返回自引用)//重点掌握–》从类的内部销毁对象自身(对象自销毁) //了解–》作为成员函数实参，实现对象之间交互 //了解 2 常成员函数(常函数)1）在一个成员函数参数表后面加上const，这个成员函数就是常成员函数。 返回类型 函数名(参数表) const {函数体}2）常成员函数中的this指针是一个常量指针，不能在常成员函数中修改成员变量的值。eg：void print(void) const {} &lt;=&gt; void print(const A* this)3）被mutable关键字修饰的成员变量，可以在常成员函数中被修改。4）非常对象既可以调用常函数也可以调用非常函数；而常对象只能调用常函数，不能调用非常函数. 注：常对象也包括常指针和常引用5）同一个类中，函数名形参表相同的成员函数，其常版本和非常版本可以构成有效的重载关系，常对象匹配常版本，非常对象匹配非常版本. 十六 析构函数(Destructor)1 语法​ class 类名{​ 类名(void){​ //主要负责清理对象生命周期中的动态资源​ }​ };​ 1）函数名必须是”类名”​ 2）没有返回类型，也没有参数​ 3）不能被重载，一个类只能有一个析构函数、 2 当对象被销毁时，相应类的析构函数将被自动执行1）栈对象当其离开所在作用域时，其析构函数被作用域终止“右化括号”调用2）堆对象的析构函数被delete操作符调用 3 如果一个类自己没有定义析构函数，那么编译器会为该类提供一个缺省的析构函数：1）对基本类型的成员变量，什么也不做2）对类 类型的成员(成员子对象)，将会自动调用相应类的析构函数. 4 对象创建和销毁的过程1）创建–》分配内存–》构造成员子对象(按声明顺序)–》执行构造函数代码2）销毁–》执行析构函数代码–》析构成员子对象(按声明逆序)–》释放内存 十七 拷贝构造和拷贝赋值1 浅拷贝和深拷贝 //参考copy.png 1）如果一个类中包含了指针形式的成员变量，缺省的拷贝构造函数只是赋值了指针变量自身，而没有复制指针所指向的内容，这种拷贝方式被称为浅拷贝.（只拷贝指针变量本身）2）浅拷贝将会导致不同对象之间的数据共享，如果数据在堆区，析构时还可能会出现”double free”的异常，为此就必须自己定义一个支持复制指针所指向内容的拷贝构造函数（拷贝指针所指向的数据），即深拷贝（先new，再*=*）。 2 拷贝赋值 //参考copy2.png 1）当两个对象进行赋值运算时，比如”i3=i2”,编译器会将其处理为“i3.operator=(i2)”成员函数调用形式，其中“operator=”被称为拷贝赋值函数，由该函数完成两个对象的赋值运算，该函数的返回结果就是赋值表达式结果.2）如果自己没有定义拷贝赋值函数，那么编译器会提供一个缺省的拷贝赋值函数，但是缺省的拷贝赋值和缺省拷贝构造类似，也是浅拷贝，只是赋值指针变量本身，而没有复制指针所指向的内容，有数据共享、double free、内存泄漏的问题。3）为了避免浅拷贝的问题，必须自己定义深拷贝赋值函数: 类名&amp; operator=(const 类名&amp; that){ if(&amp;that != this){//防止自赋值 释放旧内存; 分配新内存; 拷贝新数据; } return *this;//返回自引用 }","link":"","tags":[]},{"title":"C++_4","date":"2021-08-21T03:44:01.000Z","path":"2021/08/21/C-4/","text":"十二 类和对象//了解1 什么是对象 万物皆对象，任何一种事物都可以看做是对象. 2 如何描述对象 通过对象的属性和行为来描述对象. 3 面向对象程序设计 对自然世界中对象观察和描述引入到编程中一种理念和方法，这种方法称为”数据抽象”，即在描述对象时把细节东西剥离出去，只考虑一般性的、有规律性的、统一性的东西. 4 什么是类 类就是将多个对象共性提取出来定义的一种新的数据类型，是对 对象 属性和行为的抽象描述. 现实世界 类 虚拟世界具体对象–抽象–&gt;属性/行为–实例化–&gt;具体对象 十三 类的定义和实例化1 类定义的一般语法形式12345678struct&#x2F;class 类名:继承方式 基类,...&#123;访问控制限定符: 类名(形参表):初始化列表&#123;&#125;&#x2F;&#x2F;构造函数 ~类名(void)&#123;&#125;&#x2F;&#x2F;析构函数 返回类型 函数名(形参表)&#123;&#125;&#x2F;&#x2F;成员函数 数据类型 变量名;&#x2F;&#x2F;成员变量&#125;; 2 访问控制限定符1）public：公有成员，任何位置都可以访问。2）private：私有成员，只有类自己的成员函数才能访问3）protected：保护成员(后面讲) C++中struct和class区别：​ struct定义类默认的访问控制属性是public；而class定义类默认的访问控制属性是private。​ struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。 封装：使用函数指针把属性与方法封装到结构体中。类中的私有成员不能在外部直接访问，但是可以提供公有成员来间接访问，在函数中可以合理对非法数据加以限定控制业务逻辑的合理性，这种编程思想叫“封装。” 3 构造函数(constructor)1）语法 class 类名{ 类名(参数表){ 主要负责初始化对象，即初始化成员变量。 } };2）函数名和类名一致，没有返回类型。3）构造函数在创建对象时自动被调用，不能像普通的成员函数一样显式的调用，在创建对象时可以向构造函数传递参数.4）在每个对象的生命周期，构造函数一定会被调用，且仅会被调用一次。 4 对象的创建和销毁1）在栈区创建单个对象 //重点掌握eg: string s; 类名 对象(构造实参表);//直接初始化 string s(“hello”); 类名 对象=类名(构造实参表);//拷贝初始化(实际等价) string s = string(“hello”); &lt;=&gt; string s = “hello”;(只有第一个参数情况下) 2）在栈区创建多个对象(对象数组) 类名 对象数组[元素个数] = { 类名(构造实参表),类名(构造实参表),…}; 3）在堆区创建/销毁单个对象 //重点掌握创建： 类名* 对象指针 = new 类名(构造实参表); 注：new操作符会先分配内存再自动调用构造函数，完成对象的创建和初始化；而如果是malloc函数只能分配内存，不会调用构造函数，不具备创建对象能力. 销毁： delete 对象指针; 注：delete操作符会自动调用析构函数销毁对象再释放内存；而如果是free函数只能释放内存，不会调用析构函数，不具备销毁对象能力. 4）在堆区创建/销毁多个对象创建： 类名* 对象指针 = new 类名[元素个数] { 类名(构造实参表),类名(构造实参表),…};eg： Student* parr = new Student[3] { Student(“xiaoqiao”, 22, 10016); Student(“daqiao”, 25, 10017); };销毁： delete[] 对象指针; 5 多文件编程：类的声明和定义可以分别放在不同的文件中1）类的声明一般放在头文件中(xx.h)2）类的实现一般放在源文件中(xx.cpp) 十四 构造函数和初始化列表1 构造函数可以重载，也可以带有缺省参数。2 缺省构造函数(无参构造函数)1）如果类中没有定义任何构造函数,编译器会为该类提供一个缺省(无参)构造函数：–》对于基本类型成员变量不做初始化–》对于类 类型的成员变量(成员子对象)，将会自动调用相应类的无参构造函数来初始化 2）如果自己定义了构造函数，无论是否有参数，那么编译器都不会再提供缺省的无参构造函数了. 3 类型转换构造函数(单参构造函数)123456789 class 类名&#123;​ &#x2F;&#x2F;可以将源类型变量转换为当前类类型对象.​ 类名(源类型)&#123;...&#125;&#x2F;&#x2F;(单参构造函数)​ &#125;;​ class 类名&#123;​ &#x2F;&#x2F;加“explicit”关键字修饰，可以强制要求这种类型转换必须显式的完成.​ explicit 类名(源类型)&#123;...&#125;​ &#125;; 4 拷贝构造函数(复制构造函数)1）用一个已存在的对象作为同类对象的构造实参，创建新的副本对象时，会调用该类拷贝构造函数。 class 类名{ 类名(const 类名&amp;){//拷贝构造,一定要用引用&amp;，而且要用const（可以传左值和右值） … } }; ​ class A{…}；​ A a1(…);​ //匹配A的拷贝构造函数​ A a2(a1);​ A a2 = A(a1);​ A a2 = a1;​2）如果一个类没有自己定义拷贝构造函数，那么编译器会为该类提供一个缺省的拷贝构造函数：​ –》对于基本类型的成员变量，按字节复制​ –》对于类类型的成员变量(成员子对象)，将自动调用相应类的拷贝构造函数来初始化​ 注：一般不需要自己定义拷贝构造函数函数，因为编译器缺省提供的已经很好用了. class A1&#123;&#125;;//缺省无参，缺省拷贝 class A2&#123;//缺省拷贝 A(void)&#123;&#125; &#125;; class A3&#123;//缺省拷贝 A(int)&#123;&#125; &#125;； class A4&#123;//没有缺省构造，因为已经有拷贝构造了 A(const A&amp;)&#123;&#125; &#125;; 3）拷贝构造函数调用时机–》用一个已存在对象作为同类对象的构造实参–》以对象形式向函数传递参数（传参时可使用引用&amp;避免拷贝）–》从函数中返回对象(返回的对象先被拷贝到临时对象中，临时对象再被拷贝到目标对象中，所以发生两次拷贝，但是有可能被编译器优化掉(目标对象直接引用临时对象)而导致只发生一次拷贝) 5 初始化列表1）语法 class 类名{ //定义成员变量同时初始化，可以显式初始化成员子对象 类名(参数表):成员变量1(初值),成员变量2(初值){ … } };eg： class Student{ public: //使用构造函数体赋初值：先定义成员变量，再赋初值 Student(const string&amp; name,int age,int no){ m_name = name; m_age = age; m_no = no; } //使用初始化列表赋初值：定义成员变量同时初始化 Student(const string&amp; name,int age,int no) :m_name(name),m_age(age),m_no(no){ } private: string m_name; int m_age; int m_no; };2）大多数情况使用初始化列表和在构造函数体赋初值没有太大区别，两种形式可以任选；但是有以下特殊场景必须要使用初始化列表:–》如果有类 类型的成员变量(成员子对象)，并希望以有参方式对其进行初始化，则必须使用初始化列表显式指明成员子对象需要的构造实参。–》如果类中包含”const”或”引用”成员变量，则必须在初始化列表显式的初始化。注：成员变量的初始化顺序由声明顺序决定，而与初始化列表的顺序无关，所以不要使用一个成员变量去初始化另一个成员变量.","link":"","tags":[]},{"title":"C++_3","date":"2021-08-21T03:37:55.000Z","path":"2021/08/21/C-3/","text":"十一 类型转换1 隐式类型转换12345678910char c &#x3D; &#39;A&#39;;int i &#x3D; c;&#x2F;&#x2F;隐式void func(int i)&#123;&#125;func(c);&#x2F;&#x2F;隐式int func(void)&#123; char c&#x3D;&#39;A&#39;; return c;&#x2F;&#x2F;隐式&#125; 2 显示类型转换2.1 C++兼容C中强制类型转换123char c &#x3D; &#39;A&#39;; int i &#x3D; (int)c;&#x2F;&#x2F;C风格 int i &#x3D; int(c);&#x2F;&#x2F;C++风格 2.2 C++扩展了四种操作符形式显式转换1）静态类型转换:static_cast语法： 目标变量 = static_cast&lt;目标类型&gt;(源类型变量);适用场景： 主要用于将void* 转化为其它类型的指针，也可以用于向下造型(downcast)的显式转换 2）动态类型转换:dynamic_cast语法： 目标变量 = dynamic_cast&lt;目标类型&gt;(源类型变量);适用场景： 主要用于具有多态特性父子类指针或引用之间的显式类型转换. 动态类型转换过程中，会检查原类型变量和期望转换的类型是否一致，如果一致则转换成功，否则失败 3）去常类型转换:const_cast语法： 目标变量 = const_cast&lt;目标类型&gt;(源类型变量);适用场景： 主要用于去掉指针或引用const属性. 12345const int i &#x3D; 100；int* pi &#x3D; const_cast&lt; int* &gt;(&amp;i);&#x2F;&#x2F;ok,但是p&#x3D;&amp;i,*pi !&#x3D; i, 这是编译器优化导致的错误volatile const int i &#x3D; 100；int* pi &#x3D; const_cast&lt;int*&gt;(&amp;i);&#x2F;&#x2F;ok,p &#x3D;&#x3D; &amp;i,且*pi &#x3D;&#x3D; i, volatile是标准C语言的关键字，被volatile修饰的变量表示易变的，告诉编译器每次使用该变量时，都要小心从内存中读取，而不是取寄存器的副本，防止编译器优化引起的错误变化 4）重解释类型转换:reinterpret_cast语法： 目标变量=reinterpret_cast&lt;目标类型&gt;(源类型变量);适用场景： 在指针和整型数进行显式转换. 任意类型指针或引用之间显式转换. eg:已知物理内存地址0x12345678，向该地址存放一个整型数100？ int* paddr = reinterpret_cast&lt;int*&gt;(0x12345678); *paddr = 100; 二十三 运行时的类型信息//了解1 typeid操作符 #include typeid(类型/对象);//返回typeinfo对象，用于描述类型信息 typeinfo支持”==,!=”操作符重载，可以直接进行类型之间比较，如果类型直接具有多态的继承关系，typeid还可以利用多态的语法确定实际的目标对象类型 ​","link":"","tags":[]},{"title":"C++_2","date":"2021-08-21T03:32:40.000Z","path":"2021/08/21/C-2/","text":"六 C++的布尔类型(bool)1 bool类型是C++中的基本数据类型，专门表示逻辑值，逻辑真用true表示，逻辑假false表示2 bool类型在内存占一个字节：1表示true，0表示false3 bool类型变量可以接收任意类型表达式结果，其值非0则为true，为0则为假。 八 C++的函数1 函数重载(overload)1）定义 在相同作用域，可以定义同名的函数，但是参数必须有所区分，这样函数构成重载关系. 注：函数重载与返回类型无关。 2）函数重载匹配 调用重载关系的函数时，编译器将根据实参和形参的匹配程度，自动选择最优的重载版本，当前g++编译器匹配一般规则： 完全匹配&gt;=常量转换&gt;升级转换&gt;降级转换&gt;省略号 3）函数重载原理 C++的编译器在编译函数时，会进行换名，将参数表的类型信息整合到新的函数名中，因为重载关系的函数参数表有所区分，换出的新的函数名也一定有所区分，解决了函数重载和名字冲突的矛盾。 C++中extern “C”作用​ 被 extern 限定的函数或变量是 extern 类型的​ 被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的​ 在C++函数声明时加extern “C”，要求C++编译器不对该函数进行换名，当作C语言代码处理，便于C程序直接调用该函数，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。​ 注：extern “C”的函数无法重载。​ 2 函数的缺省参数(默认实参)1）可以为函数参数指定缺省值，调用该函数时，如果不给实参，就取缺省值作为默认实参。 void func(int i,int j=0/缺省参数/){}2）靠右原则：如果函数的某个参数带有缺省值，那么该参数右侧的所有参数都必须带有缺省值。3）如果函数的声明和定义分开写，缺省参数应该写在函数的声明部分，而定义部分不写。 3 函数的哑元参数1）定义(不是声明)函数时，只有类型而没有变量名的形参被称为哑元 void func(int){…}2）需要使用哑元场景–》在操作符重载函数中，区分前后++、– //后面讲–》兼容旧的代码 算法库：void math_func(int a,int b){…} 升级算法库:void math_func(int a,int/哑元/){…} 4 内联函数(inline)1）使用inilne关键字修饰的函数，即为内联函数，编译器将会尝试进行内联优化，可以避免函数调用开销，提高代码执行效率. inline void func(void){…}2）使用说明–》多次调用小而简单的函数适合内联优化–》调用次数极少或大而复杂的函数不适合内联–》递归函数不能内联优化–》虚函数不能内联优化//后面讲 注：内联只是一种建议而不是强制的语法要求，一个函数能否内联优化主要取决于编译器，有些函数不加inline修饰也会默认处理为内联优化，有些函数即便加了inline修饰也会被编译器忽略。 九 C++动态内存管理1 C语言动态内存管理1）分配：malloc()2）释放：free() 2 C++动态内存管理 1）分配：new/new[]2）释放：delete/delete[] 123456int* p1 &#x3D; new int;&#x2F;&#x2F;定义delete p1;int* p2 &#x3D; new int(100);&#x2F;&#x2F;定义且初始化delete p2;int* p3 &#x3D; new int[10];&#x2F;&#x2F;数组，有十个intdelete[] p3; delete一个野指针（只声明未定义的指针），危险；delete空指针（NULL），安全，无意义；不能多次delete同一个指针 十 C++引用(Reference)1 定义1）引用即别名，引用就是某个变量别名，对引用操作和对变量本身完全相同.2）语法 类型 &amp; 引用名 = 变量名; 注：引用必须在定义同时初始化（引用没有被分配内存），而且在初始化以后所绑定的目标变量不能再做修改. 注：引用类型和绑定目标变量类型要一致。 12345678910int a &#x3D; 10;int &amp; b &#x3D; a;&#x2F;&#x2F;b就是a的别名b++;cout &lt;&lt; a &lt;&lt; endl;&#x2F;&#x2F;11a++;cout &lt;&lt; b &lt;&lt; endl;&#x2F;&#x2F;12int c &#x3D; 123;b &#x3D; c;&#x2F;&#x2F;仅是赋值cout &lt;&lt; a &lt;&lt; endl;&#x2F;&#x2F;123 2 常引用1）定义引用时可以加const修饰，即为常引用，不能通过常引用修改目标变量. const 类型 &amp; 引用名 = 变量名; 类型 const &amp; 引用名 = 变量名;//和上面等价 int a = 10; const int&amp; b = a;//b就是a常引用 cout &lt;&lt; b &lt;&lt; endl;//10 b++;//error 2）普通引用也可以称为左值引用，只能引用左值；而常引用也可以称为万能引用，既可以引用左值也可以引用右值。 123456const int&amp; r1 &#x3D; 100;&#x2F;&#x2F;okint&amp; r2 &#x3D; 200;&#x2F;&#x2F;error，200为右值 int a &#x3D; 10, b &#x3D; 20;int&amp; r3 &#x3D; a+b;&#x2F;&#x2F;error&#x2F;&#x2F;r4引用的是a+b表达式结果的临时变量（右值）const int&amp; r4 &#x3D; a+b;&#x2F;&#x2F;ok 3）关于左值和右值 左值(lvalue):可以放在赋值表达式左侧或者右侧，可以被修改 右值(rvalue):只能放在赋值表达式右侧，不能被修改 练习：测试下面表达式结果，是左值还是右值？ int a,b; a+b;//右值 a+=b;//左值 ++a;//左值 a++;//右值 3 引用型函数参数1）可以将引用用于函数的参数，这时形参就是实参别名，可以通过形参直接修改实参的值；同时还能避免函数调用时传参的开销，提高代码执行效率。int func(int&amp; a, int&amp; b);2）引用型参数有可能意外修改实参的值，如果不希望修改实参，可以将形参声明为常引用，提高效率的同时还可以接收常量型的实参。int func(const int&amp; a); 4 引用型函数返回值1）可以将函数的返回类型声明为引用，这时函数的返回结果就是return后面数据的别名，可以避免返回值带来的开销，提高代码执行效率.2）如果函数返回类型是左值引用，那么函数调用表达式结果就也将是一个左值。 注：不要从函数中返回局部变量的引用，因为所引用的内存会在函数返回以后被释放，使用非常危险！可以在函数中返回成员变量、静态变量、全局变量的引用。 int&amp; func(void){ … return num; } func() = 100;//ok,左值引用 5 引用和指针1）如果从C语言角度看待引用的本质，可以认为引用就是通过指针实现的，但是在C++开发中，推荐使用引用，而不推荐使用指针. int i = 100; int* const pi = &i; int&amp; ri = i; * pi &lt;=等价=&gt; ri2）指针可以不做初始化，其目标可以在初始化以后随意改变(指针常量除外)，而引用必须做初始化，而且一旦初始化所引用的目标不能再改变. //下面内容了解3）可以定义指针的指针(二级指针)，但是不能定义引用的指针. int a = 10; int* p = &a; int** pp = &p;//二级指针 ​ int&amp; r = a;​ int&amp;* pr = &r;//error,引用的指针​ int* pr = &r;//ok,仅是普通指针​4）可以指针的引用(指针变量别名)，但是不能定义引用的引用。​ int a = 100;​ int* p = &a;​ int* &amp; rp = p;//ok,指针的引用 ​ int&amp; r = a;​ int&amp; &amp; rr = r;//error,引用用的引用​ int&amp; rr = r;//ok,但是仅是一个普通引用​5）可以指针数组，但是不能定义引用数组​ int i=10,j=20,k=30;​ int* parr[3] = {&amp;i,&amp;j,&amp;k};//ok,指针数组​ int&amp; rarr[3] = {i,j,k};//error​6）可以定义数组引用（数组别名）​ int i=10,j=20,k=30;​ int arr[3] = {i,j,k};​ int (&amp;rarr)[3] = arr;//ok, 数组引用 7）和函数指针类似，也可以定义函数引用(函数别名) void func(int i){} int main(void){ void (*pf)(int) = func;//函数指针 void (&amp;rf)(int) = func;//函数引用 pf(100); rf(100); } ​","link":"","tags":[]},{"title":"C++_1","date":"2021-08-21T03:22:05.000Z","path":"2021/08/21/C-1/","text":"C++编程习惯：1 慎用宏，可以使用const、enum、inline替换 123456789101112#define PAI 3.14--》const double PAI &#x3D; 3.14;#define SLEEP 0#define RUN 1#define STOP 2--》enum STATE&#123;SLEEP,RUN,STOP&#125;;#define Max(a,b) ((a)&gt;(b)?(a):(b)) --》inline int Max(int a,int b)&#123; return a &gt; b ? a : b; &#125; 2 变量随用随声明同时初始化3 尽量使用new/delete替换malloc/free4 少用void* 、指针计算、联合体和强制转换5 尽量使用string表示字符串，少用C风格的char*/char[] C与C++区别1）都是编译型语言2）都是强类型语言，但是C++更强3）C++去除了C中不好的特性4）C++增加了很多C语言中没有的好的语法特性，全面支持面向对象，比C语言更适合大型软件开发。 二 第一个C++程序1 编译方式1）gcc xx.cpp -lstdc++2）g++ xx.cpp //推荐 2 文件扩展名1）.cpp //推荐2）.cc3）.C4）.cxx 3 头文件 #include –》C++中和I/O相关的类型、对象、函数都在在头文件中 –》C++中大多数头文件没有”.h”后缀 注：在C++中开发中，依然可以使用标准C库的头文件，另外在C++中还提供一套不带“.h”替换版本. #include &lt;stdio.h&gt; ==&gt; #include #include &lt;stdlib.h&gt; ==&gt; #include #include &lt;string.h&gt; ==&gt; #include … 4 C++中标准输入和输出1）cin对象表示标准输入//类似scanf 123456789&#x2F;&#x2F;从键盘读取一个int数据int num&#x3D;0;scanf(&quot;%d&quot;,&amp;num);&#x2F;&#x2F;C语言cin &gt;&gt; num;&#x2F;&#x2F;C++语言注：“&gt;&gt;”被称为输入(提取)操作符&#x2F;&#x2F;从键盘同时读取一个int和一个double数据int i&#x3D;0,double d &#x3D; 0.0;scanf(&quot;%d%lf&quot;,&amp;i,&amp;d);&#x2F;&#x2F;C语言cin &gt;&gt; i &gt;&gt; d;&#x2F;&#x2F;C++语言 2）cout对象表示标准输出//类似printf 1234567891011&#x2F;&#x2F;打印输出一个int数据int num &#x3D; 123;printf(&quot;%d\\n&quot;,num);&#x2F;&#x2F;C语言cout &lt;&lt; num &lt;&lt; endl;&#x2F;&#x2F;C++语言注：“&lt;&lt;”被称为输出(插入)操作符注：“endl”表示换行和&quot;\\n&quot;类似&#x2F;&#x2F;同时打印输出一个int数据和一个double int i&#x3D;100,double d&#x3D;1.23;printf(&quot;%d,%lf\\n&quot;,i,d);&#x2F;&#x2F;C语言cout &lt;&lt; i &lt;&lt; &#39;,&#39; &lt;&lt; d &lt;&lt; endl;&#x2F;&#x2F;C++语言 三 名字空间(命名空间)1 名字空间作用1）避免名字冲突2）划分逻辑单元2 定义 namespace 名字空间名{ 名字空间成员1; 名字空间成员2; … } 注：名字空间成员可以是全局函数、全局变量、类型、名字空间. 3 名字空间成员使用1）作用域限定操作符”::” 名字空间名::要访问的成员; ​ std::cout //指定访问标准名字空间里面的cout 2）名字空间指令 using namespace 名字空间名; 注：在该条指令以后的代码中，指定名字空间的成员都可见，可以直接访问，省略”名字空间名::”. ​ using namespace std;​ cout &lt;&lt; a;//ok 3）名字空间声明 using 名字空间名::名字空间成员; 注：将名字空间中特定的一个成员引入到当前作用域，在该作用域访问这个成员就如同访问自己的局部成员一样，可以直接访问，省略”名字空间名::” 4 全局作用域和匿名名字空间//了解1）没有放在任何名字空间的成员属于全局作用域，可以直接访问，但如果和局部作用域的成员名字一样，局部优先；这时如果还希望访问全局作用域的成员可以通过“::xx”显式访问。2）定义名字空间时可以没有名字，即为匿名名字空间，匿名空间中成员和全局作用域类似，可以直接访问，也可以通过”::xx”显式的访问，唯一的区别匿名空间的成员被局限在当前文件中使用。 5 名字空间的嵌套与合并//了解1）名字空间嵌套2）名字空间合并：两个同名的空间会自动合并成一个 四 C++的结构体、联合体和枚举1 C++的结构体1）当定义结构体变量时可以省略struct关键字2）在C++的结构体内部可以直接定义函数，称为成员函数(方法)，在成员函数内部可以直接访问结构体的其它成员. 2 联合体//了解1）当定义联合体变量时可以省略union关键字2）在C++中支持匿名联合 3 枚举1）当定义枚举变量时可以省略enum关键字2）C++中枚举被看作是独立数据类型，不能把枚举直接当做整型数来使用. enum STATE&#123;SLEEP=0,RUN=1,STOP=2&#125;; /*enum*/ STATE s; s = RUN;//C:ok C++:ok s = 1;//C:ok C++:error 五 C++的字符串1 回顾C语言中的字符串，灵活，风险高1）字面值常量字符串: “…”,如”youcw”，存储在代码区(只读)2）字符指针：char*：3）字符数组：char[]：存储在栈区容易越界，非常危险 2 C++兼容C风格的字符串，同时增加了string类型，专门字符串：1）定义 string s1;//定义空字符串，存储在堆区，由系统进行管理 string s2 = “xx”;//定义同时初始化2）字符串拷贝：= string s1 = “youcw”; string s2 = “mindasheng”; s1 = s2;//将s2拷贝给s1 cout &lt;&lt; s1 &lt;&lt; endl;//“mindasheng”3）字符串连接：+ += string s1 = “hello”; string s2 = “ world”; string s3 = s1 + s2; cout &lt;&lt; s3 &lt;&lt; endl;//“hello world”4）字符串比较：== != &gt; &gt;= &lt; &lt;= if(s1 == s2){…}5）随机访问: [] string s = “minwei”; s[0] = ‘M’; s[3] = ‘W’; cout &lt;&lt; s &lt;&lt; endl;//MinWei 6）暂时可以string理解为是”类”类型，里面包含了很多成员函数，常用的： 12345678910111213size()&#x2F;length();&#x2F;&#x2F;获取字符串长度c_str();&#x2F;&#x2F;返回字符串的起始地址(const char* )string str &#x3D; &quot;youcw&quot;;str.size();&#x2F;&#x2F;5str.length();&#x2F;&#x2F;5和size()等价 string s1 &#x3D; &quot;hello&quot;;&#x2F;&#x2F;C++风格const char* s2 &#x3D; &quot;world&quot;;&#x2F;&#x2F;C风格s1 &#x3D; s2;&#x2F;&#x2F;ok，s2 &#x3D; s1;&#x2F;&#x2F;error，s2 &#x3D; s1.c_str(); ​","link":"","tags":[]},{"title":"","date":"2021-08-19T09:58:30.956Z","path":"2021/08/19/C++/","text":"const const在谁后面谁就不可修改，const在最前面则将其后移一位即可，二者等效 作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 const 的指针与引用 指针 指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer） 引用 指向常量的引用（reference to const） 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰 this 指针 类中的成员函数(包括构造函数、析构函数)都有一个隐藏的当前类 类型的指针参数，名为this。在成员函数中访问类中其它成员，其本质都是通过this来实现的。 对于普通的成员函数,this指针就是指向该成员函数的调用对象；对于构造函数,this指针就指向正在创建的对象。 this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针被隐含地声明为：const ClassName* const this，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）； this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。 在以下场景中，经常需要显式引用this指针： 为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。 –》区分作用域，(区分哪个是成员变量)–》从成员函数返回调用对象自身(返回自引用)//重点掌握–》从类的内部销毁对象自身(对象自销毁) //了解–》作为成员函数实参，实现对象之间交互 //了解 inline 内联函数 c++内联函数解析（inline） - 晴天Jay_chen - 博客园 (cnblogs.com) 使用inilne关键字修饰的函数，即为内联函数，编译器将会尝试进行内联优化，可以避免函数调用开销，提高代码执行效率. 1inline void func(void)&#123;...&#125; 特征 相当于把内联函数里面的内容写在调用内联函数处； 相当于不用执行进入函数的步骤，直接执行函数体； 相当于宏，却比宏多了类型检查，真正具有函数特性； 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数； 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。 编译器对 inline 函数的处理步骤 将 inline 函数体复制到 inline 函数调用点处； 为所用 inline 函数中的局部变量分配内存空间； 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。 优缺点优点 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 内联函数在运行时可调试，而宏定义不可以。 缺点 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。 使用说明–》多次调用小而简单的函数适合内联优化–》调用次数极少或大而复杂的函数不适合内联–》递归函数不能内联优化–》虚函数不能内联优化//后面讲 volatile1volatile int i = 10; volatile是标准C语言的关键字，被volatile修饰的变量表示易变的，告诉编译器每次使用该变量时，都要小心从内存中读取，而不是取寄存器的副本，防止编译器优化引起的错误变化 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） const 可以是 volatile （如只读的状态寄存器） 指针可以是 volatile sizeof() sizeof 对数组，得到整个数组所占空间大小。 sizeof 对指针，得到指针本身所占空间大小。 结构体的sizeof 结构体的sizeof涉及到字节对齐问题。编译器默认会对结构体进行处理（实际上其它地方的数据变量也是如此），让宽度为2的基本数据类型（short等）都位于能被2整除的地址上，让宽度为4的基本数据类型（int等）都位于能被4整除的地址上，依次类推。这样，两个数中间就可能需要加入填充字节，所以整个结构体的sizeof值就增长了。 空结构体（不含数据成员）的sizeof值为1。 联合体的sizeof 结构体在内存组织上市顺序式的，联合体则是重叠式，各成员共享一段内存；所以整个联合体的sizeof也就是每个成员sizeof的最大值。 数组的sizeof 数组的sizeof值等于数组所占用的内存字节数。 注意：1）当字符数组表示字符串时，其sizeof值将’/0’计算进去。 ​ 2）当数组为形参时，其sizeof值相当于指针的sizeof值。 指针的sizeof 指针是用来记录另一个对象的地址，所以指针的内存大小当然就等于计算机内部地址总线的宽度。在32位计算机中，一个指针变量的返回值必定是4。指针变量的sizeof值与指针所指的对象没有任何关系。 函数的sizeof sizeof也可对一个函数调用求值，其结果是函数返回值类型的大小，函数并不会被调用。 对函数求值的形式：sizeof(函数名(实参表)) 注意：1）不可以对返回值类型为空的函数求值。 ​ 2）不可以对函数名求值。 ​ 3）对有参数的函数，在用sizeof时，须写上实参表。 c++中sizeof()的用法介绍 - Mr左 - 博客园 (cnblogs.com) extern “C” 被 extern 限定的函数或变量是 extern 类型的 被 extern &quot;C&quot; 修饰的变量和函数是按照 C 语言方式编译和链接的 extern &quot;C&quot; 的作用是让 C++ 编译器将 extern &quot;C&quot; 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 C++ 中 struct 和 class总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。 区别 最本质的一个区别就是默认的访问控制 默认的继承访问权限。struct 是 public 的，class 是 private 的。 struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。 C 实现 C++ 类C 实现 C++ 的面向对象特性（封装、继承、多态） 封装：使用函数指针把属性与方法封装到结构体中 继承：结构体嵌套 多态：父类与子类方法的函数指针不同 union 联合联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点： 默认访问控制符为 public 可以含有构造函数、析构函数 不能含有引用类型的成员 不能继承自其他类，不能作为基类 不能含有虚函数 匿名 union 在定义所在作用域可直接访问 union 成员 匿名 union 不能包含 protected 成员或 private 成员 全局匿名联合必须是静态（static）的 explicit（显式）关键字 explicit 修饰构造函数时，可以防止隐式转换和复制初始化 explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外 friend 友元类和友元函数 能访问私有成员 破坏封装性 友元关系不可传递 友元关系的单向性 友元声明的形式及数量不受限制 usingusing 声明一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如： 1using namespace_name::name; using 指示using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如： 1using namespace_name name; 尽量少使用 using 指示 污染命名空间 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。 :: 范围解析运算符分类 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的 enum 枚举类型限定作用域的枚举类型1enum class open_modes &#123; input, output, append &#125;; 不限定作用域的枚举类型12enum color &#123; red, yellow, green &#125;;enum &#123; floatPrec = 6, doublePrec = 10 &#125;; 指针加法与数值加法","link":"","tags":[]},{"title":"UnixC-网络编程","date":"2021-05-04T15:41:02.000Z","path":"2021/05/04/UnixC-网络编程/","text":"十三、网络通信1.网络和网络协议1)什么是计算机网络？ 计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过有形或无形的通信线路连接起来，在网络操作系统、网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。 2)什么是网络协议？网络协议是一种特殊的软件，是计算机网络实现其功能的最基本的机制。网路协议的本质就是规则，即各种硬件和软件必须遵循的共同守则。网络协议并不是一套单独的软件，它融合于所有涉及网络通信的软件甚至硬件之中，因此可以说协议于网络中无处不在。 3)什么是协议栈？为了减少网络设计的复杂性，绝大多数网络采用分层设计的方法。所谓分层设计，就是按照信息流动的过程将网络的整体功能分解为一个个的功能层，不同机器上的同等功能层之间采用相同的协议，同一机器上相邻功能层之间通过接口进行信息传递。各层的协议和接口统称为协议栈。 1234567891011121314151617ISO(国际标准化组织)&#x2F;OSI(Open System Interconnection, 开放系统互联)网络协议模型：应用层：业务逻辑 \\表示层：数据的表现形式 | -&gt; 应用层会话层：建立、管理和终止通信过程 &#x2F;传输层：源到目的地的点对点传输网络层：路径选择、路由、寻址等网络结构拓扑数据链路层：物理寻址、数据通道、错误检测等通信路径物理层：在数据和电平信号之间进行转换比喻：买点心（应用层：业务需求）选择包装（表示层：数据形式）选择快递公司（会话层：通信过程）填写收寄单（传输层：点对点）选择路径（网络层：通路）中途周转（数据链路层：多点连线）送货过程（物理层：实际通信） 4)TCP/IP协议栈传输层：TCP、UDP网络层：IP、ICMP、IGMP链路层：ARP、RARP 5)消息包和数据流应用层：HTTP请求=用户数据包传输层：TCP头+用户数据包=TCP包网络层：IP头+TCP包=IP包链路层：以太网头+IP包+以太网尾=以太网帧物理层：以太网帧-&gt;电平信号 | ^ v | 传输线路发送数据流：消息自协议栈顶层向底层流动，逐层打包。接收数据流：消息自协议栈底层向顶层流程，逐层解析。 6)IP地址IP地址(Internet Protocol Address，互联网协议地址)是一种地址格式，为互联网上的每个网络和主机分配一个逻辑地址，其目的是消除物理地址的差异性。IP地址的计算机内部用一个网络字节序的32位(4个字节)无符号整数表示。通常习惯将其表示为点分十进制整数字符串的形式。例如：点分十进制整数字符串：1.2.3.432位(4个字节)无符号整数：0x01020304内存布局：| 0x01 | 0x02 | 0x03 | 0x04 | 低地址—————&gt;高地址网络字节序就是大端字节序，高位在低地址，低位在高地址。一台计算机的IP地址=网络地址+主机地址A级地址：以0为首8位网络地址+24位主机地址B级地址：以10为首16位网络地址+16位主机地址C级地址：以110为首24位网络地址+8位主机地址D级地址：以1110为首的32为多(组)播地址例如：某台计算机的IP地址为192.168.182.48，其网络地址和主机地址分别为何？ 192 168 182 4811000000 10101000 10110110 00110000以110为首，C级地址，网络地址是192.168.182.0，主机地址是48。主机IP地址 &amp; 子网掩码 = 网络地址主机IP地址 &amp; ~子网掩码 = 主机地址例如：主机IP地址192.168.182.48，子网掩码255.255.255.0，其网络地址和主机地址分别为何？192.168.182.48 &amp; 255.255.255.0 = 192.168.182.0192.168.182.48 &amp; 0.0.0.255 = 0.0.0.48 2.套接字1)什么是套接字？Socket，电源插座-&gt;套接字一个由系统内核负责维护，通过文件描述符访问的对象， 可用于在同一台机器或不同机器中的进程之间实现通信。进程表项 文件描述符表 0: 文件描述符标志 | * -&gt; 标准输入文件表项 -&gt; 键盘 1: 文件描述符标志 | * -&gt; 标准输出文件表项 -&gt; 显示器 2: 文件描述符标志 | * -&gt; 标准错误文件表项 -&gt; 显示器 3: 文件描述符标志 | * -&gt; 套接字对象 -&gt; 网卡 应用程序 应用程序 v v磁盘文件的文件描述符 表示网络的文件描述符 v v 文件对象 套接字对象 v v 文件系统 网络协议栈 v v 磁盘设备 网络设备套接字也可以被视为是围绕表示网络的文件描述符的一套函数库。调用其中的函数就可以访问网络上的数据，实现不同主机间的通信功能。2)绑定和连接 套接字就是系统内核内存中的一块数据——逻辑对象 | 绑定(bind)包含了IP地址和端口号等参数的网络设备——物理对象互联网 | &lt;-网络地址：192.168.182.0子网络 | &lt;-主机地址：0.0.0.48计算机 | &lt;-端口号：80 应用通过IP地址(网络地址+主机地址)和端口号就可以唯一定位互联网上的一个通信引用。 主机A应用程序 |逻辑对象(套接字) | 绑定(bind) 连接(connection)物理对象(IP地址和端口号)———物理对象(IP地址和端口号) | 绑定(bind) 逻辑对象(套接字) | 应用程序 主机B3)常用函数创建套接字： 1234567891011int socket(int domain, int type, int protocol);成功返回套接字描述符，失败返回-1。domain - 通信域，即协议族，可取以下值： PF_LOCAL&#x2F;PF_UNIX: 本地通信，进程间通信 PF_INET: 互联网通信 PF_PACKET: 底层包通信（嗅探器、端口扫描）type - 套接字类型，可取以下值： SOCK_STREAM: 流式套接字，使用TCP协议 SOCK_DGRAM: 数据报式套接字，使用UDP协议 SOCK_RAW: 原始套接字，使用自定义协议protocol - 特殊协议对于流式套接字和数据报式套接字，取0 套接字描述符与文件描述符在逻辑层面是一致的，所有关于文件描述符的规则对于套接字描述符也同样成立。同样也通过close函数关闭套接字，即释放内核中的有关资源。 基本地址结构： 1234struct sockaddr &#123; sa_family_t sa_family; &#x2F;&#x2F; 地址族 char sa_data[14]; &#x2F;&#x2F; 地址值&#125;; 基本地址结构仅用于给函数传参时做强制类型转换。 本地地址结构： 1234struct sockaddr_un &#123; sa_family_t sun_family; &#x2F;&#x2F; 地址族(AF_LOCAL&#x2F;AF_UNIX) char sun_path[]; &#x2F;&#x2F; 套接字文件路径&#125;; 网络地址结构： 123456789101112struct sockaddr_in &#123; sa_family_t sin_family; &#x2F;&#x2F; 地址族(AF_INET) in_port_t sin_port; &#x2F;&#x2F; 端口号(网络字节序) struct in_addr sin_addr; &#x2F;&#x2F; IP地址&#125;;struct in_addr &#123; in_addr_t s_addr; &#x2F;&#x2F; 网络字节序32位无符号整数形式的IP地址&#125;;typedef uint32_t in_addr_t;typedef uint16_t in_port_t; 发送：主机字节序-&gt;网络(大端)字节序接收：网络(大端)字节序-&gt;主机字节序小端字节序的主机A 大端字节序的主机B0x1234主：0x34 | 0x12 L H网：0x12 | 0x34 -&gt; 网：0x12 | 0x34 L H 主：0x12 | 0x34 ​ 0x1234 ​ 小端字节序的主机C​ -&gt; 网：0x12 | 0x34​ L H​ 主：0x34 | 0x12​ 0x1234 将套接字对象和自己的地址结构绑定在一起： 123456789int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);成功返回0，失败返回-1。sockfd - 套接字描述符addr - 自己的地址结构addrlen - 地址结构字节数addr-&gt;sa_family: AF_LOCAL&#x2F;AF_UNIX ((struct sockaddr_un*)addr)-&gt;sun_path: 套接字文件addr-&gt;sa_family: AF_INET ((struct sockaddr_in*)addr)-&gt;sin_port&#x2F;sin_addr: IP地址和端口号 将套接字对象所代表的物理对象和对方的地址结构连接在一起： 12345int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);成功返回0，失败返回-1。sockfd - 套接字描述符addr - 对方的地址结构addrlen - 地址结构字节数 通过套接字描述符接收和发送数据的过程完全与通过文件描述符读取和写入数据的过程完全一样。 12ssize_t read(int sockfd, void* buf, size_t count);ssize_t write(int sockfd, const void* buf, size_t count); 字节序转换通过网络传输多字节整数，需要在发送前转换为网络字节序，在接收后转换为主机字节序。 12345678910#include &lt;arpa&#x2F;inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort);h - host，主机(字节序)to - 到，把...转换到...n - network，网络(字节序)l - long版本，32位无符号整数s - short版本，16位无符号整数 IP地址转换(网络字节序32位无符号)整数&lt;=&gt;(点分十进制)字符串 123456in_addr_t inet_addr(const char* cp); &#x2F;&#x2F; 串-&gt;数int inet_aton(const char* cp, struct in_addr* inp);&#x2F;&#x2F; 串-&gt;数转换成功返回0，失败返回-1。char* inet_ntoa(struct in_addr in); &#x2F;&#x2F; 数-&gt;串转换成功返回字符串指针，失败返回NULL。 3.基于本地套接字的进程间通信：服务器：提供业务服务的计算机程序。客户机：请求业务服务的计算机程序。服务器 客户机创建套接字(socket) 创建套接字(socket)准备地址结构(sockaddr_un) 准备地址结构(sockaddr_un)绑定地址(bind) 建立连接(connect)接收请求(read) 发送请求(write)业务处理(…) 等待处理(…)发送响应(write) 接收响应(read)关闭套接字(close) 关闭套接字(close) 4.基于网络套接字的进程间通信：服务器 客户机创建套接字(socket) 创建套接字(socket)准备地址结构(sockaddr_in) 准备地址结构(sockaddr_in)绑定地址(bind) 建立连接(connect)接收请求(read) 发送请求(write)业务处理(…) 等待处理(…)发送响应(write) 接收响应(read)关闭套接字(close) 关闭套接字(close) 5.基于并发的TCP客户机/服务器模型1)TCP协议的基本特征A.面向连接：参与通信的双方在正式通信之前需要先建立连接，已形成一条虚拟电路，所有的后续通信都在这条虚电路上完成。类似于电话通信业务。正式通话之前要先拨号，拨通了才能讲话。拨号的过程就是一个建立连接的过程。 12345三路握手： 客户机 服务器发起连接请求 --------SYN(n)--------&gt; 被动侦听 等待应答 &lt;-ACK(n+1)+SYN(m)-- 可以接受 反向确认 ------ACK(m+1)------&gt; 连接成功 一旦三路握手完成，客户机和服务器的网络协议栈中就会保存有关连接的信息，此后的通信内容全部基于此连接实现数据传输。通信过程中任何原因导致的连接中断，都无法再继续通信，除非重新建立连接。 B.可靠传输：超时重传。每次发送一个数据包，对方都需要在一个给定的时间窗口内予以应答，如果超过时间没有收到对方的应答，发送方就会重发该数据包，只有重试过足够多的次数依然失败才会最终放弃。 C.保证顺序：发送端为每一个数据包编制序列号，接收端会根据序列号对所接收到的数据包进行重排，避免重复和乱序。 D.流量控制：协议栈底层在从另一端接收数据时，会不断告知对方它能够接收多少字节的数据，即所谓通告窗口。任何时候，这个窗口都反映了接收缓冲区可用空间的大小，从而确保不会因为发送方发送数据过快或过慢导致接收缓冲区出现上溢出或下溢出。 E.流式传输：以字节流形式传输数据，数据包在传输过程中没有记录边界。应用程序需要根据自己的规则来划分出数据包的记录边界。 定长记录 不定长记录加分隔符 定长长度加不定长记录 F.全双工：在给定的连接上，应用程序在任何时候都既可以发送数据也可以接收数据。因此TCP必须跟踪每个方向上数据流的状态信息，如序列号和通告窗口大小等。 2)TCP连接的生命周期被动打开：通过侦听套接字感知其它主机发起的连接请求。三路握手：TCP连接的建立过程。| TCP包头 | TCP包体 |&lt;20字节&gt;含有6个标志位：SYN/ACK/FIN/RST/…发送序列号和应答序列号…数据传输：超时重传、流量控制、面向字节流、全双工终止连接： 客户机 服务器主动关闭 ———FIN(n)——-&gt; 被动关闭等待应答 &lt;—–ACK(n+1)—— 关闭应答确定关闭 &lt;——–FIN(m)——- 已经关闭关闭应答 ——ACK(m+1)—–&gt; 等待应答 3)常用函数在指定套接字上启动对连接请求的侦听，即将该套接字置为被动模式，因为套接字都缺省为主动模式。 1234int listen(int sockfd, int backlog);成功返回0，失败返回-1。sockfd - 套接字描述符backlog - 未决连接请求队列的最大长度 在指定的侦听套接字上等待并接受连接请求 12345int accept(int sockfd, struct sockaddr* addr, size_t* addrlen);成功返回连接套接字描述符用于后续通信，失败返回-1。sockfd - 侦听套接字描述符addr - 输出连接请求发起者的地址信息addrlen - 输入输出连接请求发起者地址信息的字节数 该函数由TCP服务器调用，返回排在已决连接 队列首部的连接套接字对象的描述符，若已决连接队列为空，该函数会阻塞。 12345678非并发的TCP服务器：创建套接字(socket)绑定地址(bind)启动侦听(listen)等待连接(accept)&lt;--+接收请求(read)&lt;-+ |业务处理(...) | |发送响应(write)--+--+ 12345678910并发的TCP服务器创建套接字(socket)绑定地址(bind)启动侦听(listen)等待连接(accept)&lt;---+ |产生客户子进程(fork)-+ 接收请求(read)&lt;-+ 业务处理(...) | 发送响应(write)--+ 接收数据 123456ssize_t recv(int sockfd, void* buf, size_t len, int flags);flags - 接收标志，取0等价于read MSG_DONTWAIT: 非阻塞接收。对于阻塞模式，当接收缓冲区为空时，该函数会阻塞，直到接收缓冲区不空为止。如果使用了此标志位，当接收缓冲区为空时，该函数会返回-1，并置errno为EAGAIN或EWOULDBLOCK。 MSG_OOB: 接收带外数据。 MSG_PEEK: 瞄一眼数据，只将接收缓冲区中的数据复制到buf缓冲区中，但并不将其从接收缓冲区中删除。 MSG_WAITALL: 接收到所有期望接收的数据才返回，如果接收缓冲区中的数据不到len个字节，该函数会阻塞，直到可接收到len个字节为止。 发送数据 12345ssize_t send(int sockfd, const void* buf, size_t len, int flags);flags - 接收标志，取0等价于write MSG_DONTWAIT: 非阻塞发送。对于阻塞模式，当发送缓冲区的空余空间不足以容纳期望发送的字节数时，该函数会阻塞，直到发送缓冲区的空余空间足以容纳期望发送的字节数为止。如果使用了此标志位，能发送多少字节就发送多少字节，不会阻塞，甚至可能返回0表示发送缓冲区满，无法发送数据。 MSG_OOB: 发送带外数据。 MSG_DONTROUT: 不查路由表，直接在本地网中寻找目的主机。 代码：tcpsvr.c、tcpcli.c 6.基于迭代的UDP客户机/服务器模型1)UDP协议的基本特征A.面向无连接：参与通信的主机之间不需要专门建立和维护逻辑的连接通道。一个UDP套接字可以和任意其它UDP套接字通信，而不必受连接的限制。 B.不可靠传输：没有超时重传机制。可能导致数据丢失。 C.不保证顺序：没有序列号，也不进行序列重组。可能产生数据包重复和乱序。 D.无流量控制：没有通告窗口，通信参与者完全不知道对方的接受能力。可能造成数据溢出。 E.记录式传输：以消息报文的形式传输数据，数据包在传输过程中有记录边界。应用程序无需划分数据包边界。 F.全双工 通过在可靠性方面的部分牺牲换取高速度。 2)常用函数1234567891011发送函数：ssize_t sendto(int sockfd, const void* buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen);dest_addr - 数据包接收者地址结构addrlen - 数据包接收者地址结构字节数接受函数：ssize_t recvfrom(int sockfd, void* buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen);src_addr - 输出数据包发送者地址结构addrlen - 输出数据包发送者地址结构字节数 针对UDP套接字的connect函数并不象TCP套接字的connect函数一样通过三路握手过程建立所谓的虚电路连接，而仅仅是将传递给该函数的对方地址结构缓存在套接字对象中。此后通过该套接字发送数据时，可以不使用 sendto函数，而直接调用send函数，有关接收方的地址信息从套接字对象的地址缓存中提取即可。代码：concli.c 7.域名解析（Domain Name Service, DNS）字符串形式的域名(www.tmooc.cn) | v DNS服务器 | v整数形式的IP地址(202.141.55.23)–&gt;套接字编程 根据主机域名获取信息 12345678910111213struct hostent* gethostbyname(const char* name);成功返回主机信息条目指针，失败返回NULL。name - 主机域名(字符串)hostent h_name -&gt; xxx\\0 - 主机官方名 h_aliases -&gt; * * * ... NULL - 别名表 h_addrtype -&gt; AF_INET - 地址类型 h_length -&gt; 4 - 地址字节数 h_addr_list -&gt; * * * ... NULL - 地址表 | v struct in_addr s_addr - 网络字节序32位无符号整数 8.获取HTTP服务器上的页面内容HTTP, Hyper Text Transform Protocol，超文本传输协议www服务器通过http协议提供页面服务。HTTP - 应用层协议：| HTTP包头 | HTTP包体 | | TCP - 传输层协议：| TCP包头 | HTTP包头 | HTTP包体 | | IP - 网络层协议：… | …HTTP请求包头：方法 资源路径 协议及 | (URI，统一资源定位符) 其版本 | | |GET /user/project/main.html HTTP/1.1 键 值 | |Host: www.tmooc.cn\\r\\nAccept: text/html\\r\\nConnection: Keep-Alive\\r\\nUser-Agent: Mozilla/5.0\\r\\nReferer: www.tmooc.cn\\r\\n…最后一行\\r\\n\\r\\n代码：http.c","link":"","tags":[]},{"title":"UnixC-线程","date":"2021-05-04T14:32:47.000Z","path":"2021/05/04/UnixC-线程/","text":"十四、多线程1.什么是线程？源代码 -编译和链接-&gt; 程序 -加载到内存中-&gt; 进程 ​ | |​ 文件 内存​ / ​ 代码 &lt;- 执行​ 数据 &lt;- 处理​ | | &lt;- CPU​ 静态 动态​ | |​ 资源 线程线程就是进程的执行过程，即进程内部的控制序列，或者说是进程中的一个任务。一个进程可以同时拥有多个线程，即同时被系统调度的多个执行路径，但至少要有一个主线程——main函数及被其调用的其它函数。一个进程的所有线程都共享进程的代码区、数据区、BSS区、堆区、环境变量和命令行参数区、文件描述符表、信号处理函数、当前工作目录、用户和组的各种ID等。但是栈区不是共享的，一个进程的每个线程都拥有自己独立的栈区。 线程调度：1)系统内核中专门负责线程调度的处理单元被称为调度器；2)调度器将所有处于就绪状态(没有阻塞在任何系统调用上)的线程排成一个队列，即所谓就绪队列；3)调度器从就绪队列中获取队首线程，为其分配一个时间片，并令处理器执行该线程，过了一段时间： 该线程的时间片耗尽，调度器立即终止该线程，并将其排到就绪队列的尾端，接着从队首获取下一个线程； 该线程的时间片未耗尽，但需阻塞于某系统调用，比如等待I/O或者睡眠。调度器会中止该线程，并将其从就绪队列中移至等待队列，直到其等待的条件满足后，再被移回就绪队列； 4)在低优先级线程执行期间，有高优先级线程就绪，后者会抢占前者的时间片；5)若就绪队列为空，则系统内核进入空闲状态，直至其非空；6)象Linux这样的多任务分时系统，基本的调度单位是线程；7)为线程分配的时间片不宜过长，因为时间片太长会导致没有获得处理机的线程等候时间过久，降低系统运行的并行性，用户会感觉到明显的响应延迟；时间片也不宜过短，因为过短的时间片会增加在线程之间切换上下文的频率，降低系统的运行性能。 2.线程的基本特点1)线程是进程中的独立实体，可以拥有自己的资源，可以被独立标识——线程ID，同时也被作为基本调用单元，参与时间片的分配。2)线程有不同的状态，如创建、运行、终止、暂停、恢复、取消等。3)线程可以使用的大部分资源还是隶属于进程的，因此线程作为进程的一部分不能脱离进程独立存在。4)一个进程可以同时执行多个线程，这些线程可以执行相同的代码，完成相同的任务，也可以执行不同的代码，完成不同的任务。5)创建一个线程所花费的开销远小于创建进程的开销。线程也称为轻量级进程。因此在解决诸如并发问题等问题时，优先考虑多线程，其次才是多进程。6)多线程的问题在于因为太多的资源被共享，极易导致冲突，为了解决冲突可能需要增加额外的开销，因此多进程仍然有它的优势。 进程，特点：内存壁垒，重点关注：通信。 线程，特点：内存共享，重点关注：同步。 3.POSIX线程#include &lt;pthread.h&gt;-lpthread -&gt; libpthread.so//需要链接动态库 4.创建线程线程过程函数：在一个线程中被内核调用的函数，对该函数的调用过程就是线程的执行过程，从该函数中返回就意味着线程的结束。因此，main函数其实就是一个进程的主线程的线程过程函数。所有自创建的线程都必须有一个对应线程过程函数。 1234567891011void* 线程过程函数(void* 线程参数指针) &#123; 线程的执行过程&#125;int pthread_create(pthread_t* tid, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg);成功返回0，失败返回错误码。tid - 输出线程标识(TID)。attr - 线程属性，NULL表示缺省属性。start_routine - 线程过程函数指针arg - 线程参数指针 pthread_create -&gt;创建一个新线程 -&gt;调用线程过程函数(start_routine) 并传入线程参数指针(arg)被创建的子线程和创建该子线程的父线程是并行的关系，其调度顺序无法预知，因此当pthread_create函数返回时子线程执行的位置无从确定，其线程过程函数可能尚未被调用，也可能正在执行，甚至可能已经返回。传递给线程的参数对象，一定要在线程过程函数不再使用它的情况下才能被释放。 主线程和通过pthread_create函数创建的多个子线程，在时间上“同时”运行，如果不附加任何同步条件，则它们每一个执行步骤的先后顺序完全无法预知，这就叫做自由并发。 为了让线程过程函数的实现更加灵活，可以通过线程参数传递特定的信息，帮助线程过程函数执行不同的任务。 5.汇合线程12345678 创建点 汇合点--------+---------+-------&gt; 主线程 \\________&#x2F; 子线程int phread_join(pthread_t tid, void** retval);成功返回0，失败返回错误码。tid - 线程标识retval - 线程退出码 当调用pthread_join函数时：tid线程已经终止，立刻返回，返回线程退出码。tid线程尚未终止，阻塞等待，直到被汇合线程终止。 1234void* 线程过程函数(void* 线程参数指针) &#123; 线程的执行过程 return p;&#125; 线程过程函数返回一个指针P，内核将p传给线程退出码retval-&gt;q[ ]，汇合线程函数phread_join(…, &amp;q);就可以得到线程过程函数返回的内容。 phread_join主要做的工作： 等待子线程终止 清理线程的资源 获得线程过程函数的返回值 6.分离线程在有些时候作为子线程的创建者，父线程可能并不关心子线程何时终止，同时父线程也不需要获得子线程的返回值。这种情况下，就可将子线程设置为分离线程，这样的线程一旦终止，它们的资源会被系统自动回收，而无需在其父线程中调用pthread_join函数。 方法一：pthread_detach函数 123int pthread_detach(pthread_t tid);成功返回0，失败返回错误码。tid - 线程标识 方法二：通过设置线程属性 12345pthread_attr_t attr;&#x2F;&#x2F;线程属性pthread_attr_init(&amp;attr); &#x2F;&#x2F; 用缺省值初始化线程属性pthread_attr_setdetachstat(&amp;attr, PTHREAD_CREATE_DETACHED);&#x2F;&#x2F;设置分离线程属性pthread_create(..., &amp;attr, ...);&#x2F;&#x2F;在创建的时候就可以使线程为分离线程pthread_attr_destroy(&amp;attr); 7.线程ID12345678pthread_t tid;pthread_create(&amp;tid, ...); tid：输出子线程的TIDpthread_self();&#x2F;&#x2F; 返回调用线程的TIDint pthread_equal(pthread_t tid1, pthread_t tid2);&#x2F;&#x2F;比较两个线程tid两个TID相等返回非零，否则返回0。 通过pthread_self函数返回的线程ID和pthread_create函数输出的线程ID一样都是由PTHREAD库内部维护的虚拟(伪)线程ID，可用于其它需要提供线程ID的PTHREAD函数。系统内核维护的真实线程ID，可通syscall(SYS_gettid)获得： 123#include &lt;unistd.h&gt; &#x2F;&#x2F; 声明syscall函数#include &lt;syscall.h&gt; &#x2F;&#x2F; 定义SYS_gettid宏syscall(SYS_gettid);&#x2F;&#x2F;获取系统内核维护的真实线程ID 在Linux系统中，一个进程的PID实际上就是其主线程的TID。 8.终止线程(自己)1)从线程过程函数中返回，执行该过程函数的线程即终止。其返回值可通过pthread_join函数的第二参数输出给调用者。2)在线程过程函数及被其调用的任何函数中都可以调用pthread_exit函数终止当前线程： 1void pthread_exit(void* retval); retval就相当于线程过程函数的返回值，同样可被pthread_join的第二个参数输出给调用。 注意：在子线程中调用pthread_exit，只会终止调用线程自己，对其其它兄弟线程和主线程没有影响。但如果在主线程中调用pthread_exit，被终止的将是整个进程及其所包含的全部线程。 9.取消(其它)线程123int pthread_cancel(pthread_t tid);成功返回0，失败返回错误码。tid - 被取消线程的TID。 该函数只是向特定线程发出取消请求，并不等待其终止运行。缺省情况下，线程在收到取消请求以后，并不会立即终止，而是仍继续运行，直到达到某个取消点。在取消点处，线程检查其自身是否已被取消，若是则立即终止。取消点通常出现在一些特定的系统调用中。 设置调用线程的取消状态为接受或忽略取消请求： 12345int pthread_setcancelstate(int state, int* oldstate);state - 取消状态，可取以下值： PTHREAD_CANCEL_ENABLE - 接受取消请求(缺省) PTHREAD_CANCEL_DISABLE - 忽略取消请求old_state - 输出原取消状态，可取NULL。 设置调用线程的取消类型为延迟取消或立即取消： 12345int pthread_setcanceltype(int type, int* oldtype);type - 取消类型，可取以下值： PTHREAD_CANCEL_DEFERRED - 延迟取消(缺省)，接到取消请求，如果不是忽略的话，继续运行一段时间，直到执行取消点时再终止。 PTHREAD_CANEL_ASYNCHRONOUS - 立即取消，接到取消请求，如果不是忽略的话，立刻终止运行。old_type - 输出原取消类型，可取NULL。 10.线程冲突g = 0线程1 线程2把内存(g=0)中的值读入寄存器(eax=0)把寄存器(eax=0-&gt;1)中的值加1把寄存器(eax=1)中的值存入内存(g=1) 把内存(g=1)中的值读入寄存器(eax=1) 把寄存器(eax=1-&gt;2)中的值加1 把寄存器(eax=2)中的值存入内存(g=2)线程1 线程2把内存(g=0)中的值读入寄存器(eax=0) 把内存(g=0)中的值读入寄存器(eax=0)把寄存器(eax=0-&gt;1)中的值加1 把寄存器(eax=0-&gt;1)中的值加1把寄存器(eax=1)中的值存入内存(g=1) 把寄存器(eax=1)中的值存入内存(g=1) 当两个或两个的线程同时以非原子化的方式访问同一个对象时，极有可能导致对象的最终状态不稳定，这就是所谓的线程冲突。解决冲突的基本原则就是敏感操作的原子化，即保证一个线程完成这组敏感操作以后，再允许另个线程执行类似的操作，位于与共享资源有关的操作代码，在任何时候都只允许一个线程执行。 11.互斥锁1234567891011静态初始化pthread_mutex_t mutex &#x3D; PTHREAD_MUTEX_INITIALIZER;动态初始化pthread_mutex_t mutex;pthread_mutex_init(&amp;mutex, NULL); &#x2F;&#x2F; 分配内核资源pthread_mutex_destroy(&amp;mutex); &#x2F;&#x2F; 释放内核资源pthread_mutex_lock(&amp;mutex); &#x2F;&#x2F; 锁定互斥锁pthread_mutex_unlock(&amp;mutex); &#x2F;&#x2F; 解锁互斥锁 任何时刻只会有一个线程对特定的互斥锁锁定成功，其它试图对其锁定的线程会在此函数中阻塞等待，直到该互斥锁的持有者线程将其解锁为止。 对特定互斥锁对象锁定成功的线程通过pthread_mutex_unlock函数将其解锁，那些阻塞于对该互斥锁对象试图锁定的线程中的一个会被唤醒，得到该互斥锁，并从pthread_mutex_lock函数中返回。 123456789101112131415示例：void* thread1(void* arg) &#123; ... pthread_mutex_lock(&amp;mutex); 执行操作，访问共享对象 pthread_mutex_unlock(&amp;mutex); ...&#125;void* thread2(void* arg) &#123; ... pthread_mutex_lock(&amp;mutex); 执行操作，访问共享对象 pthread_mutex_unlock(&amp;mutex); ...&#125; 互斥锁在保证数据一致性和防止并发冲突的同时，也牺牲了多线程应用的并发性，因此在设计上，应尽量少地使用互斥锁，或者说只有在需要被互斥锁保护的操作过程中，使用它，而对于保护需求不明显的场合尽量不用。 12.信号量功能和用法与XSI/IPC对象中的信号量集非常类似，但是XSI/IPC对象中的信号量集只能用于进程，而这里的信号量既可以用于进程，也可以用于线程。初始化信号量： 12345int sem_init(sem_t* sem, int pshared, unsigned int value);成功返回0，失败返回-1。sem - 信号量。pshared - 用0和非0分别表示该信号量用于线程或是进程。value - 信号量的初值，即初始空闲资源数。 当pshared参数取0，信号量仅用于一个进程中的多个线程，其本质就是一个普通的全局变量，但如果改参数取值为非0，则信号量可用于不同的进程，其存储位置在可为这些进程所访问的共享内存中。 销毁信号量： 123int sem_destroy(sem_t* sem);成功返回0，失败返回-1。sem - 信号量。 等待信号量 123int sem_wait(sem_t* sem);成功返回0，失败返回-1。sem - 信号量。 如果信号量的当前值大于0，则将其减1并立即返回0，表示获得资源。如果该信号量的当前值等于0，这就意味着已经没有空闲资源可供分配，调用该该函数的线程或进程将被阻塞，直到因资源被释放信号量的值够减1为止。 释放信号量 12int sem_post(sem_t* sem);成功返回0，失败返回-1。 将信号量的值加1。那些正阻塞于针对该信号量的sem_wait函数调用中的一个线程或进程将被唤醒，并在对信号量减1之后从sem_wait函数中返回。 获取信号量的当前值 1234int sem_getvalue(sem_t* sem, int* sval);成功返回0，失败返回-1。sem - 信号量sval - 输出信号量的当前值，即当前可分配资源数 信号量与信号量集信号量 —— semaphore信号量集 —— semaphore arrays 信号量可以用于进程与进程之间、线程与线程之间的通信 信号量集只可以用于进程与进程之间的通信 信号量 信号量其实就是一个计数器，用于控制同时访问共享资源的进程/线程的总数（IPC中的信号量集只控制进程） 信号量的使用方式： 先赋初值，就是允许并行的进程最大数量。 如果有进程访问， 计数-1，到0就阻塞访问进程。 如果有进程结束访问，计数 + 1。 信号量集 信号量集就是将多个信号量放入数组，统一管理，IPC使用的是信号量的数组(信号量集)，而不是单一的信号量。信号量集其实就是一个计数器数组，只能控制进程数量而不能互发数据。 信号量集的使用步骤： 生成一个key，使用ftok() 创建/获取 信号量集的ID semget() 给信号量集中的每个信号量赋初始值 semctl() semop()负责进程访问或者结束访问时。计数的 +1和 -1 如果不再使用信号量集，可以使用scmctl() 删除 转载自链接：https://blog.csdn.net/Robot__Man/article/details/52235965 13.条件变量线程1 … if (后续操作所依赖的条件不满足) 睡眠于条件变量; 后续操作 …线程2 … 创建出后续操作所依赖的条件 唤醒在条件变量中睡眠的线程 … 1234567静态初始化pthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;动态初始化pthread_cond_init(&amp;cond, NULL);&#x2F;&#x2F;动态创建...pthread_cond_destroy(&amp;cond);&#x2F;&#x2F;销毁 123等待条件变量，即在条件变量中睡眠：int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex);当调用线程在cond条件变量中睡眠期间mutex互斥会被解锁，直到该线程从条件变量中苏醒，即从该函数中返回再重新拥有该互斥锁。 12int pthread_cond_signal(pthread_cond_t* cond);唤醒在条件变量cond中睡眠的第一个线程，即条件等待队列的队首线程，待其重新获得互斥锁以后从pthread_cond_wait函数中返回。 12int pthread_cond_broadcast(pthread_cond_t* cond);唤醒在条件变量cond中睡眠的所有线程，只有重新获得互斥锁的线程会从pthread_cond_wait函数中返回。 1234567生产者——消费者模型：硬件&#x2F;网络-&gt;生产者线程-数据-&gt;消费者线程 \\__________________&#x2F; 刚性耦合硬件&#x2F;网络-&gt;生产者线程-数据-&gt;缓冲区-数据-&gt;消费者线程 \\________________________________&#x2F; 柔性耦合 理想缓冲区：永远不满且不空实际缓冲区：满不能放入——撑死，空不能提取——饿死。生产者线程： if (缓冲区满) 睡入非满条件变量，释放缓冲区锁 被唤醒，离开条件等候队列，重新获得缓冲区锁 生产-&gt;非空 唤醒在非空条件变量中睡眠的消费者线程消费者线程： if (缓冲区空) 睡入非空条件变量，释放缓冲区锁 被唤醒，离开条件等候队列，重新获得缓冲区锁 消费-&gt;非满 唤醒在非满条件变量中睡眠的生产者线程 14.死锁死锁的四个必要条件： 独占排它：线程以独占的方式使用其所获得的资源，即在一个段时间内不允许其它线程使用该资源。这段时间内，任何试图请求该资源的线程只能在阻塞中等待，直到资源被其拥有者主动释放。 请求保持：线程已经拥有了至少一份资源，但又试图获取已被其它线程拥有的资源，因此只能在阻塞中等待，同时对自己已经获取的资源又坚守不放。 不可剥夺：线程已经获得的资源，在其未被使用完之前，不可被强制剥夺，而只能由其拥有者自己释放。 循环等待：线程集合{T0,T1,Tn}中，T0等待T1占有的资源，T1等待T2占有的资源，…，Tn等待T0占有的资源，形成环路。","link":"","tags":[]},{"title":"UnixC-进程","date":"2021-05-04T11:45:28.000Z","path":"2021/05/04/UnixC-进程/","text":"十、进程1.进程的基本概念程序：磁盘上的可执行文件。 ​ | 加载​ v进程：内存中的指令和数据。​ 执行 | ^​ v | 访问​ CPU—+ 2.进程的分类 交互式进程：由Shell启动，借助标准I/O与用户交互。 批处理进程：在无需人工干预的条件下，自动运行一组批量任务。 守护(精灵)进程：后台服务，多数时候处于待命状态，一旦有需要可被激活完成特定的任务。 3.进程快照(进程查看命令)ps - 显示当前用户拥有控制终端的进程信息 12345ps axuw - BSD风格选项a: 所有用户x: 既包括有控制终端也包括无控制终端的进程u: 详细信息w: 更大列宽 12345ps -efFl - SVR4风格选项e: 所有用户的所有进程f: 完整格式F: 更完整格式l: 长格式 1234567891011121314151617181920212223242526272829303132333435363738394041USER&#x2F;UID: 进程的实际用户IDPID: 进程标识%CPU&#x2F;C: CPU使用率%MEM: 内存使用率VSZ: 占用虚拟内存大小(KB)RSS: 占用半导体物理内存大小(KB)TTY: 终端次设备号 ttyn - 物理终端(硬件设备) pts&#x2F;n - 虚拟终端(软件窗口) ? - 无控制终端，如后台进程STAT&#x2F;S: 进程状态 O - 就绪，等待被调度 R - 运行，Linux下没有O状态，就绪状态也用R表示 S - 可唤醒睡眠，系统中断，获得资源，收到信号， 都可被唤醒，转入运行状态 D - 不可唤醒的睡眠，只能被wake_up系统调用唤醒 T - 暂停，收到SIGSTOP(19)信号转入暂停状态，收到SIGCONT(18)信号转入运行状态 W - 等待内存分页(2.6内核后被废弃) X - 终止且被回收，不可见 Z - 僵尸，已退出但未被回收 &lt; - 高优先级 N - 低优先级 L - 有被锁定在半导体内存中的分页 s - 会话首进程 l - 多线程化在前台进程组中，往往带有终端设备的进程START: 进程启动时间TIME: 进程运行时间COMMAND&#x2F;CMD: 进程启动命令F: 进程标志 1 - 通过fork产生的子进程，但是并没有通过exec创建新进程 4 - 拥有超级用户(root)特权PPID: 父进程的PIDNI: 进程nice值，-20~19，进程优先级浮动量PRI: 进程优先级&#x3D;80+nice，60~99，值越小优先级越高 I&#x2F;O消耗型进程(占用CPU少)，奖励，提高优先级，降低nice值 处理机消耗型进程(占用CPU多)，惩罚，降低优先级，提高nice值ADDR: 内核进程的内存地址，普通进程显示&quot;-&quot;SZ: 占用虚拟内存页数WCHAN: 进程正在等待的内核函数或事件PSR: 进程当前正在被哪个处理器执行 4.父子孤尸父进程创建子进程，子进程继承父进程。一个父进程可以创建多个子进程，每个子进程有且仅有一个父进程，除非是根进程(PID=0，调度器实例)没有父进程。进程树：调度进程(PID=0) init(PID=1) xinetd in.telnetd &lt;- 远程登录 login &lt;- 用户名和口令 bash &lt;- Shell命令：ls ls -&gt; 显示目录条目清单 父进程在创建完子进程以后依然存在，甚至可以和子进程进行某种形式的交互，如：传参、回收、通信等。旧进程在创建完新进程以后被其取代，新进程沿用旧进程的PID，继续独立地存在。 父进程创建子进程以后，子进程在操作系统的调度下与其父进程同时运行。如果父进程先用子进程的终止而终止，子进程即成为孤儿进程，同时被init进程收养，即成为init进程的子进程，因此init进程又被称为孤儿院进程。一个进程成为孤儿进程是正常的，系统中大多数守护进程都是孤儿进程。 如果子进程先于父进程的终止而终止，但父进程由于某种原因，没有回收子进程的尸体(终止状态)，子进程即成为僵尸进程。僵尸进程虽然已经不再活动，但其终止状态和PID仍然被保留，也会占用系统资源，直到其被父进程或init进程回收为止。如果父进程直到其终止都没有回收其处于僵尸状态的子进程，init进程会立即回收这些僵尸。因此一个进程不可能同时既是僵尸进程又是孤儿进程。 5.进程的各种ID系统内核会为每个进程维护一个进程表项，其中包括如下ID： 进程ID：系统为每个进程分配的唯一标识。内核在分配进程ID时，会持续增加，直到不发在增加了，再从头寻找被释放的ID，即延迟重用。 父进程ID：父进程的PID，在创建子进程的过程中被初始化到子进程的进程表项中。 实际用户ID：启动该进程的用户ID。 实际组ID：启动该进程的用户组ID。 有效用户ID：通常情况下，取自进程的实际用户ID。如果该进程的可执行文件带有设置用户ID位，那么该进程的有效用户ID就取自其可执行文件的拥有者用户ID。 有效组ID：通常情况下，取自进程的实际组ID。如果该进程的可执行文件带有设置组ID位，那么该进程的有效组ID就取自其可执行文件的拥有者组ID。 一个进程的能力和权限，由其有效用户ID和有效组ID决定。 1234567#include &lt;unistd.h&gt;pid_t getpid(void); &#x2F;&#x2F; 返回调用进程的PIDpid_t getppid(void); &#x2F;&#x2F; 返回调用进程的PPID，即其父进程的PIDuid_t getuid(void); &#x2F;&#x2F; 返回调用进程的实际用户IDuid_t getgid(void); &#x2F;&#x2F; 返回调用进程的实际组IDuid_t geteuid(void); &#x2F;&#x2F; 返回调用进程的有效用户IDuid_t getegid(void); &#x2F;&#x2F; 返回调用进程的有效组ID 6.创建子进程产生进程分支(fork) 123pid_t fork(void);成功分别父子进程中返回子进程的PID和0，失败返回-1。即调用一次返回两次：在父进程中返回所创建子进程的PID，而在子进程中返回0 函数的调用者往往可以根据该函数返回值的不同，分别为父子进程编写不同的处理分支 1234567891011pid_t pid &#x3D; fork();if (pid &#x3D;&#x3D; -1) &#123; perror(&quot;fork&quot;); exit(EXIT_FAILURE);&#125;if (pid &#x3D;&#x3D; 0) &#123; 子进程的处理分支 exit(EXIT_SUCCESS);&#125;父进程的处理分支exit(EXIT_SUCCESS); 子进程是父进程不完全副本，子进程的数据区、BSS区、堆栈区(包括I/O缓冲区)，甚至命令行参数和全局变量区都从父进程拷贝，唯有代码区与父进程共享。即代码共享，数据复制。fork函数成功返回以后，父子进程各自独立地运行，其被调度的先后顺序并不确定，某些实现可以保证子进程先被调度。fork函数成功返回以后，系统内核为父进程维护的文件描述符表也被复制到子进程的进程表项中，文件表项并不复制。系统总线程数达到上限(/proc/sys/kernel/threads-max)或用户总进程数达到上限(ulimit -u)，fork函数将返回失败。一个进程如果希望创建自己的副本并执行同一份代码，或希望与另一个进程并发地运行，都可以使用fork函数。 7.创建轻量级子进程12pid_t vfork(void);成功分别父子进程中返回子进程的PID和0，失败返回-1。 vfork函数与fork函数的功能基本相同，只有一下两点区别：1)vfork函数创建的子进程不复制父进程的物理内存，也不拥有自己独立的内存映射，而是与父进程共享全部地址空间。 2)vfork函数在创建子进程的同时会挂起父进程，直到子进程终止，或通过exec函数创建新进程，再恢复父进程的运行。(防止和父进程冲突) 即数据和代码都是独立的。 使用了写时拷贝(copy-on-write)优化技术的fork结合exec的使用，其性能并不弱于典型vfork+exec的用法。终止vfork函数创建的子进程，不能在main函数中使用return语句，也不要在任何函数中调用exit函数，而要调用_exit函数，以避免对父进程造成不利影响。 8.进程的终止1)正常终止1231、从main函数中rerurn返回2、在任何地方调用exit&#x2F;_exit&#x2F;_Exit函数3、在主线程中调用pthread_exit函数 进程一旦终止，被终止进程在用户空间所持有的资源会被自动释放，如代码区、数据区、堆栈区等，但内核空间中与该进程相关的资源，如进程表项、文件描述符等未必会得到释放。在main函数中执行return语句就相当于调用了exit函数。main函数的返回值和exit/ _ exit/_Exit函数的参数一样，构成了进程的退出码，可以被终止进程的父进程通过wait或waitpid函数获得，其中只有最低8位可被获取。 注册退出处理函数：当return或调用exit函数时，以下两个函数开始执行 1234567int atexit(void (*function)(void));int on_exit(void (*function)(int, void*), void* arg);int: main函数的返回值&#x2F;exit函数的参数void* arg会传给void*宏：EXIT_SUCCESS - 0EXIT_FAILURE - -1 1234567891011exit函数的执行过程： 调用实现通过atexit&#x2F;on_exit函数注册的退出处理函数 冲刷并关闭所有仍处于打开状态的标准I&#x2F;O流 删除所有通过tmpfile函数创建临时文件 调用_exit函数_exit函数的执行过程： 关闭所有仍处于打开状态的文件描述符 将调用进程的子进程(无论活死)托付给孤儿院进程收养 向调用进程的父进程发送SIGCHLD(17)信号，通知父进程回收子进程 令调用进程终止_Exit与_exit的功能完全一致，唯一的区别是前者有标准库提供，被声明于stdlib.h，而后者有系统调用提供，被声明于unistd.h。 2)异常终止 在主线程外部通过pthread_cancel将主线程取消 通过信号杀死进程 1234567Ctrl+C -&gt; SIGINT(2), 终端中断符信号, 进程收到该信号执行默认动作——（异常）终止。Ctrl+\\ -&gt; SIGQUIT(3), 终端退出符信号SIGKILL(9)SIGTERM(15)SIGSEGV(11), 内存段出错SIGBUS(7), 硬件错误... 9.回收子进程 通过等待子进程结束实现某种进程间的同步。 获知子进程的退出码，根据子进程不同的退出原因采取不同的对策。 避免过多的子进程僵尸拖垮系统。 回收子进程函数wait： 123pid_t wait(int* status);成功返回所回收子进程的PID，失败返回-1。status - 输出子进程的终止状态，可置NULL。 父进程在创建若干子进程以后调用wait函数：1)若所有子进程都在运行，则阻塞，直到有子进程终止才返回2)若至少有一个子进程已经终止，则立即返回该子进程的PID并通过status参数(若非NULL)输出器终止状态3)若没有需要等待的活动子进程，也没有需要回收的死亡子进程，则返回-1，同时置errno为ECHILD 分析进程的终止状态函数： 1234WIFEXITED(status) - 返回非零则表示进程正常终止 WEXITSTATUS(status) - 返回进程main函数的返回值或者传递给exit&#x2F;_exit&#x2F;_Exit函数参数的低8位WIFSIGNALED(status) - 返回非零则表示进程被信号杀死 WTERMSIG(status) - 返回杀死进程的信号编号 回收子进程函数waitpid： 1234567891011pid_t waitpid(pid_t pid, int* status, int options);成功返回所回收子进程的PID，失败返回-1。pid - 进程标识，可取以下值： &lt;-1: 等待并回收由-pid所标识的进程组中任意子进程 -1: 等待并回收任意子进程，相当于wait函数 0: 等待并回收与调用进程同组的任意子进程 &gt;0: 等待并回收由pid所标识的特定子进程status - 输出子进程的终止状态，可置NULL。options - 选项，可取以下值： 0: 阻塞模式，等不来就死等，类似于wait函数 WNOHANG: 非阻塞模式，如果所等子进程仍在运行，则返回0 10.创建新进程子进程：父子同在——并行。新进程：以新换旧——取代。创建新进程的exec函数族包括6个函数，根据参数的形式和是否使用PATH环境变量进行区分。 1234567为一个函数传递不定数量的字符串参数：1、void foo(const char* arg, ...); &#x2F;&#x2F; 变长参数表，...表示参数数目不固定foo(&quot;abc&quot;, &quot;def&quot;, ..., NULL);2、void bar(const char* arg[]); &#x2F;&#x2F; 字符指针数组const char* a[] &#x3D; &#123;&quot;abc&quot;, &quot;def&quot;, ..., NULL&#125;;bar(a); 1234567891011121314#include &lt;unistd.h&gt;int execl(const char* path, const char* arg, ...);path: 可执行文件的路径arg: 命令行参数$ gcc hello.c -o hellogcc-&gt;argv[0]hello.c-&gt;argv[1]-o-&gt;argv[2]hello-&gt;argv[3]execl(&quot;&#x2F;usr&#x2F;bin&#x2F;gcc&quot;, &quot;gcc&quot;, &quot;hello.c&quot;, &quot;-o&quot;, &quot;hello&quot;, NULL); | | | | argv[0] argv[1] argv[2] argv[3]用arg, ...作为命令行参数，运行path所表示的可执行文件，创建新进程，并用新进程取代调用进程。成功不返回，失败返回-1。 123int execlp(const char* file, const char* arg, ...);通过file参数传入可执行文件的名字即可，无需带路径，该函数会遍历PATH环境变量中的所有路径，寻找可执行文件。execlp(&quot;gcc&quot;, &quot;gcc&quot;, &quot;hello.c&quot;, &quot;-o&quot;, &quot;hello&quot;, NULL); 12int execle(const char* path, const char* arg, ..., char* const envp[]);envp：环境变量，以NULL结尾的字符指针数组 1234int execv(const char* path, char* const argv[]);char* const a[] &#x3D; &#123;&quot;gcc&quot;, &quot;hello.c&quot;, &quot;-o&quot;, &quot;hello&quot;, NULL&#125;execv(&quot;&#x2F;usr&#x2F;bin&#x2F;gcc&quot;, a); 12int execvp(const char* file, char* const argv[]);int execve(const char* path, char* const argv[], char* const envp[]); 12345exec(执行)+l - list，以变长参数表的形式传入命令行参数p - path，使用PATH环境变量寻找可执行文件e - environ，以字符指针数组的形式传入环境变量v - vector，以字符指针数组的形式传入命令行参数 与fork或vfork函数不同，exec函数不是创建调用进程的子进程，而是创建一个新的进程取代调用进程自身。新进程会用自己的全部地址空间，覆盖调用进程的地址空间，但进程的PID保持不变。调用exec函数不仅改变调用进程的地址空间和进程映像，调用进程的一些属性也发生了变化：1)任何处于阻塞状态的信号都会丢失；2)被设置为捕获的信号会还原为默认操作；3)有关线程属性的设置会还原为缺省值；4)有关进程的统计信息会复位；5)与进程内存有关的任何数据都会丢失，包括内存映射文件；6)标注库在用户空间维护的一切数据结构，如通过malloc函数族动态分配的堆内存，通过atexit/on_exit函数注册的退出处理函数等，都会丢失。但有些属性会被新进程继承下来，比如PID、PPID、实际用户ID和实际组ID、优先级，以及文件描述符(除非该文件描述符带有FD_CLOEXEC标志位)等。 vfork+exec模式：调用exec函数固然可以创建出新的进程，但是新进程会取代原来的进程。如果既想创建新的进程，同时有希望原来的进程继续存在，则可以考虑使用vfork+exec模式，即在由vfork产生的子进程中调用exec函数，新进程取代了子进程，但父进程依然存在。 如果一个进程可以根据用户的输入创建不同的进程，并在所建进程结束以后继续重复这个过程，那么这个进程就是Shell： Shell进程(bash)+-&gt;显示提示符并| 等待用户输入| | &lt;- 输入：ls -l| v| 调用vfork函| 数创建子进程 —————&gt; 子进程(ls) | v v| 调用waitpid函数 根据用户的输入调用exec| 等待并回收子进程 &lt;—— 函数创建新进程(/bin/ls)| |+———+ 1234567int system(const char* command);&#x2F;&#x2F;system&#x3D;vfork+exec+waitpid成功返回command命令行进程的终止状态，失败返回-1。command - 命令行字符串如果调用vfork或waitpid函数出错，返回-1。如果调用exec函数出错，返回127。如果都成功，返回command进程的终止状态，由waitpid函数的status参数输出。如果command参数取NULL指针，该函数返回-1表示失败，返回其它非0(真)值表示当前Shell可用，返回0(假)表示不可用。 十一、信号1.基本概念1)什么是信号？信号是提供异步事件处理机制的软件中断。这些异步事件可能来自硬件设备，也可能来自系统内核，甚至可能来自用户程序。进程之间可以相互发送信号，这使信号成为一种进程间通信(Inter-Process Communication, IPC)的基本手段。信号的异步特性不仅表现为它的产生是异步的，对它的处理同样也是异步的。程序设计者不可能也不需要精确地预见什么时候触发什么信号，也同样无法预见该信号究竟在什么时候会被处理。一切尽在内核操控下异步地发生。 2)什么是信号处理？每一个信号都有其生命周期：产生：信号被生成，并被发送至系统内核未决：信号被内核缓存，而后被递送至目标进程递送：内核已将信号发送至目标进程 忽略 - 什么也不做。 捕获 - 暂定当前的执行过程，转而调用一个事先写好 的信号处理函数，待该函数完成并返回后，再 继续之前被中断的过程。 默认 - 既不忽略该信号，也不用自己定义处理方式， 而是按照系统默认的方式予以响应。激励(信号)-&gt;响应(信号处理) 3)信号的名称和编号信号名称：形如SIGXXX的字符串或宏定义，提高可读性。信号编号：整数通过kill -l命令查看当前系统所支持的全部信号名称及其编号。131，31个不可靠信号，也叫非实时信号。3464， 31个可靠信号，也叫实时信号。共62个信号，注意没有32和33信号。 1234567891011SIGHUP(1)，控制终端关闭，终止SIGINT(2)，用户产生中断符(Ctrl+C)，终止SIGQUIT(3)，用户产生退出符(Ctrl+\\)，终止+转储SIGBUS(7)，硬件或内存对齐错误，终止+转储SIGKILL(9)，不能被捕获和忽略，终止SIGSEGV(11)，无效内存访问，终止+转储SIGPIPE(13)，向读端已关闭的管道写入，终止SIGALRM(14)，alarm函数设置的闹钟到期，终止SIGTERM(15)，可被捕获和忽略，终止SIGCHLD(17)，子进程终止，忽略SIGIO(29)，异步I&#x2F;O事件，终止 2.捕获信号#include &lt;signal.h&gt;typedef void (*sighandler_t) (int);//信号处理函数指针 | 函数指针 指向一个接受整型参数且无返回值的函数 设置针对特定信号的处理方式，即捕获特定的信号： 123456sighandler_t signal(int signum, sighandler_t handler);成功返回原信号处理方式，失败返回SIG_ERR(sighandler_t类型的-1)。signum - 信号编号handler - 信号处理函数指针，也可以取以下值： SIG_IGN - 忽略信号 SIG_DFL - 默认操作 12345678910111213&#x2F;&#x2F; 定义信号处理函数void sigint (int signum) &#123; SIGINT(2)信号的处理代码&#125;...&#x2F;&#x2F; 捕获SIGINT(2)信号if (signal(SIGINT, sigint) &#x3D;&#x3D; SIG_ERR) &#123; perror(&quot;signal&quot;); return -1;&#125;...signal(SIGINT, SIG_DFL); &#x2F;&#x2F; 按默认方式处理signal(SIGINT, SIG_IGN); &#x2F;&#x2F; 忽略信号 ​ SIGINT(2)​ vSIGINT(2)/PID/sigint-&gt;系统内核​ v​ 目标进程中的sigint函数 当一个信号正在被处理的过程中，相同的信号再次产生，该信号会被阻塞，直到前一个信号处理完成，即从信号处理函数中返回，后一个被阻塞的信号才被递送，进而再次执行信号处理函数。当一个不可靠信号正在被处理的过程中，多个相同的信号再次产生，只有第一个信号会被阻塞，其它信号直接丢弃，如果是可靠信号，都会被阻塞，并按照产生的顺序依次被递送。信号处理函数及被其调用的函数都有可能发生重入，由此可能引发无可预知的风险。所有标准I/O函数都是不可重入函数。在信号处理的过程中要慎用。A信号-&gt;A信号处理函数 \\ 打印AAAAAA &gt; printf(调试信息);B信号-&gt;B信号处理函数 / 打印BBBBBBAAABBBBBBAAA 3.信号捕获流程 中断主控制流程——— v ———–&gt; / 信号处理函数 / ——&gt; \\ 用户空间 / \\ / \\ ——— / \\ / \\ 内核空间内核处理流程———–&gt; ———-&gt; do_signal system_call handle_signal sys_sigreturn setup_frame restore_sigcontext信号的本质是一个中断的处理过程，而非多线程的并发过程。线程安全的函数未必是可重入函数。 4.信号捕获的一次性问题在某些非Linux操作系统上，存在信号捕获的一次性问题：即使设置了对某个信号的捕获，只有设置后的第一个该信号被递送时，信号处理函数会被执行，以后再来相同的信号，均按默认方式处理。如果希望对信号的捕获具有持久性，可以在信号处理函数返回前再次设置对该信号的捕获。 5.太平间信号SIGCHLD(17)子进程死掉后就会向父进程发送SIGCHLD(17)信号。可通过SIGCHLD(17)信号高效地回收子进程僵尸。高效：及时性，适时性。 6.信号处理的继承与恢复1)fork/vfork函数创建的子进程会继承父进程的信号处理方式，直到子进程调用exec函数创建新进程替代其自身为止。2)exec函数创建的新进程会将原进程中被设置为捕获的信号还原为默认处理。在原进程中被忽略的信号于新进程中继续被忽略。 7.发送信号1)通过键盘向当前拥有控制终端的前台进程发送信号 Ctrl+C -&gt; SIGINT(2)，默认终止进程 Ctrl+\\ -&gt; SIGQUIT(3)，默认终止进程且转储 Ctrl+Z -&gt; SIGTSTP(20)，默认停止(挂起)进程 2)来自硬件或者内核的错误和异常引发的信号 SIGILL(4)，进程试图执行非法指令 SIGBUS(7)，硬件或总线对齐错误 SIGFPE(8)，浮点异常 SIGSEGV(11)，无效内存访问 SIGPIPE(13)，向无读端的管道写入 SIGSTKFLT(16)，浮点数协处理器栈错误 SIGXFSZ(25)，文件资源超限 SIGPWR(30)，断电 SIGSYS(31)，无效系统调用 3)通过kill命令发送信号kill [-信号] PIDs |缺省发送SIGTERM(15)信号超级用户可以给任何进程发信号，普通用户只能给自己的进程发信号。 4)调用函数发送信号向特定的进程(组)发送信号： 12345678int kill(pid_t pid, int signum);成功(至少发出去一个信号)返回0，失败返回-1。pid - 进程(组)标识，可取以下值： &lt;-1：向-pid进程组中的所有进程发送信号 -1: 向系统中的所有进程发送信号 0: 向调用进程同组的所有进程发送信号 0: 向进程标识为pid的特定进程发送信号signum - 信号编号，取0用于检查pid进程是否存在，如果不存在则返回-1，且置errno为ESRCH。 向调用进程自己发送信号： 1234int raise(int signum);成功返回0，失败返回-1。signum - 信号编号raise(SIGINT) &#x3D;&#x3D; kill(getpid(), SIGINT) 通过raise或kill向调用进程自己发送信号，如果该信号被捕获，则要等到信号处理函数返回后，这两个函数才会返回。（信号不会丢失，不管发送多少次都可以收到） 8.暂停、睡眠和闹钟暂停，即不受时间限制的睡眠： 12int pause(void);成功阻塞，失败返回-1。 该函数使调用进程进入无时限的睡眠状态，即不参与内核调度，直到有信号终止了调用进程或被捕获。如果有信号被调用进程捕获，当信号处理函数返回以后，pause函数才会返回，且返回值为-1，同时置errno为EINTR，表示阻塞的系统调用被信号中断。pause函数要么不返回，要么返回-1，不会返回0。 受时间限制的睡眠： 1234567unsigned int sleep(unsigned int seconds);返回0或剩余秒数。seconds - 以秒为单位的睡眠时限int usleep(useconds_t usec);睡够了返回0，睡不够返回-1，同时置errno为EINTR。usec - 为微秒为单位的睡眠时限 该函数使调用进程睡眠seconds秒，除非有信号终止了调用进程或被其捕获。如果有信号被调用进程捕获，在信号函数返回以后，sleep函数才会返回，且返回值为剩余秒数，否则该函数返回0，表示睡眠充足。 设置闹钟 123unsigned int alarm(unsigned int seconds);返回0或先前闹钟的剩余时间。seconds - 以秒为单位的闹钟时间 alarm函数使系统内核在该函数被调用以后seconds秒的时候，向调用进程发送SIGALRM(14)信号。若在调用该函数前已设过闹钟且尚未到期，则该函数会重设闹钟，并返回先前所设闹钟的剩余秒数，否则返回0。若seconds参数取0，则取消之前设置过且未到期的闹钟。 通过alarm函数所设置的定时只是一次性的，即在定时到期时发行一次SIGALRM(14)信号，此后不会再发送该信号。如果希望获得周期性的定时效果，可以在SIGALRM(14)信号的处理函数中继续调用alarm函数，完成下一个定时的设置。 9.信号集1234567#include &lt;signal.h&gt;typedef __sigset_t sigset_t;#include &lt;sigset.h&gt;typedef struct &#123; unsigned long int __val[_SIGSET_NWORDS];&#125; __sigset_t;#define _SIGSET_NWORDS (1024 &#x2F; (8 * sizeof(unsigned long int))) 12345678910111213141516填满信号集，即将信号集的全部信号位置1int sigfillset(sigset_t* sigset);清空信号集，即将信号集的全部信号位置0int sigemptyset(sigset_t* sigset);加入信号，即将信号集中的特定信号位置1int sigaddset(sigset_t* sigset, int signum);删除信号，即将信号集中的特定信号位置0int sigdelset(sigset_t* sigset, int signum);成功返回0，失败返回-1。检查信号，即判断信号集中的特定信号位是否为1int sigismember(sigset_t* sigset, int signum);有则返回1，无则返回0，失败返回-1。 信号与信号集 信号： 是软件类型的中断，但不是中断，中断是指由外部设备通过硬件请求的方式产生的中断，信号是是由CPU运行程序错误或执行内部程序调用对于异步事件的响应。 信号集：信号的一个集合，一个能表示多个信号的数据类型(结构)，能够把 能够把系统支持的62个信号都表示下（都装下）。 10.信号屏蔽1)递送、未决和掩码当信号产生时，系统内核在目标进程的进程表项中，以信号位置1的方式，存储该信号，这个过程就叫做递送。信号从产生到完成递送之间存在一定的时间间隔，处于该间隔状态的信号就是属于未决信号。每个进程都已一个信号掩码，它实际上是一个信号集，位于该信号集中的信号一旦产生，并不会被递送给相应的进程，而是会被阻塞于未决状态。当进程正在执行类似更新数据库、设置硬件状态等敏感任务时，可能不希望被某些信号中断。这是可以通过信号掩码暂时屏蔽而非忽略这些信号，使其一旦产生即被阻塞于未决状态，待特定任务完成以后，在恢复对这些信号的处理。 2)设置信号掩码 12345678int sigprocmask(int how, const sigset_t* sigset, sigset_t* oldset);成功返回0，失败返回-1。how - 信号掩码的修改方式，可取以下值： SIG_BLOCK - 将sigset中的信号加入当前掩码 SIG_UNBLOCK - 从当前掩码中删除sigset中的信号 SIG_SETMASK - 将sigset设置为当前掩码 sigset - 信号集，取NULL则忽略参数 oldset - 原信号掩码，取NULL则忽略此参数 3)获取未决信号 123int sigpending(sigset_t* sigset);成功返回0，失败返回-1。sigset - 输出未决信号集 4)不可靠信号最多被信号掩码屏蔽一次，在屏蔽期间再有更多的相同信号，一律被丢弃。可靠信号会全部被保留下来，且按照发送的顺序排成队列。 11.现代版本的信号处理与发送经典版本的信号处理与发送：signal/kill(raise)现代版本的信号处理与发送：sigaction/sigqueue 12345int sigaction(int signum, const struct sigaction* sigact, struct sigaction* oldact);成功返回0，失败返回-1。signum - 信号编号sigact - 信号行为oldact - 输出原来的信号行为，可置NULL 当signum信号被递送时，按sigact结构所描述的行为响应之。若oldact参数非NULL，则通过该参数输出原来的响应行为。 123456789101112struct sigaction &#123; &#x2F;&#x2F; 经典版本的信号处理函数指针 void (*sa_handler)(int); &#x2F;&#x2F; 现代版本的信号处理函数指针 void (*sa_sigaction)(int, siginfo_t*, void*); &#x2F;&#x2F; 信号处理期间的附加掩码集 sigset_t sa_mask; &#x2F;&#x2F; 信号处理标志 int sa_flags; &#x2F;&#x2F; 预留项，目前置NULL void (*sa_restorer)(void);&#125;; 12345678910111213141516171819现代版本的信号处理函数：void sigint(int signum, siginfo_t* si, void* reserved) &#123; ...&#125;signum：信号编号si：信号信息reserved：保留未用typedef struct siginfo &#123; &#x2F;&#x2F; 发送信号进程的PID pid_t si_pid; &#x2F;&#x2F; 信号附加数据 sigval_t si_value; ... &#125; siginfo_t;typedef union sigval &#123; int sival_int; &#x2F;&#x2F; 用整型作为信号附加数据 void* sival_ptr; &#x2F;&#x2F; 用任意类型的指针作为信号附加数据&#125; sigval_t; 1)增减信号掩码缺省情况下，在信号处理函数的执行过程中，会自动屏蔽这个正在被处理的信号，而对于其他信号则不会被屏蔽。通过sa_mask字段可以人为指定，在信号处理函数执行期间， 除正在被处理的这个信号以外，还想屏蔽哪些信号，并在信号处理函数返回后，自动解除对它们的屏蔽。另一方面，还可以通过为sa_flags字段设置SA_NOMASK/SA_NODEFER标志位，告诉系统内核在信号处理函数执行期间，不要屏蔽这个正在被处理的信号。 2)选择信号处理函数的风格如果sa_flags字段中没有SA_SIGINFO标志位，则sa_handler字段有效，即使用经典版本的信号处理函数。相反，如果sa_flags字段包含SA_SIGINFO标志位，则sa_sigaction字段有效，即使用现代版本的信号处理函数。 3)一次性信号处理如果sa_flags字段中包含SA_ONESHOT/SA_RESETHAND标志位，那么对所捕获信号的处理就是一次性的，即在执行完一次信号处理函数后，即恢复为按默认方式处理。 4)系统调用中断重启诸如pause、sleep、usleep等系统调用的阻塞过程会被信号打断，即在针对某个信号的处理函数返回后，这些系统调用也会从阻塞中返回。如果不希望这类系统调用被所捕获的信号打断，即在针对该信号的处理函数返回后，能够自动重启阻塞过程，而不要返回，可以为sa_flags字段添加SA_RESTART标志位。 利用信号附加数据实现简单的进程间通信: 12345int sigqueue(pid_t pid, int signum, const union sigval value);成功返回0，失败返回-1。pid - 接收信号进程的PIDsignum - 信号编号value - 信号附加数据 -&gt; siginfo::si_value 12.定时器(alarm闹钟重复性不好)执行时间(真实计时器)=用户时间(虚拟计时器)+内核时间+睡眠时间 执行时间：直观感受墙钟时间 用户时间：消耗在用户态的时间 内核时间： 消耗在内核态的时间 睡眠时间：消耗在等待I/O、睡眠等不被调度的时间 执行时间 = 真实计时器定时 实用计时器定时 = 虚拟计时器定时+内核时间 利用真实计时器定时，到期信号：SIGALRM(14)利用虚拟计时器定时，到期信号：SIGVTALRM(26)利用实用计时器定时，到期信号：SIGPROF(27) 基于每钟计时器的定时都有两个参数： 初始间隔 - 从开始定时到发出第一个到期信号的时间间隔。 重复间隔 - 每相邻两个到期信号的时间间隔。 设置、开启和关闭定时器函数： 12345678int setitimer(int which, const struct itimerval* new_value, struct itimerval* old_value);成功返回0，失败返回-1。which - 指定设置哪个定时器，可取以下值： ITIMER_REAL: 基于真实计时器的定时 ITIMER_VIRTUAL: 基于虚拟计时器的定时 ITIMER_PROF: 基于实用计时器的定时new_value - 新设置值old_value - 输出原设置值，可置NULL 12345678910struct itimerval &#123; &#x2F;&#x2F; 重复间隔，取0表示只发一个信号，不重复，没有周期性 struct timeval it_interval; &#x2F;&#x2F; 初始间隔，取0表示停止定时器，不再发信号 struct timeval it_value;&#125;;struct timeval &#123; long tv_sec; &#x2F;&#x2F; 秒 long tv_usec; &#x2F;&#x2F; 微秒&#125;; 例如：5秒以后开始发SIGALRM(14)信号，以后每隔3毫秒再发一次该信号。 123456789struct itimerval it;it.it_value.tv_sec &#x3D; 5;it.it_value.tv_usec &#x3D; 0;it.it_interval.tv_sec &#x3D; 0;it.it_interval.tv_usec &#x3D; 3000;setitimer(ITIMER_REAL, &amp;it, NULL); &#x2F;&#x2F; 开...it.it_value.tv_sec &#x3D; 0;setitimer(ITIMER_REAL, &amp;it, NULL); &#x2F;&#x2F; 关 如果希望立即启动定时器，初始间隔至少是1微秒。 获取当前定时器设置： 1234567int getitimer(int which, struct itimerval* curr_value);成功返回0，失败返回-1。which - 指定设置哪个定时器，可取以下值： ITIMER_REAL: 基于真实计时器的定时 ITIMER_VIRTUAL: 基于虚拟计时器的定时 ITIMER_PROF: 基于实用计时器的定时curr_value - 当前设置值 十二、进程间通信1.什么是进程间通信Unix/Linux系统中每个进程都拥有独立的4G字节大小的虚拟内存空间。其中高地址的1G字节被映射到相同的物理内存区域，用于保存内核代码和数据。低地址的3G字节作为保存用户代码和数据的用户空间，被映射到彼此不同物理内存。因此同一个虚拟内存地址，在不同的进程中，会被映射到不同的物理内存区域，在多个进程之间以交换虚拟内存地址的方式交换数据是不可能的。鉴于进程之间天然的内存壁垒，为了能够在不同进程之间高效地交换数据，需要有一种专门的机制，这就是所谓的进程间通信(Inter-Process Communication, IPC)。 3.简单的进程间通信1)命令行参数进程1组织命令行参数-&gt;execl-&gt;进程2处理命令行参数进程1：username，passwordexecl(…, “login”, username, password, NULL) | |进程2： argv[1] argv[2] 2)环境变量进程1组织环境变量-&gt;execle-&gt;进程2处理环境变量进程1：username，passwordsprintf(envp[0], “USERNAME=%s”, username);sprintf(envp[1], “PASSWORD=%s”, password);execle(…, envp);进程2：envp[0]-&gt;USERNAME=minwei envp[1]-&gt;PASSWORD=tarena 3)wait/waitpid进程1-&gt;fork/vfork+exec-&gt;进程2 123wait&#x2F;waitpid(..., &amp;status); main-&gt;return ...; ^ exit&#x2F;_exit&#x2F;_Exit(...) |_________________________| 4)内存映射文件进程1[虚拟内存]–&gt;文件区域&lt;–[虚拟内存]进程2 5)信号进程1—-信号+附加数据—&gt;进程2 4.传统的进程间通信1)有名管道（借用内存，速度快） 进程1&lt;-管道文件-&gt;进程2有名管道：是一种文件，内存文件，有i节点没有数据块半双工通信 创建有名管道文件 1234int mkfifo(const char* pathname, model_t mode);成功返回0，失败返回-1。pathname - 文件路径mode - 权限模式 打开、关闭、读取和写入有名管道文件的方法与读写普通文件无异：open/read/write/close。编程模型进程A 进程B创建管道 mkfifo打开管道 open 打开管道读写管道 read/write 读写管道关闭管道 close 关闭管道删除管道 unlink 2)无名管道 / -无名管道-&gt; 父进程 子进程 \\ &lt;-无名管道- /半双工通信 创建无名管道 12345int pipe(int pipefd[2]);成功返回0，失败返回-1。pipefd - 输出两个文件描述符： pipefd[0]表示管道的读端 pipefd[1]表示管道的写端 1)父进程调用pipe函数在系统内核中创建无名管道对象，同时得到与该对象相关联的两个文件描述符，一个用于读取，另一个用于写入；2)父进程调用fork函数，创建子进程，子进程复制父进程的文件描述符表，因此子进程也同样拥有可用于读写管道对象的两个文件描述符。3)负责写数据进程关闭管道读端，即pipefd[0]，而负责读数据的继承关闭管道的写端，即pipefe[1]；4)父子进程通过各自持有的文件描述符，分别向管道写入和读取数据，待完成通信后再各自关闭所持有的文件描述符，内核中的无关管道对象即被释放。代码：pipe.c 基于管道通信的特殊情况1)从写端已被关闭的管道中读取只要管道缓冲区中还有数据，依然可被正常读取，一直读到缓冲区空，这时read函数会返回0（既不是返回-1也不是阻塞），如同读到文件尾。 2)向读端已被关闭的管道中写入会直接触发SIGPIPE(13)信号。该信号的默认操作是终止执行写入动作的进程。但如果执行写入动作的进程已经事先将SIGPIPE(13)信号设置为忽略或捕获，这时虽然进程不会因为写入无读端的管道而被终止，但write函数会返回-1，并置errno为EPIPE。 3)在/usr/include/linux/limits.h头文件中定义的PIPE_BUF宏(4096)表示管道写缓冲区的大小。如果写管道时发现缓冲区中的空闲空间不足以容纳此次write调用所要写入的字节数，则write函数会阻塞，直到缓冲区中的空闲空间变得足够大为止。如果同时有多个进程向同一个管道写入数据，而每次调用write函数写入的字节数都不大于BUF_SIZE，则这些write操作不会互相穿插(原子化，atomic)，反之单次写入的字节数超过了BUF_SIZE，则它们的write操作可能会相互穿插。读取一个缓冲区为空的管道，只要其写端没有被关闭，读操作就会阻塞，除非该读文件描述符被设置为非阻塞(O_NONBLOCK)，此时会立即返回失败，并置errno为EAGAIN。 管道符号的原理命令1 | 命令2 | 命令3 … | | |输出&gt;管道&gt;输入 输出&gt;管道&gt;输入 输出&gt;…A | BShell进程：int pipefd[2];pipe(pipefd); // 创建无名管道vfork(); // 产生一个子进程1 子进程1: close(pipefd[0]); // 关闭无名管道的读端 dup2(pipefd[1], STDOUT_FILENO); // 写端=标准输出 exec(A) // 创建A进程，继承了原进程的文件描述符表 // 在A进程中，写端=标准输出 // printf/puts将数据写入无名管道的写端vfork(); // 产生一个子进程2 子进程2: close(pipefd[1]); // 关闭无名管道的写端 dup2(pipefd[0], STDIN_FILENO); // 读端=标准输入 exec(B) // 创建B进程，继承了原进程的文件描述符表 // 在B进程集中，读端=标准输入 // scanf/gets从无名管道的读端读取数据A和B就成为协作进程，A写入数据进管道，B从管道中读取A写入的数据。 5.套接字进程间通信(BSD)进程1&lt;-本地套接字文件-&gt;进程2 |本地套接字文件：内存文件，有i节点没有数据块，以一种统一的编程模式和接口库，处理网络和本机通信。 6.XSI进程间通信(SVR4)1)消息队列：进程1—消息3|消息2|消息1–&gt;进程22)共享内存：进程1[虚拟内存]-&gt;物理内存&lt;-[虚拟内存]进程23)信号量集：多个进程竞争有限的资源11.XSI的IPC对象 1)IPC对象的标识符(ID)和键(KEY)IPC对象在系统内核中的唯一名称用键(KEY)表示。不同的进程可以通过键来引用该IPC对象。一旦进程获得了该IPC对象，即通过其标识(ID)来称谓该对象。 IPC对象(键) 内核空间— / — | — \\ ————— /键 |键 \\键 用户空间进程1 进程2 进程3 ID1 ID2 ID3#include &lt;sys/ipc.h&gt;key_t ftok(const char* pathname, int proj_id);成功返回IPC对象的键，失败返回-1。pathname - 一个真实存在的路径，使用该路径的i节点号proj_id - 项目ID，仅低8为有效，-128127/0255相同项目使用相同的pathname和proj_id，保证key的一致性不同项目使用不同的pathname或proj_id，避免key发生冲突 2)IPC对象的编程接口A.创建或获取IPC对象 123456&#x2F;&#x2F; 共享内存int shmget(key_t key, size_t size, int shmflg);&#x2F;&#x2F; 消息队列int msgget(key_t key, int msgflg);&#x2F;&#x2F; 信号量集int semget(key_t key, int nsems, int semflg); B.控制或销毁IPC对象 12345678910&#x2F;&#x2F; 共享内存int shmctl(int shmid, int cmd, struct shmid_ds* buf);&#x2F;&#x2F; 消息队列int msgctl(int msqid, int cmd, struct msqid_ds* buf);&#x2F;&#x2F; 信号量集int semctl(int semid, int semnum, int cmd, union semun arg);cmd - 控制命令，可取以下值： IPC_STAT: 获取IPC对象的属性 IPC_SET: 设置IPC对象的属性 IPC_RMID: 删除IPC对象 C.IPC对象的权限结构 123456789struct ipc_perm &#123; key_t __key; &#x2F;&#x2F; 键 uid_t uid; &#x2F;&#x2F; 拥有者用户 gid_t gid; &#x2F;&#x2F; 拥有者组 uid_t cuid; &#x2F;&#x2F; 创建者用户 gid_t cgid; &#x2F;&#x2F; 创建者组 unsigned short mode; &#x2F;&#x2F; 权限 unsigned short __seq; &#x2F;&#x2F; 序号&#125;; 其中只有uid、gid和model三个字段可以在创建完成以后被修改。 3)共享内存两个或者更多进程，共享一块由系统内核负责维护的物理内存，其地址空间通常被映射到每个进程虚拟内存堆和栈之间的不同区域。共享内存的属性结构： 1234567891011struct shmid_ds &#123; struct ipc_perm shm_prem; &#x2F;&#x2F; 权限结构 size_t shm_segsz; &#x2F;&#x2F; 字节数 time_t shm_atime; &#x2F;&#x2F; 最后加载时间 time_t shm_dtime; &#x2F;&#x2F; 最后卸载时间 time_t shm_ctime; &#x2F;&#x2F; 最后改变时间 pid_t shm_cpid; &#x2F;&#x2F; 创建进程的PID pit_t shm_lpid; &#x2F;&#x2F; 最后加(卸)载进程的PID shmatt_t shm_nattch; &#x2F;&#x2F; 当前加载计数 ...&#125;; 获取一个共享内存标识符或创建一个共享内存对象: 1234567int shmget(key_t key, size_t size, int shmflg);成功返回共享内存的标识符，出错返回-1，错误原因存于error中。size - 共享内存的字节数，按页向上取整。获取已有共享内存对象时可置0。shmflg - 创建标志: 0: 获取，不存在即失败。 IPC_CREATE - 创建兼获取，不存在即创建，已存在直接获取 IPC_EXCL - 不存在即创建，已存在直接报错。 加载共享内存到虚拟内存，加载虚拟内存和物理内存间的映射: 123456789void* shmat(int shmid, const void* shmaddr, int shmflags);成功返回共享内存起始地址，失败返回void*类型的-1。shmid - 共享内存标识shmaddr - 共享内存起始地址，置NULL由系统内核选择shmflags - 加载标志，可取以下值： 0: 可读可写 SHM_RDONLY: 只读 SHM_RND: 若shmaddr非空且不是页边界，则将其调整至页边界。 卸载共享内存 12int shmdt(const void* shmaddr);成功返回0，失败返回-1，错误原因存于error中。 控制或销毁共享内存 12int shmctl(int shmid, int cmd, struct shmid_ds *buf)成功返回0，失败返回，-1错误原因存于error中。 shmat函数负责将给定共享内存映射到调用进程的虚拟内存空间，返回映射区的起始地址，同时将系统内核中共享内存对象的加载计数(shm_nattch)加1。调用进程在获得shmat函数返回的共享内存起始地址以后，就可以象访问普通内存一样访问该共享内存中的数据。 shmdt函数负责从调用进程的虚拟内存中解除shmaddr所指向的映射区到共享内存的映射，同时将系统内核中共享内存对象的加载计数(shm_nattch)减1。因此加载计数为0的共享内存必定是没有任何进程使用的。 shmctl(…, IPC_RMID, …)调用可以用于销毁共享内存，但并非真的销毁，而只是做一个销毁标记，禁止任何进程对该共享内存形成新的加载，但已有的加载依然保留。只有当其使用者们纷纷卸载，直至其加载计数降为0时，共享内存才会真的被销毁。 通过共享内存实现进程间通信，可以直接访问由系统内核维护的公共内存区域，不需要额外构建用户缓冲区，也不需要在用户缓冲区和内核缓冲区之间来回复制数据。因此共享内存是速度最快的进程间通信机制。但是共享内存因为缺乏必要的同步机制，往往需要借助其它进程间通信策略提供某种形式的停等机制。 4)消息队列消息队列是由单个的类型各异的一系列消息结构组成的链表。 消息 +-&gt; 消息——— | ———-消息类型 | 消息类型数据长度 | 数据长度消息数据 | 消息数据消息指针–+ 消息指针–&gt; 尾 首 最大可发送消息字节数：8192(8K)最大全队列消息字节数：16384(16K)最大全系统消息队列数：16最大全系统消息总个数：262144 获取一个消息队列或者创建一个消息队列: 123int msgget(key_t key, int msgflg); | 0&#x2F;IPC_CREAT&#x2F;IPC_EXCL 发送消息： 1234567int msgsnd( int msqid, &#x2F;&#x2F; 消息队列标识 const void* msgp, &#x2F;&#x2F; 一个指针-&gt;| 消息类型(4字节) | 消息数据 | size_t msgsz, &#x2F;&#x2F;消息数据的长度 &lt;--长度--&gt; int msgflg &#x2F;&#x2F; 0阻塞&#x2F;IPC_NOWAIT非阻塞);成功返回0，失败返回-1。 msgsnd函数的msgp参数所指向的内存中包含4个字节大小的消息类型，其值必须大于0，但该函数的msgsz参数所表示的期望发送字节数却不包含消息类型所占的4个字节。如果系统内核中的消息未达上限，则msgsnd函数会将欲发送消息加入消息队列并立即返回0，否则该函数会阻塞，直到系统内核允许加入新消息为止(比如有消息因被接收而离开消息队列)。若msgflg参数中包含IPC_NOWAIT位，则msgsnd函数在系统内核中的消息已达上限的情况下不会阻塞，而是返回-1，并置errno为EAGAIN。 接收消息： 123456789101112int msgrcv( int msqid, &#x2F;&#x2F; 消息队列标识 void* msgp, &#x2F;&#x2F; -&gt;| 消息类型(4字节) | 消息数据缓冲区 | size_t msgsz, &#x2F;&#x2F; &lt;-----长度-----&gt; long msgtyp, &#x2F;&#x2F; 消息类型 int msgflg &#x2F;&#x2F; 0阻塞&#x2F;IPC_NOWAIT非阻塞&#x2F;...);成功返回实际接收到的消息数据的长度，失败返回-1。msgtyp可取以下值： &gt;0 - 提取消息队列中的第一条消息而无论其类型。 0 - msgflg不含MSG_EXCEPT位，提取第一条类型为msgtyp的消息，msgflg含MSG_EXCEPT位，提取第一条类型不为msgtyp的消息。 &lt;0 - 提取队列中类型小于或等于|msgtyp|的消息，类型越小的越先被提取。 注意msgrcv函数的msgp参数所指向的内存块中包含4字节的消息类型，其值由该函数输出，但该函数的msgsz参数所表示的期望接收字节数以及该函数所返回的实际接收字节数都不包含消息类型4个字节。若存在与msgtyp参数匹配的消息，但是数据长度大于msgsz参数，且msgflg参数包含MSG_NOERROR位，则置截取该消息数据的前msgsz字节返回，剩余部分直接丢弃；但如果msgflg参数不包含MSG_NOERROR位，则不处理该消息，直接返回-1，并置errno为E2BIG。msgrcv函数根据msgtyp参数对消息队列中消息有选择地接收，只有满足条件的消息才会被复制到应用程序缓冲区并从内核中删除。如果满足msgtyp条件的消息不只一条，则按照先进先出的规则提取。若消息队列中有可接收消息，则msgrcv函数会将该消息移出消息队列，并立即返回所接收到的消息数据字节数，表示接收成功，否则此函数会阻塞，直到消息队列中有可接收消息为止。若msgflg参数包含IPC_NOWAIT位，则msgrcv函数在消息队列中没有可接收消息的情况下不会阻塞，而是返回-1，并置errno为ENOMSG。 5)信号量集资源的需求者多于资源本身，如何协调有限资源在多数需求者之间的分配，以使每个资源需求者都有相对均衡的几率获得其所要求的资源。系统内核中为每一种资源维护一个资源计数器，其值为当前空闲资源的数量，每当一个进程试图获取该种资源时，会先尝试减少其计数器的值，如果该计数器的值够减(计数器&gt;=0)，则说明空闲资源足够，该进程即获得资源，如果该计数器的值不够减，则说明空闲资源不够，该进程即进入等待模式，等候其它拥有该种资源的进程释放资源。任何一个拥有该种资源的进程，一旦决定释放该资源，都必须将其计数器的值予以增加，以表示空闲资源量的增加，为其它等候该资源的进程提供条件。用一个信号量表示一种类型资源，其值为该类型资源的空闲数量。用由多个信号量组成的信号量集表示多种类型的资源。 创建或获取信号量集：#include &lt;sys/sem.h&gt; 12345678int semget(key_t key, int nsems, int semflg);成功返回信号量集标识符，失败返回-1。key - 信号量集键nsems - 信号量个数，即资源的种类数semflg - 创建标志，可取以下值： 0 - 获取，不存在即失败 IPC_CREAT - 创建，不存在即创建，已存在即获取 IPC_EXCL - 排斥，已存在即失败 操作信号量集：减操作-&gt;拥有资源…释放资源-&gt;加操作 1234567891011int semop(int semid, struct sembuf* sops, unsigned nsops);成功返回0，失败返回-1。semid - 信号量集标识sops - 操作结构数组nsops - 操作结构数组长度struct sembuf &#123; unsigned short sem_num; &#x2F;&#x2F; 信号量编号(集合索引) short sem_op; &#x2F;&#x2F; 操作数(-获取&#x2F;+释放) short sem_flg; &#x2F;&#x2F; 操作标志(0&#x2F;IPC_NOWAIT)&#125;; sops指针指向一个struct sembuf类型的结构体数组，其中每个元素都是一个struct sembuf类型的结构体，该结构体包含三个字段，用于表示针对信号量集中的一个特定信号量的特定操作。 semid=0 semid=0———- –semop()-&gt; ———- 0: 15 -1 0: 14 1: 21 1: 21 2: 33 +1 2: 34 3: 42 -1 3: 41sops 0: {0, -1, 0}1: {2, 1, 0}2: {3, -1, 0} 如果sem_op字段的值为负，则从semid信号量集第sem_num个信号量的值中减去|sem_op|，以表示对资源的获取；如果不够减(信号量的值不能为负)，则此函数会阻塞，直到够减为止，以表示对资源的等待，但如果sem_flg包含IPC_NOWAIT位，则即使不够减也不会阻塞，而是返回-1，并置errno为EAGAIN。 销毁或控制信号量集： 12int semctl(int semid, int semnum, int cmd, ...);成功返回0或其它与cmd有关的值，失败返回-1。 123456789101112131415161718A.销毁信号量集int semctl(int semid, 0, IPC_RMID); -&gt; 0&#x2F;-1B.获取信号量集中每个信号量的值unsigned short array[4]; &#x2F;&#x2F; 每个信号量的值int semctl(int semid, 0, GETALL, array); -&gt; 0&#x2F;-1C.设置信号量集中每个信号量的值unsigned short array[4] &#x3D; &#123;5, 5, 5, 5&#125;; &#x2F;&#x2F; 每个信号量的值int semctl(int semid, 0, SETALL, array); -&gt; 0&#x2F;-1D.获取信号量集中特定信号量的值int semctl(int semid, int semnum, GETVAL); -&gt;semid信号量集中第semnum个信号量的值&#x2F;-1 E.设置信号量集中特定信号量的值int semctl(int semid, int semnum, SETVAL, int val);-&gt;0&#x2F;-1将semid信号量集中第semnum个信号量的值设置为val 进程间的通信（IPC）的方式总结：命令行参数和环境变量(给main函数传参) 初始化设置 回收进程退出码(接收main函数的返回值或者exit函数的参数) 获得终止信息 内存映射文件 通过内存的方式操作共享文件，读写磁盘数据 速度慢但持久性好 信号 简单，异步，信息量有限，效率不高，可靠性不佳 有名管道或本地套接字 非近亲进程之间的中等规模数据通信 无名管道 近亲进程之间的中等规模数据通信 共享内存 大数据量的快速数据通信 缺乏同步机制，需要依赖其它IPC机制实现同步 消息队列 天然的同步性，根据类型做细分 适用于中等规模数据通信 信号量集 多数进程竞争少数资源 6)IPC命令查看IPC对象 1234ipcs -m, m&#x3D;memory, 共享内存对象ipcs -q, q&#x3D;queue, 消息队列对象ipcs -s, s&#x3D;semphore, 信号量集对象ipcs -a, a&#x3D;all, 全部IPC对象 删除IPC对象 123ipcrm -m &lt;共享内存对象标识&gt;ipcrm -q &lt;消息队列对象标识&gt;ipcrm -s &lt;信号量集对象标识&gt;","link":"","tags":[]},{"title":"UinxC-IO编程2","date":"2021-05-03T03:34:17.000Z","path":"2021/05/03/UinxC-IO编程2/","text":"九、文件1.文件系统的物理结构1)硬盘的物理结构：驱动臂、盘片、主轴、磁头、控制器 2)磁表面存储器的读写原理 硬盘片的表面覆盖着薄薄的磁性涂层，涂层中含有无数微小的磁性颗粒，谓之磁畴。相邻的若干磁畴组成一个磁性存储元，以其剩磁的极性表示二进制数字0和1。为磁头的写线圈中施加脉冲电流，可把一位二进制数组转换为磁性存储元的剩磁极性。利用磁电变换，通过磁头的读线圈，可将磁性存储元的剩磁极性转换为相应的电信号，表示二进制数。 3)磁道和扇区磁盘旋转，磁头固定，每个磁头都会在盘片表面画出一个圆形轨迹。改变磁头位置，可以形成若干大小不等的同心圆，这些同心圆就叫做磁道(Track)。每张盘片的每个表面上都有成千上万个磁道。一个磁道，以512字节为单位，分成若干个区域，其中的每个区域就叫做一个扇区(Sector)。扇区是文件存储的基本单位。 4)柱面、柱面组、分区和磁盘驱动器硬盘中，不同盘片相同半径的磁道所组成的圆柱称为柱面(Cylinder)。整个硬盘的柱面数与每张盘片的磁道数相等。硬盘上的每个字节需要通过以下参数定位：磁头号：确定哪个盘面 柱面号：确定哪个磁道 &gt; 磁盘I/O扇区号：确定哪个区域 /偏移量：确定扇区内的位置若干个连续的柱面构成一个柱面组若干个连续的柱面组构成一个分区每个分区都建有独立的文件系统若干分区构成一个磁盘驱动器 2.文件系统的逻辑结构磁盘驱动器：| 分区 | 分区 | 分区 |分区：| 引导块 | 超级块 | 柱面组 | 柱面组 | 柱面组 |柱面组：| 引导块副本| 柱面组信息 | i节点映射表 | 块位图 | i节点表 | 数据块集 |根据目录文件中记录的i节点编号检索i节点映射表，获得i节点下标，用该下标查i节点表，获得i节点，i节点中包含了数据块索引表，利用数据块索引从数据块集中读取数据块，即获得文件数据。 直接块：存储文件实际数据内容 间接块：存储下级文件数据块索引表 3.文件分类普通文件(-)：可执行程序、文本、图片、音频、视频、网页目录文件(d)：该目录中每个硬链接名和i节点号的对应表符号链接文件(l)：存放目标文件的路径管道文件(p)：有名管道，进程间通信套接字文件(s)：进程间通信块设备文件(b)：按块寻址，顺序或随机读写字符设备文件(c)：按字节寻址，只能以字节为单位顺序读写 4.文件的打开与关闭打开：在系统内核中建立一套数据结构，用于访问文件关闭：释放打开文件过程中建立的数据结构 12FILE* fp &#x3D; fopen(&quot;reame.txt&quot;, &quot;r&quot;);&#x2F;&#x2F;C语言库函数fread(fp, ...); 打开已有的文件或创建新文件 123456789101112131415161718int open(const char* pathname, int flags, mode_t mode);&#x2F;&#x2F;系统调用成功返回文件描述符，失败返回-1。pathname - 文件路径flags - 文件状态标志，可取以下值： O_RDONLY - 只读 \\ O_WRONLY - 只写 &gt; 只选其一 O_RDWR - 读写 &#x2F; O_APPEND - 追加 O_CREAT - 创建，不存在即创建，已存在即打开，除非与以下两个标志之一合用，由此标志mode参数才有效。 O_EXCL - 排它，已存在即失败 O_TRUNC - 清空，已存在即清空，同时有O_WRONLY或O_RDWR O_SYNC - 写同步，在数据被写到磁盘之前写操作不会完成，读操作本来就是同步的，此标志对读操作没有意义 O_ASYNC - 异步，在文件可读写时产生一个SIGIO信号，在对信号的处理过程中读写I&#x2F;O就绪的文件，只能用于终端设备或网络套接字，而不能用于磁盘文件 O_NONBLOCK - 非阻塞，读操作不会因为无数据可读而阻塞，写操作也不会因为缓冲区满而阻塞，相反会返回失败，并设置特定的errnomode - 权限模式，三位八进制：0XXX &#x3D; 0(拥有者用户)(同组用户)(其它用户) 4: 可读 2: 可写 1: 可执行 所创建文件的实际权限除了跟mode参数有关，还受权限掩码的影响。mode=0666umask=0002权限=mode&amp;~umask=0664 创建新文件 12int creat(const char* pathname, mode_t mode);flags: O_WRONLY | O_CREAT | O_TRUNC 打开已有文件 1int open(const char* pathname, int flags);&#x2F;&#x2F;系统调用 关闭文件 123int close(int fd);&#x2F;&#x2F;系统调用成功返回0，失败返回-1。fd - 文件描述符 作为文件描述符表项在文件描述符表中的下标，合法的文件描述符一定是大于或等于0的整数。每次产生新的文件描述符表项，系统总是从下标0开始在文件描述符表中寻找最小的未使用项。每关闭一个文件描述符，无论被其索引的文件表项和v节点是否被删除，与之对应的文件描述符表项一定会被标记为未使用，并在后续操作中为新的文件描述符所占用。系统内核缺省为每个进程打开三个文件描述符： 123#define STDIN_FILENO 0 &#x2F;&#x2F; 标准输入，即键盘#define STDOUT_FILENO 1 &#x2F;&#x2F; 标准输出，终端屏幕，有缓冲#define STDERR_FILENO 2 &#x2F;&#x2F; 标准错误，终端屏幕，无缓冲 UC C C++ 标准输入 0 stdin cin 它是命令的输入，缺省是键盘，也可以是文件或其他命令的输出 标准输出 1 stdout cout 它是命令的输出，缺省是屏幕，也可以是文件 标准错误 2 stderr cerr 这是命令错误的输出，缺省是屏幕，同样也可以是文件。 数据类型 int FILE* iostream 文件描述符是用户程序和系统内核关于文件的唯一联系方式。如果没有特别指定文件描述符，命令将使用缺省的文件描述符。在linu系统中，Shell会自动为我们打开和关闭0、1、2这三个文件描述符，我们不需要显式地打开或关闭它们。标准输入是命令的输入，默认指向键盘；标准输出是命令的输出，默认指向屏幕；标准错误是命令错误信息的输出，默认指向屏幕。如果没有显式地进行重定向，命令通过文件描述符0从屏幕读取输入，通过文件描述符1和2将输出和错误信息输出到屏幕。但如果我们想从其他文件（再次强调，I/O设备在Unix/Linux中也是文件）读取输入或产生输出，就需要对0、1、2使用重定向了。其语法如下： 1234567891011121314151617shell终端重定向命令:command &lt; filename 把标准输入重定向到filename文件中command 0&lt; filename 同上command &gt; filename 把标准输出重定向到filename文件中(覆盖)command 1&gt; fielname 同上command &gt;&gt; filename 把标准输出重定向到filename文件中(追加)command 1&gt;&gt; filename 同上 command 2&gt; filename 把标准错误重定向到filename文件中(覆盖)command 2&gt;&gt; filename 同上command &gt; filename 2&gt;&amp;1 把标准输出和标准错误一起重定向到filename文件中(覆盖)command &gt;&gt; filename 2&gt;&amp;1 把标准输出和标准错误一起重定向到filename文件中(追加)command &lt; filename &gt;filename2 把文件filename中的内容作为command的输入，把标准输出重定向到filename2文件中command 0&lt; filename 1&gt; filename2 同上 5.文件的读取和写入向指定文件写入字节流: 12345ssize_t write(int fd, const void* buf, size_t count);成功返回实际写入的字节数(0表示未写入)，失败返回-1。fd - 文件描述符buf - 内存缓冲区count - 期望写入的字节数 向指定文件读入字节流: 12345ssize_t read(int fd, void* buf, size_t count);成功返回实际读取的字节数(0表示读到文件尾)，失败返回-1。fd - 文件描述符buf - 内存缓冲区count - 期望读取的字节数 基于系统调用的文件读写本来就是面向二进制字节流的，因此对二进制读写而言，无需做任何额外的工作。如果要求文件中内容必须是可阅读的，那么就必须通过格式化和文本解析处理二进制形式的数据和文本字符串之间的转换。 6.顺序与随机读写每个打开的文件都有一个与其相关的文件读写位置保存在文件表项中，用以记录从文件头开始计算的字节偏移。文件读写位置通常是一个非负的整数，用off_t类型表示，在32位系统上被定义为long int，而在64位系统上则被定义为long long int。打开一个文件时，除非指定了O_APPEND标志，否则文件读写位置一律被设为0，即文件首字节的位置。每一次读写操作都从当前的文件读写位置开始，并根据所读写的字节数，同步增加文件读写位置，为下一次读写做好准备。因为文件读写位置是保存在文件表项而不是v节点中的，因此通过多次打开同一个文件得到多个文件描述符，各自拥有各自的文件读写位置。人为调整文件读写位置： 12345678off_t lseek(int fd, off_t offset, int whence);成功返回调整后的文件读写位置，失败返回-1。fd - 文件描述符offset - 文件读写位置相对于whence参数的偏移量whence： SEEK_SET - 从文件开始 SEEK_CUR - 从当前位置开始 SEEK_END - 从文件尾开始 lseek函数仅仅是修改文件表项中的文件读写位置，并不引发实际的I/O操作，速度很快。 123456lseek(fd, 10, SEEK_SET);lseek(fd, -10, SEEK_END);lseek(fd, 0, SEEK_CUR); &#x2F;&#x2F; 返回当前读写位置lseek(fd, 0, SEEK_END); &#x2F;&#x2F; 返回文件总字节数lseek(fd, -10, SEEK_SET); &#x2F;&#x2F; 错误lseek(fd, 10, SEEK_END); &#x2F;&#x2F; 允许，空洞部分补0 7.标准I/O和系统I/O​ 应用程序———-+​ | |​ v |​ 标准(库)I/O | fopen/fwrite/fclose |​ | |​ v |​ 系统(库)I/O | open/write/close &lt;–+代码：stdio.c、sysio.c标准库通过缓冲区优化，减少系统调用的次数，降低在用户态和内核态之间来回切换的频率，提高运行速度，缩短运行时间。 8.复制文件描述符(表项)进程表项​ …​ 文件描述符表​ |文件描述符标志 | 文件表项指针 | 0​ |文件描述符标志 | 文件表项指针 | 1​ |文件描述符标志 | 文件表项指针 | 2int fd = open(…); // fd: 3进程表项​ …​ 文件描述符表​ |文件描述符标志 | 文件表项指针 | 0​ |文件描述符标志 | 文件表项指针 | 1​ |文件描述符标志 | 文件表项指针 | 2​ |文件描述符标志 | 文件表项指针 | 3 -&gt; 文件表项文件表项：包含文件状态标志、文件读写位置、v节点指针 123456int dup(int oldfd);成功返回目标文件描述符，失败返回-1。oldfd - 源文件描述符int fd2 &#x3D; dup(fd); &#x2F;&#x2F; fd2: 7close(fd);close(fd2); dup函数将oldfd参数所对应的文件描述符表项复制到文件描述符表第一个空闲项中，同时返回该表 项所对应的文件描述符。 进程表项 … 文件描述符表 |文件描述符标志 | 文件表项指针 | 0 |文件描述符标志 | 文件表项指针 | 1 |文件描述符标志 | 文件表项指针 | 2 |文件描述符标志 | 文件表项指针 | 3-&gt;文件表项-&gt;v节点 … ^ |文件描述符标志 | 文件表项指针 | 7 ——–+fd2(7)和fd(3)对应同一个文件表项，访问同一个文件。 1234int dup2(int oldfd, int newfd);成功返回目标文件描述符，失败返回-1。oldfd - 源文件描述符newfd - 目标文件描述符 dup2函数在复制oldfd参数所标识的源文件描述符表项时，会首先检查由newfd参数所标识的目标文件描述符表项是否空闲，若空闲则直接将前者复制给后者，否则会先将目标文件描述符newfd关闭，再行复制。fd1 = open(“1.txt”, …); –&gt; 文件表项 &gt; v节点(仅仅是v节点相同)fd2 = open(“1.txt”, …); –&gt; 文件表项 / fd1 = open(“2.txt”, …); &gt; 文件表项(文件状态标志、文件读写位置、v节点指针都相同) -&gt; v节点fd2 = dup(fd1); /代码：dup.c same.c 9.文件控制1int fcntl(int fd, int cmd, ...); 1、复制文件描述符(表项)1234int fcntl(int oldfd, F_DUPFD, int newfd);成功返回目标文件描述符，失败返回-1。oldfd - 源文件描述符newfd - 目标文件描述符 该函数类似dup2函数，但略有不同。如果newfd处于打开状态，该函数并不会象dup2函数那样关闭它，而是另外寻找一个比它大的最小的空闲文件描述符作为复制目标。 2、获取/设置文件描述符标志截止目前只有一个文件描述符标志位：FD_CLOEXEC一个进程可以通过exec函数族启动另一个进程取代其自身。原进程中无FD_CLOEXEC标志位的文件描述符在新进程中会依然保持打开状态，这也是文件描述符的默认状态。如果原进程中的某个文件描述符带有此标志位，那么在新进程中该文件描述符会被关闭。 123456&#x2F;&#x2F; 获取文件描述符标志int fcntl(int fd, F_GETFD);成功返回文件描述符标志，失败返回-1。&#x2F;&#x2F; 设置文件描述符标志int fcntl(int fd, F_SETFD, int flags);成功返回0，失败返回-1。 3、获取/追加文件状态标志1234&#x2F;&#x2F; 获取文件状态标志int fcntl(int fd, F_GETFL);成功返回文件状态标志，失败返回-1。与文件创建有关的三个状态标志： O_CREAT(创建)&#x2F;O_EXCL(排他)&#x2F;O_TRUC(清空)，无法被获取。 只读标志O_RDONLY的值为0，不能与位与检测。 12345678int flags &#x3D; fcntl(fd, F_GETFL);if ((flags &amp; O_ACCMODE) &#x3D;&#x3D; O_RDONLY)&#x2F;&#x2F;只读标志O_RDONLY判断方式 &#x2F;&#x2F; 只读文件if (flags &amp; O_WRONLY) &#x2F;&#x2F; 只写文件if (flags &amp; O_RDWR) &#x2F;&#x2F; 读写文件... 1234&#x2F;&#x2F; 追加文件状态标志int fcntl(int fd, F_SETFL, flags);成功返回0，失败返回-1。只有O_APPEND(追加)和O_NONBLOCK(非阻塞)两个状态标志可被追加。 代码：fl.c 10.文件锁为了避免在读写同一个文件的同一个区域时发生冲突，进程之间应该遵循以下规则：1、如果一个进程正在写，那么其它进程既不能写也不能读。2、如果一个进程正在读，那么其它进程不能写但是可以读。3、读共享，写独占。 为了避免多个进程在读写同一个文件的同一个区域时发生冲突，操作系统引入了文件锁机制，并把文件锁分读锁和写锁两种，它们区别在于：读锁：共享锁，对一个文件的特定区域可以同时加多个读锁写锁：排它锁，对一个文件的特定区域只能加一把写锁锁模式：加锁-&gt;读写-&gt;解锁 期望的加锁 读锁 写锁文件的某 无任何锁 OK OK个区域正 多把读锁 OK NO在被访问 一把写锁 NO NO 1int fcntl(int fd, F_SETLKW&#x2F;F_SETLK, struct flock* lock); F_SETLKW: 阻塞模式，程序会一直等待。F_SETLK: 非阻塞模式，如果文件被占用直接返回false，errno=EAGAIN或EACCES 1234567struct flock &#123; short int l_type; &#x2F;&#x2F; 锁类型 F_RDLCK&#x2F;F_WRLCK&#x2F;F_UNLCK(解锁) short int l_whence; &#x2F;&#x2F; 锁区偏移起点 SEEK_SET&#x2F;SEEK_CUR&#x2F; SEEK_END off_t l_start; &#x2F;&#x2F; 锁区偏移 off_t l_len; &#x2F;&#x2F; 锁区长度(字节数)，0表示锁到尾 pid_t l_pid; &#x2F;&#x2F; 加锁进程PID，-1表示自动设置&#125;; 12345678对相对于文件头10字节开始的20字节以阻塞模式加读锁。struct flock lock;lock.l_type &#x3D; F_RDLCK;lock.l_whence &#x3D; SEEK_SET;lock.l_start &#x3D; 10;lock.l_len &#x3D; 20;lock.l_pid &#x3D; -1;fcntl(fd, F_SETLKW, &amp;lock); 12345678对相对于当前位置10字节开始到文件尾以非阻塞方式加写锁。struct flock lock;lock.l_type &#x3D; F_WRLCK;lock.l_whence &#x3D; SEEK_CUR;lock.l_start &#x3D; 10;lock.l_len &#x3D; 0;lock.l_pid &#x3D; -1;fcntl(fd, F_SETLK, &amp;lock); 12345678对整个文件解锁。struct flock lock;lock.l_type &#x3D; F_UNLCK;lock.l_whence &#x3D; SEEK_SET;lock.l_start &#x3D; 0;lock.l_len &#x3D; 0;lock.l_pid &#x3D; -1;fcntl(fd, F_SETLK, &amp;lock); 测试对文件的某个区域是否可以加某种锁，如果不能加锁，是什么原因导致加锁冲突？ 12int fcntl(int fd, F_GETLK, struct flock* lock);成功返回0，失败返回-1。 调用该函数时，lock参数表示欲加之锁的细节。函数成功返回时，通过lock参数输出欲加之锁是否可加，以及存在冲突的锁信息。v节点 i节点内容 锁表指针-&gt;锁节点-&gt;锁节点-&gt;… … 锁的类型 锁区偏移 锁区大小 加锁进程的PID 每次对给定文件的特定区域加锁，都会通过fcntl函数向系统内核传递flock结构，该结构中包含了有关锁的一些细节，诸如锁的类型、锁区的起始位置和大小，甚至加锁进程的PID(填-1由系统自动设置)。系统内核会收集所有进程对该文件所加的各种锁，并把这些flock结构中的信息，以链表的形式组织成一张锁表，其起始地址就保存在该文件的v节点中。任何一个进程通过fcntl函数对该文件加锁，系统内核都要遍历这张锁表，一旦发现有与欲加之锁构成冲突的锁即阻塞或报错，否则即将欲加之锁插入锁表，而解锁的过程实际上就是调整或删除锁表中的相应节点。文件锁属于劝谏锁，亦称协议锁，不是强制锁，自觉遵守才有用。 11.文件元数据i节点 文件元数据 数据块索引表 12345678910111213141516文件元数据结构体stat：struct stat &#123; dev_t st_dev; &#x2F;&#x2F; 设备ID ino_t st_ino; &#x2F;&#x2F; i节点号 mode_t st_mode; &#x2F;&#x2F; 文件类型和权限 nlink_t st_nlink; &#x2F;&#x2F; 硬链接数 uid_t st_uid; &#x2F;&#x2F; 用户ID gid_t st_gid; &#x2F;&#x2F; 组ID dev_t st_rdev; &#x2F;&#x2F; 特殊设备ID off_t st_size; &#x2F;&#x2F; 总字节数 blksize_t st_blksize; &#x2F;&#x2F; I&#x2F;O块字节数 blkcnt_t st_blocks; &#x2F;&#x2F; 块数 time_t st_atime; &#x2F;&#x2F; 最后访问时间 time_t st_mtime; &#x2F;&#x2F; 最后修改时间 time_t st_ctime; &#x2F;&#x2F; 最后状态改变时间&#125;; 文件类型和权限的数据类型mode_t其实就是一个整数，其中只有低16位有效。B15~B12 - 文件类型，掩码：S_IFMT1000，S_IFREG，普通文件，-0100，S_IFDIR，目录文件，d1100，S_IFSOCK，本地套接字文件，s0010，S_IFCHR，字符设备文件，c0110，S_IFBLK，块设备文件，b1010，S_IFLNK，符号链接文件，l0001，S_IFFIFO，有名管道文件，p B11~B9 - 设置用户ID位、设置组ID位和粘滞位带有设置用户ID位(即B11位为1)的可执行文件(如：/usr/bin/passwd)：系统中的每个进程其实都有两个用户ID，一个叫实际用户ID，取决于运行该进程的登录用户，另一个叫有效用户ID。一般情况下，进程的有效用户ID就取自其实际用户ID。但是如果产生该进程的可执行文件带有设置用户ID位(即B11位为1)，那么该进程的有效用户ID就不再取自实际用户ID，而是取自该可执行文件的拥有者用户ID。进程对系统资源的权限判定是根据其有效用户ID做出的，因此通过这种方法，就可以提升普通用户执行进程的权限，完成本来只有高权限用户才能完成的任务，即有限提权。带有设置组ID位(即B10位为1)的可执行文件：设置组ID位(B10)的情况与上述类似，只是针对进程的有效组ID而已。带有设置用户ID位的不可执行文件：毫无意义。带有设置组ID位的不可执行文件：某些系统用这种无意义的状态作为强制锁标志。带有粘滞位(B9位为1)的目录：除root以外的任何用户在该目录下，都只能删除或更名那些属于自己的文件或子目录，而对于其它用户的文件或子目录，既不能删除也不能改名。如：/tmp拥有者用户 拥有者组 其它用户B8B7B6 B5B4B3 B2B1B0 | | | | | | | | |读 写 执行 读 写 执行 读 写 执行 拥有者用户 拥有者组 其它用户C1 C2 C3 C4 C5 C6 C7 C8 C9-/r -/w -/x -/r -/w -/x -/r -/w -/x设置用户ID位 设置组ID位 粘滞位 S/s S/s T/t 12345678#include &lt;sys&#x2F;stat.h&gt;int stat(char const* path, struct stat* buf);&#x2F;&#x2F;获取文件信息，跟踪符号链接int fstat(int fd, struct stat* buf);&#x2F;&#x2F;跟踪符号链接int lstat(char const* path, struct stat* buf); &#x2F;&#x2F; 不跟踪符号链接成功返回0，失败返回-1。path - 文件路径buf - 文件元数据结构fd - 文件描述符 12.访问测试12345678int access(const char* pathname, int mode);成功返回0，失败返回-1。pathname - 文件路径mode - 访问权限，可取以下值： R_OK: 可读否 W_OK: 可写否 X_OK: 可执行否 F_OK: 存在否 根据调用该函数的进程的实际用户ID和实际组ID，检测其是否可读、可写或可执行给定的文件，也可检测该文件是否存在。 13.权限掩码1234#include &lt;sys&#x2F;stat.h&gt;mode_t umask(mode_t cmask);永远成功，返回原来的权限掩码。cmask - 新权限掩码 权限掩码是进程的属性之一，存储在系统内核中的进程表项里。umask函数所影响的仅仅是调用进程自己，对于其它进程，包括其父进程，如Shell，都没有任何影响。 14.修改权限1234567#include &lt;sys&#x2F;stat.h&gt;int chmod(const char* pathname, mode_t mode);int fchmod(int fd, mode_t mode);成功返回0，失败返回-1。pathname - 文件路径mode - 文件权限fd - 文件描述符 调用进程的有效用户ID必须与文件的拥有者用户ID匹配，或者是root用户，才能修改该文件的权限，且受权限掩码的影响。 15.修改文件的拥有者和(或)拥有者组123456789#include &lt;unistd.h&gt;int chown(const char* path, uid_t owner, gid_t group);int fchown(int fd, uid_t owner, gid_t group);int lchown(const char* path, uid_t owner, gid_t group); &#x2F;&#x2F; 不跟踪符号链接成功返回0，失败返回-1。path - 文件路径owner - 拥有者用户ID，-1表示不修改group - 拥有者组ID，-1表示不修改fd - 文件描述符 如果调用进程的有效用户ID为root用户，则它可以任意修改任何文件的拥有者用户和组。如果调用进程的有效用户ID为普通用户，则它只能把自己名下文件的拥有者组改成自己隶属的其它组。 16.修改文件大小123456789#include &lt;unistd.h&gt;int truncate(const char* path, off_t length);int ftruncate(int fd, off_t length);成功返回0，失败返回-1。path - 文件路径fd - 文件描述符length - 文件大小 大-&gt;小：截掉靠文件尾的部分。 小-&gt;大：在文件尾之后增加0。 17.硬链接硬链接就是文件路径，即由各级目录、分隔符(/)和文件名共同组成的字符串，与一个特定的i节点号所形成的对应关系。 12&#x2F;&#x2F;shell中创建硬链接命令ln &lt;目标路径(已经存在的路径)&gt; &lt;源路径(新建立的路径)&gt; 根据一个已有的硬链接创建一个新的硬链接 12345int link(const char* oldpath, const char* newpath);成功返回0，失败返回-1。oldpath - 已有的硬链接路径newpath - 新的硬链接路径oldpath必须存在，newpath中不能包含不存在目录。 删除硬链接 123int unlink(const char* pathname);成功返回0，失败返回-1。pathname - 文件路径(不能是目录) 从pathname所对应的目录文件中删除包含该文件的条目，同时将其对应的i节点中的硬链接数减一，若该硬链接数被减至0，则将该文件所占用的磁盘空间释放出来。 修改硬链接 1234567int rename(const char* oldpath, const char* newpath);成功返回0，失败返回-1。oldpath - 原路径newpath - 新路径rename(&quot;.&#x2F;a.txt&quot;, &quot;.&#x2F;b.txt&quot;); &#x2F;&#x2F; 改名rename(&quot;a&#x2F;1.txt&quot;, &quot;b&#x2F;1.txt&quot;); &#x2F;&#x2F; 移动rename(&quot;a&#x2F;1.txt&quot;, &quot;b&#x2F;2.txt&quot;); &#x2F;&#x2F; 移动且改名 另一个版本的unlink，还可以删除空目录的硬链接： 1int remove(const char* pathname); 18.软链接软链接文件的本质就是保存着另一个文件或目录的路径的文件。根据一个已有的硬链接创建一个符号链接 1234int symlink(const char* oldpath, const char* newpath);成功返回0，失败返回-1。oldpath - 原有路径，可以是文件，也可以是目录，甚至可以不存在newpath - 新建路径，不能包含不存在目录 读取软链接文件本身的内容 12345ssize_t readlink(const char* path, char* buf, size_t size);成功返回拷入buf的符号链接文件内容的字节数，失败返回-1。path - 软链接文件路径buf - 缓冲区size - 缓冲区大小 19.目录创建一个空目录 12345#include &lt;sys&#x2F;stat.h&gt;int mkdir(const char* pathname, mode_t model);成功返回0，失败返回-1。pathname - 目录路径mode - 访问权限，目录的执行权限(x)表示可以进入 删除一个空目录 123456int rmdir(const char* pathname);成功返回0，失败返回-1。pathname - 目录路径int remove(const char* pathname);remove &#x3D; unlink + rmdir 获取当前工作目录char* getcwd(char* buf, size_t size);成功返回工作目录字符串指针，即buf，失败返回NULL。buf - 缓冲区size - 缓冲区大小自动追加结尾空字符。当前工作目录作为进程的属性之一，也是系统内核进程表项的一部分。 改变当前工作目录 12int chdir(const char* path);成功返回0，失败返回-1。 打开目录 12DIR* opendir(const char*name);成功返回目录流指针，失败返回NULL。 读取目录 12struct dirent* readdir(DIR* dirp);成功返回目录条目指针，读完(不设置errno)或失败(设置errno)返回NULL。 1234567struct dirent &#123; ino_t d_ino; &#x2F;&#x2F; 节点号 off_t d_off; &#x2F;&#x2F; 下一条位置(索引) unsigned short d_reclen; &#x2F;&#x2F; 记录长度 unsigned char d_type; &#x2F;&#x2F; 文件类型 char d_name[]; &#x2F;&#x2F; 文件名&#125;; 关闭目录流 123int closedir(DIR* dirp);成功返回0，失败返回-1。dirp - 目录流指针","link":"","tags":[]},{"title":"UinxC-IO编程1","date":"2021-05-03T02:36:43.000Z","path":"2021/05/03/UinxC-IO编程1/","text":"一、GNU编译器(gcc)1.GCC的基本特点1)支持多种硬件架构 x86-64 AlphaARM…2)支持多种操作系统UnixLinuxAndroidiOSWindows3)支持多种编程语言CC++Objective-CJava4)查看GCC的版本gcc -v 2.构建过程源代码(.c)-预编译-&gt;头文件和宏扩展-编译-&gt;汇编码(.s)-汇编-&gt;目标码(.o)-链接-&gt;可执行代码(a.out) 123456vi hello.c - 编写源代码gcc -E hello.c -o hello.i - 预编译(编译预处理)gcc -S hello.i - 获得汇编代码(hello.s)gcc -c hello.s - 获得目标代码(hello.o)gcc hello.o -o hello - 获得可执行代码(hello).&#x2F;hello - 运行可执行代码 3.文件名后缀.h - C语言源代码头文件 .c - 预处理前的C语言源代码文件 &gt; 可读文本.s - 汇编语言文件 /.o - 目标文件 .a - 静态库文件 &gt; 不可读的二进制.so - 共享(动态)库文件 /.out - 可执行文件 / 4.编译选项gcc [选项] [参数] 文件1 文件2 …-o: 指定输出文件 1如：gcc hello.c -o hello -E: 预编译，缺省输出到屏幕，用-o指定输出文件 1如：gcc -E hello.c -o hello.i -S: 编译，将高级语言文件编译成汇编语言文件 1如：gcc -S hello.c -c: 汇编，将汇编语言文件汇编成机器语言文件 1如：gcc -c hello.s -Wall：产生全部警告 -Werror：将警告作为错误处理 -x: 指定源代码的语言 1234567如：gcc -Wall wall.c如：gcc -Werror werror.cxxx.c - C语言xxx.cpp - C++语言xxx.for - Fortran语言xxx.java - Java语言gcc -x c++ cpp.c -lstdc++ -o cpp -O0/O1/O2/O3: 指定优化等级，O0不优化，缺省O1优化 5.头文件1)头文件里写什么？头文件卫士：防止重定义、 重扩展 1234#ifndef __XXX_#define __XXX_...#endif 宏定义 1#define PI 3.14159 自定义类型 123struct Circle &#123; double x, y, r;&#125;; 类型别名 1typedef struct Circle C; 外部变量声明 1extern double e; 函数声明 1double circleArea(C c); 一个头文件可能会被多个源文件包含，写在头文件里的函数定义也会因此被预处理器扩展到多个包含该头文件的源文件中，并在编译阶段被编译到等多个不同的目标文件中，这将导致链接错误：multiple definition，多重定义。 2)去哪里找头文件？gcc -I&lt;头文件的附加搜索路径&gt;#include &lt;my.h&gt; ：先找-I指定的目录，再找系统目录。#include “my.h” ：先找-I指定的目录，再找当前目录，最后找系统目录。 头文件的系统目录： /usr/include - 标准C库 /usr/local/include - 第三方库 /usr/lib/gcc/i686-linux-gnu/5.4.0/include - 编译器库 6.预处理指令1234567891011121314151617#include - 将指定的文件内容插至此指令处#define - 定义宏#undef - 删除宏#if - 如果#ifdef - 如果宏已定义#ifndef - 如果宏未定义#else - 否则，与#if&#x2F;#ifdef&#x2F;#ifndef配合使用#elif - 否则如果，与#if&#x2F;#ifdef&#x2F;#ifndef配合使用#endif - 结束判定，与#if&#x2F;#ifdef&#x2F;#ifndef配合使用#error - 产生错误，结束预处理#warning - 产生警告，继续预处理#line - 指定行号#pragma - 设定编译器的状态或者指示编译器的操作#pragma GCC dependency +&quot;被依赖文件&quot;——对比被编译文件与被依赖文件的生成时间，如果被依赖文件形成时间晚于被编译文件，则编译过程中提示错误#pragma GCC poison +语法禁忌#pragma pack(按几字节对齐：1&#x2F;2&#x2F;4&#x2F;8)#pragma pack() - 按缺省字节数对齐，取消自定义字节对齐方式，恢复默认字节对齐 7.预定义宏无需自行定义，预处理器会根据事先设定好的规则将这些宏扩展成其对应的值。 123456789__BASE_FILE__: 正在被处理的源文件名__FILE__: __FILE__这个宏所在文件名__LINE__: __LINE__这个宏所在行的行号__FUNCTION__: __FUNCTION__这个宏所在函数的函数名__func__: 同__FUNCTION____DATE__: 处理日期__TIME__: 处理时间__INCLUDE_LEVEL__: __INCLUDE_LEVEL__这个宏所在的被包含层数，从0开始__cplusplus__: C++有定义，C无定义 8.环境变量在进程向下文中保存的一些数据：键(功能，是什么)=值(内容)。env：查看在进程向下文中保存的一些数据和环境变量。 C_INCLUDE_PATH、CPATH：C语言头文件的附加搜索路径，相当于-I选项。 CPLUS_INCLUDE_PATH：C++语言头文件的附加搜索路径，相当于-I选项。 LIBRARY_PATH：链接库路径 LD_LIBRARY_PATH： 加载库路径 #include “/…/…/xxx.h” - 移植性差#include “xxx.h”gcc -I/…/… … - 推荐C_INCLUDE_PATH/CPATH=/…/…:/… - 易冲突 三、库单一模型：将程序中所有功能全部实现于一个单一的源文件内部。编译时间长，不易于维护和升级，不易于协作开发。分离模型：将程序中的不同功能模块划分到不同的源文件中。缩短编译时间，易于维护和升级，易于协作开发。 1.静态库静态库的本质就是将多个目标文件打包成一个文件。链接静态库就是将库中被调用的代码复制到调用模块中。使用静态库的程序通常会占用较大的空间，库中代码一旦修改，所有使用该库的程序必须重新链接。使用静态库的程序在运行无需依赖库，其执行效率高。静态库的形式：libxxx.a构建静态库：.c -&gt; .o -&gt; .aar -r libxxx.a x.o y.o z.o使用静态库：gcc … -lxxx -L&lt;库路径&gt; ——推荐使用或者export LIBRARY_PATH=&lt;库路径&gt;gcc … -lxxx 2.动态(共享)库动态库和静态库最大的不同就是，链接动态库并不需要将库中被调用的代码复制到调用模块中，相反被嵌入到调用模块中的仅仅是被调用代码在动态库中的相对地址。如果动态库中的代码同时为多个进程所用，动态库的实例在整个内存空间中仅需一份，因此动态库也叫共享库或共享对象(Shared Object, so)。使用动态库的模块所占空间较小，即使修改了库中的代码，只要接口保持不变，无需重新链接。使用动态库的代码在运行时需要依赖库，执行效率略低。动态库的形式：libxxx.so构建动态库：gcc -c -fpic xxx.c -&gt; 用于生成xxx.o | 生成位置无关码 库内部的函数调用也用相对地址表示gcc -shared -o libxxx.so x.o y.o z.o -&gt;生成动态库使用动态库：gcc … -lxxx -L&lt;库路径&gt; 或者 export LIBRARY_PATH=&lt;库路径&gt;gcc … -lxxx运行时所调用的动态库必须位于LD_LIBRARY_PATH环境变量所表示的路径中。 gcc缺省链接共享库，可通过-static选项强制链接静态库。 3.动态加载动态库构建动态加载动态库：gcc xxx.c -ldl -o xxx-ldl： 系统提供的针对动态库的动态加载函数集，位于#include &lt;dlfcn.h&gt; 123456void* dlopen(const char* filename, int flag);filename - 动态库路径，若只给文件名，则根据LD_LIBRARY_PATH环境变量搜索动态库flag - 加载方式，可取以下值：RTLD_LAZY - 延迟加载，使用动态中的符号时才加载RTLD_NOW - 立即加载成功返回动态库的句柄，失败返回NULL。 该函数所返回的动态库句柄唯一地标识了系统内核所维护的动态库对象，将作为后续函数调用的参数。 1234void* dlsym(void* handle, const char* symbol);handle - 动态库句柄symbol - 符号(函数或全局变量)名成功返回函数地址，失败返回NULL。 该函数所返回的函数指针是void*类型，需要强制类型转换为实际的函数指针类型才能调用。 12345int dlclose(void* handle);handle - 动态库句柄成功返回0，失败返回非零。char* dlerror(void);之前若有错误发生则返回错误信息字符串，否则返回NULL。 四、辅助工具1.查看符号表：nm——列出目标文件(.o)、可执行文件、静态库文件(.a)或动态库文件(.so)中的符号2.显示二进制模块的反汇编信息：objdump -S3.删除目标文件(.o)、可执行文件、静态库文件(.a)或动态库文件(.so)中的符号表和调试信息：strip4.查看可执行程序文件或动态库文件所依赖的动态库文件：ldd 五、错误号和错误信息1.通过函数的返回值表达错误 返回整数的函数：通过返回合法值域以外的值表示错误 返回指针的函数：通过返回NULL指针表示错误 不需要通过返回值输出信息的函数：返回0表示成功，返回-1表示失败。 2.通过错误号和错误信息表示产生错误的具体原因 #include &lt;errno.h&gt;中有全局变量：errno，整数，标识最近一次系统调用的错误 #include &lt;string.h&gt;中有函数char* strerror(int errnum); // 根据错误号(errno)返回错误信息 #include &lt;stdio.h&gt;中有函数void perror(const char* s); // 打印最近错误的错误信息 printf函数的%m标记被替换为最近错误的错误信息 虽然所有的错误号都不是0，但是因为在函数执行成功的情况下错误号全局变量errno不会被清0，因此不能用errno是否为0作为函数成功失败的判断条件，是否出错还是应该根据函数的返回值来决定。 3.常见处理错误方式： 12345返回值 &#x3D; 函数调用(...);if (返回值表示函数调用失败) &#123; 根据errno判断发生了什么错误 针对不同的错误提供不同的处理&#125; 六、环境变量每个进程都有一张独立的环境变量表，其中的每个条目都是一个形如“键=值”形式的环境变量。env：查看系统当前环境变量的命令全局变量：environ，需要自己在代码做外部声明。environ-&gt;| * |-&gt;AAA=aaa\\0 | * |-&gt;BBB=bbb\\0 | * |-&gt;CCC=ccc\\0 |NULL|所谓环境变量表就是一个以NULL指针结束的字符指针数组char *arr[]，其中的每个元素都是一个字符指针，指向一个以空字符结尾的字符串，该字符串就是形如”键=值”形式的环境变量。类似mian函数的第二个参数char *argv[]，mian函数的三个参数char *envp[]就是环境变量表。 123456789101112131415161718192021char *getenv(char const* name);&#x2F;&#x2F;根据环境变量名获取其值成功返回变量名匹配的变量值，即等号右边的部分，失败返回NULL。name - 环境变量名，即等号左边的部分int putenv(char* string);&#x2F;&#x2F;添加或修改环境变量成功返回0，失败返回-1。string - 形如“键&#x3D;值”形式的环境变量字符串若其键已存在，则修改其中，若其键不存在，则添加新变量int setenv(const char* name, const char* value, int overwrite);&#x2F;&#x2F;添加或修改环境变量成功返回0，失败返回-1。name - 环境变量名，即等号左边的部分value - 环境变量值，即等号右边的部分overwrite - 当name参数所表示的环境变量名已存在，此参数取0则保持该变量的原值不变，若此参数取非0，则将该变量的值修改为value。int unsetenv(const char* name);&#x2F;&#x2F;删除环境变量成功返回0，失败返回-1。name - 环境变量名，即等号左边的部分int clearenv(void);&#x2F;&#x2F;清空环境变量成功返回0，失败返回-1。 七、内存1.虚拟内存、物理内存、半导体内存和换页文件虚拟内存：地址空间，虚拟的存储区域，应用程序所访问的都是虚拟内存。物理内存：存储空间，实际的存储区域，只有系统内核可以访问物理内存。虚拟内存和物理内存之间存在对应关系，当应用程序访问虚拟内存时，系统内核会依据这种对应关系找到与之相应的物理内存。上述对应关系存储在内核中的内存映射表中。物理内存包括半导体内存和换页文件两部分。当半导体内存不够用时，可以把一些长期闲置的代码和数据从半导体内存中缓存到换页文件中，这叫页面换出(1页=4096字节)，一旦需要使用被换出的代码和数据，再把它们从换页文件恢复到半导体内存中，这叫页面换入。因此，系统中的虚拟内存比半导体内存大得多。 2.进程映射(Process Maps)每个进程都拥有独立的4G字节的虚拟内存，分别被映射到不同的物理内存区域。内存映射和换入换出都是以页为单位，1页=4096字节。4G虚拟内存中高地址的1G被映射到内核的代码和数据区，这1个G在各个进程间共享。用户的应用程序只能直接访问低地址的3个G虚拟内存，因此该区域被称为用户空间，而高地址的1个G虚拟内存则被称为内核空间。用户空间中的代码只能直接访问用户空间的数据，如果要想访问内核空间中的代码和数据必须借助专门的系统调用完成。 用户空间的3G虚拟内存可以进一步被划分为如下区域： 通过size命令查看一个可执行程序的代码区、数据区和BSS区的大小。每个进程的用户空间都拥有独立的从虚拟内存到物理内存的映射，谓之进程间的内存壁垒。 3.内存的分配与释放malloc/calloc/realloc/free |调用 v brk/sbrk：以增加方式分配或释放虚拟内存 |调用 v mmap/munmap：建立虚拟内存到物理内存或文件的映射 |调用 v kmalloc/kfree brk/sbrk：以增加方式分配或释放虚拟内存 分配 = 映射+占有 映射：在地址空间(虚拟内存)和存储空间(物理内存)之间建立映射关系 占有：指定内存空间的归属性 释放 = 放弃占有+解除映射 放弃占有：解除对内存空间的归属约束 解除映射：消除地址空间(虚拟内存)和存储空间(物理内存)之间的映射关系 1234567void* sbrk(intptr_t increment);//以增加方式分配或释放虚拟内存，推荐在分配内存时使用成功返回调用该函数之前的堆顶指针，失败返回-1。increment： 0 - 堆顶指针上移，增大堆空间，分配虚拟内存 &lt;0 - 堆顶指针下移，缩小堆空间，释放虚拟内存 =0 - 不分配也不释放虚拟内存，仅仅返回当前堆顶指针//sbrk(0);返回当前堆顶 系统内核维护一个指针，指向堆内存的顶端(有效堆内存中最后一个字节的下一个位置)。sbrk函数根据增量参数increment调整该指针的位置，同时返回该指针原来的位置，期间若发生内存耗尽或空闲，则自动追加或取消相应内存页的映射。 123456int brk(void* end_data_segment);&#x2F;&#x2F;以绝对地址的方式分配或释放虚拟内存，推荐在释放内存时使用成功返回0，失败返回-1。end_data_segment: &gt;当前堆顶，分配虚拟内存 &lt;当前堆顶，释放虚拟内存 &#x3D;当前堆顶，空操作 系统内核维护一个指针，指向当前堆顶，brk函数根据指针参数end_data_segment设置堆顶的新位置，期间若发生内存耗尽或空闲，则自动追加或取消相应内存页的映射。 mmap/munmap：建立虚拟内存到物理内存或文件的映射 1234567891011121314151617181920建立虚拟内存到物理内存或文件的映射:void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset);成功返回映射区虚拟内存的起始地址，失败返回MAP_FAILED(void*类型的-1)。start - 映射区虚拟内存的起始地址，NULL表示自动选择length - 映射区的字节数，自动按页取整prot - 访问权限，可取以下值： PROT_READ - 可读 PROT_WRITE - 可写 PROT_EXEC - 可执行 PROT_NONE - 不可访问flags - 映射标志，可取以下值： MAP_ANONYMOUS - 匿名映射，将虚拟内存映射到物理内存，函数的最后两个参数fd和offset被忽略 MAP_PRIVATE - 私有映射，将虚拟内存映射到文件的内存缓冲区中而非磁盘文件 MAP_SHARED - 共享映射，将虚拟内存映射到磁盘文件中 MAP_DENYWRITE - 拒写映射，文件中被映射区域不能存在其它写入操作 MAP_FIXED - 固定映射，若在start上无法创建映射，则失败(无此标志系统会自动调整) MAP_LOCKED - 锁定映射，禁止被换出到换页文件fd - 文件描述符offset - 文件偏移量，自动按页对齐 12345解除虚拟内存到物理内存或文件的映射:int munmap(void* start, size_t length);&#x2F;&#x2F;解除虚拟内存到物理内存或文件的映射成功返回0，失败返回-1。start - 映射区的起始地址length - 映射区的字节数 八、系统调用​ 应用程序————–+ vi/emacs/gftp/firefox |​ | |​ 标准库、第三方库 |​ C/C++/Qt/X11 |​ | |​ 系统调用&lt;————+brk/sbrk/mmap/munmap 1.Linux系统内核提供了一套用于实现各种系统功能的子程序，谓之系统调用。程序编写者可以象调用普通C语言函数一样调用这些系统调用函数，以访问系统内核提供的各种服务。2.系统调用函数在形式上与普通C语言函数并无差别。二者的不同之处在于，前者工作在内核态，而后者工作在用户态。3.在Intel的CPU上运行代码分为四个安全级别：Ring0、Ring1、Ring2和Ring3。Linux系统只使用了Ring0和Ring3。用户代码工作在Ring3级，而内核代码工作在Ring0级。一般而言用户代码无法访问Ring0级的资源，除非借助系统调用，使用户代码得以进入Ring0级，使用系统内核提供的功能。4.系统内核内部维护一张全局表sys_call_table，表中的每个条目记录着每个系统调用在内核代码中的实现入口地址。5.当用户代码调用某个系统调用函数时，该函数会先将参数压入堆栈，将系统调用标识存入eax寄存器，然后通过int 80h指令触发80h中断。6.这时程序便从用户态(Ring3)进入内核态(Ring0)。7.工作系统内核中的中断处理函数被调用，80h中断的处理函数名为system_call，该函数先从堆栈中取出参数，再从eax寄存器中取出系统调用标识，然后再从sys_call_table表中找到与该系统调用标识相对应的实现代码入口地址，挈其参数调用该实现，并将处理结果逐层返回到用户代码中。","link":"","tags":[]},{"title":"数据结构与算法","date":"2021-04-18T12:37:24.000Z","path":"2021/04/18/数据结构与算法/","text":"1. 数据结构理论数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集 数据项:一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。（耳、鼻、嘴、手、脚） 数据元素:是组成数据的、有一定意义的基本单位,在计算机中通常作为整体处理。也被称为记录。（人） 数据对象:是性质相同的数据元素的集合,是数据的子集。既然数据对象是数据的子集,在实际应用中,处理的数据元素通常具有相同性质,在不产生混淆的情况下,我们都将数据对象简称为数据。 数据结构是计算机存储、组织数据的方式。是相互之间存在一种或多种特定关系的数据元素集合 算法是特定问题求解步骤的描述，在计算机中表现为指令的有限序列，算法是独立存在的一种解决问题的方法和思想。对于算法而言，语言并不重要，重要的是思想。 算法和数据结构区别 数据结构只是静态的描述了数据元素之间的关系，高效的程序需要在数据结构的基础上设计和选择算法。 算法是为了解决实际问题而设计的。数据结构是算法需要处理的问题载体。数据结构与算法相辅相成 算法的特性 算法具有五个基本的特性：输入、输出、有穷性、确定性和可行性 输入输出：算法具有零个或多个输入、至少有一个或多个输出。 有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。 确定性：算法的每一步骤都有确定的含义，不会出现二义性。 可行性：算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成。 数据结构分类1、逻辑结构集合结构：集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。各个数据元素是平等的。他们共同属于同一个集合， 线性结构：线性结构中的数据元素之间是一对一的关系。（动态数组、链表、栈、队列） 树形结构：树形结构中是数据元素之间存在一种一对多的层次关系， 图形结构： 图形结构的数据元素是多对多的关系 2、物理结构物理结构是指数据的逻辑结构在计算机中的存储形式，共分为两种：顺序存储和链式存储。 顺序存储：是把数据元素存放在地址连续的存储单元里，其数据的逻辑关系和物理关系是一致的， 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据的位置。 线性表线性表是零个或者多个数据元素的有限序列，数据元素之间是有顺序的，数据元素个数有限。通常线性表可以采用顺序存储和链式存储 1、线性表的顺序存储线性表的顺序存储结构,指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。 采用顺序存储是表示线性表最简单的方法，具体做法是：将线性表中的元素一个接一个的存储在一块连续的存储区域中，这种顺序表示的线性表也成为顺序表。 2、线性表的链式存储单链表 静态链表 首先我们让数组的元素都是由两个数据域组成,data和cur。也就是说,数组的每个下标都对应一个data和一个cur。数据域data,用来存放数据元素,也就是通常我们要处理的数据;而游标cur相当于单链表中的next指针,存放该元素的后继在数组中的下标。我们把这种用数组描述的链表叫做静态链表,这种描述方法还有起名叫做游标实现法。 循环链表 将单链表中终端结点的指针端由空指针改为指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表( circular linked list)。 双向链表 双向链表double linked list)是在单链表的每个结点中,再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域,一个指向直接后继,另一个指向直接前驱。 受限线性表栈stack栈的基本特性 具有后进先出的特性(Last In First Out=LIFO) 具有先进后出的特性(First In Last Out=FILO) 栈的操作只能操作栈顶！类比弹匣 入栈又称压栈 出栈又称弹栈 12345typedef struct stack &#123; int *arr; &#x2F;&#x2F;数组的首地址 int cap; &#x2F;&#x2F;栈的容量大小 int top; &#x2F;&#x2F;栈顶&#125;stack_t; 队列queue特性：先进先出(First In First Out=FIFO),取数从队列的开头取,存储从队列尾部存 第一个元素又称首元素,最后一个元素又称尾元素 1234567typedef struct queue &#123; int *arr; &#x2F;&#x2F;首地址 int cap; &#x2F;&#x2F;容量 int size; &#x2F;&#x2F;有效数据的个数 int front; &#x2F;&#x2F;前端(出队) int rear; &#x2F;&#x2F;后端(入队)&#125;queue_t; 链表list单链表特点：体现一对一的前后关系 1234567891011&#x2F;&#x2F;声明描述每个节点信息的数据结构typedef struct node &#123; int data; &#x2F;&#x2F;数据 struct node *next; &#x2F;&#x2F;保存下一个节点的首地址&#125;node_t;&#x2F;&#x2F;声明描述整个单链表的数据结构typedef struct list &#123; struct node *head; &#x2F;&#x2F;指向头节点 struct node *tail; &#x2F;&#x2F;指向尾节点&#125;list_t; ​ 注意：每个节点的内存不一定连续,不像数组一样连续 双链表 一个有序的结点序列，每个链表元素既有指向下一个元素的指针，又有指向前一个元素的指针，其中每个结点都有两种指针，即front和tail，front指针指向左边结点，tail指针指向右边结点 123456789101112&#x2F;*声明描述节点信息的结构体*&#x2F;typedef struct node &#123; int data; &#x2F;&#x2F;数据 struct node *next; &#x2F;&#x2F;指向下一个节点 struct node *prev; &#x2F;&#x2F;指向上一个节点&#125;node_t;&#x2F;*声明描述整个链表的结构体*&#x2F;typedef struct list &#123; struct node head; &#x2F;&#x2F;头节点 struct node tail; &#x2F;&#x2F;尾节点&#125;list_t; 循环链表指的是在单向链表和双向链表的基础上，将两种链表的最后一个结点指向第一个结点从而实现循环 树tree二叉树二叉树是一种特殊的树 1.每个节点最多有两个子节点(可以没有,可以有一个) 2.单根,每个子节点有且仅有一个父节点,整棵树只有一个根节点 左子树：根节点左边的子树 右子树：根节点右边的子树 3.一般用递归函数来处理 二叉查找树(有序二叉树)有序二叉树定义：一般来说,当左子树不为空时,左子树的元素值小于根节点 当右子树不为空时,右子树的元素值大于根节点 三种遍历方式： 先序遍历(又称前序遍历):处理节点自己的数据-&gt;处理左节点-&gt;处理右节点 中序遍历(重点):处理左节点-&gt;处理节点自己的数据-&gt;处理右节点 后序遍历:处理左节点-&gt;处理右节点-&gt;处理节点自己的数据 123456789101112&#x2F;&#x2F;声明描述节点的数据结构typedef struct node &#123; int data; &#x2F;&#x2F;数据 struct node *left; &#x2F;&#x2F;左子树地址 struct node *right; &#x2F;&#x2F;右子树地址&#125;node_t;&#x2F;&#x2F;声明描述整颗树的数据结构、typedef struct tree &#123; node_t *root; &#x2F;&#x2F;根节点地址 int cnt; &#x2F;&#x2F;节点个数&#125;tree_t;","link":"","tags":[]},{"title":"Linux驱动-电容触摸屏驱动","date":"2021-04-18T02:57:18.000Z","path":"2021/04/18/Linux驱动-电容触摸屏驱动/","text":"①、电容触摸屏是 IIC 接口的，需要触摸 IC，所谓的电容触摸驱动就是 IIC 设备驱动。②、触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息。③、电容触摸屏得到的是触摸位置绝对信息以及触摸屏是否有按下。④、电容触摸屏不需要校准， 电容触摸屏驱动其实就是以下几种 linux 驱动框架的组合：①、IIC 设备驱动，因为电容触摸 IC 基本都是 IIC 接口的，因此大框架就是 IIC 设备驱动。②、通过中断引脚(INT)向 linux 内核上报触摸信息，因此需要用到 linux 中断驱动框架。坐标的上报在中断服务函数中完成。③、触摸屏的坐标信息、屏幕按下和抬起信息都属于 linux 的 input 子系统，因此向 linux 内核上报触摸屏坐标信息就得使用 input 子系统。只是，我们得按照 linux 内核规定的规则来上报坐标信息。 多点触摸(MT)协议详解多点电容触摸的(Multi-touch，简称 MT)，MT 协议被分为两种类型，TypeA 和 TypeB，这两种类型的区别如下：TypeA：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少！)。 Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个触摸点的信息，FT5426 就属于此类型，一般的多点电容触摸屏 IC 都有此能力。 触摸点的信息通过一系列的 ABS_MT 事件(有的资料也叫消息)上报给 linux 内核，只有ABS_MT 事件是用于多点触摸的，ABS_MT 事件定义在文件 linux/input.h 中， 在 众 多 的 ABS_MT 事 件 中 ， 我 们 最 常 用 的 就 是 ABS_MT_SLOT 、ABS_MT_POSITION_X 、ABS_MT_POSITION_Y 和 ABS_MT_TRACKING_ID 。其中ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y 用 来 上报 触 摸点 的 (X,Y) 坐 标 信息 ，ABS_MT_SLOT 用 来 上 报 触 摸 点 ID ，对于 Type B 类 型 的 设 备 ， 需 要 用 到ABS_MT_TRACKING_ID 事件来区分触摸点。 对于 Type B 类型的设备，上报触摸点信息的时候需要通过 input_mt_slot()函数区分是哪一个触摸点 1void input_mt_slot(struct input_dev *dev, int slot) 第一个参数是 input_dev 设备，第二个参数 slot 用于指定当前上报的是哪个触摸点信息。input_mt_slot()函数会触发 ABS_MT_SLOT 事件，此事件会告诉接收者当前正在更新的是哪个触摸点(slot)的数据。 不管是哪个类型的设备，最终都要调用 input_sync()函数来标识多点触摸信息传输完成，告诉接收者处理之前累计的所有消息，并且准备好下一次接收。 Type B 和 Type A 相比最大的区别就是 Type B 可以区分出触摸点， 因此可以减少发送到用户空间的数据。 对于 TypeA 设备，内核驱动需要一次性将触摸屏上所有的触摸点信息全部上报，每个触摸点的信息在本次上报事件流中的顺序不重要，因为事件的过滤和手指(触摸点)跟踪是在内核空间处理的。 Type B 使用 slot 协议区分具体的触摸点，slot 需要用到 ABS_MT_TRACKING_ID 消息，这个 ID 需要硬件提供，或者通过原始数据计算出来。Type B 设备驱动需要给每个识别出来的触摸点分配一个 slot，后面使用这个 slot 来上报触摸点信息。可以通过 slot 的 ABS_MT_TRACKING_ID 来新增、替换或删除触摸点。一个非负数 的 ID 表示一个有效的触摸点，-1 这个 ID 表示未使用 slot。一个以前不存在的 ID 表示这是一个新加的触摸点，一个 ID 如果再也不存在了就表示删除了。 Type B 触摸点信息上报时序对于 Type B 类型的设备，发送触摸点信息的时序如下所示，这里以 2 个触摸点为例： 12345678910111213ABS_MT_SLOT 0 ABS_MT_TRACKING_ID 45ABS_MT_POSITION_X x[0] ABS_MT_POSITION_Y y[0] ABS_MT_SLOT 1 ABS_MT_TRACKING_ID 46ABS_MT_POSITION_X x[1] ABS_MT_POSITION_Y y[1] SYN_REPORTABS_MT_TRACKING_ID -1 SYN_REPORT 第 1 行，上报 ABS_MT_SLOT 事件，也就是触摸点对应的 SLOT。每次上报一个触摸点坐 标之前要先使用input_mt_slot函数上报当前触摸点SLOT，触摸点的SLOT其实就是触摸点ID， 需要由触摸 IC 提供。 第 2 行，根据 Type B 的要求，每个 SLOT 必须关联一个 ABS_MT_TRACKING_ID，通过 修改 SLOT 关联的 ABS_MT_TRACKING_ID 来完成对触摸点的添加、替换或删除。具体用到 的函数就是 input_mt_report_slot_state，如果是添加一个新的触摸点，那么此函数的第三个参数 active 要设置为 true，linux 内核会自动分配一个 ABS_MT_TRACKING_ID 值，不需要用户去指 定具体的 ABS_MT_TRACKING_ID 值。 第 3 行，上报触摸点 0 的 X 轴坐标，使用函数 input_report_abs 来完成。 第 4 行，上报触摸点 0 的 Y 轴坐标，使用函数 input_report_abs 来完成。 第 58 行，和第 14 行类似，只是换成了上报触摸点 0 的(X,Y)坐标信息 第 9 行，当所有的触摸点坐标都上传完毕以后就得发送 SYN_REPORT 事件，使用 input_sync 函数来完成。 第 11行，当一个触摸点(SLOT)移除以后，需要通过 ABS_MT_TRACKING_ID 事件发送一 个-1 给内核。方法很简单，同样使用 input_mt_report_slot_state 函数来完成，只需要将此函数的第三个参数 active 设置为 false 即可，不需要用户手动去设置-1。 第 12 行，当所有的触摸点坐标都上传完毕以后就得发送 SYN_REPORT 事件 多点触摸所使用到的 API 函数1、input_mt_init_slots 函数input_mt_init_slots 函数用于初始化 MT 的输入 slots，编写 MT 驱动的时候必须先调用此函数初始化 slots，此函数定义在文件 drivers/input/input-mt.c 中，函数原型如下所示： 123456int input_mt_init_slots( struct input_dev *dev, unsigned int num_slots, unsigned int flags)&#x2F;&#x2F;dev： MT 设备对应的 input_dev，因为 MT 设备隶属于 input_dev。&#x2F;&#x2F;num_slots：设备要使用的 SLOT 数量，也就是触摸点的数量。&#x2F;&#x2F;flags：其他一些 flags 信息，可以采用‘|’运算来同时设置多个 flags 标识。&#x2F;&#x2F;返回值：0，成功；负值，失败。 flags：其他一些 flags 信息，可设置的 flags 如下所示：可以采用‘|’运算来同时设置多个 flags 标识。 12345#define INPUT_MT_POINTER 0x0001 &#x2F;* pointer device, e.g. trackpad *&#x2F;#define INPUT_MT_DIRECT 0x0002 &#x2F;* direct device, e.g. touchscreen *&#x2F;#define INPUT_MT_DROP_UNUSED0x0004 &#x2F;* drop contacts not seen in frame *&#x2F;#define INPUT_MT_TRACK 0x0008 &#x2F;* use in-kernel tracking *&#x2F;#define INPUT_MT_SEMI_MT 0x0010 &#x2F;* semi-mt device, finger count handled manually *&#x2F; 2、input_mt_slot 函数此函数用于 Type B 类型，此函数用于产生 ABS_MT_SLOT 事件，告诉内核当前上报的是哪个触摸点的坐标数据，此函数定义在文件 include/linux/input/mt.h 中，函数原型如下所示： 1234void input_mt_slot(struct input_dev *dev, int slot)&#x2F;&#x2F;dev： MT 设备对应的 input_dev。&#x2F;&#x2F;slot：当前发送的是哪个 slot 的坐标信息，也就是哪个触摸点。&#x2F;&#x2F;返回值：无。 3、input_mt_report_slot_state 函数此函数用于 Type B 类型，用于产生 ABS_MT_TRACKING_ID 和 ABS_MT_TOOL_TYPE事件， ABS_MT_TRACKING_ID 事 件 给 slot 关联一个 ABS_MT_TRACKING_ID ，ABS_MT_TOOL_TYPE 事 件 指 定 触 摸 类 型 （ 是 笔 还 是 手 指 等 ）。 此 函 数 定 义 在 文 件drivers/input/input-mt.c 中，此函数原型如下所示： 123456void input_mt_report_slot_state( struct input_dev *dev, unsigned int tool_type, bool active)&#x2F;&#x2F;dev： MT 设备对应的 input_dev。&#x2F;&#x2F;tool_type：触摸类型，可以选择 MT_TOOL_FINGER(手指)、MT_TOOL_PEN(笔)或MT_TOOL_PALM(手掌)，&#x2F;&#x2F;active：true，连续触摸，input 子系统内核会自动分配一个 ABS_MT_TRACKING_ID 给 slot。false，触摸点抬起，表示某个触摸点无效了，input 子系统内核会分配一个-1 给 slot，表示触摸点溢出。&#x2F;&#x2F;返回值：无。 4、input_report_abs 函数TypeA 和 Type B 类型都使用此函数上报触摸点坐标信息，通过 ABS_MT_POSITION_X 和ABS_MT_POSITION_Y 事 件 实 现 X 和 Y 轴 坐 标 信 息 上 报 。 此 函 数 定 义 在 文 件include/linux/input.h 中，函数原型如下所示： 12345void input_report_abs( struct input_dev *dev, unsigned int code, int value)&#x2F;&#x2F;dev： MT 设备对应的 input_dev。&#x2F;&#x2F;code：要上报的是什么数据，可以设置为 ABS_MT_POSITION_X 或 ABS_MT_POSITION_Y，也就是 X 轴或者 Y 轴坐标数据。&#x2F;&#x2F;value：具体的 X 轴或 Y 轴坐标数据值。&#x2F;&#x2F;返回值：无。 5、input_mt_report_pointer_emulation 函数如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 BTN_TOOL_TAP 事件来通知用户空间当前追踪到的触摸点总数量，然后调用 input_mt_report_pointer_emulation 函数将use_count 参数设置为 false。否则的话将 use_count 参数设置为 true，表示当前的触摸点数量(此函数会获取到具体的触摸点数量，不需要用户给出) 12345void input_mt_report_pointer_emulation(struct input_dev *dev, bool use_count)&#x2F;&#x2F;dev： MT 设备对应的 input_dev。&#x2F;&#x2F;use_count：true，有效的触摸点数量；false，追踪到的触摸点数量多于当前上报的数量。&#x2F;&#x2F;返回值：无。 多点电容触摸驱动框架①、多点电容触摸芯片的接口，一般都为 I2C 接口，因此驱动主框架肯定是 I2C。②、linux 里面一般都是通过中断来上报触摸点坐标信息，因此需要用到中断框架。③、多点电容触摸属于 input 子系统，因此还要用到 input 子系统框架。④、在中断处理程序中按照 linux 的 MT 协议上报坐标信息。 1、I2C 驱动框架1234567891011121314151617181920212223242526272829 &#x2F;* 设备树匹配表 *&#x2F;static const struct of_device_id xxx_of_match[] &#x3D; &#123; &#123; .compatible &#x3D; &quot;xxx&quot;, &#125;, &#123; &#x2F;* sentinel *&#x2F; &#125;&#125;;&#x2F;* i2c 驱动结构体 *&#x2F;static struct i2c_driver ft5x06_ts_driver &#x3D; &#123; .driver &#x3D; &#123; .owner &#x3D; THIS_MODULE, .name &#x3D; &quot;edt_ft5x06&quot;, .of_match_table &#x3D; of_match_ptr(xxx_of_match), &#125;, .id_table &#x3D; xxx_ts_id, .probe &#x3D; xxx_ts_probe, .remove &#x3D; xxx_ts_remove,&#125;;static int __init xxx_init(void)&#123; int ret &#x3D; 0; ret &#x3D; i2c_add_driver(&amp;xxx_ts_driver); return ret;&#125;static void __exit xxx_exit(void)&#123; i2c_del_driver(&amp;ft5x06_ts_driver);&#125; 2、初始化触摸 IC、中断和 input 子系统初始化操作都是在 xxx_ts_probe 函数中完成， 1234567891011121314151617181920212223242526272829303132333435static int xxx_ts_probe(struct i2c_client *client, const struct i2c_device_id *id) &#123; struct input_dev *input; &#x2F;* 1、初始化 I2C *&#x2F; ...... &#x2F;* 2，申请中断， *&#x2F; devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, NULL, xxx_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, client-&gt;name, &amp;xxx); ...... &#x2F;* 3，input 设备申请与初始化 *&#x2F; input &#x3D; devm_input_allocate_device(&amp;client-&gt;dev); input-&gt;name &#x3D; client-&gt;name; input-&gt;id.bustype &#x3D; BUS_I2C; input-&gt;dev.parent &#x3D; &amp;client-&gt;dev; ...... &#x2F;* 4，初始化 input 和 MT *&#x2F; __set_bit(EV_ABS, input-&gt;evbit); __set_bit(BTN_TOUCH, input-&gt;keybit); input_set_abs_params(input, ABS_X, 0, width, 0, 0); input_set_abs_params(input, ABS_Y, 0, height, 0, 0); input_set_abs_params(input, ABS_MT_POSITION_X,0, width, 0, 0); input_set_abs_params(input, ABS_MT_POSITION_Y,0, height, 0, 0); input_mt_init_slots(input, MAX_SUPPORT_POINTS, 0); ...... &#x2F;* 5，注册 input_dev *&#x2F; input_register_device(input); ......&#125; 第 5~7 行，首先肯定是初始化触摸芯片，包括芯片的相关 IO，比如复位、中断等 IO 引脚， 然后就是芯片本身的初始化，也就是配置触摸芯片的相关寄存器。 第 9 行，因为一般触摸芯片都是通过中断来向系统上报触摸点坐标信息的，因此我们需要初始化中断，采用了 devm_request_threaded_irq 这个函数。 第 15 行，接下来就是申请 input_dev，因为多点电容触摸属于 input 子系统。这里同样使用 devm_input_allocate_device 函数来申请 input_dev，申请到 input_dev 以后还需要对其进行初始化操作。 第 23~24 行，设置 input_dev 需要上报的事件为 EV_ABS 和 BTN_TOUCH，因为多点电容 屏的触摸坐标为绝对值，因此需要上报 EV_ABS 事件。触摸屏有按下和抬起之分，因此需要上报 BTN_TOUCH 按键。 第 26~29 行，调用 input_set_abs_params 函数设置 EV_ABS 事件需要上报 ABS_X、ABS_Y、 ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。单点触摸需要上报 ABS_X 和 ABS_Y，对于多点触摸需要上报 ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。 第 30 行，调用 input_mt_init_slots 函数初始化多点电容触摸的 slots。 第 34 行，调用 input_register_device 函数系统注册前面申请到的 input_dev。 devm_request_threaded_irq 函数特点如下： ①、用于申请中断，作用和 request_irq 函数类似。 ②、此函数的作用是中断线程化。硬件中断具有最高优先级，不论什么时候只要硬件中断发生，那么内核都会终止当前正在执行的操作，转而去执行中断处理程序(不考虑关闭中断和中断优先级的情况)，如果中断非常频繁的话那么内核将会频繁的执行中断处理程序，导致任务得不到及时的处理。中断线程化以后中断将作为内核线程运行，而且也可以被赋予不同的优先级，任务的优先级可能比中断线程的优先级高，这样做的目的就是保证高优先级的任务能被优先处理。使用“devm_”前缀的函数申请到的资源可以由系统自动释放，不需要我们手动处理。 3、上报坐标信息最后就是在中断服务程序中上报读取到的坐标信息， 12345678910111213141516171819202122static irqreturn_t xxx_handler(int irq, void *dev_id) &#123; int num; &#x2F;* 触摸点数量 *&#x2F; int x[n], y[n]; &#x2F;* 保存坐标值 *&#x2F; &#x2F;* 1、从触摸芯片获取各个触摸点坐标值 *&#x2F; ...... &#x2F;* 2、上报每一个触摸点坐标 *&#x2F; for (i &#x3D; 0; i &lt; num; i++) &#123; input_mt_slot(input, id); input_mt_report_slot_state(input, MT_TOOL_FINGER, true); input_report_abs(input, ABS_MT_POSITION_X, x[i]); input_report_abs(input, ABS_MT_POSITION_Y, y[i]); &#125; ...... input_sync(input); ...... return IRQ_HANDLED;&#125; 循环上报每一个触摸点坐标，一定要按照 Type B 类型的时序进行，每一轮触摸点坐标上报完毕以后就调用一次 input_sync 函数发送一个SYN_REPORT 事件。 试验程序编写1、修改设备树1、添加 FT5426 所使用的 IOFT5426 触摸芯片用到了 4 个 IO，一个复位 IO、一个中断 IO、I2C2 的 SCL 和 SDA，所以我们需要先在设备树中添加 IO 相关的信息。复位 IO 和中断 IO 是普通的 GPIO，因此这两个 IO可以放到同一个节点下去描述，I2C2 的 SCL 和 SDA 属于 I2C2，因此这两个要放到同一个节点下去描述。 2、添加 FT5426 节点 FT5426 这个触摸 IC 挂载 I2C2 下，因此需要向 I2C2 节点下添加一个子节点，此子节点用 于描述FT5426，添加完成以后的 I2C2 节点内容如下所示 123456789101112ft5426: ft5426@38 &#123;13 compatible &#x3D; &quot;edt,edt-ft5426&quot;;14 reg &#x3D; &lt;0x38&gt;;15 pinctrl-names &#x3D; &quot;default&quot;;16 pinctrl-0 &#x3D; &lt;&amp;pinctrl_tsc17 &amp;pinctrl_tsc_reset &gt;;18 interrupt-parent &#x3D; &lt;&amp;gpio1&gt;;19 interrupts &#x3D; &lt;9 0&gt;;20 reset-gpios &#x3D; &lt;&amp;gpio5 9 GPIO_ACTIVE_LOW&gt;; 21 interrupt-gpios &#x3D; &lt;&amp;gpio1 9 GPIO_ACTIVE_LOW&gt;;22 &#125;;23 &#125;; 第 12 行，触摸屏所使用的 FT5426 芯片节点，挂载 I2C2 节点下，FT5426 的器件地址为 0X38。 第 14 行，reg 属性描述 FT5426 的器件地址为 0x38。 第 16 和 17 行，pinctrl-0 属性描述 FT5426 的复位 IO 和中断 IO 所使用的节点为 pinctrl_tsc 和 pinctrl_tsc_reset。 第 18 行，interrupt-parent 属性描述中断 IO 对应的 GPIO 组为 GPIO1。 第 19 行，interrupts 属性描述中断 IO 对应的是 GPIO1 组的 IOI09。 第 20 行，reset-gpios 属性描述复位 IO 对应的 GPIO 为 GPIO5_IO09。 第 21 行，interrupt-gpios 属性描述中断 IO 对应的 GPIO 为 GPIO1_IO09 2、编写多点电容触摸驱动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329&#x2F;***************************************************************文件名 : ft5x06.c描述 : FT5X06，包括FT5206、FT5426等触摸屏驱动程序***************************************************************&#x2F;#define MAX_SUPPORT_POINTS 5 &#x2F;* 5点触摸 *&#x2F;#define TOUCH_EVENT_DOWN 0x00 &#x2F;* 按下 *&#x2F;#define TOUCH_EVENT_UP 0x01 &#x2F;* 抬起 *&#x2F;#define TOUCH_EVENT_ON 0x02 &#x2F;* 接触 *&#x2F;#define TOUCH_EVENT_RESERVED 0x03 &#x2F;* 保留 *&#x2F;&#x2F;* FT5X06寄存器相关宏定义 *&#x2F;#define FT5X06_TD_STATUS_REG 0X02 &#x2F;* 状态寄存器地址 *&#x2F;#define FT5x06_DEVICE_MODE_REG 0X00 &#x2F;* 模式寄存器 *&#x2F;#define FT5426_IDG_MODE_REG 0XA4 &#x2F;* 中断模式 *&#x2F;#define FT5X06_READLEN 29 &#x2F;* 要读取的寄存器个数 *&#x2F;struct ft5x06_dev &#123; struct device_node *nd; &#x2F;* 设备节点 *&#x2F; int irq_pin,reset_pin; &#x2F;* 中断和复位IO *&#x2F; int irqnum; &#x2F;* 中断号 *&#x2F; void *private_data; &#x2F;* 私有数据 *&#x2F; struct input_dev *input; &#x2F;* input结构体 *&#x2F; struct i2c_client *client; &#x2F;* I2C客户端 *&#x2F;&#125;;static struct ft5x06_dev ft5x06;&#x2F;* * @description : 复位FT5X06 * @param - client : 要操作的i2c * @param - multidev: 自定义的multitouch设备 * @return : 0，成功;其他负值,失败 *&#x2F;static int ft5x06_ts_reset(struct i2c_client *client, struct ft5x06_dev *dev)&#123; int ret &#x3D; 0; if (gpio_is_valid(dev-&gt;reset_pin)) &#123; &#x2F;* 检查IO是否有效 *&#x2F; &#x2F;* 申请复位IO，并且默认输出低电平 *&#x2F; ret &#x3D; devm_gpio_request_one(&amp;client-&gt;dev, dev-&gt;reset_pin, GPIOF_OUT_INIT_LOW, &quot;edt-ft5x06 reset&quot;); if (ret) &#123; return ret; &#125; msleep(5); gpio_set_value(dev-&gt;reset_pin, 1); &#x2F;* 输出高电平，停止复位 *&#x2F; msleep(300); &#125; return 0;&#125;&#x2F;* * @description : 从FT5X06读取多个寄存器数据 * @param - dev: ft5x06设备 * @param - reg: 要读取的寄存器首地址 * @param - val: 读取到的数据 * @param - len: 要读取的数据长度 * @return : 操作结果 *&#x2F;static int ft5x06_read_regs(struct ft5x06_dev *dev, u8 reg, void *val, int len)&#123; int ret; struct i2c_msg msg[2]; struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;client; &#x2F;* msg[0]为发送要读取的首地址 *&#x2F; msg[0].addr &#x3D; client-&gt;addr; &#x2F;* ft5x06地址 *&#x2F; msg[0].flags &#x3D; 0; &#x2F;* 标记为发送数据 *&#x2F; msg[0].buf &#x3D; &amp;reg; &#x2F;* 读取的首地址 *&#x2F; msg[0].len &#x3D; 1; &#x2F;* reg长度*&#x2F; &#x2F;* msg[1]读取数据 *&#x2F; msg[1].addr &#x3D; client-&gt;addr; &#x2F;* ft5x06地址 *&#x2F; msg[1].flags &#x3D; I2C_M_RD; &#x2F;* 标记为读取数据*&#x2F; msg[1].buf &#x3D; val; &#x2F;* 读取数据缓冲区 *&#x2F; msg[1].len &#x3D; len; &#x2F;* 要读取的数据长度*&#x2F; ret &#x3D; i2c_transfer(client-&gt;adapter, msg, 2); if(ret &#x3D;&#x3D; 2) &#123; ret &#x3D; 0; &#125; else &#123; ret &#x3D; -EREMOTEIO; &#125; return ret;&#125;&#x2F;* * @description : 向ft5x06多个寄存器写入数据 * @param - dev: ft5x06设备 * @param - reg: 要写入的寄存器首地址 * @param - val: 要写入的数据缓冲区 * @param - len: 要写入的数据长度 * @return : 操作结果 *&#x2F;static s32 ft5x06_write_regs(struct ft5x06_dev *dev, u8 reg, u8 *buf, u8 len)&#123; u8 b[256]; struct i2c_msg msg; struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;client; b[0] &#x3D; reg; &#x2F;* 寄存器首地址 *&#x2F; memcpy(&amp;b[1],buf,len); &#x2F;* 将要写入的数据拷贝到数组b里面 *&#x2F; msg.addr &#x3D; client-&gt;addr; &#x2F;* ft5x06地址 *&#x2F; msg.flags &#x3D; 0; &#x2F;* 标记为写数据 *&#x2F; msg.buf &#x3D; b; &#x2F;* 要写入的数据缓冲区 *&#x2F; msg.len &#x3D; len + 1; &#x2F;* 要写入的数据长度 *&#x2F; return i2c_transfer(client-&gt;adapter, &amp;msg, 1);&#125;&#x2F;* * @description : 向ft5x06指定寄存器写入指定的值，写一个寄存器 * @param - dev: ft5x06设备 * @param - reg: 要写的寄存器 * @param - data: 要写入的值 * @return : 无 *&#x2F;static void ft5x06_write_reg(struct ft5x06_dev *dev, u8 reg, u8 data)&#123; u8 buf &#x3D; 0; buf &#x3D; data; ft5x06_write_regs(dev, reg, &amp;buf, 1);&#125;&#x2F;* * @description : FT5X06中断服务函数 * @param - irq : 中断号 * @param - dev_id : 设备结构。 * @return : 中断执行结果 *&#x2F;static irqreturn_t ft5x06_handler(int irq, void *dev_id)&#123; struct ft5x06_dev *multidata &#x3D; dev_id; u8 rdbuf[29]; int i, type, x, y, id; int offset, tplen; int ret; bool down; offset &#x3D; 1; &#x2F;* 偏移1，也就是0X02+1&#x3D;0x03,从0X03开始是触摸值 *&#x2F; tplen &#x3D; 6; &#x2F;* 一个触摸点有6个寄存器来保存触摸值 *&#x2F; memset(rdbuf, 0, sizeof(rdbuf)); &#x2F;* 清除 *&#x2F; &#x2F;* 读取FT5X06触摸点坐标从0X02寄存器开始，连续读取29个寄存器 *&#x2F; ret &#x3D; ft5x06_read_regs(multidata, FT5X06_TD_STATUS_REG, rdbuf, FT5X06_READLEN); if (ret) &#123; goto fail; &#125; &#x2F;* 上报每一个触摸点坐标 *&#x2F; for (i &#x3D; 0; i &lt; MAX_SUPPORT_POINTS; i++) &#123; u8 *buf &#x3D; &amp;rdbuf[i * tplen + offset]; &#x2F;* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下： * bit7:6 Event flag 0:按下 1:释放 2：接触 3：没有事件 * bit5:4 保留 * bit3:0 X轴触摸点的11~8位。 *&#x2F; type &#x3D; buf[0] &gt;&gt; 6; &#x2F;* 获取触摸类型 *&#x2F; if (type &#x3D;&#x3D; TOUCH_EVENT_RESERVED) continue; &#x2F;* 我们所使用的触摸屏和FT5X06是反过来的 *&#x2F; x &#x3D; ((buf[2] &lt;&lt; 8) | buf[3]) &amp; 0x0fff; y &#x3D; ((buf[0] &lt;&lt; 8) | buf[1]) &amp; 0x0fff; &#x2F;* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下： * bit7:4 Touch ID 触摸ID，表示是哪个触摸点 * bit3:0 Y轴触摸点的11~8位。 *&#x2F; id &#x3D; (buf[2] &gt;&gt; 4) &amp; 0x0f; down &#x3D; type !&#x3D; TOUCH_EVENT_UP; input_mt_slot(multidata-&gt;input, id); input_mt_report_slot_state(multidata-&gt;input, MT_TOOL_FINGER, down); if (!down) continue; input_report_abs(multidata-&gt;input, ABS_MT_POSITION_X, x); input_report_abs(multidata-&gt;input, ABS_MT_POSITION_Y, y); &#125; input_mt_report_pointer_emulation(multidata-&gt;input, true); input_sync(multidata-&gt;input);fail: return IRQ_HANDLED;&#125;&#x2F;* * @description : FT5x06中断初始化 * @param - client : 要操作的i2c * @param - multidev: 自定义的multitouch设备 * @return : 0，成功;其他负值,失败 *&#x2F;static int ft5x06_ts_irq(struct i2c_client *client, struct ft5x06_dev *dev)&#123; int ret &#x3D; 0; &#x2F;* 1,申请中断GPIO *&#x2F; if (gpio_is_valid(dev-&gt;irq_pin)) &#123; ret &#x3D; devm_gpio_request_one(&amp;client-&gt;dev, dev-&gt;irq_pin, GPIOF_IN, &quot;edt-ft5x06 irq&quot;); if (ret) &#123; dev_err(&amp;client-&gt;dev, &quot;Failed to request GPIO %d, error %d\\n&quot;, dev-&gt;irq_pin, ret); return ret; &#125; &#125; &#x2F;* 2，申请中断,client-&gt;irq就是IO中断， *&#x2F; ret &#x3D; devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, NULL, ft5x06_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, client-&gt;name, &amp;ft5x06); if (ret) &#123; dev_err(&amp;client-&gt;dev, &quot;Unable to request touchscreen IRQ.\\n&quot;); return ret; &#125; return 0;&#125; &#x2F;* * @description : i2c驱动的probe函数，当驱动与 * 设备匹配以后此函数就会执行 * @param - client : i2c设备 * @param - id : i2c设备ID * @return : 0，成功;其他负值,失败 *&#x2F;static int ft5x06_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)&#123; int ret &#x3D; 0; ft5x06.client &#x3D; client; &#x2F;* 1，获取设备树中的中断和复位引脚 *&#x2F; ft5x06.irq_pin &#x3D; of_get_named_gpio(client-&gt;dev.of_node, &quot;interrupt-gpios&quot;, 0); ft5x06.reset_pin &#x3D; of_get_named_gpio(client-&gt;dev.of_node, &quot;reset-gpios&quot;, 0); &#x2F;* 2，复位FT5x06 *&#x2F; ret &#x3D; ft5x06_ts_reset(client, &amp;ft5x06); if(ret &lt; 0) &#123; goto fail; &#125; &#x2F;* 3，初始化中断 *&#x2F; ret &#x3D; ft5x06_ts_irq(client, &amp;ft5x06); if(ret &lt; 0) &#123; goto fail; &#125; &#x2F;* 4，初始化FT5X06 *&#x2F; ft5x06_write_reg(&amp;ft5x06, FT5x06_DEVICE_MODE_REG, 0); &#x2F;* 进入正常模式 *&#x2F; ft5x06_write_reg(&amp;ft5x06, FT5426_IDG_MODE_REG, 1); &#x2F;* FT5426中断模式 *&#x2F; &#x2F;* 5，input设备注册 *&#x2F; ft5x06.input &#x3D; devm_input_allocate_device(&amp;client-&gt;dev); if (!ft5x06.input) &#123; ret &#x3D; -ENOMEM; goto fail; &#125; ft5x06.input-&gt;name &#x3D; client-&gt;name; ft5x06.input-&gt;id.bustype &#x3D; BUS_I2C; ft5x06.input-&gt;dev.parent &#x3D; &amp;client-&gt;dev; __set_bit(EV_KEY, ft5x06.input-&gt;evbit); __set_bit(EV_ABS, ft5x06.input-&gt;evbit); __set_bit(BTN_TOUCH, ft5x06.input-&gt;keybit); input_set_abs_params(ft5x06.input, ABS_X, 0, 1024, 0, 0); input_set_abs_params(ft5x06.input, ABS_Y, 0, 600, 0, 0); input_set_abs_params(ft5x06.input, ABS_MT_POSITION_X,0, 1024, 0, 0); input_set_abs_params(ft5x06.input, ABS_MT_POSITION_Y,0, 600, 0, 0); ret &#x3D; input_mt_init_slots(ft5x06.input, MAX_SUPPORT_POINTS, 0); if (ret) &#123; goto fail; &#125; ret &#x3D; input_register_device(ft5x06.input); if (ret) goto fail; return 0;fail: return ret;&#125;&#x2F;* * @description : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行 * @param - client : i2c设备 * @return : 0，成功;其他负值,失败 *&#x2F;static int ft5x06_ts_remove(struct i2c_client *client)&#123; &#x2F;* 释放input_dev *&#x2F; input_unregister_device(ft5x06.input); return 0;&#125;&#x2F;* * 设备树匹配表 *&#x2F;static const struct of_device_id ft5x06_of_match[] &#x3D; &#123; &#123; .compatible &#x3D; &quot;edt,edt-ft5206&quot;, &#125;, &#123; .compatible &#x3D; &quot;edt,edt-ft5426&quot;, &#125;, &#123; &#x2F;* sentinel *&#x2F; &#125;&#125;;&#x2F;* i2c驱动结构体 *&#x2F; static struct i2c_driver ft5x06_ts_driver &#x3D; &#123; .driver &#x3D; &#123; .owner &#x3D; THIS_MODULE, .name &#x3D; &quot;edt_ft5x06&quot;, .of_match_table &#x3D; of_match_ptr(ft5x06_of_match), &#125;, .id_table &#x3D; ft5x06_ts_id, .probe &#x3D; ft5x06_ts_probe, .remove &#x3D; ft5x06_ts_remove,&#125;;","link":"","tags":[]},{"title":"Linux驱动-串口驱动","date":"2021-04-18T02:23:45.000Z","path":"2021/04/18/Linux驱动-串口驱动/","text":"根据电平的不同，串口分为 TTL 和 RS232。不管是什么样的接口电平，其驱动程序都是一样的，通过外接 RS485 这样的芯片就可以将串口转换为 RS485 信号，正点原子的 I.MX6U-ALPHA 开发板就是这么做的。对于正点原子的 I.MX6U-ALPHA 开发板而言， RS232、RS485 以及 GPS 模 块接口通通连接到了 I.MX6U 的 UART3 接口上，因此这些外设最终都归结为 UART3 的串口驱动。学习一下如何驱动 I.MX6U-ALPHA 开发板上的 UART3 串口，进而实现 RS232、RS485 以及 GSP 驱动。 Linux 下 UART 驱动框架1、uart_driver 注册与注销同 I2C、SPI 一样，Linux 也提供了串口驱动框架，我们只需要按照相应的串口框架编写驱动程序即可。串口驱动没有什么主机端和设备端之分，就只有一个串口驱动，而且这个驱动已经由 NXP 官方已经编写好了，我们真正要做的就是在设备树中添加所要使用的串口节点信息。当系统启动以后串口驱动和设备匹配成功，相应的串口就会被驱动起来，生成/dev/ttymxcX(X=0….n)文件。 uart_driver 结构体表示 UART 驱动，uart_driver 定义在 include/linux/serial_core.h 文件中，内容如下： 1234567891011struct uart_driver &#123; struct module *owner; &#x2F;* 模块所属者 *&#x2F; const char *driver_name; &#x2F;* 驱动名字 *&#x2F; const char *dev_name; &#x2F;* 设备名字 *&#x2F; int major; &#x2F;* 主设备号 *&#x2F; int minor; &#x2F;* 次设备号 *&#x2F; int nr; &#x2F;* 设备数 *&#x2F; struct console *cons; &#x2F;* 控制台 *&#x2F; struct uart_state *state; struct tty_driver *tty_driver;&#125;; 每个串口驱动都需要定义一个 uart_driver，加载驱动的时候通过 uart_register_driver 函数向系统注册这个 uart_driver，注销驱动的时候也需要注销掉前面注册的 uart_driver，需要用到 uart_unregister_driver 函数， 1234567int uart_register_driver(struct uart_driver *drv)&#x2F;&#x2F;drv：要注册的 uart_driver。&#x2F;&#x2F;返回值：0，成功；负值，失败。void uart_unregister_driver(struct uart_driver *drv)&#x2F;&#x2F;drv：要注销的 uart_driver。&#x2F;&#x2F;返回值：无。 2、uart_port 的添加与移除uart_port 表示一个具体的 port，uart_port 定义在 include/linux/serial_core.h 文件每个 UART 都有一个 uart_port，uart_port 中最主要的就 ops，ops 包含了串口的具体驱动函数。那么 uart_port 和 uart_driver 结合要用到 uart_add_one_port 函数，卸载 UART 驱动的时候也需要将 uart_port 从相应的 uart_driver 中移除，需要用到uart_remove_one_port 函数， 123456789int uart_add_one_port(struct uart_driver *drv, struct uart_port *uport)&#x2F;&#x2F;drv：此 port 对应的 uart_driver。&#x2F;&#x2F;uport：要添加到 uart_driver 中的 port。&#x2F;&#x2F;返回值：0，成功；负值，失败。int uart_remove_one_port(struct uart_driver *drv, struct uart_port *uport)&#x2F;&#x2F;drv：要卸载的 port 所对应的 uart_driver。&#x2F;&#x2F;uport：要卸载的 uart_port。&#x2F;&#x2F;返回值：0，成功；负值，失败。 3、uart_ops 实现uart_port 中的 ops 成员变量很重要，因为 ops 包含了针对 UART 具体的驱动函数，Linux 系统收发数据最终调用的都是 ops 中的函数。ops 是 uart_ops类型的结构体指针变量，uart_ops 定义在 include/linux/serial_core.h 文件中。UART 驱动编写人员需要实现 uart_ops，因为 uart_ops 是最底层的 UART 驱动接口，是实实在在的和 UART 寄存器打交道的。 I.MX6U UART 驱动分析1、UART 的 platform 驱动框架I.MX6U 的 UART 本质上是一个 platform 驱动。打开 imx6ull.dtsi 文件，找到 UART3 对应的子节点的compatible 属性，这里一共有三个值：“fsl,imx6ul-uart”、“fsl,imx6q-uart”和“fsl,imx21-uart”。对应的 UART 驱动文件件为 drivers/tty/serial/imx.c，驱动文件的主要工作就是通过传统匹配表或设备树所匹配表匹配设备和驱动，然后初始化platform 驱动框架platform_driver类型的结构体 serial_imx_driver。最后就是驱动入口函数调用 uart_register_driver 函数向 Linux 内核注册 uart_driver，驱动出口函数调用 uart_unregister_driver 函数注销掉前面注 册的 uart_driver。 2、uart_driver 初始化在 imx_serial_init 函数中向 Linux 内核注册了 imx_reg，imx_reg 就是 uart_driver 类型的结构体变量，imx_reg 定义如下： 123456789static struct uart_driver imx_reg &#x3D; &#123; .owner &#x3D; THIS_MODULE, .driver_name &#x3D; DRIVER_NAME, .dev_name &#x3D; DEV_NAME, .major &#x3D; SERIAL_IMX_MAJOR, .minor &#x3D; MINOR_START, .nr &#x3D; ARRAY_SIZE(imx_ports), .cons &#x3D; IMX_CONSOLE,&#125;; 3、uart_port 初始化与添加当 UART 设备和驱动匹配成功以后 serial_imx_probe 函数就会执行，此函数的重点工作就是初始化 uart_port，然后将其添加到对应的 uart_driver 中。imx_port 结构体 NXP 为 I.MX 系列 SOC 定义的一个设备结构体，此结构体内部就包含了 uart_port 成员变量。 serial_imx_probe 函数，函数内容如下： 1234567891011121314static int serial_imx_probe(struct platform_device *pdev)&#123; struct imx_port *sport; sport &#x3D; devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*sport), GFP_KERNEL); res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0); base &#x3D; devm_ioremap_resource(&amp;pdev-&gt;dev, res); rxirq &#x3D; platform_get_irq(pdev, 0); 1993 txirq &#x3D; platform_get_irq(pdev, 1); 1994 rtsirq &#x3D; platform_get_irq(pdev, 2); sport-&gt;port.ops &#x3D; &amp;imx_pops; …………………… return uart_add_one_port(&amp;imx_reg, &amp;sport-&gt;port);&#125; 先定义一个 imx_port 类型的结构体指针变量 sport。然后为 sport 申请内存。从设备树中获取 I.MX 系列 SOC UART 外设寄存器首地址，对于I.MX6ULL 的 UART3 来说就是 0X021EC000。得到寄存器首地址以后对其进行内存映射，得到对应的虚拟地址。获取中断信息，申请中断。初始化 sport 的 port 成员变量，也就是设置 uart_ops 为 imx_pops，imx_pops 就是 I.MX6ULL 最底层的驱动函数集合。使用 uart_add_one_port 向 uart_driver 添加 uart_port，在这里就是向 imx_reg 添 加 sport-&gt;port。 4、imx_pops 结构体变量imx_pops 就是 uart_ops 类型的结构体变量，保存了 I.MX6ULL 串口最底层的操作函数，imx_pops 中的函数基本都是和 I.MX6ULL 的 UART 寄存器打交道的，","link":"","tags":[]},{"title":"Linux驱动-SPI驱动","date":"2021-04-17T14:50:57.000Z","path":"2021/04/17/Linux驱动-SPI驱动/","text":"Linux 下 SPI 驱动框架SPI 主机驱动SPI 主机驱动就是 SOC 的 SPI 控制器驱动，类似 I2C 驱动里面的适配器驱动。Linux 内核使用 spi_master表示 SPI 主机驱动，spi_master 是个结构体，定义在 include/linux/spi/spi.h 文件中，内容如下(有缩减)： 1234567891011struct spi_master &#123; struct device dev; struct list_head list; ...... (*transfer)(struct spi_device *spi, struct spi_message *mesg); ...... int (*transfer_one_message)(struct spi_master *master, struct spi_message *mesg); ......&#125;;&#x2F;&#x2F;transfer函数，和 i2c_algorithm 中的 master_xfer 函数一样，控制器数据传输函数。&#x2F;&#x2F;transfer_one_message函数，也用于 SPI 数据发送，用于发送一个spi_message，SPI的数据会打包成 spi_message，然后以队列方式发送出去。 SPI 主机端最终会通过 transfer 函数与 SPI 设备进行通信，因此对于 SPI 主机控制器的驱动编写者而言 transfer 函数是需要实现的，因为不同的 SOC 其 SPI 控制器不同，寄存器都不一样。SPI 主机驱动一般都是 SOC 厂商去编写的。 SPI 主机驱动的核心就是申请 spi_master，然后初始化 spi_master，最后向 Linux 内核注册 spi_master。 1、spi_master 申请与释放 spi_alloc_master 函数用于申请 spi_master，当我们删除一个 SPI 主机驱动的时候就需要释放掉前面申请的 spi_master，spi_master 的释放通过 spi_master_put 函数来完成。 123456789struct spi_master *spi_alloc_master(struct device *dev, unsigned size)&#x2F;&#x2F;dev：设备，一般是 platform_device 中的 dev 成员变量。&#x2F;&#x2F;size：私有数据大小，可以通过 spi_master_get_devdata 函数获取到这些私有数据。&#x2F;&#x2F;返回值：申请到的 spi_master。void spi_master_put(struct spi_master *master)&#x2F;&#x2F;master：要释放的 spi_master。&#x2F;&#x2F;返回值：无 2、spi_master 的注册与注销 当 spi_master 初始化完成以后就需要将其注册到 Linux 内核，如果要注销 spi_master 的话可以使用 spi_unregister_master 函数 1234567int spi_register_master(struct spi_master *master)&#x2F;&#x2F;master：要注册的 spi_master。&#x2F;&#x2F;返回值：0，成功；负值，失败。void spi_unregister_master(struct spi_master *master)&#x2F;&#x2F;master：要注销的 spi_master。&#x2F;&#x2F;返回值：无。 SPI 设备驱动Linux 内核使用 spi_driver 结构体来表示 spi 设备驱动，spi_driver 结构体定义在include/linux/spi/spi.h 文件中，结构体内容如下： 1234567struct spi_driver &#123; const struct spi_device_id *id_table; int (*probe)(struct spi_device *spi); int (*remove)(struct spi_device *spi); void (*shutdown)(struct spi_device *spi); struct device_driver driver;&#125;; spi_driver 和 i2c_driver、platform_driver 基本一样，当 SPI 设备和驱动匹配成功以后 probe 函数就会执行。 spi_driver 初始化完成以后需要向 Linux 内核注册，spi_driver 注册函数为spi_register_driver，注销 SPI 设备驱动以后也需要注销掉前面注册的 spi_driver，使用 spi_unregister_driver 函数完成 spi_driver 的注销， 1234567int spi_register_driver(struct spi_driver *sdrv)&#x2F;&#x2F;sdrv：要注册的 spi_driver。&#x2F;&#x2F;返回值：0，注册成功；赋值，注册失败。void spi_unregister_driver(struct spi_driver *sdrv)&#x2F;&#x2F;sdrv：要注销的 spi_driver。&#x2F;&#x2F;返回值：无。 **spi_driver 注册示例程序如下： ** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#x2F;* probe 函数 *&#x2F;static int xxx_probe(struct spi_device *spi) &#123; &#x2F;* 具体函数内容 *&#x2F; return 0; &#125;&#x2F;* remove 函数 *&#x2F;static int xxx_remove(struct spi_device *spi)&#123; &#x2F;* 具体函数内容 *&#x2F; return 0;&#125;&#x2F;* 传统匹配方式 ID 列表 *&#x2F;static const struct spi_device_id xxx_id[] &#x3D; &#123; &#123;&quot;xxx&quot;, 0&#125;, &#123;&#125;&#125;;&#x2F;* 设备树匹配列表 *&#x2F;static const struct of_device_id xxx_of_match[] &#x3D; &#123; &#123; .compatible &#x3D; &quot;xxx&quot; &#125;, &#123; &#x2F;* Sentinel *&#x2F; &#125;&#125;;&#x2F;* SPI 驱动结构体 *&#x2F;static struct spi_driver xxx_driver &#x3D; &#123; .probe &#x3D; xxx_probe, .remove &#x3D; xxx_remove, .driver &#x3D; &#123; .owner &#x3D; THIS_MODULE, .name &#x3D; &quot;xxx&quot;, .of_match_table &#x3D; xxx_of_match, &#125;, .id_table &#x3D; xxx_id,&#125;;&#x2F;* 驱动入口函数 *&#x2F;static int __init xxx_init(void)&#123; return spi_register_driver(&amp;xxx_driver);&#125;&#x2F;* 驱动出口函数 *&#x2F;static void __exit xxx_exit(void)&#123; spi_unregister_driver(&amp;xxx_driver);&#125; SPI 设备和驱动匹配过程SPI 设备和驱动的匹配过程是由 SPI 总线来完成的，这点和 platform、I2C 等驱动一样，SPI 总线为 spi_bus_type， 123456struct bus_type spi_bus_type &#x3D; &#123; .name &#x3D; &quot;spi&quot;, .dev_groups &#x3D; spi_dev_groups, .match &#x3D; spi_match_device, .uevent &#x3D; spi_uevent,&#125;; SPI 设备和驱动的匹配函数为 spi_match_device，spi_match_device函数中的of_driver_match_device 函数用于完成设备树设备和驱动匹配，比较 SPI 设备节 点的 compatible 属性和 of_device_id 中的 compatible 属性是否相等，如果相当的话就表示 SPI 设备和驱动匹配。 spi_match_device函数中spi_match_id 函数用于传统的、无设备树的 SPI 设备和驱动匹配过程。比较 SPI设备名字和 spi_device_id 的 name 字段是否相等，相等的话就说明 SPI 设备和驱动匹配。 SPI 设备驱动编写流程1、SPI 设备信息描述1、IO 的 pinctrl 子节点创建与修改 首先肯定是根据所使用的 IO 来创建或修改 pinctrl 子节点，这个没什么好说的，唯独要注意的就是检查相应的 IO 有没有被其他的设备所使用，如果有的话需要将其删除掉！ 2、SPI 设备节点的创建与修改 采用设备树的情况下，SPI 设备信息描述就通过创建相应的设备子节点来完成， SPI 设备数据收发处理流程SPI 设备驱动的核心是 spi_driver，当我们向 Linux 内 核注册成功 spi_driver 以后就可以使用 SPI 核心层提供的 API 函数来对设备进行读写操作了。 首先是 spi_transfer 结构体，此结构体用于描述 SPI 传输信息，结构体内容如下： 12345678struct spi_transfer &#123;const void *tx_buf;610 void *rx_buf;611 unsigned len;&#125;;&#x2F;&#x2F;tx_buf 保存着要发送的数据。&#x2F;&#x2F;rx_buf 用于保存接收到的数据。&#x2F;&#x2F;len是要进行传输的数据长度，SPI是全双工通信，因此在一次通信中发送和接收的字节数都是一样的，所以 spi_transfer中也就没有发送长度和接收长度之分。 spi_transfer 需要组织成 spi_message，spi_message 也是一个结构体，在使用spi_message之前需要对其进行初始化，spi_message初始化函数为spi_message_init， 1234void spi_message_init(struct spi_message *m)函数参数和返回值含义如下：m：要初始化的 spi_message。返回值：无。 spi_message 初始化完成以后需要将 spi_transfer 添加到 spi_message 队列中，这里我们要用到 spi_message_add_tail 函数， 123void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m)t：要添加到队列中的 spi_transfer。 m：spi_transfer 要加入的 spi_message。返回值：无。 spi_message 准备好以后既可以进行数据传输了，数据传输分为同步传输和异步传输。同步传输会阻塞的等待 SPI 数据传输完成，同步传输函数为 spi_sync。异步传输不会阻塞的等到 SPI 数据传输完成，异步传输需要设置 spi_message 中的 complete成员变量，complete 是一个回调函数，当 SPI 异步传输完成以后此函数就会被调用。SPI 异步传输函数为 spi_async， 123456789int spi_sync(struct spi_device *spi, struct spi_message *message)&#x2F;&#x2F;spi：要进行数据传输的 spi_device。&#x2F;&#x2F;message：要传输的 spi_message。&#x2F;&#x2F;返回值：无。int spi_async(struct spi_device *spi, struct spi_message *message)&#x2F;&#x2F;spi：要进行数据传输的 spi_device。&#x2F;&#x2F;message：要传输的 spi_message。&#x2F;&#x2F;返回值：无 SPI 数据传输步骤如下： ①、申请并初始化 spi_transfer，设置 spi_transfer 的 tx_buf 成员变量，tx_buf 为要发送的数据。然后设置 rx_buf 成员变量，rx_buf 保存着接收到的数据。最后设置 len 成员变量，也就是要进行数据通信的长度。②、使用 spi_message_init 函数初始化 spi_message。③、使用spi_message_add_tail函数将前面设置好的spi_transfer添加到spi_message队列中。④、使用 spi_sync 函数完成 SPI 数据同步传输。 **通过 SPI 进行 n 个字节的数据发送和接收的示例代码如下所示： ** 12345678910111213141516171819202122232425262728&#x2F;* SPI 多字节发送 *&#x2F;static int spi_send(struct spi_device *spi, u8 *buf, int len) &#123; int ret; struct spi_message m; struct spi_transfer t &#x3D; &#123; .tx_buf &#x3D; buf, .len &#x3D; len, &#125;; spi_message_init(&amp;m); &#x2F;* 初始化 spi_message *&#x2F; spi_message_add_tail(t, &amp;m);&#x2F;* 将 spi_transfer 添加到 spi_message 队列 *&#x2F; ret &#x3D; spi_sync(spi, &amp;m); &#x2F;* 同步传输 *&#x2F; return ret; &#125;&#x2F;* SPI 多字节接收 *&#x2F;static int spi_receive(struct spi_device *spi, u8 *buf, int len) &#123; int ret; struct spi_message m; struct spi_transfer t &#x3D; &#123; .rx_buf &#x3D; buf, .len &#x3D; len, &#125;; spi_message_init(&amp;m); &#x2F;* 初始化 spi_message *&#x2F; spi_message_add_tail(t, &amp;m);&#x2F;* 将 spi_transfer 添加到 spi_message 队列 *&#x2F; ret &#x3D; spi_sync(spi, &amp;m); &#x2F;* 同步传输 *&#x2F; return ret;&#125; 试验程序编写1、修改设备树1、添加 ICM20608 所使用的 IO 首先在 imx6ull-alientek-emmc.dts 文件中添加 ICM20608 所使用的 IO 信息，在 iomuxc 节点中添加一个新的子节点来描述 ICM20608 所使用的 SPI 引脚，子节点名字为 pinctrl_ecspi3， 12345678pinctrl_ecspi3: icm20608 &#123; fsl,pins &#x3D; &lt; MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20 0x10b0 &#x2F;* CS *&#x2F; MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK 0x10b1 &#x2F;* SCLK *&#x2F; MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO 0x10b1 &#x2F;* MISO *&#x2F; MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI 0x10b1 &#x2F;* MOSI *&#x2F; &gt;;&#125;; UART2_TX_DATA 这个 IO 是 ICM20608 的片选信号，这里我们并没有将其复用为 ECSPI3的SS0 信号，而是将其复用为了普通的 GPIO。因为我们需要自己控制片选信号，所以将其复用为普通的 GPIO。 2、在 ecspi3 节点追加 icm20608 子节点 123456789&amp;ecspi3 &#123; 2 fsl,spi-num-chipselects &#x3D; &lt;1&gt;;3 cs-gpio &#x3D; &lt;&amp;gpio1 20 GPIO_ACTIVE_LOW&gt;; &#x2F;* cant&#39;t use cs-gpios! *&#x2F;4 pinctrl-names &#x3D; &quot;default&quot;; 5 pinctrl-0 &#x3D; &lt;&amp;pinctrl_ecspi3&gt;;6 status &#x3D; &quot;okay&quot;; 7 8 spidev: icm20608@0 &#123; 9 compatible &#x3D; &quot;alientek,icm20608&quot;;10 spi-max-frequency &#x3D; &lt;8000000&gt;;11 reg &#x3D; &lt;0&gt;;12 &#125;;13 &#125;; 第 2 行，设置当前片选数量为 1，因为就只接了一个 ICM20608。 第 3 行，注意！这里并没有用到“cs-gpios”属性，而是用了一个自己定义的“cs-gpio”属性，因为我们要自己控制片选引脚。如果使用“cs-gpios”属性的话 SPI 主机驱动就会控制片选引脚。 第 5 行，设置 IO 要使用的 pinctrl_ecspi3子节点，第 6 行，imx6ull.dtsi 文件中默认将 ecspi3 节点状态(status)设置为“disable”，这里我们要将其改为“okay”。 第 8~12 行，icm20608 设备子节点，因为 icm20608 连接在 ECSPI3 的第 0 个通道上，因此@后面为 0。 第 9 行设置节点属性兼容值为“alientek,icm20608”， 第 10 行设置 SPI 最大时钟频率为 8MHz，这是 ICM20608 的 SPI 接口所能支持的最大的时钟频率。 第 11 行，icm20608 连接在通道 0 上，因此 reg 为 0。 2、编写 ICM20608 驱动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304&#x2F;***************************************************************文件名 : icm20608.c描述 : ICM20608 SPI驱动程序***************************************************************&#x2F;struct icm20608_dev &#123; void *private_data; &#x2F;* 私有数据 *&#x2F; int cs_gpio; &#x2F;* 片选所使用的GPIO编号 *&#x2F; signed int gyro_x_adc; &#x2F;* 陀螺仪X轴原始值 *&#x2F; signed int gyro_y_adc; &#x2F;* 陀螺仪Y轴原始值 *&#x2F; signed int gyro_z_adc; &#x2F;* 陀螺仪Z轴原始值 *&#x2F; signed int accel_x_adc; &#x2F;* 加速度计X轴原始值 *&#x2F; signed int accel_y_adc; &#x2F;* 加速度计Y轴原始值 *&#x2F; signed int accel_z_adc; &#x2F;* 加速度计Z轴原始值 *&#x2F; signed int temp_adc; &#x2F;* 温度原始值 *&#x2F;&#125;;static struct icm20608_dev icm20608dev;&#x2F;* * @description : 从icm20608读取多个寄存器数据 * @param - dev: icm20608设备 * @param - reg: 要读取的寄存器首地址 * @param - val: 读取到的数据 * @param - len: 要读取的数据长度 * @return : 操作结果 *&#x2F;static int icm20608_read_regs(struct icm20608_dev *dev, u8 reg, void *buf, int len)&#123; int ret; unsigned char txdata[len]; struct spi_message m; struct spi_transfer *t; struct spi_device *spi &#x3D; (struct spi_device *)dev-&gt;private_data; gpio_set_value(dev-&gt;cs_gpio, 0); &#x2F;* 片选拉低，选中ICM20608 *&#x2F; t &#x3D; kzalloc(sizeof(struct spi_transfer), GFP_KERNEL); &#x2F;* 申请内存 *&#x2F; &#x2F;* 第1次，发送要读取的寄存地址 *&#x2F; txdata[0] &#x3D; reg | 0x80; &#x2F;* 写数据的时候寄存器地址bit8要置1 *&#x2F; t-&gt;tx_buf &#x3D; txdata; &#x2F;* 要发送的数据 *&#x2F; t-&gt;len &#x3D; 1; &#x2F;* 1个字节 *&#x2F; spi_message_init(&amp;m); &#x2F;* 初始化spi_message *&#x2F; spi_message_add_tail(t, &amp;m);&#x2F;* 将spi_transfer添加到spi_message队列 *&#x2F; ret &#x3D; spi_sync(spi, &amp;m); &#x2F;* 同步发送 *&#x2F; &#x2F;* 第2次，读取数据 *&#x2F; txdata[0] &#x3D; 0xff; &#x2F;* 随便一个值，此处无意义 *&#x2F; t-&gt;rx_buf &#x3D; buf; &#x2F;* 读取到的数据 *&#x2F; t-&gt;len &#x3D; len; &#x2F;* 要读取的数据长度 *&#x2F; spi_message_init(&amp;m); &#x2F;* 初始化spi_message *&#x2F; spi_message_add_tail(t, &amp;m);&#x2F;* 将spi_transfer添加到spi_message队列 *&#x2F; ret &#x3D; spi_sync(spi, &amp;m); &#x2F;* 同步发送 *&#x2F; kfree(t); &#x2F;* 释放内存 *&#x2F; gpio_set_value(dev-&gt;cs_gpio, 1); &#x2F;* 片选拉高，释放ICM20608 *&#x2F; return ret;&#125;&#x2F;* * @description : 向icm20608多个寄存器写入数据 * @param - dev: icm20608设备 * @param - reg: 要写入的寄存器首地址 * @param - val: 要写入的数据缓冲区 * @param - len: 要写入的数据长度 * @return : 操作结果 *&#x2F;static s32 icm20608_write_regs(struct icm20608_dev *dev, u8 reg, u8 *buf, u8 len)&#123; int ret; unsigned char txdata[len]; struct spi_message m; struct spi_transfer *t; struct spi_device *spi &#x3D; (struct spi_device *)dev-&gt;private_data; t &#x3D; kzalloc(sizeof(struct spi_transfer), GFP_KERNEL); &#x2F;* 申请内存 *&#x2F; gpio_set_value(dev-&gt;cs_gpio, 0); &#x2F;* 片选拉低 *&#x2F; &#x2F;* 第1次，发送要读取的寄存地址 *&#x2F; txdata[0] &#x3D; reg &amp; ~0x80; &#x2F;* 写数据的时候寄存器地址bit8要清零 *&#x2F; t-&gt;tx_buf &#x3D; txdata; &#x2F;* 要发送的数据 *&#x2F; t-&gt;len &#x3D; 1; &#x2F;* 1个字节 *&#x2F; spi_message_init(&amp;m); &#x2F;* 初始化spi_message *&#x2F; spi_message_add_tail(t, &amp;m);&#x2F;* 将spi_transfer添加到spi_message队列 *&#x2F; ret &#x3D; spi_sync(spi, &amp;m); &#x2F;* 同步发送 *&#x2F; &#x2F;* 第2次，发送要写入的数据 *&#x2F; t-&gt;tx_buf &#x3D; buf; &#x2F;* 要写入的数据 *&#x2F; t-&gt;len &#x3D; len; &#x2F;* 写入的字节数 *&#x2F; spi_message_init(&amp;m); &#x2F;* 初始化spi_message *&#x2F; spi_message_add_tail(t, &amp;m);&#x2F;* 将spi_transfer添加到spi_message队列 *&#x2F; ret &#x3D; spi_sync(spi, &amp;m); &#x2F;* 同步发送 *&#x2F; kfree(t); &#x2F;* 释放内存 *&#x2F; gpio_set_value(dev-&gt;cs_gpio, 1);&#x2F;* 片选拉高，释放ICM20608 *&#x2F; return ret;&#125;&#x2F;* * @description : 读取icm20608指定寄存器值，读取一个寄存器 * @param - dev: icm20608设备 * @param - reg: 要读取的寄存器 * @return : 读取到的寄存器值 *&#x2F;static unsigned char icm20608_read_onereg(struct icm20608_dev *dev, u8 reg)&#123; u8 data &#x3D; 0; icm20608_read_regs(dev, reg, &amp;data, 1); return data;&#125;&#x2F;* * @description : 向icm20608指定寄存器写入指定的值，写一个寄存器 * @param - dev: icm20608设备 * @param - reg: 要写的寄存器 * @param - data: 要写入的值 * @return : 无 *&#x2F; static void icm20608_write_onereg(struct icm20608_dev *dev, u8 reg, u8 value)&#123; u8 buf &#x3D; value; icm20608_write_regs(dev, reg, &amp;buf, 1);&#125;&#x2F;* * @description : 读取ICM20608的数据，读取原始数据，包括三轴陀螺仪、 * : 三轴加速度计和内部温度。 * @param - dev : ICM20608设备 * @return : 无。 *&#x2F;void icm20608_readdata(struct icm20608_dev *dev)&#123; unsigned char data[14]; icm20608_read_regs(dev, ICM20_ACCEL_XOUT_H, data, 14); dev-&gt;accel_x_adc &#x3D; (signed short)((data[0] &lt;&lt; 8) | data[1]); dev-&gt;accel_y_adc &#x3D; (signed short)((data[2] &lt;&lt; 8) | data[3]); dev-&gt;accel_z_adc &#x3D; (signed short)((data[4] &lt;&lt; 8) | data[5]); dev-&gt;temp_adc &#x3D; (signed short)((data[6] &lt;&lt; 8) | data[7]); dev-&gt;gyro_x_adc &#x3D; (signed short)((data[8] &lt;&lt; 8) | data[9]); dev-&gt;gyro_y_adc &#x3D; (signed short)((data[10] &lt;&lt; 8) | data[11]); dev-&gt;gyro_z_adc &#x3D; (signed short)((data[12] &lt;&lt; 8) | data[13]);&#125;&#x2F;* * @description : 打开设备 * @param - inode : 传递给驱动的inode * @param - filp : 设备文件，file结构体有个叫做pr似有ate_data的成员变量 * 一般在open的时候将private_data似有向设备结构体。 * @return : 0 成功;其他 失败 *&#x2F;static int icm20608_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data &#x3D; &amp;icm20608dev; &#x2F;* 设置私有数据 *&#x2F; return 0;&#125;&#x2F;* * @description : 从设备读取数据 * @param - filp : 要打开的设备文件(文件描述符) * @param - buf : 返回给用户空间的数据缓冲区 * @param - cnt : 要读取的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 读取的字节数，如果为负值，表示读取失败 *&#x2F;static ssize_t icm20608_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off)&#123; signed int data[7]; long err &#x3D; 0; struct icm20608_dev *dev &#x3D; (struct icm20608_dev *)filp-&gt;private_data; icm20608_readdata(dev); data[0] &#x3D; dev-&gt;gyro_x_adc; data[1] &#x3D; dev-&gt;gyro_y_adc; data[2] &#x3D; dev-&gt;gyro_z_adc; data[3] &#x3D; dev-&gt;accel_x_adc; data[4] &#x3D; dev-&gt;accel_y_adc; data[5] &#x3D; dev-&gt;accel_z_adc; data[6] &#x3D; dev-&gt;temp_adc; err &#x3D; copy_to_user(buf, data, sizeof(data)); return 0;&#125;&#x2F;* * @description : 关闭&#x2F;释放设备 * @param - filp : 要关闭的设备文件(文件描述符) * @return : 0 成功;其他 失败 *&#x2F;static int icm20608_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;&#x2F;* icm20608操作函数 *&#x2F;static const struct file_operations icm20608_ops &#x3D; &#123; .owner &#x3D; THIS_MODULE, .open &#x3D; icm20608_open, .read &#x3D; icm20608_read, .release &#x3D; icm20608_release,&#125;;&#x2F;* * ICM20608内部寄存器初始化函数 * @param : 无 * @return : 无 *&#x2F;void icm20608_reginit(void)&#123; u8 value &#x3D; 0; icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, 0x80); mdelay(50); icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, 0x01); mdelay(50); value &#x3D; icm20608_read_onereg(&amp;icm20608dev, ICM20_WHO_AM_I); printk(&quot;ICM20608 ID &#x3D; %#X\\r\\n&quot;, value); icm20608_write_onereg(&amp;icm20608dev, ICM20_SMPLRT_DIV, 0x00); &#x2F;* 输出速率是内部采样率 *&#x2F; icm20608_write_onereg(&amp;icm20608dev, ICM20_GYRO_CONFIG, 0x18); &#x2F;* 陀螺仪±2000dps量程 *&#x2F; icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG, 0x18); &#x2F;* 加速度计±16G量程 *&#x2F; icm20608_write_onereg(&amp;icm20608dev, ICM20_CONFIG, 0x04); &#x2F;* 陀螺仪低通滤波BW&#x3D;20Hz *&#x2F; icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG2, 0x04); &#x2F;* 加速度计低通滤波BW&#x3D;21.2Hz *&#x2F; icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_2, 0x00); &#x2F;* 打开加速度计和陀螺仪所有轴 *&#x2F; icm20608_write_onereg(&amp;icm20608dev, ICM20_LP_MODE_CFG, 0x00); &#x2F;* 关闭低功耗 *&#x2F; icm20608_write_onereg(&amp;icm20608dev, ICM20_FIFO_EN, 0x00); &#x2F;* 关闭FIFO *&#x2F;&#125; &#x2F;* * @description : spi驱动的probe函数，当驱动与 * 设备匹配以后此函数就会执行 * @param - client : spi设备 * @param - id : spi设备ID * *&#x2F; static int icm20608_probe(struct spi_device *spi)&#123; int ret &#x3D; 0; &#x2F;* 1、构建设备号 *&#x2F; &#x2F;* 2、注册设备 *&#x2F; &#x2F;* 3、创建类 *&#x2F; &#x2F;* 4、创建设备 *&#x2F; &#x2F;* 获取设备树中cs片选信号 *&#x2F; icm20608dev.nd &#x3D; of_find_node_by_path(&quot;&#x2F;soc&#x2F;aips-bus@02000000&#x2F;spba-bus@02000000&#x2F;ecspi@02010000&quot;); if(icm20608dev.nd &#x3D;&#x3D; NULL) &#123; printk(&quot;ecspi3 node not find!\\r\\n&quot;); return -EINVAL; &#125; &#x2F;*初始化spi_device *&#x2F; spi-&gt;mode &#x3D; SPI_MODE_0; &#x2F;*MODE0，CPOL&#x3D;0，CPHA&#x3D;0*&#x2F; spi_setup(spi); icm20608dev.private_data &#x3D; spi; &#x2F;* 设置私有数据 *&#x2F; &#x2F;* 初始化ICM20608内部寄存器 *&#x2F; icm20608_reginit(); return 0;&#125;&#x2F;* 传统匹配方式ID列表 *&#x2F;static const struct spi_device_id icm20608_id[] &#x3D; &#123; &#123;&quot;alientek,icm20608&quot;, 0&#125;, &#123;&#125;&#125;;&#x2F;* 设备树匹配列表 *&#x2F;static const struct of_device_id icm20608_of_match[] &#x3D; &#123; &#123; .compatible &#x3D; &quot;alientek,icm20608&quot; &#125;, &#123; &#x2F;* Sentinel *&#x2F; &#125;&#125;;&#x2F;* SPI驱动结构体 *&#x2F; static struct spi_driver icm20608_driver &#x3D; &#123; .probe &#x3D; icm20608_probe, .remove &#x3D; icm20608_remove, .driver &#x3D; &#123; .owner &#x3D; THIS_MODULE, .name &#x3D; &quot;icm20608&quot;, .of_match_table &#x3D; icm20608_of_match, &#125;, .id_table &#x3D; icm20608_id,&#125;; &#x2F;* * @description : 驱动入口函数 * @param : 无 * @return : 无 *&#x2F;static int __init icm20608_init(void)&#123; return spi_register_driver(&amp;icm20608_driver);&#125;&#x2F;* * @description : 驱动出口函数 * @param : 无 * @return : 无 *&#x2F;static void __exit icm20608_exit(void)&#123; spi_unregister_driver(&amp;icm20608_driver);&#125;","link":"","tags":[]},{"title":"Linux驱动-I2C驱动","date":"2021-04-17T05:51:36.000Z","path":"2021/04/17/Linux驱动-I2C驱动/","text":"Linux I2C驱动框架裸机篇中编写 AP3216C 驱动的四个文件：bsp_i2c.c、bsp_i2c.h、bsp_ap3216c.c 和 bsp_ap3216c.h。其中前两个是 I.MX6U 的 IIC 接口驱动，后两个文 件是 AP3216C 这个 I2C 设备驱动文件。相当于有两部分驱动： I2C 主机驱动、I2C 设备驱动。 对于 I2C 主机驱动，一旦编写完成就不需要再做修改，其他的 I2C 设备直接调用主机驱动提供的 API 函数完成读写操作即可。这个正好符合 Linux 的驱动分离与分层的思想，因此 Linux内核也将 I2C 驱动分为两部分：①、I2C 总线驱动，I2C 总线驱动就是 SOC 的 I2C 控制器驱动，也叫做 I2C 适配器驱动。②、I2C 设备驱动，I2C 设备驱动就是针对具体的 I2C 设备而编写的驱动。 I2C 总线驱动platform 是虚拟出来的一条总线，目的是为了实现总线、设备、驱动框架。。对于 I2C 而言，不需要虚拟出一条总线，直接使用 I2C 总线即可。I2C 总线驱动重点是 I2C 适配器(也就是 SOC 的 I2C 接口控制器)驱动，这里要用到 两个重要的数据结构：i2c_adapter 和 i2c_algorithm，Linux 内核将 SOC 的 I2C 适配器(控制器) 抽象成 i2c_adapter，i2c_adapter 结构体定义在 include/linux/i2c.h 文件中，结构体内容如下： 1234567struct i2c_adapter &#123; struct module *owner; unsigned int class; &#x2F;* classes to allow probing for *&#x2F; const struct i2c_algorithm *algo; &#x2F;* 总线访问算法 *&#x2F; void *algo_data; ………………&#125;; 对于一个 I2C 适配器，肯定要对外提供读写 API 函数，设备驱动程序可以使用这些 API 函数来完成读写操作。i2c_algorithm 就是 I2C 适配器与 IIC 设备进行通信的方法。 123456789101112struct i2c_algorithm &#123; ...... int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num); int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr, unsigned short flags, char read_write, u8 command, int size, union i2c_smbus_data *data); &#x2F;* To determine what the adapter supports *&#x2F; u32 (*functionality) (struct i2c_adapter *); ......&#125;;&#x2F;&#x2F;master_xfer 就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之间的通信。&#x2F;&#x2F;smbus_xfer 就是 SMBUS 总线的传输函数。 综上所述，I2C 总线驱动(I2C 适配器驱动)的主要工作就是初始化 i2c_adapter 结构体变量，然后设置 i2c_algorithm 中的 master_xfer 函数。 完成初始化以后通过 i2c_add_numbered_adapter或 i2c_add_adapter 这两个函数向系统注册设置好的 i2c_adapter，如果要删除 I2C 适配器的话使用 i2c_del_adapter 函数即可。 12345678910int i2c_add_adapter(struct i2c_adapter *adapter)int i2c_add_numbered_adapter(struct i2c_adapter *adap)&#x2F;&#x2F;这两个函数的区别在于 i2c_add_adapter 使用动态的总线号，而 i2c_add_numbered_adapter使用静态总线号。&#x2F;&#x2F;adapter 或 adap：要添加到 Linux 内核中的 i2c_adapter，也就是 I2C 适配器。&#x2F;&#x2F;返回值：0，成功；负值，失败。void i2c_del_adapter(struct i2c_adapter * adap)&#x2F;&#x2F;adap：要删除的 I2C 适配器。&#x2F;&#x2F;返回值：无。 一般 SOC 的 I2C 总线驱动都是由半导体厂商编写的，比如 I.MX6U 的 I2C 适配器驱动 NXP 已经编写好了，这个不需要用户去编写。只要专注于 I2C 设备驱 动即可。 I2C 设备驱动I2C 设备驱动重点关注两个数据结构：i2c_client 和 i2c_driver，i2c_client 就是描述设备信息的，i2c_driver 描述驱动内容，类似于 platform_driver。 1、i2c_client 结构体1234567891011struct i2c_client &#123; unsigned short flags; &#x2F;* 标志 *&#x2F; unsigned short addr; &#x2F;* 芯片地址，7 位，存在低 7 位*&#x2F; ...... char name[I2C_NAME_SIZE]; &#x2F;* 名字 *&#x2F; struct i2c_adapter *adapter; &#x2F;* 对应的 I2C 适配器 *&#x2F; struct device dev; &#x2F;* 设备结构体 *&#x2F; int irq; &#x2F;* 中断 *&#x2F; struct list_head detected; ......&#125;; 一个设备对应一个 i2c_client，每检测到一个 I2C 设备就会给这个 I2C 设备分配一个i2c_client。 2、i2c_driver 结构体i2c_driver 类似 platform_driver，是编写 I2C 设备驱动重点要处理的内容， 1234567891011struct i2c_driver &#123; ……………… int (*probe)(struct i2c_client *, const struct i2c_device_id *); ……………… struct device_driver driver; const struct i2c_device_id *id_table; ………………&#125;&#x2F;&#x2F;当 I2C 设备和驱动匹配成功以后 probe 函数就会执行，和 platform 驱动一样。 &#x2F;&#x2F;device_driver 驱动结构体，如果使用设备树的话，需要设置 device_driver 的of_match_table 成员变量， 也就是驱动的兼容(compatible)属性。 &#x2F;&#x2F;id_table 是传统的、未使用设备树的设备匹配 ID 表。 重点工作就是构建 i2c_driver，构建完成以后需要向Linux 内核注册这个 i2c_driver。i2c_driver 注册函数为 int i2c_register_driver，注销 I2C 设备驱动的时候需要将前面注册的 i2c_driver 从 Linux 内核中注销掉，需要用到 i2c_del_driver 函数， 12345678int i2c_register_driver(struct module *owner, struct i2c_driver *driver)&#x2F;&#x2F;owner：一般为 THIS_MODULE。&#x2F;&#x2F;driver：要注册的 i2c_driver。&#x2F;&#x2F;返回值：0，成功；负值，失败。void i2c_del_driver(struct i2c_driver *driver)&#x2F;&#x2F;driver：要注销的 i2c_driver。&#x2F;&#x2F;返回值：无。 i2c_driver 的注册示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#x2F;* i2c 驱动的 probe 函数 *&#x2F;static int xxx_probe(struct i2c_client *client, const struct i2c_device_id *id)&#123; &#x2F;* 函数具体程序 *&#x2F; return 0; &#125;&#x2F;* i2c 驱动的 remove 函数 *&#x2F;static int ap3216c_remove(struct i2c_client *client)&#123; &#x2F;* 函数具体程序 *&#x2F; return 0;&#125;&#x2F;* 传统匹配方式 ID 列表 *&#x2F;static const struct i2c_device_id xxx_id[] &#x3D; &#123; &#123;&quot;xxx&quot;, 0&#125;, &#123;&#125;&#125;;&#x2F;* 设备树匹配列表 *&#x2F;static const struct of_device_id xxx_of_match[] &#x3D; &#123; &#123; .compatible &#x3D; &quot;xxx&quot; &#125;, &#123; &#x2F;* Sentinel *&#x2F; &#125;&#125;;&#x2F;* i2c 驱动结构体 *&#x2F;static struct i2c_driver xxx_driver &#x3D; &#123; .probe &#x3D; xxx_probe, .remove &#x3D; xxx_remove, .driver &#x3D; &#123; .owner &#x3D; THIS_MODULE, .name &#x3D; &quot;xxx&quot;, .of_match_table &#x3D; xxx_of_match, &#125;, .id_table &#x3D; xxx_id,&#125;;&#x2F;* 驱动入口函数 *&#x2F;static int __init xxx_init(void)&#123; int ret &#x3D; 0; ret &#x3D; i2c_add_driver(&amp;xxx_driver); return ret;&#125;&#x2F;* 驱动出口函数 *&#x2F;static void __exit xxx_exit(void)&#123; i2c_del_driver(&amp;xxx_driver);&#125;module_init(xxx_init);module_exit(xxx_exit); i2c_device_id，无设备树的时候匹配 ID 表。 of_device_id，设备树所使用的匹配表。 i2c_driver，当 I2C 设备和 I2C 驱动匹配成功以后 probe 函数就会执行，这些和 platform 驱动一样，probe 函数里面基本就是标准的字符设备驱动那一套了。 I2C 设备和驱动匹配过程I2C 设备和驱动的匹配过程是由 I2C 核心来完成的，drivers/i2c/i2c-core.c 就是 I2C 的核心部分。 设备和驱动的匹配过程也是由 I2C 总线完成的，I2C 总线的数据结构为 i2c_bus_type，定义 在 drivers/i2c/i2c-core.c 文件，i2c_bus_type 内容如下： 1234567struct bus_type i2c_bus_type &#x3D; &#123; .name &#x3D; &quot;i2c&quot;, .match &#x3D; i2c_device_match,&#x2F;&#x2F;.match 就是 I2C 总线的设备和驱动匹配函数， .probe &#x3D; i2c_device_probe, .remove &#x3D; i2c_device_remove, .shutdown &#x3D; i2c_device_shutdown,&#125;; I.MX6U 的 I2C 适配器驱动分析Linux 下的 I2C 驱动框架，重点分为 I2C 适配器驱动和 I2C 设备驱动， 其中 I2C 适配器驱动就是 SOC 的 I2C 控制器驱动。I2C 设备驱动是需要用户根据不同的 I2C 设备去编写，而 I2C 适配器驱动一般都是 SOC 厂商去编写的，比如 NXP 就编写好了 I.MX6U 的I2C 适配器驱动。I.MX6U 的 I2C 适配器驱动是个标准的 platform 驱动，虽然 I2C 总线为别的设备提供了一种I2C总线驱动框架，但是 I2C 适配器却是 platform驱动。 在 imx6ull.dtsi 文件中找到 I.MX6U 的 I2C1 控制器节点，i2c1 节点的 compatible 属性值有两个：“fsl,imx6ul-i2c”和“fsl,imx21- i2c”。I.MX6U 的 I2C 适配器驱动文件为 drivers/i2c/busses/i2c-imx.c中设备树 ID为“fsl,imx21-i2c”属性值，设备树中 i2c1 节点的 compatible 属性值就是与此匹配上的。因此 i2c-imx.c 文件就是 I.MX6U 的 I2C 适配器驱动文件。 当设备和驱动匹配成功以后 i2c_imx_probe 函数就会执行，i2c_imx_probe 函数就会完成 I2C 适配器初始化工作。 i2c_imx_probe 函数主要的工作就是一下两点： 初始化 i2c_adapter，设置 i2c_algorithm 为 i2c_imx_algo，最后向 Linux 内核注册i2c_adapter。 初始化 I2C1 控制器的相关寄存器。 i2c_imx_algo 包含 I2C1 适配器与 I2C 设备的通信函数 master_xfer，i2c_imx_probe中设置i2c_adapter的algo成员变量为i2c_imx_algo，也就是设置 i2c_algorithm。 123456static struct i2c_algorithm i2c_imx_algo &#x3D; &#123; .master_xfer &#x3D; i2c_imx_xfer, .functionality &#x3D; i2c_imx_func,&#125;;&#x2F;&#x2F;.functionality用于返回此I2C适配器支持什么样的通信协议&#x2F;&#x2F;.master_xfer通过此函数来完成与 I2C 设备通信的 functionality用于返回此I2C适配器支持什么样的通信协议，在这里 functionality 就是 i2c_imx_func 函数， 123static u32 i2c_imx_func(struct i2c_adapter *adapter) &#123; return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_READ_BLOCK_DATA; &#125; i2c_imx_xfer 函数，因为最终就是通过此函数来完成与 I2C 设备通信的， 1234567891011121314151617static int i2c_imx_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)&#123; ……………… &#x2F;* Start I2C transfer *&#x2F; result &#x3D; i2c_imx_start(i2c_imx); if (msgs[i].flags &amp; I2C_M_RD) result &#x3D; i2c_imx_read(i2c_imx, &amp;msgs[i], is_lastmsg); else &#123; if (i2c_imx-&gt;dma &amp;&amp; msgs[i].len &gt;&#x3D; DMA_THRESHOLD) result &#x3D; i2c_imx_dma_write(i2c_imx, &amp;msgs[i]); else result &#x3D; i2c_imx_write(i2c_imx, &amp;msgs[i]); &#125; ……………… i2c_imx_stop(i2c_imx);&#125; 调用 i2c_imx_start 函数开启 I2C 通信。 如果是从 I2C 设备读数据的话就调用 i2c_imx_read 函数 向 I2C 设备写数据，如果要用 DMA 的话就使用 i2c_imx_dma_write 函数来完成写数据。如果不使用 DMA 的话就使用 i2c_imx_write 函数完成写数据。 I2C 通信完成以后调用 i2c_imx_stop 函数停止 I2C 通信。 I2C 设备驱动编写流程I2C 适配器驱动 SOC 厂商已经替我们编写好了，我们需要做的就是编写具体的设备驱动 1、I2C 设备信息描1、未使用设备树的时候 首先肯定要描述 I2C 设备节点信息，在未使用设备树的时候需要在 BSP 里面使用 i2c_board_info 结构体来描述一个具体的 I2C 设备。i2c_board_info 结构体如下： 1234567891011struct i2c_board_info &#123; char type[I2C_NAME_SIZE]; &#x2F;* I2C 设备名字 *&#x2F; unsigned short flags; &#x2F;* 标志 *&#x2F; unsigned short addr; &#x2F;* I2C 器件地址 *&#x2F; void *platform_data; struct dev_archdata *archdata; struct device_node *of_node; struct fwnode_handle *fwnode; int irq;&#125;;&#x2F;&#x2F;type 和 addr 这两个成员变量是必须要设置的，一个是 I2C 设备的名字，一个是 I2C 设备的器件地址。 2、使用设备树的时候 使用设备树的时候 I2C 设备信息通过在 i2c节点下创建子节点，然后在这个子节点内描述设备芯片的相关信息。 2、I2C 设备数据收发处理流程I2C 设备驱动首先要做的就是初始化 i2c_driver 并向 Linux 内核注册。当设备和驱动匹配以后 i2c_driver 里面的 probe 函数就会执行，probe 函数里面所做的就是字符设备驱动那一套了。一般需要在 probe 函数里面初始化 I2C 设备，要初始化 I2C 设备就必须能够对 I2C 设备寄存器进行读写操作，这里就要用到 i2c_transfer 函数了。i2c_transfer 函数最终会调用 I2C 适配器中 i2c_algorithm 里面的 master_xfer 函数，对于 I.MX6U 而言就是i2c_imx_xfer 这个函数。i2c_transfer 函数原型如下： 12345int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)&#x2F;&#x2F;adap：所使用的 I2C 适配器，i2c_client 会保存其对应的 i2c_adapter。&#x2F;&#x2F;msgs：I2C 要发送的一个或多个消息。&#x2F;&#x2F;num：消息数量，也就是 msgs 的数量。&#x2F;&#x2F;返回值：负值，失败，其他非负值，发送的 msgs数量。 参数msgs ，这是一个 i2c_msg 类型的指针参数，Linux 内核使用 i2c_msg 结构体来描述一个消息，使用 i2c_transfer 函数发送数据之前要先构建好 i2c_msg。i2c_msg 结构体定义 在 include/uapi/linux/i2c.h 文件中， 1234567891011121314struct i2c_msg &#123; __u16 addr; &#x2F;* 从机地址 *&#x2F; __u16 flags; &#x2F;* 标志 *&#x2F; #define I2C_M_TEN 0x0010 #define I2C_M_RD 0x0001 #define I2C_M_STOP 0x8000 #define I2C_M_NOSTART 0x4000 #define I2C_M_REV_DIR_ADDR 0x2000 #define I2C_M_IGNORE_NAK 0x1000 #define I2C_M_NO_RD_ACK 0x0800 #define I2C_M_RECV_LEN 0x0400 __u16 len; &#x2F;* 消息(本msg)长度 *&#x2F; __u8 *buf; &#x2F;* 消息数据 *&#x2F;&#125;; 使用 i2c_transfer 进行 I2C 数据收发的示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#x2F;* 设备结构体 *&#x2F;struct xxx_dev &#123; ...... void *private_data; &#x2F;* 私有数据，一般会设置为 i2c_client *&#x2F;&#125;;&#x2F;** @description : 读取 I2C 设备多个寄存器数据* @param – dev : I2C 设备* @param – reg : 要读取的寄存器首地址* @param – val : 读取到的数据* @param – len : 要读取的数据长度* @return : 操作结果*&#x2F;static int xxx_read_regs(struct xxx_dev *dev, u8 reg, void *val, int len)&#123; int ret; struct i2c_msg msg[2]; struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data; &#x2F;* msg[0]，第一条写消息，发送要读取的寄存器首地址 *&#x2F; msg[0].addr &#x3D; client-&gt;addr; &#x2F;* I2C 器件地址 *&#x2F; msg[0].flags &#x3D; 0; &#x2F;* 标记为发送数据 *&#x2F; msg[0].buf &#x3D; &amp;reg; &#x2F;* 读取的首地址 *&#x2F; msg[0].len &#x3D; 1; &#x2F;* reg 长度 *&#x2F; &#x2F;* msg[1]，第二条读消息，读取寄存器数据 *&#x2F; msg[1].addr &#x3D; client-&gt;addr; &#x2F;* I2C 器件地址 *&#x2F; msg[1].flags &#x3D; I2C_M_RD; &#x2F;* 标记为读取数据 *&#x2F; msg[1].buf &#x3D; val; &#x2F;* 读取数据缓冲区 *&#x2F; msg[1].len &#x3D; len; &#x2F;* 要读取的数据长度 *&#x2F; ret &#x3D; i2c_transfer(client-&gt;adapter, msg, 2); if(ret &#x3D;&#x3D; 2) &#123; ret &#x3D; 0; &#125; else &#123; ret &#x3D; -EREMOTEIO; &#125; return ret;&#125;&#x2F;** @description : 向 I2C 设备多个寄存器写入数据* @param – dev : 要写入的设备结构体* @param – reg : 要写入的寄存器首地址* @param – val : 要写入的数据缓冲区* @param – len : 要写入的数据长度* @return : 操作结果*&#x2F;static s32 xxx_write_regs(struct xxx_dev *dev, u8 reg, u8 *buf, u8 len)&#123; u8 b[256]; struct i2c_msg msg; struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data; b[0] &#x3D; reg; &#x2F;* 寄存器首地址 *&#x2F; memcpy(&amp;b[1],buf,len); &#x2F;* 将要发送的数据拷贝到数组 b 里面 *&#x2F; msg.addr &#x3D; client-&gt;addr; &#x2F;* I2C 器件地址 *&#x2F; msg.flags &#x3D; 0; &#x2F;* 标记为写数据 *&#x2F; msg.buf &#x3D; b; &#x2F;* 要发送的数据缓冲区 *&#x2F; msg.len &#x3D; len + 1; &#x2F;* 要发送的数据长度 *&#x2F; return i2c_transfer(client-&gt;adapter, &amp;msg, 1);&#125; 在设备结构体里面添加一个执行void的指针成员变量private_data，此成员变量用于保存设备的私有数据。在 I2C 设备驱动中我们一般将其指向 I2C 设备对应的i2c_client。 xxx_read_regs 函数用于读取 I2C 设备多个寄存器数据。定义了一个i2c_msg 数组，2 个数组元素，因为 I2C 读取数据的时候要先发送要读取的寄存器地址，然后再读取数据，所以需要准备两个 i2c_msg。一个用于发送寄存器地址，一个用于读取寄存器值。对于 msg[0]，将 flags 设置为 0，表示写数据。msg[0]的 addr 是 I2C 设备的器件地址，msg[0]的 buf成员变量就是要读取的寄存器地址。对于 msg[1]，将 flags 设置为 I2C_M_RD，表示读取数据。msg[1]的 buf 成员变量用于保存读取到的数据，len 成员变量就是要读取的数据长度。调用i2c_transfer 函数完成 I2C 数据读操作。 xxx_write_regs 函数用于向 I2C 设备多个寄存器写数据，I2C 写操作要比读操作简单一点，因此一个 i2c_msg 即可。数组 b 用于存放寄存器首地址和要发送的数据，第 59 行设置 msg 的 addr 为 I2C 器件地址。第 60 行设置 msg 的 flags 为 0，也就是写数据。第 62 行设置要发送的数据，也就是数组 b。第 63 行设置 msg 的 len 为 len+1，因为要加上一个字节的寄存器地址。最后通过 i2c_transfer 函数完成向 I2C 设备的写操作。 实验程序编写1、修改设备树1.IO 修改或添加 首先肯定是要修改 IO，AP3216C 用到了 I2C1 接口，I.MX6U-ALPHA 开发板上的 I2C1 接口使用到了 UART4_TXD 和 UART4_RXD，因此肯定要在设备树里面设置这两个 IO。如果要用 到 AP3216C 的中断功能的话还需要初始化 AP_INT 对应的 GIO1_IO01 这个 IO，不使用中断功能。因此只需要设置 UART4_TXD 和 UART4_RXD 这两个 IO， 123456pinctrl_i2c1: i2c1grp &#123; fsl,pins &#x3D; &lt; MX6UL_PAD_UART4_TX_DATA__I2C1_SCL 0x4001b8b0 MX6UL_PAD_UART4_RX_DATA__I2C1_SDA 0x4001b8b0 &gt;;&#125;; pinctrl_i2c1 就是 I2C1 的 IO 节点，这里将 UART4_TXD 和 UART4_RXD 这两个 IO 分别复用为 I2C1_SCL 和 I2C1_SDA，电气属性都设置为 0x4001b8b0。 2.在 i2c1 节点追加 ap3216c 子节点 将 i2c1 节点里面原有的 mag3110 和 fxls8471 这两个 I2C 子节点删除，然后添加 ap3216c子节点信息 1234567891011&amp;i2c1 &#123; clock-frequency &#x3D; &lt;100000&gt;; pinctrl-names &#x3D; &quot;default&quot;; pinctrl-0 &#x3D; &lt;&amp;pinctrl_i2c1&gt;; status &#x3D; &quot;okay&quot;; ap3216c@1e &#123; compatible &#x3D; &quot;alientek,ap3216c&quot;; reg &#x3D; &lt;0x1e&gt;; &#125;;&#125;; 第 7 行，ap3216c 子节点，@后面的“1e”是 ap3216c 的器件地址。第 8 行，设置 compatible 值为“alientek,ap3216c”。第 9 行，reg 属性也是设置 ap3216c 器件地址的，因此 reg 设置为 0x1e。设备树修改完成以后使用“make dtbs”重新编译一下，然后使用新的设备树启动 Linux 内核。/sys/bus/i2c/devices 目录下存放着所有 I2C 设备，如果设备树修改正确的话，会在/sys/bus/i2c/devices 目录下看到一个名为“0-001e”的子目录，“0-001e”就是 ap3216c 的设备目录，“1e”就是 ap3216c 器件地址。 2、AP3216C 驱动编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250&#x2F;***************************************************************文件名 : ap3216c.c描述 : AP3216C驱动程序***************************************************************&#x2F;struct ap3216c_dev &#123; void *private_data; &#x2F;* 私有数据 *&#x2F; unsigned short ir, als, ps; &#x2F;* 三个光传感器数据 *&#x2F;&#125;;static struct ap3216c_dev ap3216cdev;&#x2F;* * @description : 从ap3216c读取多个寄存器数据 * @param - dev: ap3216c设备 * @param - reg: 要读取的寄存器首地址 * @param - val: 读取到的数据 * @param - len: 要读取的数据长度 * @return : 操作结果 *&#x2F;static int ap3216c_read_regs(struct ap3216c_dev *dev, u8 reg, void *val, int len)&#123; int ret; struct i2c_msg msg[2]; struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data; &#x2F;* msg[0]为发送要读取的首地址 *&#x2F; msg[0].addr &#x3D; client-&gt;addr; &#x2F;* ap3216c地址 *&#x2F; msg[0].flags &#x3D; 0; &#x2F;* 标记为发送数据 *&#x2F; msg[0].buf &#x3D; &amp;reg; &#x2F;* 读取的首地址 *&#x2F; msg[0].len &#x3D; 1; &#x2F;* reg长度*&#x2F; &#x2F;* msg[1]读取数据 *&#x2F; msg[1].addr &#x3D; client-&gt;addr; &#x2F;* ap3216c地址 *&#x2F; msg[1].flags &#x3D; I2C_M_RD; &#x2F;* 标记为读取数据*&#x2F; msg[1].buf &#x3D; val; &#x2F;* 读取数据缓冲区 *&#x2F; msg[1].len &#x3D; len; &#x2F;* 要读取的数据长度*&#x2F; ret &#x3D; i2c_transfer(client-&gt;adapter, msg, 2); if(ret &#x3D;&#x3D; 2) &#123; ret &#x3D; 0; &#125; else &#123; printk(&quot;i2c rd failed&#x3D;%d reg&#x3D;%06x len&#x3D;%d\\n&quot;,ret, reg, len); ret &#x3D; -EREMOTEIO; &#125; return ret;&#125;&#x2F;* * @description : 向ap3216c多个寄存器写入数据 * @param - dev: ap3216c设备 * @param - reg: 要写入的寄存器首地址 * @param - val: 要写入的数据缓冲区 * @param - len: 要写入的数据长度 * @return : 操作结果 *&#x2F;static s32 ap3216c_write_regs(struct ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)&#123; u8 b[256]; struct i2c_msg msg; struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data; b[0] &#x3D; reg; &#x2F;* 寄存器首地址 *&#x2F; memcpy(&amp;b[1],buf,len); &#x2F;* 将要写入的数据拷贝到数组b里面 *&#x2F; msg.addr &#x3D; client-&gt;addr; &#x2F;* ap3216c地址 *&#x2F; msg.flags &#x3D; 0; &#x2F;* 标记为写数据 *&#x2F; msg.buf &#x3D; b; &#x2F;* 要写入的数据缓冲区 *&#x2F; msg.len &#x3D; len + 1; &#x2F;* 要写入的数据长度 *&#x2F; return i2c_transfer(client-&gt;adapter, &amp;msg, 1);&#125;&#x2F;* * @description : 读取ap3216c指定寄存器值，读取一个寄存器 * @param - dev: ap3216c设备 * @param - reg: 要读取的寄存器 * @return : 读取到的寄存器值 *&#x2F;static unsigned char ap3216c_read_reg(struct ap3216c_dev *dev, u8 reg)&#123; u8 data &#x3D; 0; ap3216c_read_regs(dev, reg, &amp;data, 1); return data;#if 0 struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data; return i2c_smbus_read_byte_data(client, reg);#endif&#125;&#x2F;* * @description : 向ap3216c指定寄存器写入指定的值，写一个寄存器 * @param - dev: ap3216c设备 * @param - reg: 要写的寄存器 * @param - data: 要写入的值 * @return : 无 *&#x2F;static void ap3216c_write_reg(struct ap3216c_dev *dev, u8 reg, u8 data)&#123; u8 buf &#x3D; 0; buf &#x3D; data; ap3216c_write_regs(dev, reg, &amp;buf, 1);&#125;&#x2F;* * @description : 读取AP3216C的数据，读取原始数据，包括ALS,PS和IR, 注意！ * : 如果同时打开ALS,IR+PS的话两次数据读取的时间间隔要大于112.5ms * @param - ir : ir数据 * @param - ps : ps数据 * @param - ps : als数据 * @return : 无。 *&#x2F;void ap3216c_readdata(struct ap3216c_dev *dev)&#123; unsigned char i &#x3D;0; unsigned char buf[6]; &#x2F;* 循环读取所有传感器数据 *&#x2F; for(i &#x3D; 0; i &lt; 6; i++) &#123; buf[i] &#x3D; ap3216c_read_reg(dev, AP3216C_IRDATALOW + i); &#125; if(buf[0] &amp; 0X80) &#x2F;* IR_OF位为1,则数据无效 *&#x2F; dev-&gt;ir &#x3D; 0; else &#x2F;* 读取IR传感器的数据 *&#x2F; dev-&gt;ir &#x3D; ((unsigned short)buf[1] &lt;&lt; 2) | (buf[0] &amp; 0X03); dev-&gt;als &#x3D; ((unsigned short)buf[3] &lt;&lt; 8) | buf[2]; &#x2F;* 读取ALS传感器的数据 *&#x2F; if(buf[4] &amp; 0x40) &#x2F;* IR_OF位为1,则数据无效 *&#x2F; dev-&gt;ps &#x3D; 0; else &#x2F;* 读取PS传感器的数据 *&#x2F; dev-&gt;ps &#x3D; ((unsigned short)(buf[5] &amp; 0X3F) &lt;&lt; 4) | (buf[4] &amp; 0X0F); &#125;&#x2F;* * @description : 打开设备 * @param - inode : 传递给驱动的inode * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量 * 一般在open的时候将private_data指向设备结构体。 * @return : 0 成功;其他 失败 *&#x2F;static int ap3216c_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data &#x3D; &amp;ap3216cdev; &#x2F;* 初始化AP3216C *&#x2F; ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, 0x04); &#x2F;* 复位AP3216C *&#x2F; mdelay(50); &#x2F;* AP3216C复位最少10ms *&#x2F; ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, 0X03); &#x2F;* 开启ALS、PS+IR *&#x2F; return 0;&#125;&#x2F;* * @description : 从设备读取数据 * @param - filp : 要打开的设备文件(文件描述符) * @param - buf : 返回给用户空间的数据缓冲区 * @param - cnt : 要读取的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 读取的字节数，如果为负值，表示读取失败 *&#x2F;static ssize_t ap3216c_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off)&#123; short data[3]; long err &#x3D; 0; struct ap3216c_dev *dev &#x3D; (struct ap3216c_dev *)filp-&gt;private_data; ap3216c_readdata(dev); data[0] &#x3D; dev-&gt;ir; data[1] &#x3D; dev-&gt;als; data[2] &#x3D; dev-&gt;ps; err &#x3D; copy_to_user(buf, data, sizeof(data)); return 0;&#125;&#x2F;* * @description : 关闭&#x2F;释放设备 * @param - filp : 要关闭的设备文件(文件描述符) * @return : 0 成功;其他 失败 *&#x2F;static int ap3216c_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;&#x2F;* AP3216C操作函数 *&#x2F;static const struct file_operations ap3216c_ops &#x3D; &#123; .owner &#x3D; THIS_MODULE, .open &#x3D; ap3216c_open, .read &#x3D; ap3216c_read, .release &#x3D; ap3216c_release,&#125;; &#x2F;* * @description : i2c驱动的probe函数，当驱动与 * 设备匹配以后此函数就会执行 * @param - client : i2c设备 * @param - id : i2c设备ID * @return : 0，成功;其他负值,失败 *&#x2F;static int ap3216c_probe(struct i2c_client *client, const struct i2c_device_id *id)&#123; &#x2F;* 1、构建设备号 *&#x2F; &#x2F;* 2、注册设备 *&#x2F; &#x2F;* 3、创建类 *&#x2F; &#x2F;* 4、创建设备 *&#x2F; ap3216cdev.private_data &#x3D; client; return 0;&#125;&#x2F;* * @description : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行 * @param - client : i2c设备 * @return : 0，成功;其他负值,失败 *&#x2F;static int ap3216c_remove(struct i2c_client *client)&#123; &#x2F;* 删除设备 *&#x2F; &#x2F;* 注销掉类和设备 *&#x2F; return 0;&#125;&#x2F;* 传统匹配方式ID列表 *&#x2F;static const struct i2c_device_id ap3216c_id[] &#x3D; &#123; &#123;&quot;alientek,ap3216c&quot;, 0&#125;, &#123;&#125;&#125;;&#x2F;* 设备树匹配列表 *&#x2F;static const struct of_device_id ap3216c_of_match[] &#x3D; &#123; &#123; .compatible &#x3D; &quot;alientek,ap3216c&quot; &#125;, &#123; &#x2F;* Sentinel *&#x2F; &#125;&#125;;&#x2F;* i2c驱动结构体 *&#x2F; static struct i2c_driver ap3216c_driver &#x3D; &#123; .probe &#x3D; ap3216c_probe, .remove &#x3D; ap3216c_remove, .driver &#x3D; &#123; .owner &#x3D; THIS_MODULE, .name &#x3D; &quot;ap3216c&quot;, .of_match_table &#x3D; ap3216c_of_match, &#125;, .id_table &#x3D; ap3216c_id,&#125;; ap3216c 设备结构体的 private_data 成员变量用于存放 ap3216c 对应的 i2c_client。 ir、als 和 ps 分别存储 AP3216C 的 IR、ALS 和 PS 数据。定义一个 ap3216c_dev 类型的设备结构体变量 ap3216cdev。 ap3216c_read_regs 函数实现多字节读取，但是 AP3216C 好像不支持连续多字节读取，此函数在测试其他 I2C 设备的时候可以实现多给字节连续读取，但是在 AP3216C 上不能连续读取多个字节。不过读取一个字节没有问题的。ap3216c_write_regs 函数实现连续多字节写操作。 ap3216c_read_reg 函数用于读取 AP3216C 的指定寄存器数据，用于一个寄存器的数据读取。ap3216c_write_reg 函数用于向 AP3216C 的指定寄存器写入数据，用于一个寄存器的数据写操作。 ap3216c_probe 函数，当 I2C 设备和驱动匹配成功以后此函数就会执行，platform 驱动框架一样。此函数前面都是标准的字符设备注册代码，最后面会将此函数的第一个参数 client 传递给 ap3216cdev 的 private_data 成员变量。 ap3216c_id 匹配表，i2c_device_id 类型。用于传统的设备和驱动匹配，也就是没有使用设备树的时候。ap3216c_of_match 匹配表，of_device_id 类型，用于设备树设备和驱动匹配。这里只写了一个 compatible 属性，值为“alientek,ap3216c”。 ap3216c_driver 结构体变量，i2c_driver 类型。 驱动入口函数 ap3216c_init，此函数通过调用 i2c_add_driver 来向 Linux 内核注册 i2c_driver，也就是ap3216c_driver。 驱动出口函数 ap3216c_exit，此函数通过调用 i2c_del_driver 来注销掉前面注册的 ap3216c_driver。","link":"","tags":[]},{"title":"Linux驱动-RTC驱动","date":"2021-04-17T05:04:41.000Z","path":"2021/04/17/Linux驱动-RTC驱动/","text":"Linux 内核 RTC 驱动RTC 设备驱动是一个标准的字符设备驱动，应用程序通过 open、release、read、write 和 ioctl等函数完成对 RTC 设备的操作。Linux 内核将 RTC 设备抽象为 rtc_device 结构体，因此 RTC 设备驱动就是申请并初始化rtc_device，最后将 rtc_device 注册到 Linux 内核里面，这样 Linux 内核就有一个 RTC 设备的。 rtc_device 结构体，此结构体定义在 include/linux/rtc.h 文件中，结构体内容如下(删除条件编译)： 123456789101112131415struct rtc_device&#123; struct device dev; &#x2F;* 设备 *&#x2F; struct module *owner; int id; &#x2F;* ID *&#x2F; char name[RTC_DEVICE_NAME_SIZE]; &#x2F;* 名字 *&#x2F; const struct rtc_class_ops *ops; &#x2F;* RTC 设备底层操作函数 *&#x2F; struct mutex ops_lock; struct cdev char_dev; &#x2F;* 字符设备 *&#x2F; unsigned long flags; ………………&#125;; RTC 设备的操作是用一个 rtc_class_ops 类型的操作集合(结构体)来表示的，就是是 ops 成员变量，这是一个 rtc_class_ops 类型的指针变量。rtc_class_ops为 RTC 设备的最底层操作函数集合，包括从 RTC 设备中读取时间、向 RTC 设备写入新的时间值等。因此，rtc_class_ops 是需要用户根据所使用的 RTC 设备编写的 1234567891011121314struct rtc_class_ops &#123; int (*open)(struct device *); void (*release)(struct device *); int (*ioctl)(struct device *, unsigned int, unsigned long); int (*read_time)(struct device *, struct rtc_time *); int (*set_time)(struct device *, struct rtc_time *); int (*read_alarm)(struct device *, struct rtc_wkalrm *); int (*set_alarm)(struct device *, struct rtc_wkalrm *); int (*proc)(struct device *, struct seq_file *); int (*set_mmss64)(struct device *, time64_t secs); int (*set_mmss)(struct device *, unsigned long secs); int (*read_callback)(struct device *, int data); int (*alarm_irq_enable)(struct device *, unsigned int enabled);&#125;; rtc_class_ops 中的这些函数只是最底层的 RTC 设备操作函数，并不是提供给应用层的file_operations 函数操作集。RTC 是个字符设备，那么肯定有字符设备的 file_operations 函数操作集，Linux 内核提供了一个 RTC 通用字符设备驱动文件，文件名为 drivers/rtc/rtc-dev.c，rtc-dev.c 文件提供了所有 RTC 设备共用的 file_operations 函数操作集，如下所示： 12345678910static const struct file_operations rtc_dev_fops &#x3D; &#123; .owner &#x3D; THIS_MODULE, .llseek &#x3D; no_llseek, .read &#x3D; rtc_dev_read, .poll &#x3D; rtc_dev_poll, .unlocked_ioctl &#x3D; rtc_dev_ioctl, .open &#x3D; rtc_dev_open, .release &#x3D; rtc_dev_release, .fasync &#x3D; rtc_dev_fasync,&#125;; rtc_dev_fops是标准的字符设备操作集。应用程序可以通过 ioctl 函数来设置/读取时间、设置/读取闹钟的操作，那么驱动中对应的 rtc_dev_ioctl 函数就会执行， rtc_dev_ioctl 最终会通过操作 rtc_class_ops 中的 read_time、set_time 等函数来对具体 RTC 设备的读写操作。 如果向rtc_dev_ioctl 函数传入参数cmd=RTC_RD_TIME (时间读取命令)，就会调用 rtc_read_time 函数会调用_ _rtc_read_time函数，__rtc_read_time 函数再通过调用 rtc_class_ops 中的read_time 函数来从 RTC 设备中获取当前时间。rtc_dev_ioctl 函数对其他的命令处理都是类似的，传入参数cmd=RTC_ALM_READ (闹钟读取命令) ，就会调用 rtc_read_alarm ，而 rtc_read_alarm 函数再经过层层调用，最终会调用 rtc_class_ops 中的 read_alarm 函数来获取闹钟值。 当 rtc_class_ops 准备好以后需要将其注册到 Linux 内核中，可以使用rtc_device_register函数完成注册工作。此函数会申请一个rtc_device并且初始化这个rtc_device，最后向调用者返回这个 rtc_device，当卸载 RTC 驱动的时候需要调用 rtc_device_unregister 函数来注销注册的 rtc_device， 1234567891011struct rtc_device *rtc_device_register(const char *name, struct device *dev, const struct rtc_class_ops *ops, struct module *owner)&#x2F;&#x2F;name：设备名字。&#x2F;&#x2F;dev：设备。&#x2F;&#x2F;ops：RTC 底层驱动函数集。&#x2F;&#x2F;owner：驱动模块拥有者。&#x2F;&#x2F;返回值：注册成功的话就返回 rtc_device，错误的话会返回一个负值。void rtc_device_unregister(struct rtc_device *rtc)&#x2F;&#x2F;rtc：要删除的 rtc_device。&#x2F;&#x2F;返回值：无。 I.MX6U 内部 RTC 驱动分析I.MX6U 的 RTC 驱动不用自己编写，因为 NXP 已经写好了。其实对于大多数的 SOC 来讲，内部 RTC 驱动都不需要我们去编写，半导体厂商会编写好。得看一下这些原厂是怎么编写 RTC 驱动的。 分析驱动，先从设备树入手，打开 imx6ull.dtsi，在里面找到如下 snvs_rtc 设备节点，设置兼容属性 compatible 的值为“fsl,sec-v4.0-mon-rtc-lp”。驱动文件rtc-snvs.c中的设备树 ID 表有一条 compatible 属性，值为“fsl,sec-v4.0-mon-rtc-lp”，因此 imx6ull.dtsi 中的 snvs_rtc 设备节点会和此驱动匹配。该驱动文件采用标准的 platform 驱动框架，当设备和驱动匹配成功以后 snvs_rtc_probe 函数就会执行。 12345678910111213141516171819202122232425static int snvs_rtc_probe(struct platform_device *pdev)&#123; res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0); mmio &#x3D; devm_ioremap_resource(&amp;pdev-&gt;dev, res); ……………… data-&gt;regmap &#x3D; devm_regmap_init_mmio(&amp;pdev-&gt;dev, mmio, &amp;snvs_rtc_config); ……………… data-&gt;irq &#x3D; platform_get_irq(pdev, 0); ……………… &#x2F;* Initialize glitch detect *&#x2F; regmap_write(data-&gt;regmap, data-&gt;offset + SNVS_LPPGDR,SNVS_LPPGDR_INIT); &#x2F;* Clear interrupt status *&#x2F; regmap_write(data-&gt;regmap, data-&gt;offset + SNVS_LPSR,0xffffffff); &#x2F;* Enable RTC *&#x2F; snvs_rtc_enable(data, true); ret &#x3D; devm_request_irq(&amp;pdev-&gt;dev, data-&gt;irq,snvs_rtc_irq_handler, IRQF_SHARED, &quot;rtc alarm&quot;, &amp;pdev-&gt;dev); data-&gt;rtc &#x3D; devm_rtc_device_register(&amp;pdev-&gt;dev, pdev-&gt;name, &amp;snvs_rtc_ops, THIS_MODULE); &#125; 调用 platform_get_resource 函数从设备树中获取到 RTC 外设寄存器基地址。 调用函数 devm_ioremap_resource 完成内存映射，得到 RTC 外设寄存器物理基地址对应的虚拟地址。 Linux3.1 引入了一个全新的 regmap 机制，regmap 用于提供一套方便的 API 函数去操作底层硬件寄存器，以提高代码的可重用性。snvs-rtc.c 文件会采用 regmap 机制来读写RTC 底层硬件寄存器。这里使用 devm_regmap_init_mmio 函数将 RTC 的硬件寄存器转化为regmap 形式，这样 regmap 机制的 regmap_write、regmap_read 等 API 函数才能操作寄存器。 调用platform_get_irq从设备树中获取 RTC 的中断号。 调用regmap_write设置 RTC_ LPPGDR 寄存器值为 SNVS_LPPGDR_INIT= 0x41736166，这里就是用的 regmap 机制的 regmap_write 函数完成对寄存器进行写操作。 调用regmap_write设置 RTC_LPSR 寄存器，写入 0xffffffff，LPSR 是 RTC 状态寄存器，写 1 清零， 因此这一步就是清除 LPSR 寄存器。 调用 snvs_rtc_enable 函数使能 RTC，此函数会设置 RTC_LPCR 寄存器。 调用devm_request_irq函数请求RTC中断，中断服务函数为snvs_rtc_irq_handler，用于 RTC 闹钟中断。 调用 devm_rtc_device_register 函数向系统注册 rtc_devcie，RTC 底层驱动集为 snvs_rtc_ops。snvs_rtc_ops操作集包含了读取/设置RTC时间，读取/设置闹钟等函数。 1234567static const struct rtc_class_ops snvs_rtc_ops &#x3D; &#123; .read_time &#x3D; snvs_rtc_read_time, .set_time &#x3D; snvs_rtc_set_time, .read_alarm &#x3D; snvs_rtc_read_alarm, .set_alarm &#x3D; snvs_rtc_set_alarm, .alarm_irq_enable &#x3D; snvs_rtc_alarm_irq_enable,&#125;;","link":"","tags":[]},{"title":"Linux驱动-LCD驱动","date":"2021-04-16T15:59:08.000Z","path":"2021/04/16/Linux驱动-LCD驱动/","text":"Framebuffer 设备裸机 LCD 驱动编写流程如下：①、初始化 I.MX6U 的 eLCDIF 控制器，重点是 LCD 屏幕宽(width)、高(height)、hspw、hbp、hfp、vspw、vbp 和 vfp 等信息。 ②、初始化 LCD 像素时钟。③、设置 RGBLCD 显存。④、应用程序直接通过操作显存来操作 LCD，实现在 LCD 上显示字符、图片等信息。 在 Linux 中应用程序最终也是通过操作 RGB LCD 的显存来实现在 LCD 上显示字符、图片等信息。在裸机中我们可以随意的分配显存，但是在 Linux 系统中内存的管理很严格，显存是需要申请的，不是你想用就能用的。而且因为虚拟内存的存在，驱动程序设置的显存和应用程序访问的显存要是同一片物理内存。 为了解决上述问题，Framebuffer 诞生了， Framebuffer 翻译过来就是帧缓冲，简称 fb，以后的 Linux 学习中见到“Framebuffer”或者“fb”的话第一反应应该想到 RGBLCD或者显示设备。fb 是一种机制，将系统中所有跟显示有关的硬件以及软件集合起来，虚拟出一个 fb 设备，当编写好 LCD 驱动以后会生成一个名为/dev/fbX(X=0~n)的设备，应用程序通过访问/dev/fbX 这个设备就可以访问 LCD。 /dev/fbX是个字符设备，因此肯定有file_operations 操作集，fb 的 file_operations 操作集定义在 drivers/video/fbdev/core/fbmem.c 文件中。 LCD 驱动简析不同分辨率的 LCD 屏幕其 eLCDIF 控制器驱动代码都是一样的，只需要修改好对应的屏幕参数即可。屏幕参数信息属于屏幕设备信息内容，这些肯定是要放到设备树中的，因此我们本章实验的主要工作就是修改设备树， Linux 下 Framebuffer 驱动的编写流程， Linux 内核将所有的 Framebuffer 抽象为一个叫做 fb_info 的结构 体，fb_info 结构体包含了 Framebuffer 设备的完整属性和操作集合，因此每一个 Framebuffer 设备都必须有一个 fb_info。换言之就是，LCD 的驱动就是构建 fb_info，并且向系统注册 fb_info的过程。fb_info 结构体定义在 include/linux/fb.h 文件里面 123456789101112131415161718192021struct fb_info &#123; ………… struct fb_var_screeninfo var; &#x2F;* 当前可变参数 *&#x2F; struct fb_fix_screeninfo fix; &#x2F;* 当前固定参数 *&#x2F; struct fb_monspecs monspecs; &#x2F;* 当前显示器特性 *&#x2F; struct work_struct queue; &#x2F;* 帧缓冲事件队列 *&#x2F; struct fb_pixmap pixmap; &#x2F;* 图像硬件映射 *&#x2F; struct fb_pixmap sprite; &#x2F;* 光标硬件映射 *&#x2F; struct fb_cmap cmap; &#x2F;* 当前调色板 *&#x2F; struct list_head modelist; &#x2F;* 当前模式列表 *&#x2F; struct fb_videomode *mode; &#x2F;* 当前视频模式 *&#x2F; ...... struct fb_ops *fbops; &#x2F;* 帧缓冲操作函数集 *&#x2F; struct device *device; &#x2F;* 父设备 *&#x2F; struct device *dev; &#x2F;* 当前 fb 设备 *&#x2F; int class_flag; &#x2F;* 私有 sysfs 标志 *&#x2F; ...... char __iomem *screen_base; &#x2F;* 虚拟内存基地址(屏幕显存) *&#x2F; unsigned long screen_size; &#x2F;* 虚拟内存大小(屏幕显存大小) *&#x2F; void *pseudo_palette; &#x2F;* 伪 16 位调色板 *&#x2F;&#125;; fb_info 结构体的成员变量很多，我们重点关注 var、fix、fbops、screen_base、screen_size和 pseudo_palette。mxsfb_probe 函数的主要工作内容为：①、申请 fb_info。②、初始化 fb_info 结构体中的各个成员变量。③、初始化 eLCDIF 控制器。④、使用 register_framebuffer 函数向 Linux 内核注册初始化好的 fb_info 123int register_framebuffer(struct fb_info *fb_info)&#x2F;&#x2F;fb_info：需要上报的 fb_info。&#x2F;&#x2F;返回值：0，成功；负值，失败。 LCD 驱动程序编写6ULL 的 eLCDIF 接口驱动程序 NXP 已经编写好了，因此 LCD 驱动部分我们不需要去修改。我们需要做的就是按照所使用的 LCD 来修改设备树。重点要注意三个地方： ①、LCD 所使用的 IO 配置。 ②、LCD 屏幕节点修改，修改相应的属性值，换成我们所使用的 LCD 屏幕参数。 ③、LCD 背光节点信息修改，要根据实际所使用的背光 IO 来修改相应的设备节点信息。 1、LCD 屏幕 IO 配置 首先要检查一下设备树中 LCD 所使用的 IO 配置，这个其实 NXP 都已经写好了，不需要修改， 2、LCD 屏幕参数节点信息修改 继续在 imx6ull-alientek-emmc.dts 文件中找到 lcdif 节点，节点内容如下所示： 1234567891011121314151617181920212223242526272829303132&amp;lcdif &#123; pinctrl-names &#x3D; &quot;default&quot;; pinctrl-0 &#x3D; &lt;&amp;pinctrl_lcdif_dat &#x2F;* 使用到的 IO *&#x2F;&amp;pinctrl_lcdif_ctrl&amp;pinctrl_lcdif_reset&gt;;display &#x3D; &lt;&amp;display0&gt;;status &#x3D; &quot;okay&quot;; 8 display0: display &#123; &#x2F;* LCD 属性信息 *&#x2F;bits-per-pixel &#x3D; &lt;16&gt;; &#x2F;* 一个像素占用几个 bit *&#x2F;bus-width &#x3D; &lt;24&gt;; &#x2F;* 总线宽度 *&#x2F;display-timings &#123;native-mode &#x3D; &lt;&amp;timing0&gt;; &#x2F;* 时序信息 *&#x2F;timing0: timing0 &#123; clock-frequency &#x3D; &lt;9200000&gt;; &#x2F;* LCD 像素时钟，单位 Hz *&#x2F;hactive &#x3D; &lt;480&gt;; &#x2F;* LCD X 轴像素个数 *&#x2F;vactive &#x3D; &lt;272&gt;; &#x2F;* LCD Y 轴像素个数 *&#x2F;hfront-porch &#x3D; &lt;8&gt;; &#x2F;* LCD hfp 参数 *&#x2F;hback-porch &#x3D; &lt;4&gt;; &#x2F;* LCD hbp 参数 *&#x2F;hsync-len &#x3D; &lt;41&gt;; &#x2F;* LCD hspw 参数 *&#x2F;vback-porch &#x3D; &lt;2&gt;; &#x2F;* LCD vbp 参数 *&#x2F;vfront-porch &#x3D; &lt;4&gt;; &#x2F;* LCD vfp 参数 *&#x2F;vsync-len &#x3D; &lt;10&gt;; &#x2F;* LCD vspw 参数 *&#x2F;hsync-active &#x3D; &lt;0&gt;; &#x2F;* hsync 数据线极性 *&#x2F;vsync-active &#x3D; &lt;0&gt;; &#x2F;* vsync 数据线极性 *&#x2F;de-active &#x3D; &lt;1&gt;; &#x2F;* de 数据线极性 *&#x2F;pixelclk-active &#x3D; &lt;0&gt;; &#x2F;* clk 数据线先极性 *&#x2F;&#125;;&#125;;&#125;;&#125;; 第 3 行，pinctrl-0 属性，LCD 所使用的 IO 信息，这里用到了 pinctrl_lcdif_dat(RGB LCD 的 24 根数据线配置项)、pinctrl_lcdif_ctrl(RGB LCD 的 4 根控制线配置项，包括 CLK、ENABLE、VSYNC 和 HSYNC)和 pinctrl_lcdif_reset (LCD 复位 IO 信息节点)这三个 IO 相关的节点。第 6 行，display 属性，指定 LCD 属性信息所在的子节点，这里为 display0，下面就是 display0子节点内容。第 932 行，display0 子节点，描述 LCD 的参数信息，第 10 行的 bits-per-pixel 属性用于指明一个像素占用的 bit 数，默认为 16bit。将 LCD 配置为 RGB888 模式，因此一个像素点占用 24bit，bits-per-pixel 属性要改为 24。第 11 行的 bus-width 属性用于设置数据线宽度，因为要配置为 RGB888 模式，因此 bus-width 也要设置为 24。 第 1330 行，这几行设置了 LCD 的时序参数信息，需要根据自己所使用的屏幕去修改。 3、LCD 屏幕背光节点信息 正点原子的 LCD 接口背光控制 IO 连接到了 I.MX6U 的 GPIO1_IO08 引脚上，GPIO1_IO08复用为 PWM1_OUT，通过 PWM 信号来控制 LCD 屏幕背光的亮度，正点原子 I.MX6U-ALPHA 开发板的 LCD 背光引脚和 NXP 官方 EVK 开发 板的背光引脚一样，因此背光的设备树节点是不需要修改的。 12345 pinctrl_pwm1: pwm1grp &#123; fsl,pins &#x3D; &lt; MX6UL_PAD_GPIO1_IO08__PWM1_OUT 0x110b0 &gt;;&#125;; pinctrl_pwm1 节点就是 GPIO1_IO08 的配置节点，设置 GPIO1_IO08 这个 IO 复用为 PWM1_OUT，并且设置电气属性值为 0x110b0。 LCD 背光要用到 PWM1，因此也要设置 PWM1 节点，在 imx6ull.dtsi 文件中找到如下内容： 123456789pwm1: pwm@02080000 &#123; compatible &#x3D; &quot;fsl,imx6ul-pwm&quot;, &quot;fsl,imx27-pwm&quot;; reg &#x3D; &lt;0x02080000 0x4000&gt;; interrupts &#x3D; &lt;GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH&gt;; clocks &#x3D; &lt;&amp;clks IMX6UL_CLK_PWM1&gt;, &lt;&amp;clks IMX6UL_CLK_PWM1&gt;; clock-names &#x3D; &quot;ipg&quot;, &quot;per&quot;; #pwm-cells &#x3D; &lt;2&gt;;&#125;; imx6ull.dtsi 文件中的 pwm1 节点信息不要修改，如果要修改 pwm1 节点内容的话在imx6ull-alientek-emmc.dts 文件中修改。继续在 imx6ull-alientek-emmc.dts 文件中找到向 pwm1追加的内容 12345&amp;pwm1 &#123; pinctrl-names &#x3D; &quot;default&quot;; pinctrl-0 &#x3D; &lt;&amp;pinctrl_pwm1&gt;; status &#x3D; &quot;okay&quot;; &#125;; 设置 pwm1 所使用的 IO 为 pinctrl_pwm1，也就是GPIO1_IO08 这个 IO。将 status 设置为 okay。 需要一个节点来将 LCD 背光和 PWM1_OUT连接起来 ，Linux系统才知道PWM1_OUT 就是控制 LCD 背光的。 这 个节点就是backlight，backlight节点创建总结一下：①、节点名称要为“backlight”。②、节点的 compatible 属性值要为“pwm-backlight”，③、pwms属性用于描述背光所使用的PWM以及PWM频率，比如要使用的pwm1，pwm 频率设置为 5KHz(④、brightness-levels 属性描述亮度级别，范围为 0~255，0 表示 PWM 占空比为 0%，也就是亮度最低，255 表示 100%占空比，也就是亮度最高。⑤、default-brightness-level 属性为默认亮度级别。 1234567backlight &#123; compatible &#x3D; &quot;pwm-backlight&quot;; pwms &#x3D; &lt;&amp;pwm1 0 5000000&gt;; brightness-levels &#x3D; &lt;0 4 8 16 32 64 128 255&gt;; default-brightness-level &#x3D; &lt;6&gt;; status &#x3D; &quot;okay&quot;; &#125;; 设置背光使用 pwm1，PWM 频率为 5KHz。设置背 8 级背光(0~7)，分别为 0、4、8、16、32、64、128、255，对应占空比为0%、1.57%、3.13%、6.27%、12.55%、25.1%、50.19%、100%。设置默认背光等级为 6，也就是 50.19%的亮度。","link":"","tags":[]},{"title":"Linux驱动-INPUT子系统","date":"2021-04-16T12:58:20.000Z","path":"2021/04/16/Linux驱动-INPUT子系统/","text":"input 子系统按键、鼠标、键盘、触摸屏等都属于输入(input)设备，Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。输入设备本质上还是字符设备，只是在此基础上套上了 input 框架，用户只需要负责上报输入事件，比如按键值、坐标等信息，input 核心层负责处理这些事件。 input 子系统管理输入的子系统，和 pinctrl 和 gpio 子系统 一样，都是 Linux 内核针对某一类设备而创建的框架。比如按键输入、键盘、鼠标、触摸屏等等这些都属于输入设备，不同的输入设备所代表的含义不同，按键和键盘就是代表按键信息，鼠标和触摸屏代表坐标信息，因此在应用层的处理就不同。 对于驱动编写者而言不需要去关心应用层的事情，我们只需要按照要求上报这些输入事件即可。为此 input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点。input 子系统驱动分层模型，编写驱动程序的时候只需要关注中间的驱动层、核心层和事件层，这三个层的分工如下： 驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。 核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。 事件层：主要和用户空间进行交互。 input 驱动编写流程input 核心层会向 Linux 内核注册一个字符设备，主设备号为 INPUT_MAJOR=13，因此input 子系统的所有设备主设备号都为 13，在使用 input 子系统处理输入设备的时候就不需要去注册字符设备了，只需要向系统注册一个 input_device 即可。 1、注册 input_dev在使用 input 子系统的时候我们只需要注册一个 input 设备即可，input_dev 结构体表示 input设备， 1234567891011121314struct input_dev &#123; const char *name; const char *phys; const char *uniq; struct input_id id; unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; &#x2F;* 事件类型的位图 *&#x2F; unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; &#x2F;* 按键值的位图 *&#x2F; unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; &#x2F;* 相对坐标的位图 *&#x2F; ...... bool devres_managed;&#125;; evbit、keybit、relbit 等等都是存放不同事件对应的值。 evbit 表示输入事件类型，可选的事件类型定义在 include/uapi/linux/input.h 文件 中，要使用到按键，那么就需要注册 EV_KEY 事件，如果要使用连按功能的话还需要注册 EV_REP 事件。 事件类型如下： 123456789101112#define EV_SYN 0x00 &#x2F;* 同步事件 *&#x2F;#define EV_KEY 0x01 &#x2F;* 按键事件 *&#x2F;#define EV_REL 0x02 &#x2F;* 相对坐标事件 *&#x2F;#define EV_ABS 0x03 &#x2F;* 绝对坐标事件 *&#x2F;#define EV_MSC 0x04 &#x2F;* 杂项(其他)事件 *&#x2F;#define EV_SW 0x05 &#x2F;* 开关事件 *&#x2F;#define EV_LED 0x11 &#x2F;* LED *&#x2F;#define EV_SND 0x12 &#x2F;* sound(声音) *&#x2F;#define EV_REP 0x14 &#x2F;* 重复事件 *&#x2F;#define EV_FF 0x15 &#x2F;* 压力事件 *&#x2F;#define EV_PWR 0x16 &#x2F;* 电源事件 *&#x2F;#define EV_FF_STATUS 0x17 &#x2F;* 压力状态事件 *&#x2F; 要使用按键事件，因此要用到 keybit，keybit 就是按键事件使用的位图，Linux 内核定义了很多按键值，这些按键值定义在 include/uapi/linux/input.h 文件中，按键值如下： 123456789#define KEY_RESERVED 0#define KEY_ESC 1#define KEY_7 8#define KEY_8 9#define KEY_9 10#define KEY_0 11......#define BTN_TRIGGER_HAPPY39 0x2e6#define BTN_TRIGGER_HAPPY40 0x2e7 可以将开发板上的按键值设置为任意一个，可将 I.MX6U-ALPHA 开发板上的 KEY 按键值设置为 KEY_0。 在编写 input 设备驱动的时候需要先申请一个 input_dev 结构体变量，使用input_allocate_device 函数来申请一个 input_dev，如果要注销的 input 设备的话需要使用 input_free_device 函数来释放掉前面申请到的input_dev 123456struct input_dev *input_allocate_device(void)&#x2F;&#x2F;参数：无。&#x2F;&#x2F;返回值：申请到的 input_dev。void input_free_device(struct input_dev *dev)&#x2F;&#x2F;dev：需要释放的 input_dev。&#x2F;&#x2F;返回值：无。 申请好一个 input_dev 以后就需要初始化这个 input_dev，需要初始化的内容主要为事件类型(evbit)和事件值(keybit)这两种。input_dev 初始化完成以后就需要向 Linux 内核注册 input_dev了，需要用到 input_register_device 函数，注销 input 驱动的时候也需要使用 input_unregister_device 函数来注销掉前面注册的 input_dev。 123456int input_register_device(struct input_dev *dev)&#x2F;&#x2F;dev：要注册的 input_dev 。&#x2F;&#x2F;返回值：0，input_dev 注册成功；负值，input_dev 注册失败。void input_unregister_device(struct input_dev *dev)&#x2F;&#x2F;dev：要注销的 input_dev 。&#x2F;&#x2F;返回值：无。 综上所述，input_dev 注册过程如下： ①、使用 input_allocate_device 函数申请一个 input_dev。②、初始化 input_dev 的事件类型以及事件值。③、使用 input_register_device 函数向 Linux 系统注册前面初始化好的 input_dev。④、卸载input驱动的时候需要先使用input_unregister_device函数注销掉注册的input_dev，然后使用 input_free_device 函数释放掉前面申请的 input_dev。 123456789101112131415161718192021222324252627282930313233343536struct input_dev *inputdev; &#x2F;* input 结构体变量 *&#x2F;&#x2F;* 驱动入口函数 *&#x2F;static int __init xxx_init(void) &#123; ...... inputdev &#x3D; input_allocate_device(); &#x2F;* 申请 input_dev *&#x2F; inputdev-&gt;name &#x3D; &quot;test_inputdev&quot;; &#x2F;* 设置 input_dev 名字 *&#x2F; &#x2F;*********第一种设置事件和事件值的方法***********&#x2F; __set_bit(EV_KEY, inputdev-&gt;evbit); &#x2F;* 设置产生按键事件 *&#x2F; __set_bit(EV_REP, inputdev-&gt;evbit); &#x2F;* 重复事件 *&#x2F; __set_bit(KEY_0, inputdev-&gt;keybit); &#x2F;*设置产生哪些按键值 *&#x2F; &#x2F;************************************************&#x2F; &#x2F;*********第二种设置事件和事件值的方法***********&#x2F; keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) |BIT_MASK(EV_REP); keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |&#x3D; BIT_MASK(KEY_0); &#x2F;************************************************&#x2F; &#x2F;*********第三种设置事件和事件值的方法***********&#x2F; keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) | BIT_MASK(EV_REP); input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0); &#x2F;************************************************&#x2F; &#x2F;* 注册 input_dev *&#x2F; input_register_device(inputdev); ...... return 0;&#125;&#x2F;* 驱动出口函数 *&#x2F;static void __exit xxx_exit(void)&#123; input_unregister_device(inputdev); &#x2F;* 注销 input_dev *&#x2F; input_free_device(inputdev); &#x2F;* 删除 input_dev *&#x2F;&#125; 先定义一个 input_dev 结构体指针变量。 驱动入口函数，在此函数中完成 input_dev 的申请、设置、注册等工作调用 input_allocate_device 函数申请一个 input_dev。设置 input 设备事件和按键值，这里用了三种方法来设置事件和按键值。调用 input_register_device 函数向 Linux内核注册 inputdev。 驱动出口函数，调用 input_unregister_device 函数注销前面注册的input_dev，调用 input_free_device 函数删除前面申请的 input_dev。 2、上报输入事件向 Linux 内核注册好 input_dev 以后需要获取到具体的输入值，或者说是输入事件，然后将输入事件上报给 Linux 内核。比如按键，我们需要在按键中断处理函数，或者消抖定时器中断函数中将按键值上报给 Linux 内核，这样 Linux 内核才能获取到正确的输入值。不同的事件，其上报事件的 API 函数不同， input_event 函数用于上报指定的事件以及对应的值 123456void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)&#x2F;&#x2F;dev：需要上报的 input_dev。&#x2F;&#x2F;type: 上报的事件类型，比如 EV_KEY。&#x2F;&#x2F;code：事件码，也就是我们注册的按键值，比如 KEY_0、KEY_1 等等。&#x2F;&#x2F;value：事件值，比如 1 表示按键按下，0 表示按键松开。&#x2F;&#x2F;返回值：无。 input_event 函数可以上报所有的事件类型和事件值，Linux 内核也提供了其他的针对具体事件的上报函数，这些函数其实都用到了 input_event 函数。 1234void input_report_key(struct input_dev *dev, unsigned int code, int value)void input_report_rel(struct input_dev *dev, unsigned int code, int value)void input_report_abs(struct input_dev *dev, unsigned int code, int value)………… 这些函数的本质就是 input_event 函数，如果要上报按键事件的话还是建议大家使用 input_report_key 函数。 当上报事件以后还需要使用 input_sync 函数来告诉 Linux 内核 input 子系统上报结束，input_sync 函数本质是上报一个同步事件 123void input_sync(struct input_dev *dev)&#x2F;&#x2F;dev：需要上报同步事件的 input_dev。&#x2F;&#x2F;返回值：无。 综上所述，按键的上报事件的参考代码如下所示 1234567891011121314&#x2F;* 用于按键消抖的定时器服务函数 *&#x2F;void timer_function(unsigned long arg) &#123; unsigned char value; value &#x3D; gpio_get_value(keydesc-&gt;gpio); &#x2F;* 读取 IO 值 *&#x2F; if(value &#x3D;&#x3D; 0)&#123; &#x2F;* 按下按键 *&#x2F; &#x2F;* 上报按键值 *&#x2F; input_report_key(inputdev, KEY_0, 1); &#x2F;* 最后一个参数 1，按下 *&#x2F; input_sync(inputdev); &#x2F;* 同步事件 *&#x2F; &#125; else &#123; &#x2F;* 按键松开 *&#x2F; input_report_key(inputdev, KEY_0, 0); &#x2F;* 最后一个参数 0，松开 *&#x2F; input_sync(inputdev); &#x2F;* 同步事件 *&#x2F; &#125; &#125; 先获取按键值，判断按键是否按下。 如果按键值为 0 那么表示按键被按下了，如果按键按下的话就要使用 input_report_key 函数向 Linux 系统上报按键值，比如向 Linux 系统通知 KEY_0 这个按键按下了。 如果按键值为 1 的话就表示按键没有按下，是松开的。向 Linux 系统通知KEY_0 这个按键没有按下或松开了。 input_event 结构体Linux 内核使用 input_event 这个结构体来表示所有的输入事件，input_event 结构体定义在 include/uapi/linux/input.h 文件中，结构体内容如下： 12345678910struct input_event &#123; struct timeval time; __u16 type; __u16 code; __s32 value;&#125;;&#x2F;&#x2F;time：时间，也就是此事件发生的时间，为 timeval 结构体类型&#x2F;&#x2F;type：事件类型，比如 EV_KEY，表示此次事件为按键事件，此成员变量为 16 位。&#x2F;&#x2F;code：事件码，比如在EV_KEY事件中code就表示具体的按键码，如：KEY_0、KEY_1这些按键。此成员变量为16位。&#x2F;&#x2F;value：值，比如EV_KEY事件中value就是按键值，表示按键有没有被按下，如果为 1 的话说明按键按下，如果为 0 的话说明按键没有被按下或者按键松开了。 time：时间，也就是此事件发生的时间，为 timeval 结构体类型，timeval 结构体定义如下： 12345struct timeval &#123; __kernel_time_t tv_sec; &#x2F;* 秒 *&#x2F; __kernel_suseconds_t tv_usec; &#x2F;* 微秒 *&#x2F;&#125;;&#x2F;&#x2F;tv_sec 和 tv_usec 这两个成员变量都为 long 类型，也就是32位。 input_envent 这个结构体非常重要，因为所有的输入设备最终都是按照 input_event 结构体呈现给用户的，用户应用程序可以通过 input_event 来获取到具体的输入事件或相关的值。 实验程序编写驱动程序编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;***************************************************************文件名 : keyinput.c描述 : Linux按键input子系统实验***************************************************************&#x2F;&#x2F;* keyinput设备结构体 *&#x2F;struct keyinput_dev&#123; struct input_dev *inputdev; &#x2F;* input结构体 *&#x2F;&#125;;struct keyinput_dev keyinputdev; &#x2F;* key input设备 *&#x2F;void timer_function(unsigned long arg)&#123; value &#x3D; gpio_get_value(keydesc-&gt;gpio); &#x2F;* 读取IO值 *&#x2F; if(value &#x3D;&#x3D; 0)&#123; &#x2F;* 按下按键 *&#x2F; &#x2F;* 上报按键值 *&#x2F; &#x2F;&#x2F;input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 1); input_report_key(dev-&gt;inputdev, keydesc-&gt;value, 1);&#x2F;* 最后一个参数表示按下还是松开，1为按下，0为松开 *&#x2F; input_sync(dev-&gt;inputdev); &#125; else &#123; &#x2F;* 按键松开 *&#x2F; &#x2F;&#x2F;input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 0); input_report_key(dev-&gt;inputdev, keydesc-&gt;value, 0); input_sync(dev-&gt;inputdev); &#125; &#125;static int keyio_init(void)&#123; &#x2F;* 申请input_dev *&#x2F; keyinputdev.inputdev &#x3D; input_allocate_device(); keyinputdev.inputdev-&gt;name &#x3D; KEYINPUT_NAME;#if 0 &#x2F;* 初始化input_dev，设置产生哪些事件 *&#x2F; __set_bit(EV_KEY, keyinputdev.inputdev-&gt;evbit); &#x2F;* 设置产生按键事件 *&#x2F; __set_bit(EV_REP, keyinputdev.inputdev-&gt;evbit); &#x2F;* 重复事件，比如按下去不放开，就会一直输出信息 *&#x2F; &#x2F;* 初始化input_dev，设置产生哪些按键 *&#x2F; __set_bit(KEY_0, keyinputdev.inputdev-&gt;keybit); #endif#if 0 keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) | BIT_MASK(EV_REP); keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |&#x3D; BIT_MASK(KEY_0);#endif keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) | BIT_MASK(EV_REP); input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0); &#x2F;* 注册输入设备 *&#x2F; ret &#x3D; input_register_device(keyinputdev.inputdev); return 0;&#125;static void __exit keyinput_exit(void)&#123; &#x2F;* 释放input_dev *&#x2F; input_unregister_device(keyinputdev.inputdev); input_free_device(keyinputdev.inputdev);&#125; 在设备结构体中定义一个 input_dev 指针变量。 在按键消抖定时器处理函数中上报输入事件，也就是使用 input_report_key函数上报按键事件以及按键值，最后使用 input_sync 函数上报一个同步事件，这一步一定得做！ 使用 input_allocate_device 函数申请 input_dev，然后设置相应的事件以及事件码(也就是 KEY 模拟成那个按键，设置为 KEY_0)。最后使用 input_register_device函数向 Linux 内核注册 input_dev。 当注销 input 设备驱动的时候使用 input_unregister_device 函数注销掉前面注册的 input_dev，最后使用 input_free_device 函数释放掉前面申请的 input_dev。 编写测试 APP12345678910111213141516171819202122232425262728293031&#x2F;***************************************************************文件名 : keyinputApp.c描述 : input子系统测试APP。使用方法 ：.&#x2F;keyinputApp &#x2F;dev&#x2F;input&#x2F;event1***************************************************************&#x2F;&#x2F;* 定义一个input_event变量，存放输入事件信息 *&#x2F;static struct input_event inputevent;int main(int argc, char *argv[])&#123; fd &#x3D; open(filename, O_RDWR); while (1) &#123; err &#x3D; read(fd, &amp;inputevent, sizeof(inputevent)); switch (inputevent.type) &#123; case EV_KEY: if (inputevent.code &lt; BTN_MISC) &#123; &#x2F;* 键盘键值 *&#x2F; printf(&quot;key %d %s\\r\\n&quot;, inputevent.code, inputevent.value); &#125; else &#123; printf(&quot;button %d %s\\r\\n&quot;, inputevent.code, inputevent.value); &#125; break; &#x2F;* 其他类型的事件，自行处理 *&#x2F; case EV_REL: break; &#125; &#125; &#125; return 0;&#125; Linux 内核会使用 input_event 结构体来表示输入事件，所以要获取按键输入信息，那么必须借助于 input_event 结构体。 向 Linux 内核成功注册 input_dev 设备以后，会在/dev/input 目录下生成一个名为“eventX(X=0….n)”的文件，这个/dev/input/eventX 就是对应的 input 设备文件。我们读取这个文件就可以获取到输入事件信息，使用read函数读取输入设备文件/dev/input/eventX，读取到的数据按照 input_event 结构体组织起来。获取到输入事件以后(input_event 结构体类型)使用 switch case 语句来判断事件类型，设置的事件类型为 EV_KEY，因此只需要处理 EV_KEY 事件即可。 自带按键驱动程序的使用要使用Linux内核自带的按键驱动程序很简单，只需要根据Documentation/devicetree/bindings/input/gpio-keys.txt 这个文件在设备树中添加指定的设备节点即可，节点要求如下：①、节点名字为“gpio-keys”。②、gpio-keys 节点的 compatible 属性值一定要设置为“gpio-keys”。③、所有的 KEY 都是 gpio-keys 的子节点，每个子节点可以用如下属性描述自己： gpios：KEY 所连接的 GPIO 信息。 interrupts：KEY 所使用 GPIO 中断信息，不是必须的，可以不写。 label：KEY 名字 linux,code：KEY 要模拟的按键，也就是示例代码 58.1.2.4 中的这些按键。④、如果按键要支持连按的话要加入 autorepeat。打开 imx6ull-alientek-emmc.dts，根据上面的要求创建对应的设备节点，设备节点内容如下所示： 1234567891011gpio-keys &#123; compatible &#x3D; &quot;gpio-keys&quot;; #address-cells &#x3D; &lt;1&gt;; #size-cells &#x3D; &lt;0&gt;; autorepeat; key0 &#123; label &#x3D; &quot;GPIO Key Enter&quot;; linux,code &#x3D; &lt;KEY_ENTER&gt;; gpios &#x3D; &lt;&amp;gpio1 18 GPIO_ACTIVE_LOW&gt;; &#125;;&#125;; autorepeat 表示按键支持连按。 ALPHA 开发板 KEY 按键信息，名字设置为“GPIO Key Enter”，这里将 开发板上的 KEY 按键设置为“EKY_ENTER”这个按键，也就是回车键，效果和键盘上的回车键一样。将开发板上最后设置 KEY 所使用的 IO 为 GPIO1_IO18，一定要检查一下设备树看看此 GPIO 有没有被用到其他外设上，如果有的话要删除掉相关代码！","link":"","tags":[]},{"title":"Linux驱动-MISC驱动","date":"2021-04-16T11:05:33.000Z","path":"2021/04/16/Linux驱动-MISC驱动/","text":"MISC 设备驱动misc 的意思是混合、杂项的，因此 MISC 驱动也叫做杂项驱动，当某些外设无法进行分类的时候就可以使用 MISC 驱动。MISC 驱动其实就是最简单的字符设备驱动，通常嵌套在 platform 总线驱动中，实现复杂的驱动。 所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。随着 Linux字符设备驱动的不断增加，设备号变得越来越紧张，尤其是主设备号，MISC 设备驱动就用于解决此问题。MISC 设备会自动创建 cdev，不需要像我们以前那样手动创建，因此采用 MISC 设备驱动可以简化字符设备驱动的编写。 需要向 Linux 注册一个 miscdevice 设备，miscdevice是一个结构体，定义在文件 include/linux/miscdevice.h 中，内容如下： 1234567891011121314struct miscdevice &#123; int minor; &#x2F;* 子设备号 *&#x2F; const char *name; &#x2F;* 设备名字 *&#x2F; const struct file_operations *fops; &#x2F;* 设备操作集 *&#x2F; struct list_head list; struct device *parent; struct device *this_device; const struct attribute_group **groups; const char *nodename; umode_t mode;&#125;;&#x2F;*minor 表示子设备号，MISC 设备的主设备号为 10，这个是固定的，需要用户指定子设备号，Linux系统已经预定义了一些MISC设备的子设备号，在使用时可以从这些预定义的子设备号中挑选一个，当然也可以自己定义，只要这个子设备号没有被其他设备使用接口。*&#x2F; &#x2F;&#x2F;name 就是此 MISC 设备名字，当此设备注册成功以后就会在&#x2F;dev 目录下生成一个名为 name的设备文件。&#x2F;&#x2F;fops 就是字符设备的操作集合，MISC 设备驱动最终是需要使用用户提供的 fops 操作集合。 定义一个 MISC 设备(miscdevice 类型)以后需要设置 minor、name 和 fops 这三个成员变量。 当设置好 miscdevice 以后就需要使用 misc_register 函数向系统中注册一个 MISC 设备，卸载设备驱动模块的时候需要调用 misc_deregister 函数来注销掉 MISC 设备 123456int misc_register(struct miscdevice * misc)&#x2F;&#x2F;misc：要注册的 MISC 设备。&#x2F;&#x2F;返回值：负数，失败；0，成功。int misc_deregister(struct miscdevice *misc)&#x2F;&#x2F;misc：要注销的 MISC 设备。&#x2F;&#x2F;返回值：负数，失败；0，成功。 misc_register 函数会自动创建 cdev、设备等等， misc_deregister 函数会自动删除此前创建的 cdev、设备等等内容。 实验程序编写采用 platform 加 misc 的方式编写 beep 驱动，这也是实际的 Linux 驱动中很 常用的方法。采用 platform 来实现总线、设备和驱动，misc 主要负责完成字符设备的创建。 修改设备树 驱动程序编写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#x2F;***************************************************************文件名 : miscbeep.c描述 : 采用MISC的蜂鸣器驱动程序。***************************************************************&#x2F;#define MISCBEEP_MINOR 144 &#x2F;* 子设备号 *&#x2F;&#x2F;* MISC设备结构体 *&#x2F;static struct miscdevice beep_miscdev &#x3D; &#123; .minor &#x3D; MISCBEEP_MINOR, .name &#x3D; MISCBEEP_NAME, .fops &#x3D; &amp;miscbeep_fops,&#125;; &#x2F;* * @description : flatform驱动的probe函数，当驱动与 * 设备匹配以后此函数就会执行 * @param - dev : platform设备 * @return : 0，成功;其他负值,失败 *&#x2F;static int miscbeep_probe(struct platform_device *dev)&#123; &#x2F;* 一般情况下会注册对应的字符设备，但是这里我们使用MISC设备 * 所以我们不需要自己注册字符设备驱动，只需要注册misc设备驱动即可 *&#x2F; ret &#x3D; misc_register(&amp;beep_miscdev); if(ret &lt; 0)&#123; printk(&quot;misc device register failed!\\r\\n&quot;); return -EFAULT; &#125; return 0;&#125;&#x2F;* * @description : platform驱动的remove函数，移除platform驱动的时候此函数会执行 * @param - dev : platform设备 * @return : 0，成功;其他负值,失败 *&#x2F;static int miscbeep_remove(struct platform_device *dev)&#123; &#x2F;* 注销设备的时候关闭LED灯 *&#x2F; gpio_set_value(miscbeep.beep_gpio, 1); &#x2F;* 注销misc设备 *&#x2F; misc_deregister(&amp;beep_miscdev); return 0;&#125; &#x2F;* 匹配列表 *&#x2F; static const struct of_device_id beep_of_match[] &#x3D; &#123; &#123; .compatible &#x3D; &quot;atkalpha-beep&quot; &#125;, &#123; &#x2F;* Sentinel *&#x2F; &#125; &#125;; &#x2F;* platform驱动结构体 *&#x2F;static struct platform_driver beep_driver &#x3D; &#123; .driver &#x3D; &#123; .name &#x3D; &quot;imx6ul-beep&quot;, &#x2F;* 驱动名字，用于和设备匹配 *&#x2F; .of_match_table &#x3D; beep_of_match, &#x2F;* 设备树匹配表 *&#x2F; &#125;, .probe &#x3D; miscbeep_probe, .remove &#x3D; miscbeep_remove,&#125;;&#x2F;* * @description : 驱动出口函数 * @param : 无 * @return : 无 *&#x2F;static int __init miscbeep_init(void)&#123; return platform_driver_register(&amp;beep_driver);&#125;&#x2F;* * @description : 驱动出口函数 * @param : 无 * @return : 无 *&#x2F;static void __exit miscbeep_exit(void)&#123; platform_driver_unregister(&amp;beep_driver);&#125; MISC 设备 beep_miscdev，设置子设备号为 144，设置设备名字为“miscbeep”，这样当系统启动以后就会在/dev/目录下存在一个名为“miscbeep”的设备文件。设置 MISC 设备的操作函数集合，为 file_operations 类型。 platform 框架的 probe 函数，当驱动与设备匹配以后此函数就会执行，首先在此函数中初始化 BEEP 所使用的 IO。最后通过 misc_register 函数向 Linux 内核注册MISC 设备，也就是前面定义的 beep_miscdev。 platform 框架的 remove 函数，在此函数中调用 misc_deregister 函数来注销MISC 设备。 第 163~196，标准的 platform 驱动","link":"","tags":[]},{"title":"Linux驱动-platform设备驱动-设备树","date":"2021-04-16T10:24:46.000Z","path":"2021/04/16/Linux驱动-platform设备驱动-设备树/","text":"设备树下的 platform 驱动platform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没 有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代 表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的 platform 驱动的时候我们需要注意一下几点： 1、在设备树中创建设备节点 毫无疑问，肯定要先在设备树中创建设备节点来描述设备信息，重点是要设置好 compatible 属性的值，因为 platform 总线需要通过设备节点的 compatible 属性值来匹配驱动！ 2、编写 platform 驱动的时候要注意兼容属性 在使用设备树的时候 platform 驱动会通过 of_match_table 来保存兼容性值，也就是表明此驱动兼容哪些设备。所以，of_match_table 将会尤为重要， 3、编写 platform 驱动 基于设备树的 platform 驱动和上一章无设备树的 platform 驱动基本一样，都是当驱动和设备匹配成功以后就会执行 probe 函数。我们需要在 probe 函数里面执行字符设备驱动那一套，当注销驱动模块的时候 remove 函数就会执行，都是大同小异的。 实验程序编写编写基于设备树的 platform 驱动，所以需要在设备树中添加设备节点，然后只需要编写 platform 驱动即可。 修改设备树文件 platform 驱动程序编写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#x2F;***************************************************************文件名 : leddriver.c描述 : 设备树下的platform驱动***************************************************************&#x2F;&#x2F;* * @description : flatform驱动的probe函数，当驱动与 * 设备匹配以后此函数就会执行 * @param - dev : platform设备 * @return : 0，成功;其他负值,失败 *&#x2F;static int led_probe(struct platform_device *dev)&#123; ………… return 0;&#125;&#x2F;* * @description : platform驱动的remove函数，移除platform驱动的时候此函数会执行 * @param - dev : platform设备 * @return : 0，成功;其他负值,失败 *&#x2F;static int led_remove(struct platform_device *dev)&#123; gpio_set_value(leddev.led0, 1); &#x2F;* 卸载驱动的时候关闭LED *&#x2F; cdev_del(&amp;leddev.cdev); &#x2F;* 删除cdev *&#x2F; unregister_chrdev_region(leddev.devid, LEDDEV_CNT); &#x2F;* 注销设备号 *&#x2F; device_destroy(leddev.class, leddev.devid); class_destroy(leddev.class); return 0;&#125;&#x2F;* 匹配列表 *&#x2F;static const struct of_device_id led_of_match[] &#x3D; &#123; &#123; .compatible &#x3D; &quot;atkalpha-gpioled&quot; &#125;, &#123; &#x2F;* Sentinel *&#x2F; &#125;&#125;;&#x2F;* platform驱动结构体 *&#x2F;static struct platform_driver led_driver &#x3D; &#123; .driver &#x3D; &#123; .name &#x3D; &quot;imx6ul-led&quot;, &#x2F;* 驱动名字，用于和设备匹配 *&#x2F; .of_match_table &#x3D; led_of_match, &#x2F;* 设备树匹配表 *&#x2F; &#125;, .probe &#x3D; led_probe, .remove &#x3D; led_remove,&#125;; &#x2F;* * @description : 驱动模块加载函数 * @param : 无 * @return : 无 *&#x2F;static int __init leddriver_init(void)&#123; return platform_driver_register(&amp;led_driver);&#125;&#x2F;* * @description : 驱动模块卸载函数 * @param : 无 * @return : 无 *&#x2F;static void __exit leddriver_exit(void)&#123; platform_driver_unregister(&amp;led_driver);&#125;module_init(leddriver_init);module_exit(leddriver_exit); platform 驱动的 probe 函数，当设备树中的设备节点与驱动之间匹配成功以后此函数就会执行，原来在驱动加载函数里面做的工作现在全部放到 probe 函s数里面完成。 remobe 函数，当卸载 platform 驱动的时候此函数就会执行。在此函数里面释放内存、注销字符设备等，也就是将原来驱动卸载函数里面的工作全部都放到 remove 函数中 完成。 led_of_match匹配表，描述了此驱动都和什么样的设备匹配，添加了一条值为”atkalpha-gpioled”的 compatible 属性值，当设备树中某个设备节点的 compatible 属性值也为“atkalpha-gpioled”的时候就会与此驱动匹配。 在编最后一个元素一定要为空！ platform_driver 驱动结构体，设置这个 platform 驱动的名字为“imx6ul\u0002led”，因此，当驱动加载成功以后就会在/sys/bus/platform/drivers/目录下存在一个名为“imx6u\u0002led”的文件。 设置 of_match_table 为上面的 led_of_match。 驱动模块加载函数，在此函数里面通过 platforms_driver_register 向 Linux 内核注册 led_driver 驱动。 驱动模块卸载函数，在此函数里面通过 platform_driver_unregister 从 Linux内核卸载 led_driver 驱动。","link":"","tags":[]},{"title":"Linux驱动-platform设备驱动-非设备树","date":"2021-04-16T09:31:45.000Z","path":"2021/04/16/Linux驱动-platform设备驱动-非设备树/","text":"使用platform 驱动框架来编写一个 LED 灯驱动，不使用设备树来描述设备信息，我们采用自定义platform_device这种“古老”方式来编写LED的设备信息。 需要编写一个驱动模块和一个设备模块，其中驱动模块是 platform 驱动程序， 设备模块是 platform 的设备信息。当这两个模块都加载成功以后就会匹配成功，然后 platform 驱动模块中的 probe 函数就会执行，probe 函数中就是传统的字符设备驱动那一套。 试验程序编写 platform 设备与驱动程序编写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#x2F;***************************************************************文件名 : leddriver.c描述 : platform驱动***************************************************************&#x2F;&#x2F;* * @description : flatform驱动的probe函数，当驱动与设备匹配以后此函数就会执行 * @param - dev : platform设备 * @return : 0，成功;其他负值,失败 *&#x2F;static int led_probe(struct platform_device *dev)&#123; ………… return 0;&#125;&#x2F;* * @description : platform驱动的remove函数，移除platform驱动的时候此函数会执行 * @param - dev : platform设备 * @return : 0，成功;其他负值,失败 *&#x2F;static int led_remove(struct platform_device *dev)&#123; iounmap(IMX6U_CCM_CCGR1); iounmap(SW_MUX_GPIO1_IO03); ………… cdev_del(&amp;leddev.cdev);&#x2F;* 删除cdev *&#x2F; unregister_chrdev_region(leddev.devid, LEDDEV_CNT); &#x2F;* 注销设备号 *&#x2F; device_destroy(leddev.class, leddev.devid); class_destroy(leddev.class); return 0;&#125;&#x2F;* platform驱动结构体 *&#x2F;static struct platform_driver led_driver &#x3D; &#123; .driver &#x3D; &#123; .name &#x3D; &quot;imx6ul-led&quot;, &#x2F;* 驱动名字，用于和设备匹配 *&#x2F; &#125;, .probe &#x3D; led_probe, .remove &#x3D; led_remove,&#125;; &#x2F;* * @description : 驱动模块加载函数 * @param : 无 * @return : 无 *&#x2F;static int __init leddriver_init(void)&#123; return platform_driver_register(&amp;led_driver);&#125;&#x2F;* * @description : 驱动模块卸载函数 * @param : 无 * @return : 无 *&#x2F;static void __exit leddriver_exit(void)&#123; platform_driver_unregister(&amp;led_driver);&#125;module_init(leddriver_init);module_exit(leddriver_exit); probe 函数，当设备和驱动匹配以后此函数就会执行，当匹配成功以后会在终端上输出“led driver and device has matched!”这样语句。在 probe 函数里面初始化 LED、注册字符设备驱动。也就是将原来在驱动加载函数里面做的工作全部放到 probe 函数里面完成。 remobe 函数，当卸载 platform 驱动的时候此函数就会执行。在此函数里面 释放内存、注销字符设备等。也就是将原来驱动卸载函数里面的工作全部都放到 remove 函数中完成。 platform_driver 驱动结构体，注意 name 字段为”imx6ul-led”，和leddevice.c 文件里面设置的设备 name 字段一致 驱动模块加载函数，在此函数里面通过 platform_driver_register 向 Linux 内核注册 led_driver 驱动。 驱动模块卸载函数，在此函数里面通过 platform_driver_unregister 从 Linux 内核卸载 led_driver 驱动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&#x2F;***************************************************************文件名 : leddevice.c描述 : platform设备***************************************************************&#x2F;&#x2F;* * 寄存器地址定义 *&#x2F;#define CCM_CCGR1_BASE (0X020C406C) #define SW_MUX_GPIO1_IO03_BASE (0X020E0068)#define SW_PAD_GPIO1_IO03_BASE (0X020E02F4)#define GPIO1_DR_BASE (0X0209C000)#define GPIO1_GDIR_BASE (0X0209C004)#define REGISTER_LENGTH 4&#x2F;* @description : 释放flatform设备模块的时候此函数会执行 * @param - dev : 要释放的设备 * @return : 无 *&#x2F;static void led_release(struct device *dev)&#123; printk(&quot;led device released!\\r\\n&quot;); &#125;&#x2F;* * 设备资源信息，也就是LED0所使用的所有寄存器 *&#x2F;static struct resource led_resources[] &#x3D; &#123; [0] &#x3D; &#123; .start &#x3D; CCM_CCGR1_BASE, .end &#x3D; (CCM_CCGR1_BASE + REGISTER_LENGTH - 1), .flags &#x3D; IORESOURCE_MEM, &#125;, [1] &#x3D; &#123; .start &#x3D; SW_MUX_GPIO1_IO03_BASE, .end &#x3D; (SW_MUX_GPIO1_IO03_BASE + REGISTER_LENGTH - 1), .flags &#x3D; IORESOURCE_MEM, &#125;, [2] &#x3D; &#123; .start &#x3D; SW_PAD_GPIO1_IO03_BASE, .end &#x3D; (SW_PAD_GPIO1_IO03_BASE + REGISTER_LENGTH - 1), .flags &#x3D; IORESOURCE_MEM, &#125;, [3] &#x3D; &#123; .start &#x3D; GPIO1_DR_BASE, .end &#x3D; (GPIO1_DR_BASE + REGISTER_LENGTH - 1), .flags &#x3D; IORESOURCE_MEM, &#125;, [4] &#x3D; &#123; .start &#x3D; GPIO1_GDIR_BASE, .end &#x3D; (GPIO1_GDIR_BASE + REGISTER_LENGTH - 1), .flags &#x3D; IORESOURCE_MEM, &#125;,&#125;;&#x2F;* * platform设备结构体 *&#x2F;static struct platform_device leddevice &#x3D; &#123; .name &#x3D; &quot;imx6ul-led&quot;, .id &#x3D; -1, .dev &#x3D; &#123; .release &#x3D; &amp;led_release, &#125;, .num_resources &#x3D; ARRAY_SIZE(led_resources), .resource &#x3D; led_resources,&#125;; &#x2F;* * @description : 设备模块加载 * @param : 无 * @return : 无 *&#x2F;static int __init leddevice_init(void)&#123; return platform_device_register(&amp;leddevice);&#125;&#x2F;* * @description : 设备模块注销 * @param : 无 * @return : 无 *&#x2F;static void __exit leddevice_exit(void)&#123; platform_device_unregister(&amp;leddevice);&#125;module_init(leddevice_init);module_exit(leddevice_exit); led_resources 数组，也就是设备资源，描述了 LED 所要使用到的寄存器信息，也就是 IORESOURCE_MEM 资源。 platform 设备结构体变量 leddevice，这里要注意 name 字段为“imx6ul-led”， platform 驱动中的 name 字段也要为“imx6ul-led”，否则设备和驱动匹配失败。 设备模块加载函数，在此函数里面通过 platform_device_register 向 Linux 内核注册 leddevice 这个 platform 设备。 设备模块卸载函数，在此函数里面通过 platform_device_unregister 从 Linux内核中删除掉 leddevice 这个 platform 设备。","link":"","tags":[]},{"title":"Linux驱动-platform设备驱动","date":"2021-04-16T08:28:54.000Z","path":"2021/04/16/Linux驱动-platform设备驱动/","text":"Linux 驱动的分离与分层驱动的分隔与分离 对于 Linux 这样一个成熟、庞大、复杂的操作系统，代码的重用性非常重要，否则的话就会在 Linux 内核中存在大量无意义的重复代码。尤其是驱动程序，因为驱动程序占用了 Linux内核代码量的大头，如果不对驱动程序加以管理，任由重复的代码肆意增加，那么用不了多久Linux 内核的文件数量就庞大到无法接受的地步。 驱动的分隔，也就是将主机驱动和设备驱动分隔开来，比如 I2C、SPI 等等都会采用驱动分隔的方式来简化驱动的开发。在实际的驱动开发中，一般 I2C 主机控制器驱动已经由半导体厂家编写好了，而设备驱动一般也由设备器件的厂家编写好了，我们只需要提供设备信息即可，比如 I2C 设备的话提供设备连接到了哪个 I2C 接口上，I2C 的速度是多少等等。相当于将设备信息从设备驱动中剥离开来，驱动使用标准方法去获取到设备信息(比如从设备树中获取到设备信息)，然后根据获取到的设备信息来初始化设备。 这样就相当于驱动只负责驱动，设备只负责设备，想办法将两者进行匹配即可。这个就是 Linux 中的总线(bus)、驱动(driver)和设备(device)模型，也就是常说的驱动分离。总线就是驱动和设备信息的月老，负责给两者牵线搭桥。 当我们向系统注册一个驱动的时候，总线就会在右侧的设备中查找，看看有没有与之匹配的设备，如果有的话就将两者联系起来。同样的，当向系统中注册一个设备的时候，总线就会在左侧的驱动中查找看有没有与之匹配的设备，有的话也联系起来。Linux 内核中大量的驱动程序都采用总线、驱动和设备模式，platform 驱动就是这一思想下的产物 驱动的分层Linux 下的驱动往往也是分层的，分层的目的也是为了在不同的层处理不同的内容。以其他书籍或者资料常常使用到的input(输入子系统)为例，简单介绍一下驱动的分层。input 子系统负责管理所有跟输入有关的驱动，包括键盘、鼠标、触摸等，最底层的就是设备原始驱动，负责获取输入设备的原始值，获取到的输入事件上报给 input 核心层。input 核心层会处理各种 IO 模型，并且提 供 file_operations 操作集合。我们在编写输入设备驱动的时候只需要处理好输入事件的上报即 可，至于如何处理这些上报的输入事件那是上层去考虑的，我们不用管。可以看出借助分层模型可以极大的简化我们的驱动编写，对于驱动编写来说非常的友好。 platform 平台驱动模型前面的设备驱动的分离引出了总线(bus)、驱动(driver)和设备(device)模型，比 如 I2C、SPI、USB 等总线。但是在 SOC 中有些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型该怎么办呢？为了解决此问题，Linux 提出了 platform 这个虚拟总线，相应的就有 platform_driver 和 platform_device。 platform 总线Linux系统内核使用bus_type结构体表示总线，此结构体定义在文件include/linux/device.h， bus_type 结构体内容如下： 1234567891011 struct bus_type &#123; const char *name; &#x2F;* 总线名字 *&#x2F; const char *dev_name; struct device *dev_root; 5 struct device_attribute *dev_attrs; const struct attribute_group **bus_groups; &#x2F;* 总线属性 *&#x2F; const struct attribute_group **dev_groups; &#x2F;* 设备属性 *&#x2F; const struct attribute_group **drv_groups; &#x2F;* 驱动属性 *&#x2F; int (*match)(struct device *dev, struct device_driver *drv); ………………&#125;； match 函数，匹配函数，完成设备和驱动之间匹配的，总线就是使用 match 函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备，因此每一条总线都必须实现此函数。两个参数：dev 和 drv，这两个参数分别为 device 和 device_driver 类型，也就是设备和驱动。 platform 总线 platform_bus_type是 bus_type 的一个具体实例，定义在文件 drivers/base/platform.c，platform 总线定义如下： 1234567struct bus_type platform_bus_type &#x3D; &#123; .name &#x3D; &quot;platform&quot;, .dev_groups &#x3D; platform_dev_groups, .match &#x3D; platform_match, &#x2F;&#x2F;匹配函数。 .uevent &#x3D; platform_uevent, .pm &#x3D; &amp;platform_dev_pm_ops,&#125;; 驱动和设备的匹配有四种方法，我们依次来看一下： 第一种匹配方式， OF 类型的匹配，也就是设备树采用的匹配方式，of_driver_match_device 函数定义在文件 include/linux/of_device.h 中。device_driver 结构体(表示设备驱动)中有个名为of_match_table的成员变量，此成员变量保存着驱动的compatible匹配表，设备树中的每个设备节点的 compatible 属性会和 of_match_table 表中的所有成员比较，查看是否有相同的条目，如果有的话就表示设备和此驱动匹配，设备和驱动匹配成功以后probe 函数就会执行。 第二种匹配方式，ACPI 匹配方式。 第三种匹配方式，id_table 匹配，每个 platform_driver 结构体有一个 id_table成员变量，保存了很多 id 信息。这些 id 信息存放着这个 platformd 驱动所支持的驱动类型。 第四种匹配方式，如果第三种匹配方式的 id_table 不存在的话就直接比较驱动和设备的 name 字段，看看是不是相等，如果相等的话就匹配成功。 对于支持设备树的 Linux 版本号，一般设备驱动为了兼容性都支持设备树和无设备树两种匹配方式。也就是第一种匹配方式一般都会存在，第三种和第四种只要存在一种就可以，一般用的最多的还是第四种，也就是直接比较驱动和设备的 name 字段，毕竟这种方式最简单了。 platform 驱动platform_driver 结 构 体 表 示 platform 驱动，此结构体定义在文件include/linux/platform_device.h 中 123456789struct platform_driver &#123; int (*probe)(struct platform_device *); int (*remove)(struct platform_device *); void (*shutdown)(struct platform_device *); int (*suspend)(struct platform_device *, pm_message_t state); int (*resume)(struct platform_device *); struct device_driver driver; const struct platform_device_id *id_table; 9 bool prevent_deferred_probe;&#125;; probe 函数，当驱动与设备匹配成功以后 probe 函数就会执行，非常重要的函数！一般驱动的提供者会编写，如果自己要编写一个全新的驱动，那么 probe 就需要自行实现。 driver 成员，为 device_driver 结构体变量，Linux 内核里面大量使用到了面向对象的思维，device_driver 相当于基类，提供了最基础的驱动框架。plaform_driver 继承了这个基类，然后在此基础上又添加了一些特有的成员变量。device_driver 结构体的成员of_match_table ，就是采用设备树的时候驱动使用的匹配表，同样是数组，每个匹配项都为 of_device_id 结构体类型，此结构体定义在文件 include/linux/mod_devicetable.h 中，内容如下： 123456struct of_device_id &#123; char name[32]; char type[32]; char compatible[128]; const void *data; &#125;; device_driver 结构体的成员compatible 非常重要，因为对于设备树而言，就是通过设备节点的 compatible 属性值和 of_match_table 中每个项目的 compatible 成员变量进行比较，如果有相等的就表示设备和此驱动匹配成功。 id_table 表， platform 总线匹配驱动和设备的时候采用的第三种方法，id_table 是个表(也就是数组)，每个元素的类型为 platform_device_id， 1234struct platform_device_id &#123; char name[PLATFORM_NAME_SIZE]; kernel_ulong_t driver_data; &#125;; 在编写 platform 驱动的时候，首先定义一个 platform_driver 结构体变量，然后实现结构体中的各个成员变量，重点是实现匹配方法以及 probe 函数。当驱动和设备匹配成功以后 probe函数就会执行，具体的驱动程序在 probe 函数里面编写，比如字符设备驱动等等。当我们定义并初始化好 platform_driver 结构体变量以后，需要在驱动入口函数里面调用platform_driver_register 函数向 Linux 内核注册一个 platform 驱动，还需要在驱动卸载函数中通过 platform_driver_unregister 函数卸载 platform 驱动。 123456int platform_driver_register (struct platform_driver *driver)&#x2F;&#x2F;driver：要注册的 platform 驱动。&#x2F;&#x2F;返回值：负数，失败；0，成功。void platform_driver_unregister(struct platform_driver *drv)&#x2F;&#x2F;drv：要卸载的 platform 驱动。 platform 驱动框架如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#x2F;* 设备结构体 *&#x2F;struct xxx_dev&#123; struct cdev cdev; &#x2F;* 设备结构体其他具体内容 *&#x2F;&#125;;struct xxx_dev xxxdev; &#x2F;* 定义个设备结构体变量 *&#x2F;static struct file_operations xxx_fops &#x3D; &#123; .owner &#x3D; THIS_MODULE,&#125;;&#x2F;** platform 驱动的 probe 函数* 驱动与设备匹配成功以后此函数就会执行*&#x2F;static int xxx_probe(struct platform_device *dev)&#123; ...... cdev_init(&amp;xxxdev.cdev, &amp;xxx_fops); &#x2F;* 注册字符设备驱动 *&#x2F; &#x2F;* 函数具体内容 *&#x2F; return 0;&#125;static int xxx_remove(struct platform_device *dev)&#123; ...... cdev_del(&amp;xxxdev.cdev);&#x2F;* 删除 cdev *&#x2F; &#x2F;* 函数具体内容 *&#x2F; return 0;&#125;&#x2F;* 匹配列表 *&#x2F;static const struct of_device_id xxx_of_match[] &#x3D; &#123; &#123; .compatible &#x3D; &quot;xxx-gpio&quot; &#125;, &#123; &#x2F;* Sentinel *&#x2F; &#125;&#125;; &#x2F;* * platform 平台驱动结构体*&#x2F;static struct platform_driver xxx_driver &#x3D; &#123; .driver &#x3D; &#123; .name &#x3D; &quot;xxx&quot;, .of_match_table &#x3D; xxx_of_match, &#125;, .probe &#x3D; xxx_probe, .remove &#x3D; xxx_remove,&#125;; &#x2F;* 驱动模块加载 *&#x2F;static int __init xxxdriver_init(void)&#123; return platform_driver_register(&amp;xxx_driver);&#125;&#x2F;* 驱动模块卸载 *&#x2F;static void __exit xxxdriver_exit(void)&#123; platform_driver_unregister(&amp;xxx_driver);&#125; 总体来说，platform 驱动还是传统的字符设备驱动、块设备驱动或网络设备驱动，只是套上了一张“platform”的皮，目的是为了使用总线、驱动和设备这个驱动模型来实现驱动的分离与分层。 platform 设备platform 驱动已经准备好了，我们还需要 platform 设备，否则的话单单一个驱动也做不了什么。platform_device 这个结构体表示 platform 设备，如果内核支持设备树的话就不要再使用 platform_device 来描述设备了，因为改用设备树去描述了。platform_device 结构体定义在文件include/linux/platform_device.h 中， 1234567struct platform_device &#123; const char *name; ………… u32 num_resources; struct resource *resource; …………&#125;; name 表示设备名字，要和所使用的 platform 驱动的 name 字段相同，否则的话备就无法匹配到对应的驱动。比如对应的 platform 驱动的 name 字段为“xxx-gpio”，那么此 name字段也要设置为“xxx-gpio”。num_resources 表示资源数量，一般为第 28 行 resource 资源的大小。resource 表示资源，也就是设备信息，比如外设寄存器等。Linux 内核使用 resource结构体表示资源 1234567struct resource &#123; resource_size_t start; resource_size_t end; const char *name; unsigned long flags; struct resource *parent, *sibling, *child;&#125;； start 和 end 分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址，name 表示资源名字，flags 表示资源类型，可选的资源类型都定义在了文件include/linux/ioport.h 里面。 在以前不支持设备树的Linux版本中，用户需要编写platform_device变量来描述设备信息，然后使用 platform_device_register 函数将设备信息注册到 Linux 内核中，如果不再使用 platform 的话可以通过 platform_device_unregister 函数注销掉相应的 platform设备， 12345int platform_device_register(struct platform_device *pdev)&#x2F;&#x2F;pdev：要注册的 platform 设备。&#x2F;&#x2F;返回值：负数，失败；0，成功。void platform_device_unregister(struct platform_device *pdev)&#x2F;&#x2F;pdev：要注销的 platform 设备。 platform 设备信息框架如下所示，在不支持设备树的 Linux 版本中使用的，当 Linux 内核支持了设备树以后就不需要用户手动去注册 platform 设备了。因为设备信息都放到了设备树中去描述，Linux 内核启动的时候会从设备树中读取设备信息，然后将其组织成 platform_device 形式，至于设备树到 platform_device 的具体过程就不去详细的追究了。 1234567891011121314151617181920212223242526272829303132333435363738 &#x2F;* 寄存器地址定义*&#x2F;#define PERIPH1_REGISTER_BASE (0X20000000) &#x2F;* 外设 1 寄存器首地址 *&#x2F; #define PERIPH2_REGISTER_BASE (0X020E0068) &#x2F;* 外设 2 寄存器首地址 *&#x2F;#define REGISTER_LENGTH 4&#x2F;* 资源 *&#x2F;static struct resource xxx_resources[] &#x3D; &#123; [0] &#x3D; &#123; .start &#x3D; PERIPH1_REGISTER_BASE, .end &#x3D; (PERIPH1_REGISTER_BASE + REGISTER_LENGTH - 1), .flags &#x3D; IORESOURCE_MEM, &#125;, [1] &#x3D; &#123; .start &#x3D; PERIPH2_REGISTER_BASE, .end &#x3D; (PERIPH2_REGISTER_BASE + REGISTER_LENGTH - 1), .flags &#x3D; IORESOURCE_MEM, &#125;,&#125;;&#x2F;* platform 设备结构体 *&#x2F;static struct platform_device xxxdevice &#x3D; &#123; .name &#x3D; &quot;xxx-gpio&quot;, .id &#x3D; -1, .num_resources &#x3D; ARRAY_SIZE(xxx_resources), .resource &#x3D; xxx_resources,&#125;;&#x2F;* 设备模块加载 *&#x2F;static int __init xxxdevice_init(void)&#123; return platform_device_register(&amp;xxxdevice);&#125;&#x2F;* 设备模块注销 *&#x2F;static void __exit xxx_resourcesdevice_exit(void)&#123; platform_device_unregister(&amp;xxxdevice);&#125; 数组 xxx_resources 表示设备资源，一共有两个资源，分别为设备外设 1 和外设 2 的寄存器信息。因此 flags 都为 IORESOURCE_MEM，表示资源为内存类型的。 platform 设备结构体变量，注意 name 字段要和所使用的驱动中的 name 字段一致，否则驱动和设备无法匹配成功。num_resources 表示资源大小，其实就是数组 xxx_resources的元素数量，这里用 ARRAY_SIZE 来测量一个数组的元素个数。 设备模块加载函数，在此函数中调用 platform_device_register 向 Linux 内核注 册 platform 设备。 设备模块卸载函数，在此函数中调用 platform_device_unregister 从 Linux 内核中卸载 platform 设备。","link":"","tags":[]},{"title":"Linux驱动-异步通知","date":"2021-04-16T07:40:56.000Z","path":"2021/04/16/Linux驱动-异步通知/","text":"异步通知简介Linux 应用程序可以通过阻塞或者非阻塞这两种方式来访问驱动设备，通过阻塞方式访问的话应用程序会处于休眠态，等待驱动设备可以使用，非阻塞方式的话会通过 poll 函数来不断的轮询，查看驱动设备文件是否可以使用。这两种方式都需要应用程序主动的去查询设备的使用情况。 最好的方式就是驱动程序能主动向应用程序发出通知，报告自己可以访问，然后应用程序在从驱动程序中读取或写入数据，类似中断的机制。Linux 提供了异步通知这个机制来完成此功能。 信号类似于我们硬件上使用的“中断”，只不过信号是软件层次上的。算是在软件层次上对中断的一种模拟，驱动可以通过主动向应用程序发送信号的方式来报告自己可以访问了，应用程序获取到信号以后就可以从驱动设备中读取或者写入数据了。整个过程就相当于应用程序收到了驱动发送过来了的一个中断，然后应用程序去响应这个中断，在整个处理过程中应用程序并没有去查询驱动设备是否可以访问，一切都是由驱动设备自己告诉给应用程序的。 阻塞、非阻塞、异步通知，这三种是针对不同的场合提出来的不同的解决方法，没有优劣之分，根据自己的实际需求选择合适的处理方法即可。 异步通知的核心就是信号，在 arch/xtensa/include/uapi/asm/signal.h 文件中定义了 Linux 所支持的所有信号， 12#define SIGKILL 9 &#x2F;* 杀死、终止进程 *&#x2F;#define SIGSTOP 19 &#x2F;* 停止进程的执行，只是暂停 *&#x2F; 除了 SIGKILL(9)和 SIGSTOP(19)这两个信号不能被忽略外，其他的信号都可以忽略。这些信号就相当于中断号，不同的中断号代表了不同的中断，不同的中断所做的处理不同，因此，驱动程序可以通过向应用程序发送不同的信号来实现不同的功能。 驱动中的信号处理1、fasync_struct 结构体首先我们需要在驱动程序中定义一个 fasync_struct 结构体指针变量，一般将 fasync_struct 结构体指针变量定义到设备结构体中： 12345678struct fasync_struct &#123; spinlock_t fa_lock; int magic; int fa_fd; struct fasync_struct *fa_next; struct file *fa_file; struct rcu_head fa_rcu;&#125;; 2、fasync 函数如果要使用异步通知，需要在设备驱动中实现 file_operations 操作集中的 fasync 函数，此函数格式如下所示： 1int (*fasync) (int fd, struct file *filp, int on) fasync 函数里面一般通过调用 fasync_helper 函数来初始化前面定义的 fasync_struct 结构体指针。在关闭驱动文件的时候需要在 file_operations 操作集中的 release 函数中使用释放fasync_helper函数 释放fasync_struct。 12int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)&#x2F;&#x2F;前三个参数就是 fasync 函数的那三个参数，第四个参数就是要初始化的 fasync_struct 结构体指针变量。 当应用程序通过“fcntl(fd, F_SETFL, flags | FASYNC)”改变fasync 标记的时候，驱动程序 file_operations 操作集中的 fasync 函数就会执行。 驱动程序中的 fasync 函数参考示例如下： 12345678910111213141516171819202122232425struct xxx_dev &#123; ...... struct fasync_struct *async_queue; &#x2F;* 异步相关结构体 *&#x2F;&#125;;static int xxx_fasync(int fd, struct file *filp, int on) &#123; struct xxx_dev *dev &#x3D; (xxx_dev)filp-&gt;private_data; if (fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue) &lt; 0) return -EIO; return 0;&#125;static int xxx_release(struct inode *inode, struct file *filp) &#123; return xxx_fasync(-1, filp, 0); &#x2F;* 删除异步通知 *&#x2F;&#125;static struct file_operations xxx_ops &#x3D; &#123; ...... .fasync &#x3D; xxx_fasync, .release &#x3D; xxx_release, ......&#125;; 3、kill_fasync 函数当设备可以访问的时候，驱动程序需要向应用程序发出信号，相当于产生“中断”。kill_fasync函数负责发送指定的信号，kill_fasync 函数原型如下所示： 1234void kill_fasync(struct fasync_struct **fp, int sig, int band)&#x2F;&#x2F;fp：要操作的 fasync_struct。&#x2F;&#x2F;sig：要发送的信号。&#x2F;&#x2F;band：可读时设置为 POLL_IN，可写时设置为 POLL_OUT。 应用程序对异步通知的处理应用程序对异步通知的处理包括以下三步： 1、注册信号处理函数我们使用中断的时候需要设置中断处理函数，同样的，如果要在应用程序中使用信号，那么就必须设置信号所使用的信号处理函数，在应用程序中使用 signal 函数来设置指定信号的处理函数，signal 函数原型如下所示： 1234sighandler_t signal(int signum, sighandler_t handler)&#x2F;&#x2F;signum：要设置处理函数的信号。&#x2F;&#x2F;handler：信号的处理函数。信号处理函数原型：typedef void (*sighandler_t)(int)&#x2F;&#x2F;返回值：设置成功的话返回信号的前一个处理函数，设置失败的话返回 SIG_ERR。 2、将本应用程序的进程号告诉给内核使用 fcntl(fd, F_SETOWN, getpid())将本应用程序的进程号告诉给内核。 3、开启异步通知使用如下两行程序开启异步通知： 12flags &#x3D; fcntl(fd, F_GETFL); &#x2F;* 获取当前的进程状态 *&#x2F;fcntl(fd, F_SETFL, flags | FASYNC); &#x2F;* 开启当前进程异步通知功能 *&#x2F; 重点就是通过 fcntl 函数设置进程状态为 FASYNC，经过这一步，驱动程序中的 fasync 函数就会执行。 实验程序编写当按键按下以后驱动程序向应用程序发送 SIGIO 信号，应用程序获取到 SIGIO 信号以后 读取并且打印出按键值。 驱动程序编写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#x2F;***************************************************************文件名 : asyncnoti.c描述 : 非阻塞IO访问***************************************************************&#x2F;&#x2F;* imx6uirq设备结构体 *&#x2F;struct imx6uirq_dev&#123; struct fasync_struct *async_queue; &#x2F;* 异步相关结构体 *&#x2F;&#125;;struct imx6uirq_dev imx6uirq; &#x2F;* irq设备 *&#x2F;&#x2F;* @description : 定时器服务函数，用于按键消抖，定时器到了以后 * 再次读取按键值，如果按键还是处于按下状态就表示按键有效。 * @param - arg : 设备结构变量 * @return : 无 *&#x2F;void timer_function(unsigned long arg)&#123; if(atomic_read(&amp;dev-&gt;releasekey)) &#123; &#x2F;* 一次完整的按键过程 *&#x2F; if(dev-&gt;async_queue) kill_fasync(&amp;dev-&gt;async_queue, SIGIO, POLL_IN); &#x2F;* 释放SIGIO信号 *&#x2F; &#125;&#125;&#x2F;* * @description : fasync函数，用于处理异步通知 * @param - fd : 文件描述符 * @param - filp : 要打开的设备文件(文件描述符) * @param - on : 模式 * @return : 负数表示函数执行失败 *&#x2F;static int imx6uirq_fasync(int fd, struct file *filp, int on)&#123; struct imx6uirq_dev *dev &#x3D; (struct imx6uirq_dev *)filp-&gt;private_data; return fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue);&#125;&#x2F;* * @description : release函数，应用程序调用close关闭驱动文件的时候会执行 * @param - inode : inode节点 * @param - filp : 要打开的设备文件(文件描述符) * @return : 负数表示函数执行失败 *&#x2F;static int imx6uirq_release(struct inode *inode, struct file *filp)&#123; return imx6uirq_fasync(-1, filp, 0);&#125;&#x2F;* 设备操作函数 *&#x2F;static struct file_operations imx6uirq_fops &#x3D; &#123; .owner &#x3D; THIS_MODULE, .open &#x3D; imx6uirq_open, .read &#x3D; imx6uirq_read, .fasync &#x3D; imx6uirq_fasync, .release &#x3D; imx6uirq_release,&#125;; 在设备结构体 imx6uirq_dev 中添加 fasync_struct 指针变量。如果是一次完整的按键过程，那么就通过 kill_fasync 函数发送 SIGIO 信号。imx6uirq_fasync 函数，为 file_operations 操作集中的 fasync 函数，此函数内容很简单，就是调用一下 fasync_helper。 release 函数，应用程序调用 close 函数关闭驱动设备文件的时候此函数就会执行，在此函数中释放掉 fasync_struct 指针变量。设置 file_operations 操作集中的 fasync 和 release 这两个成员变量。 编写测试 APP测试 APP 要实现的内容很简单，设置 SIGIO 信号的处理函数为 sigio_signal_func，当驱动 程序向应用程序发送 SIGIO 信号以后 sigio_signal_func 函数就会执行。sigio_signal_func 函数内 容很简单，就是通过 read 函数读取按键值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x2F;***************************************************************文件名 : asyncnotiApp.c描述 : 异步通知测试APP使用方法 ：.&#x2F;asyncnotiApp &#x2F;dev&#x2F;asyncnoti 打开测试App***************************************************************&#x2F;static int fd &#x3D; 0; &#x2F;* 文件描述符 *&#x2F;&#x2F;* * SIGIO信号处理函数 * @param - signum : 信号值 * @return : 无 *&#x2F;static void sigio_signal_func(int signum)&#123; int err &#x3D; 0; unsigned int keyvalue &#x3D; 0; err &#x3D; read(fd, &amp;keyvalue, sizeof(keyvalue)); if(err &lt; 0) &#123; &#x2F;* 读取错误 *&#x2F; &#125; else &#123; printf(&quot;sigio signal! key value&#x3D;%d\\r\\n&quot;, keyvalue); &#125;&#125;&#x2F;* * @description : main主程序 * @param - argc : argv数组元素个数 * @param - argv : 具体参数 * @return : 0 成功;其他 失败 *&#x2F;int main(int argc, char *argv[])&#123; filename &#x3D; argv[1]; fd &#x3D; open(filename, O_RDWR); &#x2F;* 设置信号SIGIO的处理函数 *&#x2F; signal(SIGIO, sigio_signal_func); fcntl(fd, F_SETOWN, getpid()); &#x2F;* 设置当前进程接收SIGIO信号 *&#x2F; flags &#x3D; fcntl(fd, F_GETFL); &#x2F;* 获取当前的进程状态 *&#x2F; fcntl(fd, F_SETFL, flags | FASYNC); &#x2F;* 设置进程启用异步通知功能 *&#x2F; while(1) &#123; sleep(2); &#125; close(fd); return 0;&#125; sigio_signal_func 函数，SIGIO 信号的处理函数，当驱动程序有效按键按下以后就会发送 SIGIO 信号，此函数就会执行。此函数通过 read 函数读取按键值，然后通过printf 函数打印在终端上。 通过 signal 函数设置 SIGIO 信号的处理函数为 sigio_signal_func。 设置当前进程的状态，开启异步通知的功能。 while 循环，等待信号产生。","link":"","tags":[]},{"title":"Linux驱动-非阻塞IO","date":"2021-04-16T06:31:11.000Z","path":"2021/04/16/Linux驱动-阻塞和非阻塞-非阻塞IO/","text":"非阻塞 IO对于非阻塞 IO，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。当使用非阻塞IO时，应用程序使用非阻塞访问方式从设备读取数据，当设备不可用或数据未准备好的时候会立即向内核返回一个错误码，表示数据读取失败。应用程序会再次重新读取数据，这样一直往复循环，直到数据读取成功。 12345应用程序非阻塞读取数据int fd; int data &#x3D; 0; fd &#x3D; open(&quot;&#x2F;dev&#x2F;xxx_dev&quot;, O_RDWR | O_NONBLOCK); &#x2F;* 非阻塞方式打开 *&#x2F;ret &#x3D; read(fd, &amp;data, sizeof(data)); &#x2F;* 读取数据 *&#x2F; 第 4 行使用 open 函数打开“/dev/xxx_dev”设备文件的时候添加了参数“O_NONBLOCK”，表示以非阻塞方式打开设备，这样从设备中读取数据的时候就是非阻塞方式的了。 非阻塞机制(轮询)如果用户应用程序以非阻塞的方式访问设备，设备驱动程序就要提供非阻塞的处理方式，也就是轮询。poll、epoll 和 select 可以用于处理轮询，应用程序通过 select、epoll 或 poll 函数来查询设备是否可以操作，如果可以操作的话就从设备读取或者向设备写入数据。当应用程序调用 select、epoll 或 poll 函数的时候设备驱动程序中的 poll 函数就会执行，因此需要在设备驱动程序中编写 poll 函数。 1、Linux 驱动下的 poll 操作函数当应用程序调用 select 或 poll 函数来对驱动程序进行非阻塞访问的时候，驱动程序file_operations 操作集中的 poll 函数就会执行。所以驱动程序的编写者需要提供对应的 poll 函数，poll 函数原型如下所示： 123456789101112unsigned int (*poll) (struct file *filp, struct poll_table_struct *wait)&#x2F;&#x2F;filp：要打开的设备文件(文件描述符)。&#x2F;&#x2F;wait：结构体 poll_table_struct 类型指针，由应用程序传递进来的。一般将此参数传递给&#x2F;&#x2F;poll_wait 函数。&#x2F;&#x2F;返回值:向应用程序返回设备或者资源状态，可以返回的资源状态如下： POLLIN 有数据可以读取。 POLLPRI 有紧急的数据需要读取。 POLLOUT 可以写数据。 POLLERR 指定的文件描述符发生错误。 POLLHUP 指定的文件描述符挂起。 POLLNVAL 无效的请求。 POLLRDNORM 等同于 POLLIN，普通数据可读 需要在驱动程序的 poll 函数中调用 poll_wait 函数，poll_wait 函数不会引起阻塞，只是将应用程序添加到 poll_table 中，poll_wait 函数原型如下： 123void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)&#x2F;&#x2F;wait_address 是要添加到 poll_table 中的等待队列头，&#x2F;&#x2F;p 就是 poll_table，就是file_operations 中 poll 函数的 wait 参数。 应用程序调用 select、epoll 或 poll 函数1、select 函数1234567int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)&#x2F;&#x2F;nfds：所要监视的这三类文件描述集合中，最大文件描述符加 1。&#x2F;&#x2F;readfds、writefds 和 exceptfds：这三个指针指向描述符集合，这三个参数指明了关心哪些描述符、需要满足哪些条件等等，&#x2F;&#x2F;timeout:超时时间，当 timeout 为 NULL 的时候就表示无限期的等待。&#x2F;&#x2F;返回值：0，表示的话就表示超时发生，但是没有任何文件描述符可以进行操作；-1，发生&#x2F;&#x2F;错误；其他值，可以进行操作的文件描述符个数。 readfds、writefds 和 exceptfds：这三个指针指向描述符集合，这三个参数指明了关心哪些描述符、需要满足哪些条件等等，这三个参数都是 fd_set 类型的，fd_set 类型变量的每一个位都代表了一个文件描述符。readfds 用于监视指定描述符集的读变化，也就是监视这些文件是否可以读取，只要这些集合里面有一个文件可以读取那么 seclect 就会返回一个大于 0 的值表示文件可以读取。如果没有文件可以读取，那么就会根据 timeout 参数来判断是否超时。可以将 readfs设置为 NULL，表示不关心任何文件的读变化。 writefs 用于监视这些文件是否可以进行写操作。exceptfds 用于监视这些文件的异常。 比如我们现在要从一个设备文件中读取数据，那么就可以定义一个 fd_set 变量，这个变量要传递给参数 readfds。当我们定义好一个 fd_set 变量以后可以使用如下所示几个宏进行操作： 1234void FD_ZERO(fd_set *set)void FD_SET(int fd, fd_set *set)void FD_CLR(int fd, fd_set *set)int FD_ISSET(int fd, fd_set *set) FD_ZERO 用于将 fd_set 变量的所有位都清零，FD_SET 用于将 fd_set 变量的某个位置 1，也就是向 fd_set 添加一个文件描述符 fd 。FD_CLR 用户将 fd_set变量的某个位清零，也就是将一个文件描述符 fd 从 fd_set 中删除FD_ISSET 用于测试一个文件描述符 fd是否属于某个集合。 timeout:超时时间，当我们调用 select 函数等待某些文件描述符可以设置超时时间，超时时间使用结构体 timeval 表示，结构体定义如下所示： 1234struct timeval &#123; long tv_sec; &#x2F;* 秒 *&#x2F; long tv_usec; &#x2F;* 微妙 *&#x2F;&#125;; 使用 select 函数对某个设备驱动文件进行读非阻塞访问的操作示例如下所示： 123456789101112131415161718192021222324252627282930void main(void) &#123; int ret, fd; &#x2F;* 要监视的文件描述符 *&#x2F; fd_set readfds; &#x2F;* 读操作文件描述符集 *&#x2F; struct timeval timeout; &#x2F;* 超时结构体 *&#x2F; fd &#x3D; open(&quot;dev_xxx&quot;, O_RDWR | O_NONBLOCK); &#x2F;* 非阻塞式访问 *&#x2F; FD_ZERO(&amp;readfds); &#x2F;* 清除 readfds *&#x2F; FD_SET(fd, &amp;readfds); &#x2F;* 将 fd 添加到 readfds 里面 *&#x2F; &#x2F;* 构造超时时间 *&#x2F; timeout.tv_sec &#x3D; 0; timeout.tv_usec &#x3D; 500000; &#x2F;* 500ms *&#x2F; ret &#x3D; select(fd + 1, &amp;readfds, NULL, NULL, &amp;timeout); switch (ret) &#123; case 0: &#x2F;* 超时 *&#x2F; printf(&quot;timeout!\\r\\n&quot;); break; case -1: &#x2F;* 错误 *&#x2F; printf(&quot;error!\\r\\n&quot;); break; default: &#x2F;* 可以读取数据 *&#x2F; if(FD_ISSET(fd, &amp;readfds)) &#123; &#x2F;* 判断是否为 fd 文件描述符 *&#x2F; &#x2F;* 使用 read 函数读取数据 *&#x2F; &#125; break; &#125; &#125; 2、poll 函数在单个线程中，select 函数能够监视的文件描述符数量有最大的限制，一般为 1024，可以修改内核将监视的文件描述符数量改大，但是这样会降低效率！这个时候就可以使用 poll 函数，poll 函数本质上和 select 没有太大的差别，但是 poll 函数没有最大文件描述符限制，Linux 应用程序中 poll 函数原型如下所示： 12345int poll(struct pollfd *fds, nfds_t nfds, int timeout)&#x2F;&#x2F;fds：要监视的文件描述符集合以及要监视的事件,为一个数组，数组元素都是结构体 pollfd类型的，&#x2F;&#x2F;nfds：poll 函数要监视的文件描述符数量。&#x2F;&#x2F;timeout：超时时间，单位为 ms。&#x2F;&#x2F;返回值：返回 revents 域中不为 0 的 pollfd 结构体个数，也就是发生事件或错误的文件描述符数量；0，超时；-1，发生错误，并且设置 errno 为错误类型。 fds：要监视的文件描述符集合以及要监视的事件,为一个数组，数组元素都是结构体 pollfd类型的， 1234567891011121314struct pollfd &#123; int fd; &#x2F;* 文件描述符 *&#x2F; short events; &#x2F;* 请求的事件 *&#x2F; short revents; &#x2F;* 返回的事件 *&#x2F;&#125;;&#x2F;&#x2F;fd 是要监视的文件描述符，如果 fd 无效的话那么 events 监视事件也就无效，并且 revents返回 0。events 是要监视的事件，可监视的事件类型如下所示： POLLIN 有数据可以读取。 POLLPRI 有紧急的数据需要读取。 POLLOUT 可以写数据。 POLLERR 指定的文件描述符发生错误。 POLLHUP 指定的文件描述符挂起。 POLLNVAL 无效的请求。 POLLRDNORM 等同于 POLLIN&#x2F;&#x2F;revents 是返回参数，也就是返回的事件，由 Linux 内核设置具体的返回事件。 使用 poll 函数对某个设备驱动文件进行读非阻塞访问的操作示例如下所示： 1234567891011121314151617181920212223void main(void) &#123; int ret; int fd; &#x2F;* 要监视的文件描述符 *&#x2F; struct pollfd fds; fd &#x3D; open(filename, O_RDWR | O_NONBLOCK); &#x2F;* 非阻塞式访问 *&#x2F; &#x2F;* 构造结构体 *&#x2F; fds.fd &#x3D; fd; fds.events &#x3D; POLLIN; &#x2F;* 监视数据是否可以读取 *&#x2F; ret &#x3D; poll(&amp;fds, 1, 500); &#x2F;* 轮询文件是否可操作，超时 500ms *&#x2F; if (ret) &#123; &#x2F;* 数据有效 *&#x2F; ...... &#x2F;* 读取数据 *&#x2F; ...... &#125; else if (ret &#x3D;&#x3D; 0) &#123; &#x2F;* 超时 *&#x2F; ...... &#125; else if (ret &lt; 0) &#123; &#x2F;* 错误 *&#x2F; ...... &#125;&#125; 3、epoll 函数传统的 selcet 和 poll 函数都会随着所监听的 fd 数量的增加，出现效率低下的问题，而且poll 函数每次必须遍历所有的描述符来检查就绪的描述符，这个过程很浪费时间。为此，epoll应运而生，epoll 就是为处理大并发而准备的，一般常常在网络编程中使用 epoll 函数。应用程序需要先使用 epoll_create 函数创建一个 epoll 句柄， 123int epoll_create(int size)&#x2F;&#x2F;size：从 Linux2.6.8 开始此参数已经没有意义了，随便填写一个大于 0 的值就可以。&#x2F;&#x2F;返回值：epoll 句柄，如果为-1 的话表示创建失败。 epoll 句柄创建成功以后使用 epoll_ctl 函数向其中添加要监视的文件描述符以及监视的事件， 123456789int epoll_ctl(int epfd, int op, int fd,struct epoll_event *event)epfd：要操作的 epoll 句柄，也就是使用 epoll_create 函数创建的 epoll 句柄。op：表示要对 epfd(epoll 句柄)进行的操作，可以设置为： EPOLL_CTL_ADD 向 epfd 添加文件参数 fd 表示的描述符。 EPOLL_CTL_MOD 修改参数 fd 的 event 事件。 EPOLL_CTL_DEL 从 epfd 中删除 fd 描述符。fd：要监视的文件描述符。event：要监视的事件类型，为 epoll_event 结构体类型指针，返回值：0，成功；-1，失败，并且设置 errno 的值为相应的错误码。 event：要监视的事件类型，为 epoll_event 结构体类型指针，epoll_event 结构体类型如下所示： 123456789101112struct epoll_event &#123; uint32_t events; &#x2F;* epoll 事件 *&#x2F; epoll_data_t data; &#x2F;* 用户数据 *&#x2F;&#125;;&#x2F;&#x2F;events 成员变量表示要监视的事件，可选的事件如下所示，这些事件可以进行“或”操作，即可以设置监视多个事件。EPOLLIN 有数据可以读取。EPOLLOUT 可以写数据。EPOLLPRI 有紧急的数据需要读取。EPOLLERR 指定的文件描述符发生错误。EPOLLHUP 指定的文件描述符挂起。EPOLLET 设置 epoll 为边沿触发，默认触发模式为水平触发。EPOLLONESHOT 一次性的监视，当监视完成以后还需要再次监视某个fd，那么就需要将fd 重新添加到 epoll 里面。 一切都设置好以后应用程序就可以通过 epoll_wait 函数来等待事件的发生，类似 select 函数。 1234567int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout)&#x2F;&#x2F;epfd：要等待的 epoll。&#x2F;&#x2F;events：指向 epoll_event 结构体的数组，当有事件发生的时候 Linux 内核会填写 events，调用者可以根据 events 判断发生了哪些事件。&#x2F;&#x2F;maxevents：events 数组大小，必须大于 0。&#x2F;&#x2F;timeout：超时时间，单位为 ms。&#x2F;&#x2F;返回值：0，超时；-1，错误；其他值，准备就绪的文件描述符数量。 epoll 更多的是用在大规模的并发服务器上，因为在这种场合下 select 和 poll 并不适合。当设计到的文件描述符(fd)比较少的时候就适合用 selcet 和 poll，本章我们就使用 sellect 和 poll 这两个函数。 非阻塞 IO 实验Linux 中断中，我们直接在应用程序中通过 read 函数不断的读取按键状态，当按键有效的时候就打印出按键值。这种方法有个缺点，那就是 imx6uirqApp 这个测试应用程序拥有很高的 CPU 占用率，原因就在于我们是直接在 while 循环中通过 read 函数读取按键值，因此 imx6uirqApp 这个软件会一直运行，一直读取 按键值，CPU 使用率肯定就会很高。最好的方法就是在没有有效的按键事件发生的时候，imx6uirqApp 这个应用程序应该处于休眠状态，当有按键事件发生以后 imx6uirqApp 这个应用程序才运行，打印出按键值，这样就会降低 CPU 使用率。 1、驱动程序编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&#x2F;***************************************************************文件名 : noblock.c描述 : 非阻塞IO访问***************************************************************&#x2F;&#x2F;* imx6uirq设备结构体 *&#x2F;struct imx6uirq_dev&#123; wait_queue_head_t r_wait; &#x2F;* 读等待队列头 *&#x2F;&#125;;struct imx6uirq_dev imx6uirq; &#x2F;* irq设备 *&#x2F;&#x2F;* @description : 定时器服务函数，用于按键消抖，定时器到了以后 * 再次读取按键值，如果按键还是处于按下状态就表示按键有效。 * @param - arg : 设备结构变量 * @return : 无 *&#x2F;void timer_function(unsigned long arg)&#123; &#x2F;* 唤醒进程 *&#x2F; if(atomic_read(&amp;dev-&gt;releasekey)) &#123; &#x2F;* 完成一次按键过程 *&#x2F; &#x2F;* wake_up(&amp;dev-&gt;r_wait); *&#x2F; wake_up_interruptible(&amp;dev-&gt;r_wait); &#125;&#125;&#x2F;* * @description : 按键IO初始化 * @param : 无 * @return : 无 *&#x2F;static int keyio_init(void)&#123; &#x2F;* 初始化等待队列头 *&#x2F; init_waitqueue_head(&amp;imx6uirq.r_wait); return 0;&#125; &#x2F;* * @description : 从设备读取数据 * @param - filp : 要打开的设备文件(文件描述符) * @param - buf : 返回给用户空间的数据缓冲区 * @param - cnt : 要读取的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 读取的字节数，如果为负值，表示读取失败 *&#x2F;static ssize_t imx6uirq_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)&#123; if (filp-&gt;f_flags &amp; O_NONBLOCK) &#123; &#x2F;* 非阻塞访问 *&#x2F; if(atomic_read(&amp;dev-&gt;releasekey) &#x3D;&#x3D; 0) &#x2F;* 没有按键按下，返回-EAGAIN *&#x2F; return -EAGAIN; &#125; &#125; &#x2F;* * @description : poll函数，用于处理非阻塞访问 * @param - filp : 要打开的设备文件(文件描述符) * @param - wait : 等待列表(poll_table) * @return : 设备或者资源状态， *&#x2F;unsigned int imx6uirq_poll(struct file *filp, struct poll_table_struct *wait)&#123; poll_wait(filp, &amp;dev-&gt;r_wait, wait); &#x2F;* 将等待队列头添加到poll_table中 *&#x2F; if(atomic_read(&amp;dev-&gt;releasekey)) &#123; &#x2F;* 按键按下 *&#x2F; mask &#x3D; POLLIN | POLLRDNORM; &#x2F;* 返回PLLIN *&#x2F; &#125; return mask;&#125;&#x2F;* 设备操作函数 *&#x2F;static struct file_operations imx6uirq_fops &#x3D; &#123; .owner &#x3D; THIS_MODULE, .open &#x3D; imx6uirq_open, .read &#x3D; imx6uirq_read, .poll &#x3D; imx6uirq_poll,&#125;; 判断是否为非阻塞式读取访问，如果是的话就判断按键是否有效，也就是判断一下有没有按键按下，如果没有的话就返回-EAGAIN。 mx6uirq_poll 函数就是 file_operations 驱动操作集中的 poll 函数，当应用 程序调用 select 或者 poll 函数的时候 imx6uirq_poll 函数就会执行。调用 poll_wait 函数 将等待队列头添加到 poll_table 中，判断按键是否有效，如果按键有效的话就向应用程序返回 POLLIN 这个事件，表示有数据可以读取。 设置 file_operations 的 poll 成员变量为 imx6uirq_poll 编写测试 APP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&#x2F;***************************************************************文件名 : noblockApp.c描述 : 非阻塞访问测试APP使用方法 ：.&#x2F;blockApp &#x2F;dev&#x2F;blockio 打开测试App***************************************************************&#x2F;&#x2F;* * @description : main主程序 * @param - argc : argv数组元素个数 * @param - argv : 具体参数 * @return : 0 成功;其他 失败 *&#x2F;int main(int argc, char *argv[])&#123; filename &#x3D; argv[1]; fd &#x3D; open(filename, O_RDWR | O_NONBLOCK); &#x2F;* 非阻塞访问 *&#x2F;#if 0 &#x2F;* 构造结构体 *&#x2F; fds.fd &#x3D; fd; fds.events &#x3D; POLLIN; while (1) &#123; ret &#x3D; poll(&amp;fds, 1, 500); if (ret) &#123; &#x2F;* 数据有效 *&#x2F; ret &#x3D; read(fd, &amp;data, sizeof(data)); if(ret &lt; 0) &#123; &#x2F;* 读取错误 *&#x2F; &#125; else &#123; if(data) printf(&quot;key value &#x3D; %d \\r\\n&quot;, data); &#125; &#125; else if (ret &#x3D;&#x3D; 0) &#123; &#x2F;* 超时 *&#x2F; &#x2F;* 用户自定义超时处理 *&#x2F; &#125; else if (ret &lt; 0) &#123; &#x2F;* 错误 *&#x2F; &#x2F;* 用户自定义错误处理 *&#x2F; &#125; &#125;#endif while (1) &#123; FD_ZERO(&amp;readfds); FD_SET(fd, &amp;readfds); &#x2F;* 构造超时时间 *&#x2F; timeout.tv_sec &#x3D; 0; timeout.tv_usec &#x3D; 500000; &#x2F;* 500ms *&#x2F; ret &#x3D; select(fd + 1, &amp;readfds, NULL, NULL, &amp;timeout); switch (ret) &#123; case 0: &#x2F;* 超时 *&#x2F; &#x2F;* 用户自定义超时处理 *&#x2F; break; case -1: &#x2F;* 错误 *&#x2F; &#x2F;* 用户自定义错误处理 *&#x2F; break; default: &#x2F;* 可以读取数据 *&#x2F; if(FD_ISSET(fd, &amp;readfds)) &#123; ret &#x3D; read(fd, &amp;data, sizeof(data)); if (ret &lt; 0) &#123; &#x2F;* 读取错误 *&#x2F; &#125; else &#123; if (data) printf(&quot;key value&#x3D;%d\\r\\n&quot;, data); &#125; &#125; break; &#125; &#125; close(fd); return ret;&#125; 分别使用 poll 函数、select 函数来实现非阻塞访问， 在 while 循环中使用 poll 函数不 断的轮询，检查驱动程序是否有数据可以读取，如果可以读取的话就调用 read 函数读取按键 数据。","link":"","tags":[]},{"title":"Linux驱动-阻塞IO","date":"2021-04-16T06:31:02.000Z","path":"2021/04/16/Linux驱动-阻塞和非阻塞-阻塞IO/","text":"这里的“IO”单片机的“GPIO”(也就是引脚)。 这里的 IO 指的是 Input/Output，也就是输入/输出，是应用程序对驱动设备的输入/输出操作。 阻塞IO当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么阻塞式 IO 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。当使用阻塞IO时，应用程序调用 read 函数从设备中读取数据，当设备不可用或数据未准备好的时候就会进入到休眠态。等设备可用的时候就会从休眠态唤醒，然后从设备中读取数据返回给应用程序。 12345&#x2F;&#x2F;应用程序阻塞读取数据int fd; int data &#x3D; 0; fd &#x3D; open(&quot;&#x2F;dev&#x2F;xxx_dev&quot;, O_RDWR); &#x2F;* 阻塞方式打开 *&#x2F;ret &#x3D; read(fd, &amp;data, sizeof(data)); &#x2F;* 读取数据 *&#x2F; 可以看出，对于设备驱动文件的默认读取方式就是阻塞式的，所以前面所有的例程测试 APP 都是采用阻塞 IO。 阻塞IO机制等待队列 1、等待队列头IO 阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU 资源让出来。但是，当设备文件可以操作的时候就必须唤醒进程，一般在中断函数里面完成唤醒工作。Linux 内核提供了等待队列(wait queue)来实现阻塞进程的唤醒工作，如果我们要在驱动中使用等待队列，必须创建并初始化一个等待队列头，等待队列头使用结构体wait_queue_head_t 表示 12345struct __wait_queue_head &#123; spinlock_t lock; struct list_head task_list;&#125;;typedef struct __wait_queue_head wait_queue_head_t; 定义好等待队列头以后需要初始化，使用 init_waitqueue_head 函数初始化等待队列头， 1void init_waitqueue_head(wait_queue_head_t *q)&#x2F;&#x2F;参数 q 就是要初始化的等待队列头。 2、等待队列项 等待队列头就是一个等待队列的头部，每个访问设备的进程都是一个队列项，当设备不可用的时候就要将这些进程对应的等待队列项添加到等待队列里面。结构体 wait_queue_t 表示等待队列项， 1234567struct __wait_queue &#123; unsigned int flags; void *private; wait_queue_func_t func; struct list_head task_list; &#125;;typedef struct __wait_queue wait_queue_t; 使用宏 DECLARE_WAITQUEUE 定义并初始化一个等待队列项，宏的内容如下： 1DECLARE_WAITQUEUE(name, tsk) name ，等待队列项的名字，tsk 表示这个等待队列项属于哪个任务(进程)，一般设置为current ， 在 Linux 内核中 current 相 当 于一个全 局 变 量 ， 表 示当前 进 程 。 因 此 宏 DECLARE_WAITQUEUE 就是给当前正在运行的进程创建并初始化了一个等待队列项。 3、将队列项添加/移除等待队列头 当设备不可访问的时候就需要将进程对应的等待队列项添加到前面创建的等待队列头中，只有添加到等待队列头中以后进程才能进入休眠态。当设备可以访问以后再将进程对应的等待队列项从等待队列头中移除即可，等待队列项添加、等待队列项移除 API 函数如下： 123void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)&#x2F;&#x2F;q：要删除的等待队列项所处的等待队列头。wait：要删除的等待队列项。返回值：无 4、等待唤醒当设备可以使用的时候就要唤醒进入休眠态的进程(主动唤醒)，唤醒可以使用如下两个函数： 12void wake_up(wait_queue_head_t *q)void wake_up_interruptible(wait_queue_head_t *q) 参数 q 就是要唤醒的等待队列头，这两个函数会将这个等待队列头中的所有进程都唤醒。wake_up 函数可以唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 状态的进程，而 wake_up_interruptible 函数只能唤醒处于 TASK_INTERRUPTIBLE 状态的进程。 5、等待事件除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就自动唤醒等待队列中的进程 1234567891011wait_event(wq, condition) &#x2F;&#x2F;等待以wq 为等待队列头的等待队列被唤醒，前提是 condition 条件必须满足(为真)，否则一直阻塞。此函数会将 进程设置为TASK_UNINTERRUPTIBLE 状态wait_event_timeout(wq, condition, timeout) &#x2F;&#x2F;功能和 wait_event 类似，但是此函数可以添加超时时间，以 jiffies 为单位。此函数有返回值，如果返回 0 的话表示超时时间到，而且 condition 为假。为 1 的话表示 condition 为真，也就是条件满足了。 wait_event_interruptible(wq, condition) &#x2F;&#x2F;与 wait_event 函数类似，但是此函数将进程设置为 TASK_INTERRUPTIBLE，就是可以被信号打断。wait_event_interruptible_timeout(wq, condition, timeout) &#x2F;&#x2F;与 wait_event_timeout 函数类似，此函数也将进程设置为 TASK_INTERRUPTIBLE，可以被信号打断。 阻塞 IO 实验Linux 中断中，我们直接在应用程序中通过 read 函数不断的读取按键状态，当按键有效的时候就打印出按键值。这种方法有个缺点，那就是 imx6uirqApp 这个测试应用程序拥有很高的 CPU 占用率，原因就在于我们是直接在 while 循环中通过 read 函数读取按键值，因此 imx6uirqApp 这个软件会一直运行，一直读取 按键值，CPU 使用率肯定就会很高。最好的方法就是在没有有效的按键事件发生的时候，imx6uirqApp 这个应用程序应该处于休眠状态，当有按键事件发生以后 imx6uirqApp 这个应用程序才运行，打印出按键值，这样就会降低 CPU 使用率。 使用等待队列实现阻塞访问重点注意两点： ①、将任务或者进程加入到等待队列头， ②、在合适的点唤醒等待队列，一般都是中断处理函数里面 实验程序编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&#x2F;***************************************************************文件名 : block.c描述 : 阻塞IO访问***************************************************************&#x2F;&#x2F;* imx6uirq设备结构体 *&#x2F;struct imx6uirq_dev&#123; wait_queue_head_t r_wait; &#x2F;* 读等待队列头 *&#x2F;&#125;;struct imx6uirq_dev imx6uirq; &#x2F;* irq设备 *&#x2F;&#x2F;* @description : 定时器服务函数，用于按键消抖，定时器到了以后 * 再次读取按键值，如果按键还是处于按下状态就表示按键有效。 * @param - arg : 设备结构变量 * @return : 无 *&#x2F;void timer_function(unsigned long arg)&#123; &#x2F;* 唤醒进程 *&#x2F; if(atomic_read(&amp;dev-&gt;releasekey)) &#123; &#x2F;* 完成一次按键过程 *&#x2F; &#x2F;* wake_up(&amp;dev-&gt;r_wait); *&#x2F; wake_up_interruptible(&amp;dev-&gt;r_wait); &#125;&#125;&#x2F;* * @description : 按键IO初始化 * @param : 无 * @return : 无 *&#x2F;static int keyio_init(void)&#123; &#x2F;* 初始化等待队列头 *&#x2F; init_waitqueue_head(&amp;imx6uirq.r_wait); return 0;&#125; &#x2F;* * @description : 从设备读取数据 * @param - filp : 要打开的设备文件(文件描述符) * @param - buf : 返回给用户空间的数据缓冲区 * @param - cnt : 要读取的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 读取的字节数，如果为负值，表示读取失败 *&#x2F;static ssize_t imx6uirq_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)&#123;#if 0 &#x2F;* 加入等待队列，等待被唤醒,也就是有按键按下 *&#x2F; ret &#x3D; wait_event_interruptible(dev-&gt;r_wait, atomic_read(&amp;dev-&gt;releasekey)); if (ret) &#123; goto wait_error; &#125; #endif DECLARE_WAITQUEUE(wait, current); &#x2F;* 定义一个等待队列 *&#x2F; if(atomic_read(&amp;dev-&gt;releasekey) &#x3D;&#x3D; 0) &#123; &#x2F;* 没有按键按下 *&#x2F; add_wait_queue(&amp;dev-&gt;r_wait, &amp;wait); &#x2F;* 将等待队列添加到等待队列头 *&#x2F; __set_current_state(TASK_INTERRUPTIBLE);&#x2F;* 设置任务状态 *&#x2F; schedule(); &#x2F;* 进行一次任务切换，当前进程就会进入到休眠态 *&#x2F; if(signal_pending(current)) &#123; &#x2F;* 判断是否为信号引起的唤醒 *&#x2F; ret &#x3D; -ERESTARTSYS; goto wait_error; &#125; __set_current_state(TASK_RUNNING); &#x2F;* 将当前任务设置为运行状态 *&#x2F; remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait); &#x2F;* 将对应的队列项从等待队列头删除 *&#x2F; &#125; keyvalue &#x3D; atomic_read(&amp;dev-&gt;keyvalue); releasekey &#x3D; atomic_read(&amp;dev-&gt;releasekey); if (releasekey) &#123; &#x2F;* 有按键按下 *&#x2F; if (keyvalue &amp; 0x80) &#123; keyvalue &amp;&#x3D; ~0x80; ret &#x3D; copy_to_user(buf, &amp;keyvalue, sizeof(keyvalue)); &#125; else &#123; goto data_error; &#125; atomic_set(&amp;dev-&gt;releasekey, 0);&#x2F;* 按下标志清零 *&#x2F; &#125; else &#123; goto data_error; &#125; return 0;wait_error: set_current_state(TASK_RUNNING); &#x2F;* 设置任务为运行态 *&#x2F; remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait); &#x2F;* 将等待队列移除 *&#x2F; return ret;data_error: return -EINVAL;&#125;&#x2F;* * @description : 驱动入口函数 * @param : 无 * @return : 无 *&#x2F;static int __init imx6uirq_init(void)&#123; &#x2F;* 5、始化按键 *&#x2F; atomic_set(&amp;imx6uirq.keyvalue, INVAKEY); atomic_set(&amp;imx6uirq.releasekey, 0); keyio_init(); return 0;&#125; 在设备结构体中添加一个等待队列头 r_wait，因为在 Linux 驱动中处理阻塞 IO 需要用到等待队列。 定时器中断处理函数执行，表示有按键按下，先判断一下是否是一次有效的按键，如果是的话就通过 wake_up 或者 wake_up_interruptible 函数来唤醒等待队列头r_wait。 调用 init_waitqueue_head 函数初始化等待队列头 r_wait 采用等待事件来处理 read 的阻塞访问，wait_event_interruptible 函数等待releasekey 有效，也就是有按键按下。如果按键没有按下的话进程就会进入休眠状态，因为采用了 wait_event_interruptible 函数，因此进入休眠态的进程可以被信号打断。 第 208~218 行，首先使用 DECLARE_WAITQUEUE 宏定义一个等待队列，如果没有按键按下的话就使用 add_wait_queue 函数将当前任务的等待队列添加到等待队列头 r_wait 中。随后调用 _set_current_state 函数设置当前进程的状态为 TASK_INTERRUPTIBLE，也就是可以被信号打断。接下来调用 schedule 函数进行一次任务切换，当前进程就会进入到休眠态。如果有按键按下，那么进入休眠态的进程就会唤醒，然后接着从休眠点开始运行。在这里也就是从第 213行开始运行，首先通过 signal_pending 函数判断一下进程是不是由信号唤醒的，如果是由信号唤醒的话就直接返回-ERESTARTSYS 这个错误码。如果不是由信号唤醒的(也就是被按键唤醒的) 那么就在 217 行调用__set_current_state 函数将任务状态设置为 TASK_RUNNING，然后在218 行调用 remove_wait_queue 函数将进程从等待队列中删除。","link":"","tags":[]},{"title":"Linux驱动-Linux中断下半部机制","date":"2021-04-15T16:04:12.000Z","path":"2021/04/16/Linux驱动-Linux中断下半部机制/","text":"上半部与下半部上半部和下半部也称为顶半部和底半部。在使用 request_irq 申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。中断处理函数一定要快点执行完毕，越短越好，但是有些中断处理过程就是比较费时间，必须要对其进行处理，缩小中断处理函数的执行时间。 中断处理过程可分为了两部分： 上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。 下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。 因此，Linux 内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，那些对时间敏感、执行速度快的操作可以放到中断处理函数中，也就是上半部。剩下的所有工作都可以放到下半部去执行， ①、如果要处理的内容不希望被其他中断打断，那么可以放到上半部。 ②、如果要处理的任务对时间敏感，可以放到上半部。 ③、如果要处理的任务与硬件有关，可以放到上半部 ④、除了上述三点以外的其他任务，优先考虑放到下半部。 下半部机制1、软中断Linux内核使用结构体softirq_action表示软中断，softirq_action结构体定义在文件include/linux/interrupt.h中， 1234struct softirq_action&#123; void (*action)(struct softirq_action *);&#125;; 1static struct softirq_action softirq_vec[NR_SOFTIRQS]; 123456789101112131415示例代码softirq_vec 数组enum&#123; HI_SOFTIRQ&#x3D;0, &#x2F;* 高优先级软中断 *&#x2F; TIMER_SOFTIRQ, &#x2F;* 定时器软中断 *&#x2F; NET_TX_SOFTIRQ, &#x2F;* 网络数据发送软中断 *&#x2F; NET_RX_SOFTIRQ, &#x2F;* 网络数据接收软中断 *&#x2F; BLOCK_SOFTIRQ, BLOCK_IOPOLL_SOFTIRQ, TASKLET_SOFTIRQ, &#x2F;* tasklet 软中断 *&#x2F; SCHED_SOFTIRQ, &#x2F;* 调度软中断 *&#x2F; HRTIMER_SOFTIRQ, &#x2F;* 高精度定时器软中断 *&#x2F; RCU_SOFTIRQ, &#x2F;* RCU 软中断 *&#x2F; NR_SOFTIRQS &#x2F;* *&#x2F;&#125;; 可以看出，一共有 10 个软中断，NR_SOFTIRQS 是枚举类型，NR_SOFTIRQS 为 10，softirq_action 结构体中的 action 成员变量就是软中断的服务函数，数组 softirq_vec 是个有 10 个 元素的全局数组，因此所有的 CPU(对于 SMP 系统而言)都可以访问到，每个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个 CPU 所执行的软中断服务函数确是相同的，都是数组 softirq_vec 中定义的 action 函数。 要使用软中断，必须先使用 open_softirq 函数注册对应的软中断处理函数，open_softirq 函数原型如下： 1void open_softirq(int nr, void (*action)(struct softirq_action *)) nr：要开启的软中断，在示例代码 51.1.2.3 中选择一个。action：软中断对应的处理函数。返回值：没有返回值。 注册好软中断以后需要通过 raise_softirq 函数触发，raise_softirq 函数原型如下： 1void raise_softirq(unsigned int nr)&#x2F;&#x2F;nr：要触发的软中断。返回值：没有返回值。 软中断必须在编译的时候静态注册！Linux内核使用 softirq_init 函数初始化软中断，softirq_init 函数定义在 kernel/softirq.c 文件里面， 1234567891011121314void __init softirq_init(void)&#123; int cpu; for_each_possible_cpu(cpu) &#123; per_cpu(tasklet_vec, cpu).tail &#x3D; &amp;per_cpu(tasklet_vec, cpu).head; per_cpu(tasklet_hi_vec, cpu).tail &#x3D; &amp;per_cpu(tasklet_hi_vec, cpu).head; &#125; open_softirq(TASKLET_SOFTIRQ, tasklet_action); open_softirq(HI_SOFTIRQ, tasklet_hi_action);&#125; softirq_init 函数默认会打开 TASKLET_SOFTIRQ (tasklet 软中断)和 HI_SOFTIRQ(高优先级软中断)。 2、tasklettasklet 是利用软中断来实现的另外一种下半部机制，在软中断和 tasklet 之间，建议使用 tasklet。 12345678struct tasklet_struct&#123; struct tasklet_struct *next; &#x2F;* 下一个 tasklet *&#x2F; unsigned long state; &#x2F;* tasklet 状态 *&#x2F; atomic_t count; &#x2F;* 计数器，记录对 tasklet 的引用数 *&#x2F; void (*func)(unsigned long); &#x2F;* tasklet 执行的函数 *&#x2F; unsigned long data; &#x2F;* 函数 func 的参数 *&#x2F;&#125;; func 函数就是 tasklet 要执行的处理函数，用户定义函数内容，相当于中断处理函数。 如果要使用 tasklet，必须先定义一个 tasklet，然后使用 tasklet_init 函数初始化 tasklet， 12void tasklet_init(struct tasklet_struct *t,void (*func)(unsigned long), unsigned long data); t：要初始化的 taskletfunc：tasklet 的处理函数。data：要传递给 func 函数的参数返回值：没有返回值。 也 可 以 使 用 宏 DECLARE_TASKLET 来 一 次 性 完 成 tasklet 的 定 义 和 初 始 化 1DECLARE_TASKLET(name, func, data) 其中 name 为要定义的 tasklet 名字，这个名字就是一个 tasklet_struct 类型的时候变量，func就是 tasklet 的处理函数，data 是传递给 func 函数的参数。 在上半部，也就是中断处理函数中调用 tasklet_schedule 函数就能使 tasklet 在合适的时间运行， 1void tasklet_schedule(struct tasklet_struct *t) t：要调度的 tasklet，也就是 DECLARE_TASKLET 宏里面的 name。 返回值：没有返回值。 参考使用示例 12345678910111213141516171819202122232425&#x2F;* 定义 taselet *&#x2F;struct tasklet_struct testtasklet;&#x2F;* tasklet 处理函数 *&#x2F;void testtasklet_func(unsigned long data) &#123; &#x2F;* tasklet 具体处理内容 *&#x2F;&#125;&#x2F;* 中断处理函数 *&#x2F;irqreturn_t test_handler(int irq, void *dev_id) &#123; ...... &#x2F;* 调度 tasklet *&#x2F; tasklet_schedule(&amp;testtasklet); ......&#125;&#x2F;* 驱动入口函数 *&#x2F;static int __init xxxx_init(void) &#123; ...... &#x2F;* 初始化 tasklet *&#x2F; tasklet_init(&amp;testtasklet, testtasklet_func, data); &#x2F;* 注册中断处理函数 *&#x2F; request_irq(xxx_irq, test_handler, 0, &quot;xxx&quot;, &amp;xxx_dev); ......&#125; 3、工作队列工作队列是另外一种下半部执行方式，工作队列在进程上下文执行，工作队列将要推后的工作交给一个内核线程去执行，因为工作队列工作在进程上下文，因此工作队列允许睡眠或重新调度。因此如果你要推后的工作可以睡眠那么就可以选择工作队列，否则的话就只能选择软中断或 tasklet。 Linux 内核使用 work_struct 结构体表示一个工作， 12345struct work_struct &#123; atomic_long_t data; struct list_head entry; work_func_t func; &#x2F;* 工作队列处理函数 *&#x2F;&#125;; 这些工作组织成结构体workqueue_struct 工作队列。 Linux 内核使用工作者线程(worker thread)来处理工作队列中的各个工作，Linux 内核使用worker 结构体表示工作者线程，worker 结构体内容如下： 1234struct worker &#123;……………… struct workqueue_struct *rescue_wq;&#125;; 每个 worker 都有一个工作队列，工作者线程处理自己工作队列中的所有工作。在实际的驱动开发中，只需要定义工作(work_struct)即可，关于工作队列和工作者线程基本不用去管。 简单创建工作很简单，直接定义一个 work_struct 结构体变量即可，然后使用 INIT_WORK 宏来初始化工作. 1#define INIT_WORK(_work, _func)&#x2F;&#x2F;_work 表示要初始化的工作，_func 是工作对应的处理函数。 也可以使用 DECLARE_WORK 宏一次性完成工作的创建和初始化，宏定义如下： 1#define DECLARE_WORK(n, f)&#x2F;&#x2F;n 表示定义的工作(work_struct)，f 表示工作对应的处理函数。 和 tasklet 一样，工作也是需要调度才能运行的，工作的调度函数为 schedule_work 1bool schedule_work(struct work_struct *work)&#x2F;&#x2F;work：要调度的工作。返回值：0 成功，其他值 失败。 参考使用示例 1234567891011121314151617181920212223242526&#x2F;* 定义工作(work) *&#x2F;struct work_struct testwork;&#x2F;* work 处理函数 *&#x2F;void testwork_func_t(struct work_struct *work);&#123; &#x2F;* work 具体处理内容 *&#x2F;&#125;&#x2F;* 中断处理函数 *&#x2F;irqreturn_t test_handler(int irq, void *dev_id) &#123; ...... &#x2F;* 调度 work *&#x2F; schedule_work(&amp;testwork); ......&#125;&#x2F;* 驱动入口函数 *&#x2F;static int __init xxxx_init(void) &#123; ...... &#x2F;* 初始化 work *&#x2F; INIT_WORK(&amp;testwork, testwork_func_t); &#x2F;* 注册中断处理函数 *&#x2F; request_irq(xxx_irq, test_handler, 0, &quot;xxx&quot;, &amp;xxx_dev); ......&#125;","link":"","tags":[]},{"title":"Linux驱动-Linux中断","date":"2021-04-15T13:17:29.000Z","path":"2021/04/15/Linux驱动-Linux中断/","text":"Linux 内核提供了完善的中断框架，我们只需要申请中断，然后注册中断处理函数即可，使用非常方便，不需要一系列复杂的寄存器配置。 Linux 中断 API 函数1、中断号 每个中断都有一个中断号，通过中断号即可区分不同的中断，有的资料也把中断号叫做中断线。在 Linux 内核中使用一个 int 变量表示中断号，关于中断号就是裸机学的中断号了。 2、request_irq 函数 在 Linux 内核中要想使用某个中断是需要申请的，request_irq 函数用于申请中断，request_irq函数可能会导致睡眠，因此不能在中断上下文或者其他禁止睡眠的代码段中使用 request_irq 函数。request_irq 函数会激活(使能)中断，所以不需要我们手动去使能中断， 12int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev) irq：要申请中断的中断号。 handler：中断处理函数，当中断发生以后就会执行此中断处理函数。 flags：中断标志。标志可以通过“|”来实现多种组合。 IRQF_ONESHOT ——单次中断，中断执行一次就结束。IRQF_TRIGGER_NONE ——无触发。IRQF_TRIGGER_RISING ——上升沿触发。IRQF_TRIGGER_FALLING ——下降沿触发。IRQF_TRIGGER_HIGH ——高电平触发。IRQF_TRIGGER_LOW 低电平触发。 name：中断名字，设置以后可以在/proc/interrupts 文件中看到对应的中断名字。 dev：如果将 flags 设置为 IRQF_SHARED 的话，dev 用来区分不同的中断，一般情况下将dev 设置为设备结构体，dev 会传递给中断处理函数 irq_handler_t 的第二个参数。 返回值：0 中断申请成功，其他负值 中断申请失败，如果返回-EBUSY 的话表示中断已经被申请了。 3、free_irq 函数 使用中断的时候需要通过 request_irq 函数申请，使用完成以后就要通过 free_irq 函数释放掉相应的中断。如果中断不是共享的，那么 free_irq 会删除中断处理函数并且禁止中断。free_irq函数原型如下所示： 1void free_irq(unsigned int irq, void *dev) irq：要释放的中断。dev：如果中断设置为共享(IRQF_SHARED)的话，此参数用来区分具体的中断。共享中断只有在释放最后中断处理函数的时候才会被禁止掉。返回值：无。 4、中断处理函数使用 request_irq 函数申请中断的时候需要设置中断处理函数，中断处理函数格式如下所示： 1irqreturn_t (*irq_handler_t) (int, void *) 第一个参数是要中断处理函数要相应的中断号。第二个参数是一个指向 void 的指针，也就是个通用指针，需要与 request_irq 函数的 dev 参数保持一致。用于区分共享中断的不同设备，dev 也可以指向设备数据结构。中断处理函数的返回值为 irqreturn_t 类型。irqreturn_t 是个枚举类型， 123456enum irqreturn &#123; IRQ_NONE &#x3D; (0 &lt;&lt; 0), IRQ_HANDLED &#x3D; (1 &lt;&lt; 0), IRQ_WAKE_THREAD &#x3D; (1 &lt;&lt; 1),&#125;;typedef enum irqreturn irqreturn_t; 一般中断服务函数返回值使用如 下形式： 1return IRQ_RETVAL(IRQ_HANDLED) 5、中断使能与禁止函数 123void enable_irq(unsigned int irq)void disable_irq(unsigned int irq)void disable_irq_nosync(unsigned int irq) enable_irq 和 disable_irq 用于使能和禁止指定的中断，irq 就是要禁止的中断号。disable_irq函数要等到当前正在执行的中断处理函数执行完才返回，因此使用者需要保证不会产生新的中断，并且确保所有已经开始执行的中断处理程序已经全部退出。在这种情况下，可以使用disable_irq_nosync 函数，其调用以后立即返回，不会等待当前中断处理程序执行完毕。 开启或关闭全局中断，使用如下两个函数： 12local_irq_enable()&#x2F;&#x2F; 用于使能当前处理器中断系统local_irq_disable()&#x2F;&#x2F;用于禁止当前处理器中断系统。 将中断状态恢复到以前的状态的函数： 12local_irq_save(flags) &#x2F;&#x2F;local_irq_save 函数用于禁止中断，并且将中断状态保存在 flags 中。local_irq_restore(flags) &#x2F;&#x2F;用于恢复中断，将中断到 flags 状态。 设备树中断信息节点如果使用设备树的话就需要在设备树中设置好中断属性信息，Linux 内核通过读取设备树中的中断属性信息来配置中断。打开 imx6ull.dtsi 文件，其中的 intc 节点就是I.MX6ULL 的中断控制器节点，节点内容如下所示： 1234567intc: interrupt-controller@00a01000 &#123; compatible &#x3D; &quot;arm,cortex-a7-gic&quot;; #interrupt-cells &#x3D; &lt;3&gt;; interrupt-controller; reg &#x3D; &lt;0x00a01000 0x1000&gt;, &lt;0x00a02000 0x100&gt;;&#125;; 第 2 行，compatible 属性值为“arm,cortex-a7-gic”在 Linux 内核源码中搜索“arm,cortex-a7- gic”即可找到 GIC 中断控制器驱动文件。 第 3 行，#interrupt-cells 和#address-cells、#size-cells 一样。表示此中断控制器下设备的 cells 大小，对于设备而言，会使用 interrupts 属性描述中断信息，#interrupt-cells 描述了 interrupts 属性的 cells 大小，也就是一条信息有几个 cells。每个 cells 都是 32 位整形值，对于 ARM 处理的GIC 来说，一共有 3 个 cells，这三个 cells 的含义如下： 第一个 cells：中断类型，0 表示 SPI 中断，1 表示 PPI 中断。 第二个 cells：中断号，对于 SPI 中断来说中断号的范围为 0987，对于 PPI 中断来说中断号的范围为 015。 第三个 cells：标志，bit[3:0]表示中断触发类型，为 1 的时候表示上升沿触发，为 2 的时候表示下降沿触发，为 4 的时候表示高电平触发，为 8 的时候表示低电平触发。bit[15:8]为 PPI 中断的 CPU 掩码。 第 4 行，interrupt-controller 节点为空，表示当前节点是中断控制器。 对于 gpio 来说，gpio 节点也可以作为中断控制器，比如 imx6ull.dtsi 文件中的 gpio5 节点内容如下所示： 12345678gpio5: gpio@020ac000 &#123; compatible &#x3D; &quot;fsl,imx6ul-gpio&quot;, &quot;fsl,imx35-gpio&quot;; reg &#x3D; &lt;0x020ac000 0x4000&gt;; interrupts &#x3D; &lt;GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH&gt;; gpio-controller; 7 #gpio-cells &#x3D; &lt;2&gt;; interrupt-controller; 9 #interrupt-cells &#x3D; &lt;2&gt;;&#125;; 第 4 行，interrupts 描述中断源信息，对于 gpio5 来说一共有两条信息，中断类型都是 SPI，触发电平都是 IRQ_TYPE_LEVEL_HIGH。不同之处在于中断源，一个是 74，一个是 75，GPIO5 一共用了 2 个中断号，一个是 74，一个是 75。其中 74 对应 GPIO5_IO00GPIO5_IO15 这低 16 个 IO，75 对应 GPIO5_IO16GPIOI5_IO31 这高 16 位 IO。 第 8 行，interrupt-controller 表明了 gpio5 节点也是个中断控制器，用于控制 gpio5 所有 IO的中断。 第 9 行，将#interrupt-cells 修改为 2。 简单总结一下与中断有关的设备树属性信息：①、#interrupt-cells，指定中断源的信息 cells 个数。②、interrupt-controller，表示当前节点为中断控制器。③、interrupts，指定中断号，触发方式等。④、interrupt-parent，指定父中断，也就是中断控制 获取中断号编写驱动的时候需要用到中断号，我们用到中断号，中断信息已经写到了设备树里面，因此可以通过 irq_of_parse_and_map 函数从 interupts 属性中提取到对应的设备号，函数原型如下： 1unsigned int irq_of_parse_and_map(struct device_node *dev, int index) dev：设备节点。index：索引号，interrupts 属性可能包含多条中断信息，通过 index 指定要获取的信息。返回值：中断号。 如果使用 GPIO 的话，可以使用 gpio_to_irq 函数来获取 gpio 对应的中断号，函数原型如下： 1int gpio_to_irq(unsigned int gpio)&#x2F;&#x2F;gpio：要获取的 GPIO 编号。返回值：GPIO 对应的中断号。 实验程序编写驱动 I.MX6U-ALPHA 开发板上的 KEY0 按键，不过我们采用中断的方式， 并且采用定时器来实现按键消抖，应用程序读取按键值并且通过终端打印出来。 修改设备树文件使用到了按键 KEY0，按键 KEY0 使用中断模式，因此需要在“key”节点下添加 中断相关属性 1234567891011key &#123; #address-cells &#x3D; &lt;1&gt;; #size-cells &#x3D; &lt;1&gt;; compatible &#x3D; &quot;atkalpha-key&quot;; pinctrl-names &#x3D; &quot;default&quot;; pinctrl-0 &#x3D; &lt;&amp;pinctrl_key&gt;; key-gpio &#x3D; &lt;&amp;gpio1 18 GPIO_ACTIVE_LOW&gt;; &#x2F;* KEY0 *&#x2F; interrupt-parent &#x3D; &lt;&amp;gpio1&gt;; interrupts &#x3D; &lt;18 IRQ_TYPE_EDGE_BOTH&gt;; &#x2F;* FALLING RISING *&#x2F; status &#x3D; &quot;okay&quot;;&#125;; 第 8 行，设置 interrupt-parent 属性值为“gpio1”，因为 KEY0 所使用的 GPIO 为GPIO1_IO18，也就是设置 KEY0 的 GPIO 中断控制器为 gpio1。 第 9 行，设置 interrupts 属性，也就是设置中断源，第一个 cells 的 18 表示 GPIO1 组的 18号 IO。IRQ_TYPE_EDGE_BOTH 表示上升沿和下降沿同时有效， 相当于 KEY0 按下和释放都会触发中断。 按键中断驱动程序编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&#x2F;***************************************************************文件名 : imx6uirq.c描述 : Linux中断驱动实验***************************************************************&#x2F;&#x2F;* 中断IO描述结构体 *&#x2F;struct irq_keydesc &#123; int gpio; &#x2F;* gpio *&#x2F; int irqnum; &#x2F;* 中断号 *&#x2F; unsigned char value; &#x2F;* 按键对应的键值 *&#x2F; char name[10]; &#x2F;* 名字 *&#x2F; irqreturn_t (*handler)(int, void *); &#x2F;* 中断服务函数 *&#x2F;&#125;;&#x2F;* imx6uirq设备结构体 *&#x2F;struct imx6uirq_dev&#123; atomic_t keyvalue; &#x2F;* 有效的按键键值 *&#x2F; atomic_t releasekey; &#x2F;* 标记是否完成一次完成的按键，包括按下和释放 *&#x2F; struct timer_list timer;&#x2F;* 定义一个定时器*&#x2F; struct irq_keydesc irqkeydesc[KEY_NUM]; &#x2F;* 按键描述数组 *&#x2F; unsigned char curkeynum; &#x2F;* 当前的按键号 *&#x2F;&#125;;struct imx6uirq_dev imx6uirq; &#x2F;* irq设备 *&#x2F;&#x2F;* @description : 中断服务函数，开启定时器，延时10ms， * 定时器用于按键消抖。 * @param - irq : 中断号 * @param - dev_id : 设备结构。 * @return : 中断执行结果 *&#x2F;static irqreturn_t key0_handler(int irq, void *dev_id)&#123; struct imx6uirq_dev *dev &#x3D; (struct imx6uirq_dev *)dev_id; dev-&gt;curkeynum &#x3D; 0; dev-&gt;timer.data &#x3D; (volatile long)dev_id; mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(10)); &#x2F;* 10ms定时 *&#x2F; return IRQ_RETVAL(IRQ_HANDLED);&#125;&#x2F;* @description : 定时器服务函数，用于按键消抖，定时器到了以后 * 再次读取按键值，如果按键还是处于按下状态就表示按键有效。 * @param - arg : 设备结构变量 * @return : 无 *&#x2F;void timer_function(unsigned long arg)&#123; unsigned char value; unsigned char num; struct irq_keydesc *keydesc; struct imx6uirq_dev *dev &#x3D; (struct imx6uirq_dev *)arg; num &#x3D; dev-&gt;curkeynum; keydesc &#x3D; &amp;dev-&gt;irqkeydesc[num]; value &#x3D; gpio_get_value(keydesc-&gt;gpio); &#x2F;* 读取IO值 *&#x2F; if(value &#x3D;&#x3D; 0)&#123; &#x2F;* 按下按键 *&#x2F; atomic_set(&amp;dev-&gt;keyvalue, keydesc-&gt;value); &#125; else&#123; &#x2F;* 按键松开 *&#x2F; atomic_set(&amp;dev-&gt;keyvalue, 0x80 | keydesc-&gt;value); atomic_set(&amp;dev-&gt;releasekey, 1); &#x2F;* 标记松开按键，即完成一次完整的按键过程 *&#x2F; &#125; &#125;&#x2F;* * @description : 按键IO初始化 * @param : 无 * @return : 无 *&#x2F;static int keyio_init(void)&#123; &#x2F;* 初始化key所使用的IO，并且设置成中断模式 *&#x2F; for (i &#x3D; 0; i &lt; KEY_NUM; i++) &#123; memset(imx6uirq.irqkeydesc[i].name, 0, sizeof(name)); &#x2F;* 缓冲区清零 *&#x2F; sprintf(imx6uirq.irqkeydesc[i].name, &quot;KEY%d&quot;, i); &#x2F;* 组合名字 *&#x2F; gpio_request(imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].name); gpio_direction_input(imx6uirq.irqkeydesc[i].gpio); imx6uirq.irqkeydesc[i].irqnum &#x3D; irq_of_parse_and_map(imx6uirq.nd, i);#if 0 imx6uirq.irqkeydesc[i].irqnum &#x3D; gpio_to_irq(imx6uirq.irqkeydesc[i].gpio);#endif printk(&quot;key%d:gpio&#x3D;%d, irqnum&#x3D;%d\\r\\n&quot;,i, imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].irqnum); &#125; &#x2F;* 申请中断 *&#x2F; imx6uirq.irqkeydesc[0].handler &#x3D; key0_handler; imx6uirq.irqkeydesc[0].value &#x3D; KEY0VALUE; for (i &#x3D; 0; i &lt; KEY_NUM; i++) &#123; ret &#x3D; request_irq(imx6uirq.irqkeydesc[i].irqnum, imx6uirq.irqkeydesc[i].handler, IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, imx6uirq.irqkeydesc[i].name, &amp;imx6uirq); if(ret &lt; 0)&#123; printk(&quot;irq %d request failed!\\r\\n&quot;, imx6uirq.irqkeydesc[i].irqnum); return -EFAULT; &#125; &#125; &#x2F;* 创建定时器 *&#x2F; init_timer(&amp;imx6uirq.timer); imx6uirq.timer.function &#x3D; timer_function; return 0;&#125;&#x2F;* * @description : 驱动入口函数 * @param : 无 * @return : 无 *&#x2F;static int __init imx6uirq_init(void)&#123; &#x2F;* 5、初始化按键 *&#x2F; atomic_set(&amp;imx6uirq.keyvalue, INVAKEY); atomic_set(&amp;imx6uirq.releasekey, 0); keyio_init(); return 0;&#125;&#x2F;* * @description : 驱动出口函数 * @param : 无 * @return : 无 *&#x2F;static void __exit imx6uirq_exit(void)&#123; unsigned int i &#x3D; 0; &#x2F;* 删除定时器 *&#x2F; del_timer_sync(&amp;imx6uirq.timer); &#x2F;* 删除定时器 *&#x2F; &#x2F;* 释放中断 *&#x2F; for (i &#x3D; 0; i &lt; KEY_NUM; i++) &#123; free_irq(imx6uirq.irqkeydesc[i].irqnum, &amp;imx6uirq); &#125;&#125; 结构体 irq_keydesc 为按键的中断描述结构体，gpio 为按键 GPIO 编号，irqnum为按键 IO 对应的中断号，value 为按键对应的键值，name 为按键名字，handler 为按键中断服务函数。使用 irq_keydesc 结构体即可描述一个按键中断。 结构体 imx6uirq_dev 为本例程设备结构体，第 55 行的 keyvalue 保存按键值， releasekey 表示按键是否被释放，如果按键被释放表示发生了一次完整的按键过程。 timer 为按键消抖定时器，数组 irqkeydesc 为按键信息数组，数组元素个数就是开发板上的按键个数，I.MX6U-ALIPHA 开发板上只有一个按键，因此 irqkeydesc 数组只有一个元素。curkeynum 表示当前按键。 key0_handler 函数，按键 KEY0 中断处理函数，参数 dev_id 为设备结构体，也就是 imx6uirq。设置 curkeynum=0，表示当前按键为 KEY0，使用 mod_timer函数启动定时器，定时器周期为 10ms。 timer_function 函数，定时器定时处理函数，参数 arg 是设备结构体，也就是imx6uirq，在此函数中读取按键值。 keyio_init 函数，按键 IO 初始化函数，在驱动入口函数里面会调用 keyio_init来初始化按键 IO。轮流初始化所有的按键，包括申请 IO、设置 IO 为输入模式、 从设备树中获取 IO 的中断号等等。通过 irq_of_parse_and_map 函数从设备树中获取按键 IO 对应的中断号。也可以使用 gpio_to_irq 函数将某个 IO 设置为中断状态，并且返回其中断 号。设置 KEY0 按键对应的按键中断处理函数为 key0_handler、KEY0 的按键值为 KEY0VALUE。轮流调用 request_irq 函数申请中断号，设置中断触发模式为IRQF_TRIGGER_FALLING 和 IRQF_TRIGGER_RISING，也就是上升沿和下降沿都可以触发中断。最后，初始化定时器，并且设置定时器的定时处理函数。 驱动出口函数调用 del_timer_sync 函数删除定时器，轮流释放申请的所有按键中断。","link":"","tags":[]},{"title":"Linux驱动-内核定时器","date":"2021-04-15T12:07:16.000Z","path":"2021/04/15/Linux驱动-内核定时器/","text":"1、内核时间管理简介Linux 要运行，需要一个系统时钟的，至于这个系统时钟是由哪个定时器提供的，这对于我们 Linux 驱动编写者来说，不需要深入研究这些具体的实现，只需要掌握相应的 API 函数即可。 硬件定时器提供时钟源，时钟源的频率可以设置， 设置好以后就周期性的产生定时中断，系统使用定时中断来计时。中断周期性产生的频率就是系统频率， 也叫做节拍率(tick rate)(有的资料也叫系统频率)，比如 1000Hz，100Hz 等等说的就是系统节拍率。系统节拍率是可以设置的，单位是 Hz， 高节拍率和低节拍率的优缺点： ①、高节拍率会提高系统时间精度，如果采用 100Hz 的节拍率，时间精度就是 10ms，采用1000Hz 的话时间精度就是 1ms，精度提高了 10 倍。高精度时钟的好处有很多，对于那些对时 间要求严格的函数来说，能够以更高的精度运行，时间测量也更加准确。 ②、高节拍率会导致中断的产生更加频繁，频繁的中断会加剧系统的负担，1000Hz 和 100Hz 的系统节拍率相比，系统要花费 10 倍的“精力”去处理中断。中断服务函数占用处理器的时间 增加，但是现在的处理器性能都很强大，所以采用 1000Hz 的系统节拍率并不会增加太大的负载压力。 Linux 内核使用全局变量 jiffies 来记录系统从启动以来的系统节拍数，系统启动的时候会将 jiffies 初始化为 0， 12extern u64 __jiffy_data jiffies_64;&#x2F;&#x2F;定义了一个 64 位的 jiffies_64。extern unsigned long volatile __jiffy_data jiffies;&#x2F;&#x2F;定义一个unsigned long的32位jiffies。 HZ 表示每秒的节拍数，jiffies 表示系统运行的 jiffies 节拍数，所以 jiffies/HZ 就是系统运行时间，单位为秒。不管是 32 位还是 64 位的 jiffies，都有溢出的风险，溢出以后会重新从 0 开始计数，相当于绕回来了，因此有些资料也将这个现象也叫做绕回。假如 HZ 为最大值 1000 的时候，32 位的 jiffies 只需要 49.7 天就发生了绕回，对于 64 位的 jiffies 来说大概需要5.8 亿年才能绕回，因此 jiffies_64 的绕回忽略不计。处理 32 位 jiffies 的绕回显得尤为重要， Linux 内核提供了如表 所示的几个 API 函数来处理绕回。 1234time_after(unkown, known)time_before(unkown, known)time_after_eq(unkown, known)time_before_eq(unkown, known) unkown通常为jiffies，known通常是需要对比的值。如果 unkown 超过 known 的话，time_after 函数返回真，否则返回假。如果 unkown 没有超过 known 的话 time_before 函数返回真，否则返回假。 1234567891011unsigned long timeout;timeout &#x3D; jiffies + (2 * HZ); &#x2F;* 超时的时间点 *&#x2F;&#x2F;*************************************具体的代码************************************&#x2F;&#x2F;* 判断有没有超时 *&#x2F;if(time_before(jiffies, timeout)) &#123; &#x2F;* 超时未发生 *&#x2F;&#125; else &#123; &#x2F;* 超时发生 *&#x2F;&#125; timeout 就是超时时间点，如果 jiffies 大于 timeout 那就表示超时了，比如我们要判断代码执行时间是不是超过了 2 秒，那么超时时间点就是 jiffies+(2*HZ)。通过函数 time_before 来判断 jiffies 是否小于 timeout，如果小于的话就表示没有超时。 Linux 内核提供了几个 jiffies 和 ms、us、ns 之间的转换函数 12345678&#x2F;&#x2F;将 jiffies 类型的参数 j 分别转换为对应的毫秒、微秒、纳秒。int jiffies_to_msecs(const unsigned long j) int jiffies_to_usecs(const unsigned long j)u64 jiffies_to_nsecs(const unsigned long j)&#x2F;&#x2F;将毫秒、微秒、纳秒转换为 jiffies 类型。long msecs_to_jiffies(const unsigned int m)long usecs_to_jiffies(const unsigned int u)unsigned long nsecs_to_jiffies(u64 n) 2、内核定时器简介定时器是一个很常用的功能，需要周期性处理的工作都要用到定时器。Linux 内核定时器采用系统时钟来实现，并不是 PIT 等硬件定时器。Linux 内核定时器使用很简单，只需要提供超时时间(相当于定时值)和定时处理函数即可，当超时时间到了以后设置的定时处理函数就会执行，使用内核定时器不需要做一大堆的寄存器初始化工作。 在使用内核定时器的时候要注意一点，内核定时器并不是周期性运行的，超时以后就会自动关闭，因此如果想要实现周期性定时，那么就需要在定时处理函数中重新开启定时器。 Linux 内核使用 timer_list 结构体表示内核定时器。 12345678struct timer_list &#123; struct list_head entry; unsigned long expires; &#x2F;* 定时器超时时间，单位是节拍数 *&#x2F; struct tvec_base *base; void (*function)(unsigned long); &#x2F;* 定时处理函数 *&#x2F; unsigned long data; &#x2F;* 要传递给 function 函数的参数 *&#x2F; int slack;&#125;; 要使用内核定时器首先要先定义一个timer_list 变量，表示定时器，tiemr_list 结构体的expires 成员变量表示超时时间，单位为节拍数。需要定义一个周期为 2 秒的定时器，那么这个定时器的超时时间就是 jiffies+(2HZ)，因此 expires=jiffies+(2HZ)。function 就是定时器超时以后的定时处理函数。 API 函数1、init_timer 函数init_timer 函数负责初始化 timer_list 类型变量 1void init_timer(struct timer_list *timer) timer：要初始化定时器。返回值：没有返回值。 2、add_timer 函数用于向 Linux 内核注册定时器，使用 add_timer 函数向内核注册定时器以后，定时器就会开始运行 1void add_timer(struct timer_list *timer) timer：要注册的定时器。返回值：没有返回值。 3、del_timer 函数 del_timer 函数用于删除一个定时器，不管定时器有没有被激活，都可以使用此函数删除。在多处理器系统上，定时器可能会在其他的处理器上运行，因此在调用 del_timer 函数删除定时器之前要先等待其他处理器的定时处理器函数退出。 1int del_timer(struct timer_list * timer) timer：要删除的定时器。返回值：0，定时器还没被激活；1，定时器已经激活。 4、del_timer_sync 函数 del_timer_sync 函数是 del_timer 函数的同步版，会等待其他处理器使用完定时器再删除，del_timer_sync 不能使用在中断上下文中。 1int del_timer_sync(struct timer_list *timer) timer：要删除的定时器。返回值：0，定时器还没被激活；1，定时器已经激活。 5、mod_timer 函数mod_timer 函数用于修改定时值，如果定时器还没有激活的话，mod_timer 函数会激活定时器！ 1int mod_timer(struct timer_list *timer, unsigned long expires) timer：要修改超时时间(定时值)的定时器。expires：修改后的超时时间。返回值：0，调用 mod_timer 函数前定时器未被激活；1，调用 mod_timer 函数前定时器已被激活。 使用流程 12345678910111213141516171819202122232425262728struct timer_list timer; &#x2F;* 定义定时器 *&#x2F;&#x2F;* 定时器回调函数 *&#x2F;void function(unsigned long arg) &#123; &#x2F;&#x2F;定时器处理代码 &#x2F;&#x2F;如果需要定时器周期性运行的话就使用 mod_timer函数重新设置超时值并且启动定时器。 mod_timer(&amp;dev-&gt;timertest, jiffies + msecs_to_jiffies(2000));&#125;&#x2F;* 初始化函数 *&#x2F;void init(void) &#123; init_timer(&amp;timer); &#x2F;* 初始化定时器 *&#x2F; timer.function &#x3D; function; &#x2F;* 设置定时处理函数 *&#x2F; timer.expires&#x3D;jffies + msecs_to_jiffies(2000);&#x2F;* 超时时间 2 秒 *&#x2F; timer.data &#x3D; (unsigned long)&amp;dev; &#x2F;* 将设备结构体作为参数 *&#x2F; add_timer(&amp;timer); &#x2F;* 启动定时器 *&#x2F;&#125;&#x2F;* 退出函数 *&#x2F;void exit(void)&#123; del_timer(&amp;timer); &#x2F;* 删除定时器 *&#x2F; &#x2F;* 或者使用 *&#x2F; del_timer_sync(&amp;timer);&#125; Linux 内核短延时函数 1234&#x2F;&#x2F;Linux 内核提供毫秒、微 秒和纳秒延时函数，void ndelay(unsigned long nsecs)void udelay(unsigned long usecs)void mdelay(unsigned long mseces) 3、实验程序编写使用内核定时器周期性的点亮和熄灭开发板上的 LED 灯，LED 灯的闪烁周期由内核定时器来设置，测试应用程序可以控制内核定时器周期。 驱动程序编写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#define CLOSE_CMD (_IO(0XEF, 0x1)) &#x2F;* 关闭定时器 *&#x2F;#define OPEN_CMD (_IO(0XEF, 0x2)) &#x2F;* 打开定时器 *&#x2F;#define SETPERIOD_CMD (_IO(0XEF, 0x3)) &#x2F;* 设置定时器周期命令 *&#x2F;&#x2F;* timer设备结构体 *&#x2F;struct timer_dev&#123; dev_t devid; &#x2F;* 设备号 *&#x2F; struct cdev cdev; &#x2F;* cdev *&#x2F; struct class *class; &#x2F;* 类 *&#x2F; struct device *device; &#x2F;* 设备 *&#x2F; int major; &#x2F;* 主设备号 *&#x2F; int minor; &#x2F;* 次设备号 *&#x2F; struct device_node *nd; &#x2F;* 设备节点 *&#x2F; int led_gpio; &#x2F;* key所使用的GPIO编号 *&#x2F; int timeperiod; &#x2F;* 定时周期,单位为ms *&#x2F; struct timer_list timer;&#x2F;* 定义一个定时器*&#x2F; spinlock_t lock; &#x2F;* 定义自旋锁 *&#x2F;&#125;;struct timer_dev timerdev; &#x2F;* timer设备 *&#x2F;&#x2F;* * @description : 初始化LED灯IO，open函数打开驱动的时候 * 初始化LED灯所使用的GPIO引脚。 * @param : 无 * @return : 无 *&#x2F;static int led_init(void)&#123; int ret &#x3D; 0; timerdev.nd &#x3D; of_find_node_by_path(&quot;&#x2F;gpioled&quot;); if (timerdev.nd&#x3D;&#x3D; NULL) &#123; return -EINVAL; &#125; timerdev.led_gpio &#x3D; of_get_named_gpio(timerdev.nd ,&quot;led-gpio&quot;, 0); if (timerdev.led_gpio &lt; 0) &#123; printk(&quot;can&#39;t get led\\r\\n&quot;); return -EINVAL; &#125; &#x2F;* 初始化led所使用的IO *&#x2F; gpio_request(timerdev.led_gpio, &quot;led&quot;); &#x2F;* 请求IO *&#x2F; ret &#x3D; gpio_direction_output(timerdev.led_gpio, 1); if(ret &lt; 0) &#123; printk(&quot;can&#39;t set gpio!\\r\\n&quot;); &#125; return 0;&#125;&#x2F;* * @description : 打开设备 * @param - inode : 传递给驱动的inode * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量 * 一般在open的时候将private_data指向设备结构体。 * @return : 0 成功;其他 失败 *&#x2F;static int timer_open(struct inode *inode, struct file *filp)&#123; int ret &#x3D; 0; filp-&gt;private_data &#x3D; &amp;timerdev; &#x2F;* 设置私有数据 *&#x2F; timerdev.timeperiod &#x3D; 1000; &#x2F;* 默认周期为1s *&#x2F; ret &#x3D; led_init(); &#x2F;* 初始化LED IO *&#x2F; if (ret &lt; 0) &#123; return ret; &#125; return 0;&#125;&#x2F;* * @description : ioctl函数， * @param - filp : 要打开的设备文件(文件描述符) * @param - cmd : 应用程序发送过来的命令 * @param - arg : 参数 * @return : 0 成功;其他 失败 *&#x2F;static long timer_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; struct timer_dev *dev &#x3D; (struct timer_dev *)filp-&gt;private_data; int timerperiod; unsigned long flags; switch (cmd) &#123; case CLOSE_CMD: &#x2F;* 关闭定时器 *&#x2F; del_timer_sync(&amp;dev-&gt;timer); break; case OPEN_CMD: &#x2F;* 打开定时器 *&#x2F; spin_lock_irqsave(&amp;dev-&gt;lock, flags); timerperiod &#x3D; dev-&gt;timeperiod; spin_unlock_irqrestore(&amp;dev-&gt;lock, flags); mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(timerperiod)); break; case SETPERIOD_CMD: &#x2F;* 设置定时器周期 *&#x2F; spin_lock_irqsave(&amp;dev-&gt;lock, flags); dev-&gt;timeperiod &#x3D; arg; spin_unlock_irqrestore(&amp;dev-&gt;lock, flags); mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(arg)); break; default: break; &#125; return 0;&#125;&#x2F;* 设备操作函数 *&#x2F;static struct file_operations timer_fops &#x3D; &#123; .owner &#x3D; THIS_MODULE, .open &#x3D; timer_open, .unlocked_ioctl &#x3D; timer_unlocked_ioctl,&#125;;&#x2F;* 定时器回调函数 *&#x2F;void timer_function(unsigned long arg)&#123; struct timer_dev *dev &#x3D; (struct timer_dev *)arg; static int sta &#x3D; 1; int timerperiod; unsigned long flags; sta &#x3D; !sta; &#x2F;* 每次都取反，实现LED灯反转 *&#x2F; gpio_set_value(dev-&gt;led_gpio, sta); &#x2F;* 重启定时器 *&#x2F; spin_lock_irqsave(&amp;dev-&gt;lock, flags); timerperiod &#x3D; dev-&gt;timeperiod; spin_unlock_irqrestore(&amp;dev-&gt;lock, flags); mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(dev-&gt;timeperiod)); &#125;&#x2F;* * @description : 驱动入口函数 * @param : 无 * @return : 无 *&#x2F;static int __init timer_init(void)&#123; &#x2F;* 初始化自旋锁 *&#x2F; spin_lock_init(&amp;timerdev.lock); &#x2F;* 注册字符设备驱动 *&#x2F; &#x2F;* 1、创建设备号 *&#x2F; if (timerdev.major) &#123; &#x2F;* 定义了设备号 *&#x2F; timerdev.devid &#x3D; MKDEV(timerdev.major, 0); register_chrdev_region(timerdev.devid, TIMER_CNT, TIMER_NAME); &#125; else &#123; &#x2F;* 没有定义设备号 *&#x2F; alloc_chrdev_region(&amp;timerdev.devid, 0, TIMER_CNT, TIMER_NAME); &#x2F;* 申请设备号 *&#x2F; timerdev.major &#x3D; MAJOR(timerdev.devid); &#x2F;* 获取分配号的主设备号 *&#x2F; timerdev.minor &#x3D; MINOR(timerdev.devid); &#x2F;* 获取分配号的次设备号 *&#x2F; &#125; &#x2F;* 2、初始化cdev *&#x2F; timerdev.cdev.owner &#x3D; THIS_MODULE; cdev_init(&amp;timerdev.cdev, &amp;timer_fops); &#x2F;* 3、添加一个cdev *&#x2F; cdev_add(&amp;timerdev.cdev, timerdev.devid, TIMER_CNT); &#x2F;* 4、创建类 *&#x2F; timerdev.class &#x3D; class_create(THIS_MODULE, TIMER_NAME); if (IS_ERR(timerdev.class)) &#123; return PTR_ERR(timerdev.class); &#125; &#x2F;* 5、创建设备 *&#x2F; timerdev.device &#x3D; device_create(timerdev.class, NULL, timerdev.devid, NULL, TIMER_NAME); if (IS_ERR(timerdev.device)) &#123; return PTR_ERR(timerdev.device); &#125; &#x2F;* 6、初始化timer，设置定时器处理函数,还未设置周期，所有不会激活定时器 *&#x2F; init_timer(&amp;timerdev.timer); timerdev.timer.function &#x3D; timer_function; timerdev.timer.data &#x3D; (unsigned long)&amp;timerdev; &#x2F;* 要传递给 function 函数的参数 *&#x2F; return 0;&#125;&#x2F;* * @description : 驱动出口函数 * @param : 无 * @return : 无 *&#x2F;static void __exit timer_exit(void)&#123; gpio_set_value(timerdev.led_gpio, 1); &#x2F;* 卸载驱动的时候关闭LED *&#x2F; del_timer_sync(&amp;timerdev.timer); &#x2F;* 删除timer *&#x2F;#if 0 del_timer(&amp;timerdev.tiemr);#endif&#125; 第 38~50 行，定时器设备结构体，在 48 行定义了一个定时器成员变量 timer。 第 60~82 行，LED 灯初始化函数，从设备树中获取 LED 灯信息，然后初始化相应的 IO。 第 91~102 行，函数 timer_open，对应应用程序的 open 函数，应用程序调用 open 函数打开/dev/timer 驱动文件的时候此函数就会执行。此函数设置文件私有数据为 timerdev，并且初始化定时周期默认为 1 秒，最后调用 led_init 函数初始化 LED 所使用的 IO。 第 111~137 行，函数 timer_unlocked_ioctl，对应应用程序的 ioctl 函数，应用程序调用 ioctl函数向驱动发送控制信息，此函数响应并执行。此函数ioctl**(fd,** cmd**,** arg**);** 有三个参数：filp，cmd 和 arg，其中 filp是对应的设备文件，cmd 是应用程序发送过来的命令信息，arg 是应用程序发送过来的参数，在例程中 arg 参数表示定时周期。 一共有三种命令 CLOSE_CMD，OPEN_CMD 和 SETPERIOD_CMD，这三个命令分别为关闭定时器、打开定时器、设置定时周期。这三个命令的左右如下： CLOSE_CMD：关闭定时器命令，调用 del_timer_sync 函数关闭定时器。 OPEN_CMD：打开定时器命令，调用 mod_timer 函数打开定时器，定时周期为 timerdev 的timeperiod 成员变量，定时周期默认是 1 秒。 SETPERIOD_CMD：设置定时器周期命令，参数 arg 就是新的定时周期，设置 timerdev 的timeperiod 成员变量为 arg 所表示定时周期指。并且使用 mod_timer 重新打开定时器，使定时器以新的周期运行。 第 140~144 行，定时器驱动操作函数集 timer_fops。 第 147~162 行，函数 timer_function，定时器服务函数，此函有一个参数 arg，在本例程中arg 参数就是 timerdev 的地址，这样通过 arg 参数就可以访问到设备结构体。当定时周期到了以后此函数就会被调用。在此函数中将 LED 灯的状态取反，实现 LED 灯闪烁的效果。因为内核定时器不是循环的定时器，执行一次以后就结束了，因此在 161 行又调用了 mod_timer 函数重新开启定时器。 第 169~209 行，函数 timer_init，驱动入口函数。 在第 205~207 行初始化定时器，设置定时器的定时处理函数为 timer_function，另外设置要传递给 timer_function 函数的参数为 timerdev的地址。在此函数中并没有调用 timer_add 函数来开启定时器，因此定时器默认是关闭的，除非应用程序发送打开命令。 第 216~231 行，驱动出口函数，在 219 行关闭 LED，也就是卸载驱动以后 LED 处于熄灭状态。第 220 行调用 del_timer_sync 函数删除定时器，也可以使用 del_timer 函数。","link":"","tags":[]},{"title":"Linux驱动-并发与竞争-自旋锁","date":"2021-04-15T10:41:42.000Z","path":"2021/04/15/Linux驱动-并发与竞争-自旋锁/","text":"1、自旋锁当一个线程要访问某个共享资源的时候首先要先获取相应的锁，锁只能被一个线程持有，只要此线程不释放持有的锁，那么其他的线程就不能获取此锁。对于自旋锁而言，如果自旋锁正在被线程 A 持有，线程 B 想要获取自旋锁，那么线程 B 就会处于忙循环-旋转-等待状态，线程B不会进入休眠状态或者说去做其他的处理，而是会一直傻傻的在那里“转圈圈”的等待锁可用。(类别电话亭) 自旋锁的“自旋”也就是“原地打转”的意思，“原地打转”的目的是为了等待自旋锁可以用，可以访问共享资源。把自旋锁比作一个变量 a，变量 a=1 的时候表示共享资源可用，当 a=0 的时候表示共享资源不可用。现在线程 A 要访问共享资源，发现 a=0(自旋锁被其他线程持有)，那么线程 A 就会不断的查询 a 的值，直到 a=1。 从这里我们可以看到自旋锁的一个缺点：那就等待自旋锁的线程会一直处于自旋状态，这样会浪费处理器时间，降低系统性能，所以自旋锁的持有时间不能太长。所以自旋锁适用于短时期的轻量级加锁，如果遇到需要长时间持有锁的场景那就需要换其他的方法了。 Linux 内核使用结构体 spinlock_t 表示自旋锁，结构体定义如下所示： 123456789101112131415typedef struct spinlock &#123; union &#123; struct raw_spinlock rlock;#ifdef CONFIG_DEBUG_LOCK_ALLOC# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map)) struct &#123; u8 __padding[LOCK_PADSIZE]; struct lockdep_map dep_map; &#125;;#endif &#125;;&#125; spinlock_t;spinlock_t lock; &#x2F;&#x2F;定义自旋锁 自旋锁 API 函数1234567DEFINE_SPINLOCK(spinlock_t lock) &#x2F;&#x2F;定义并初始化一个自选变量。int spin_lock_init(spinlock_t *lock) &#x2F;&#x2F;初始化自旋锁。void spin_lock(spinlock_t *lock) &#x2F;&#x2F;获取指定的自旋锁，也叫做加锁。void spin_unlock(spinlock_t *lock) &#x2F;&#x2F;释放指定的自旋锁。int spin_trylock(spinlock_t *lock) &#x2F;&#x2F;尝试获取指定的自旋锁，如果没有获取到就返回 0int spin_is_locked(spinlock_t *lock)&#x2F;&#x2F;检查指定的自旋锁是否被获取，如果没有被获取就返回非0，否则返回 0。 自旋锁API函数适用于SMP或支持抢占的单CPU下线程之间的并发访问，也就是用于线程与线程之间，被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API 函数，否则的话会可能会导致死锁现象的发生。 死锁：自旋锁会自动禁止抢占，也就说当线程 A得到锁以后会暂时禁止内核抢占。如果线程 A 在持有锁期间进入了休眠状态，那么线程 A 会自动放弃 CPU 使用权。线程 B 开始运行，线程 B 也想要获取锁，但是此时锁被 A 线程持有，而 且内核抢占还被禁止了！线程 B 无法被调度出去，那么线程 A 就无法运行，锁也就无法释放，所以死锁发生了！ API 函数用于线程之间的并发访问时，中断也想访问共享资源。中断里面可以使用自旋锁，但是在中断里面使用自旋锁的时候，在获取锁之前一定要先禁止本地中断(也就是本 CPU 中断，对于多核 SOC来说会有多个 CPU 核)，否则可能导致锁死现象的发生。线程 A 先运行，并且获取到了 lock 这个锁，当线程 A 运行 functionA 函数的时候中断发生了，中断抢走了 CPU 使用权。但是中断要执行的中断服务函数也要获取 lock 这个锁， 但是这个锁被线程 A 占有着，中断就会一直自旋，等待锁有效。但是在中断服务函数执行完之前，线程 A 是不可能执行的，线程 A 与中断僵持着，死锁发生！ 最好的解决方法就是获取锁之前关闭本地中断，Linux内核提供了相应的 API 函数 1234void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)&#x2F;&#x2F;保存中断状态，禁止本地中断，并获取自旋锁。void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)&#x2F;&#x2F;将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁。在释放锁的时候会恢复中断状态。 下半部(BH)也会竞争共享资源，有些资料也会将下半部叫做底半部。如果要在下半部里面使用自旋锁， 12void spin_lock_bh(spinlock_t *lock) &#x2F;&#x2F;关闭下半部，并获取自旋锁。void spin_unlock_bh(spinlock_t *lock) &#x2F;&#x2F;打开下半部，并释放自旋锁 其他类型的锁在自旋锁的基础上还衍生出了其他特定场合使用的锁，这些锁在驱动中其实用的不多，更多的是在 Linux 内核中使用。 1、读写自旋锁 读写自旋锁为读和写操作提供了不同的锁，一次只能允许一个写操作，也就是只能一个线程持有写锁，而且不能进行读操作。但是当没有写操作的时候允许一个或多个线程持有读锁， 可以进行并发的读操作。也就是使用读写锁的时候读操作和写操作不能同时进行。 2、顺序锁 顺序锁在读写锁的基础上衍生而来的，使用顺序锁的话可以允许在写的时候进行读操作，也就是实现同时读写，但是不允许同时进行并发的写操作。虽然顺序锁的读和写操作可以同时进行，但是如果在读的过程中发生了写操作， 最好重新进行读取，保证数据完整性。 顺序锁保护的资源不能是指针，因为如果在写操作的时候可能会导致指针无效，而这个时候恰巧有读操作访问指针的话就可能导致意外发生，比如读取野指针导致系统崩溃。 自旋锁使用注意事项①、因为在等待自旋锁的时候处于“自旋”状态，因此锁的持有时间不能太长，一定要短，否则的话会降低系统性能。如果临界区比较大，运行时间比较长的话要选择其他的并发处理方式，比如稍后要讲的信号量和互斥体。 ②、自旋锁保护的临界区内不能调用任何可能导致线程休眠的 API 函数，否则的话可能导致死锁。 ③、不能递归申请自旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就必须“自旋”，等待锁被释放，然而你正处于“自旋”状态，根本没法释放锁。结果就是自己把自己锁死了！④、在编写驱动程序的时候我们必须考虑到驱动的可移植性，因此不管你用的是单核的还是多核的 SOC，都将其当做多核 SOC 来编写驱动程序。 2、实验程序编写自旋锁保护的临界区要尽可能的短，因此在 open 函数中申请自旋锁，然后在 release 函 数中释放自旋锁的方法就不可取。我们可以使用一个变量来表示设备的使用情况，如果设备被使用了那么变量就加一，设备被释放以后变量就减 1，我们只需要使用自旋锁保护这个变量即可。 下面通过定义一个变量 dev_stats 表示设备的使用情况，dev_stats为 0 的时候表示设备没有被使用，dev_stats 大于 0 的时候表示设备被使用。驱动 open 函数中先判断 dev_stats 是否为 0，也就是判断设备是否可用，如果为 0 的话就使用设备，并且将 dev_stats加 1，表示设备被使用了。使用完以后在 release 函数中将 dev_stats 减 1，表示设备没有被使用 了。因此真正实现设备互斥访问的是变量 dev_stats，但是我们要使用自旋锁对 dev_stats 来做保护。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&#x2F;***************************************************************文件名 : spinlock.c描述 : 自旋锁实验，使用自旋锁来实现对实现设备的互斥访问***************************************************************&#x2F;&#x2F;* gpioled设备结构体 *&#x2F;struct gpioled_dev&#123; int dev_stats; &#x2F;* 设备使用状态，0，设备未使用;&gt;0,设备已经被使用 *&#x2F; spinlock_t lock; &#x2F;* 自旋锁 *&#x2F;&#125;;struct gpioled_dev gpioled; &#x2F;* led设备 *&#x2F;&#x2F;* * @description : 打开设备 * @param - inode : 传递给驱动的inode * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量 * 一般在open的时候将private_data指向设备结构体。 * @return : 0 成功;其他 失败 *&#x2F;static int led_open(struct inode *inode, struct file *filp)&#123; unsigned long flags; filp-&gt;private_data &#x3D; &amp;gpioled; &#x2F;* 设置私有数据 *&#x2F; spin_lock_irqsave(&amp;gpioled.lock, flags); &#x2F;* 上锁 *&#x2F; if (gpioled.dev_stats) &#123; &#x2F;* 如果设备被使用了 *&#x2F; spin_unlock_irqrestore(&amp;gpioled.lock, flags);&#x2F;* 解锁 *&#x2F; return -EBUSY; &#125; gpioled.dev_stats++; &#x2F;* 如果设备没有打开，那么就标记已经打开了 *&#x2F; spin_unlock_irqrestore(&amp;gpioled.lock, flags);&#x2F;* 解锁 *&#x2F; return 0;&#125;&#x2F;* * @description : 关闭&#x2F;释放设备 * @param - filp : 要关闭的设备文件(文件描述符) * @return : 0 成功;其他 失败 *&#x2F;static int led_release(struct inode *inode, struct file *filp)&#123; unsigned long flags; struct gpioled_dev *dev &#x3D; filp-&gt;private_data; &#x2F;* 关闭驱动文件的时候将dev_stats减1 *&#x2F; spin_lock_irqsave(&amp;dev-&gt;lock, flags); &#x2F;* 上锁 *&#x2F; if (dev-&gt;dev_stats) &#123; dev-&gt;dev_stats--; &#125; spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);&#x2F;* 解锁 *&#x2F; return 0;&#125;&#x2F;* * @description : 驱动入口函数 * @param : 无 * @return : 无 *&#x2F;static int __init led_init(void)&#123; int ret &#x3D; 0; &#x2F;* 初始化自旋锁 *&#x2F; spin_lock_init(&amp;gpioled.lock); return 0;&#125; 第 43 行，dev_stats 表示设备状态，如果为 0 的话表示设备还没有被使用，如果大于 0 的话就表示设备已经被使用了。 第 44 行，定义自旋锁变量 lock。 第 61~67 行，使用自旋锁实现对设备的互斥访问，第 61 行调用 spin_lock_irqsave 函数获取锁，为了考虑到驱动兼容性，这里并没有使用 spin_lock 函数来获取锁。第 62 行判断dev_stats 是否大于 0，如果是的话表示设备已经被使用了，那么就调用 spin_unlock_irqrestore函数释放锁，并且返回-EBUSY。如果设备没有被使用的话就在第 66 行将 dev_stats 加 1，表 示设备要被使用了，然后调用 spin_unlock_irqrestore 函数释放锁。自旋锁的工作就是保护dev_stats 变量，真正实现对设备互斥访问的是 dev_stats。 第 126~131 行，在 release 函数中将 dev_stats 减 1，表示设备被释放了，可以被其他的应用 程序使用。将 dev_stats 减 1 的时候需要自旋锁对其进行保护。 第 155 行，在驱动入口函数 led_init 中调用 spin_lock_init 函数初始化自旋锁。","link":"","tags":[]},{"title":"Linux驱动-并发与竞争-信号量","date":"2021-04-15T10:41:22.000Z","path":"2021/04/15/Linux驱动-并发与竞争-信号量/","text":"1、信号量信号量是同步的一种方式。Linux 内核也提供了信号量机制，信号量常常用于控制对共享资源的访问。相比于自旋锁，信号量可以使线程进入休眠状态。 A 与 B、C 合租了一套房子，这个房子只有一个厕所，一次只能一个人使用。某一天早上 A 去上厕所了，过了一会 B 也想用厕所，因为 A 在厕所里面，所以 B 只能等到 A 用来了才能进去。B 要么就一直在厕所门口等着， 等 A 出来，这个时候就相当于自旋锁。B 也可以告诉 A，让 A 出来以后通知他一下，然后 B 继续回房间睡觉，这个时候相当于信号量。 可以看出，使用信号量会提高处理器的使用效率，毕竟不用一直傻乎乎的在那里“自旋”等待。但是，信号量的开销要比自旋锁大，因为信号量使线程进入休眠状态以后会切换线程，切换线程就会有开销。总结一下信号量的特点： ①、因为信号量可以使等待资源线程进入休眠状态，因此适用于那些占用资源比较久的场合。 ②、因此信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。 ③、如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势。 信号量有一个信号量值，相当于一个房子有 10 把钥匙，这 10 把钥匙就相当于信号量值为10。因此，可以通过信号量来控制访问共享资源的访问数量，如果要想进房间，那就要先获取一把钥匙，信号量值减 1，直到 10 把钥匙都被拿走，信号量值为 0，这个时候就不允许任何人 进入房间了，因为没钥匙了。如果有人从房间出来，那他要归还他所持有的那把钥匙，信号量值加 1，此时有 1 把钥匙了，那么可以允许进去一个人。相当于通过信号量控制访问资源的线程数，在初始化的时候将信号量值设置的大于 1，那么这个信号量就是计数型信号量，计数型信号量不能用于互斥访问，因为它允许多个线程同时访问共享资源。如果要互斥的访问共享资源那么信号量的值就不能大于 1，此时的信号量就是一个二值信号量。 信号量 API 函数Linux 内核使用 semaphore 结构体表示信号量，结构体内容如下所示： 12345struct semaphore &#123; raw_spinlock_t lock; unsigned int count; struct list_head wait_list;&#125;; 12345678DEFINE_SEAMPHORE(name) &#x2F;&#x2F;定义一个信号量，并且设置信号量的值为 1。void sema_init(struct semaphore *sem, int val) &#x2F;&#x2F;初始化信号量 sem，设置信号量值为 val。void down(struct semaphore *sem)&#x2F;&#x2F;获取信号量，因为会导致休眠，因此不能在中断中使用。int down_trylock(struct semaphore *sem)&#x2F;&#x2F;尝试获取信号量，如果能获取到信号量就获取，并且返回 0。如果不能就返回非 0，并且不会进入休眠。int down_interruptible(struct semaphore *sem)&#x2F;&#x2F;获取信号量，使用down进入休眠状态的线程不能被信号打断。而使用此函数进入休眠以后是可以被信号打断的。void up(struct semaphore *sem) &#x2F;&#x2F;释放信号量 信号量的使用如下所示： 12345struct semaphore sem; &#x2F;* 定义信号量 *&#x2F;sema_init(&amp;sem, 1)； &#x2F;* 初始化信号量 *&#x2F;down(&amp;sem); &#x2F;* 申请信号量 *&#x2F;&#x2F;* 临界区 *&#x2F;up(&amp;sem); &#x2F;* 释放信号量 *&#x2F; 2、实验程序编写使用信号量实现了一次只能有一个应用程序访问 LED 灯，信号量可以导致休眠，因此信号量保护的临界区没有运行时间限制，可以在驱动的 open 函数申请信号量，然后在release 函数中释放信号量。但是信号量不能用在中断中，本节实验我们不会在中断中使用信号量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x2F;***************************************************************文件名 : semaphore.c描述 : 信号量实验，使用信号量来实现对实现设备的互斥访问***************************************************************&#x2F;&#x2F;* gpioled设备结构体 *&#x2F;struct gpioled_dev&#123; struct semaphore sem; &#x2F;* 信号量 *&#x2F;&#125;;struct gpioled_dev gpioled; &#x2F;* led设备 *&#x2F;&#x2F;* * @description : 打开设备 * @param - inode : 传递给驱动的inode * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量 * 一般在open的时候将private_data指向设备结构体。 * @return : 0 成功;其他 失败 *&#x2F;static int led_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data &#x3D; &amp;gpioled; &#x2F;* 设置私有数据 *&#x2F; &#x2F;* 获取信号量 *&#x2F; if (down_interruptible(&amp;gpioled.sem)) &#123; &#x2F;* 获取信号量,进入休眠状态的进程可以被信号打断 *&#x2F; return -ERESTARTSYS; &#125;#if 0 down(&amp;gpioled.sem); &#x2F;* 不能被信号打断 *&#x2F;#endif return 0;&#125;&#x2F;* * @description : 关闭&#x2F;释放设备 * @param - filp : 要关闭的设备文件(文件描述符) * @return : 0 成功;其他 失败 *&#x2F;static int led_release(struct inode *inode, struct file *filp)&#123; struct gpioled_dev *dev &#x3D; filp-&gt;private_data; up(&amp;dev-&gt;sem); &#x2F;* 释放信号量，信号量值加1 *&#x2F; return 0;&#125;&#x2F;* * @description : 驱动入口函数 * @param : 无 * @return : 无 *&#x2F;static int __init led_init(void)&#123; int ret &#x3D; 0; &#x2F;* 初始化信号量 *&#x2F; sema_init(&amp;gpioled.sem, 1); return 0;&#125; 第 43 行，在设备结构体中添加一个信号量成员变量 sem。 第 60~65行，在 open函数中申请信号量，可以使用 down 函数，也可以使用 down_interruptible函数。如果信号量值大于等于 1 就表示可用，那么应用程序就会开始使用 LED 灯。如果信号量值为 0 就表示应用程序不能使用 LED 灯，此时应用程序就会进入到休眠状态。等到信号量值大于 1 的时候应用程序就会唤醒，申请信号量，获取 LED 灯使用权。 第 123 行，在 release 函数中调用 up 函数释放信号量，这样其他因为没有得到信号量而进入休眠状态的应用程序就会唤醒，获取信号量。 第 147 行，在驱动入口函数中调用 sema_init 函数初始化信号量 sem 的值为 1，相当于 sem是个二值信号量。 总结一下，当信号量 sem 为 1 的时候表示 LED 灯还没有被使用，如果应用程序 A 要使用LED 灯，先调用 open 函数打开/dev/gpioled，这个时候会获取信号量 sem，获取成功以后 sem 的值减 1 变为 0。如果此时应用程序 B 也要使用 LED 灯，调用 open 函数打开/dev/gpioled 就会因为信号量无效(值为 0)而进入休眠状态。当应用程序 A 运行完毕，调用 close 函数关闭/dev/gpioled的时候就会释放信号量 sem，此时信号量 sem 的值就会加 1，变为 1。信号量 sem 再次有效，表示其他应用程序可以使用 LED 灯了，此时在休眠状态的应用程序 A 就会获取到信号量 sem，获取成功以后就开始使用 LED 灯。","link":"","tags":[]},{"title":"Linux驱动-并发与竞争-原子操作","date":"2021-04-15T10:40:54.000Z","path":"2021/04/15/Linux驱动-并发与竞争-原子操作/","text":"1、原子操作原子操作就是指不能再进一步分割的操作，一般原子操作用于变量或者位操作。原子操作只能对整形变量或者位进行保护。C 语言里面简简单单的一句“a=3”，编译成汇编文件以后变成了 3 句，那么程 序在执行的时候肯定汇编语句一条一条的执行。 123ldr r0, &#x3D;0X30000000 &#x2F;* 变量 a 地址 *&#x2F;ldr r1, &#x3D; 3 &#x2F;* 要写入的值 *&#x2F;str r1, [r0] &#x2F;* 将 3 写入到 a 变量中 *&#x2F; 假设现在线程 A要向 a 变量写入 10 这个值，而线程 B 也要向 a 变量写入 20 这个值，结果线程 A 最终将变量 a 设置为了 20。这就是一个最简单的设置变量值的并发与竞争的例子。要解决并发与竞争问题就要保证三行汇编指令作为一个整体运行，也就是作为一个原子存在。 Linux 内核 提供了一组原子操作 API 函数来完成此功能，Linux 内核提供了两组原子操作 API 函数，一组是对整形变量进行操作的，一组是对位进行操作的， 原子整形操作 API 函数 Linux 内核定义了叫做 atomic_t 的结构体来完成整形数据的原子操作，在使用中用原子变量来代替整形变量， 123typedef struct &#123; int counter;&#125; atomic_t; 在定义原子变量的时候给原子变量赋初值 1atomic_t b &#x3D; ATOMIC_INIT(0); &#x2F;&#x2F;定义原子变量 b 并赋初值为 0 12345678910111213MIC_INIT(int i) &#x2F;&#x2F;定义原子变量的时候对其初始化。int atomic_read(atomic_t *v)&#x2F;&#x2F;读取 v 的值，并且返回。void atomic_set(atomic_t *v, int i)&#x2F;&#x2F;向 v 写入 i 值。void atomic_add(int i, atomic_t *v) &#x2F;&#x2F;给 v 加上 i 值。void atomic_sub(int i, atomic_t *v) &#x2F;&#x2F;从 v 减去 i 值。void atomic_inc(atomic_t *v) &#x2F;&#x2F;给 v 加 1，也就是自增。void atomic_dec(atomic_t *v) &#x2F;&#x2F;从 v 减 1，也就是自减int atomic_dec_return(atomic_t *v) &#x2F;&#x2F;从 v 减 1，并且返回 v 的值。int atomic_inc_return(atomic_t *v) &#x2F;&#x2F;给 v 加 1，并且返回 v 的值。int atomic_sub_and_test(int i, atomic_t *v) &#x2F;&#x2F;从 v 减 i，如果结果为 0 就返回真，否则返回假int atomic_dec_and_test(atomic_t *v) &#x2F;&#x2F;从 v 减 1，如果结果为 0 就返回真，否则返回假int atomic_inc_and_test(atomic_t *v) &#x2F;&#x2F;给 v 加 1，如果结果为 0 就返回真，否则返回假int atomic_add_negative(int i, atomic_t *v) &#x2F;&#x2F;给 v 加 i，如果结果为负就返回真，否则返回假 原子位操作 API 函数 位操作也是很常用的操作，Linux 内核也提供了一系列的原子位操作 API 函数，只不过原子位操作不像原子整形变量那样有个 atomic_t 的数据结构，原子位操作是直接对内存进行操作，API 函数所示： 1234567void set_bit(int nr, void *p) &#x2F;&#x2F;将 p 地址的第 nr 位置 1。void clear_bit(int nr,void *p) &#x2F;&#x2F;将 p 地址的第 nr 位清零。void change_bit(int nr, void *p) &#x2F;&#x2F;将 p 地址的第 nr 位进行翻转。int test_bit(int nr, void *p) 获取 p &#x2F;&#x2F;地址的第 nr 位的值。int test_and_set_bit(int nr, void *p) &#x2F;&#x2F;将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值。int test_and_clear_bit(int nr, void *p) &#x2F;&#x2F;将 p 地址的第 nr 位清零，并且返回 nr 位原来的值。int test_and_change_bit(int nr, void *p) &#x2F;&#x2F;将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值。 2、实验程序编写使用原子操作来 实现对 LED 这个设备的互斥访问，也就是一次只允许一个应用程序可以使用 LED 灯。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#x2F;***************************************************************文件名 : atomic.c描述 : 原子操作实验，使用原子变量来实现对实现设备的互斥访问***************************************************************&#x2F;&#x2F;* gpioled设备结构体 *&#x2F;struct gpioled_dev&#123; atomic_t lock; &#x2F;* 原子变量 *&#x2F;&#125;;struct gpioled_dev gpioled; &#x2F;* led设备 *&#x2F;&#x2F;* * @description : 打开设备 * @param - inode : 传递给驱动的inode * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量 * 一般在open的时候将private_data指向设备结构体。 * @return : 0 成功;其他 失败 *&#x2F;static int led_open(struct inode *inode, struct file *filp)&#123; &#x2F;* 通过判断原子变量的值来检查LED有没有被别的应用使用 *&#x2F; if (!atomic_dec_and_test(&amp;gpioled.lock)) &#123; atomic_inc(&amp;gpioled.lock); &#x2F;* 小于0的话就加1,使其原子变量等于0 *&#x2F; return -EBUSY; &#x2F;* LED被使用，返回忙 *&#x2F; &#125; filp-&gt;private_data &#x3D; &amp;gpioled; &#x2F;* 设置私有数据 *&#x2F; return 0;&#125;&#x2F;* * @description : 关闭&#x2F;释放设备 * @param - filp : 要关闭的设备文件(文件描述符) * @return : 0 成功;其他 失败 *&#x2F;static int led_release(struct inode *inode, struct file *filp)&#123; struct gpioled_dev *dev &#x3D; filp-&gt;private_data; &#x2F;* 关闭驱动文件的时候释放原子变量 *&#x2F; atomic_inc(&amp;dev-&gt;lock); return 0;&#125;&#x2F;* * @description : 驱动出口函数 * @param : 无 * @return : 无 *&#x2F;static int __init led_init(void)&#123; int ret &#x3D; 0; &#x2F;* 初始化原子变量 *&#x2F; atomic_set(&amp;gpioled.lock, 1); &#x2F;* 原子变量初始值为1 *&#x2F; return 0;&#125; 第 42 行，原子变量 lock，用来实现一次只能允许一个应用访问 LED 灯，led_init 驱动入口函数会将 lock 的值设置为 1。 第 57~60 行，每次调用 open 函数打开驱动设备的时候先申请 lock，如果申请成功的话就表示LED灯还没有被其他的应用使用，如果申请失败就表示LED灯正在被其他的应用程序使用。每次打开驱动设备的时候先使用 atomic_dec_and_test 函数将 lock 减 1，如果 atomic_dec_and_test函数返回值为真就表示 lock 当前值为 0，说明设备可以使用。如果 atomic_dec_and_test 函数返回值为假，就表示 lock 当前值为负数(lock 值默认是 1)，lock 值为负数的可能性只有一个，那就是其他设备正在使用 LED。其他设备正在使用 LED 灯，那么就只能退出了，在退出之前调用函数 atomic_inc 将 lock 加 1，因为此时 lock 的值被减成了负数，必须要对其加 1，将 lock 的值变为 0。 第 120 行，LED 灯使用完毕，应用程序调用 close 函数关闭的驱动文件，led_release 函数执行，调用 atomic_inc 释放 lcok，也就是将 lock 加 1。 第 143 行，初始化原子变量 lock，初始值设置为 1，这样每次就只允许一个应用使用 LED灯。","link":"","tags":[]},{"title":"Linux驱动-并发与竞争-互斥体","date":"2021-04-15T10:40:32.000Z","path":"2021/04/15/Linux驱动-并发与竞争-互斥体/","text":"1、互斥体Linux 提供了一个比信号量更专业的机制来进行互斥，它就是互斥体—mutex。互斥访问表示一次只有一个线程可以访问共享资源，不能递归申请互斥体。在编写 Linux 驱动的时候遇到需要互斥访问的地方建议使用 mutex。Linux 内核使用 mutex 结构体表示互斥体，定义如下 12345struct mutex &#123; &#x2F;* 1: unlocked, 0: locked, negative: locked, possible waiters *&#x2F; atomic_t count; spinlock_t wait_lock;&#125;; 在使用 mutex 之前要先定义一个 mutex 变量。在使用 mutex 的时候要注意如下几点： ①、mutex 可以导致休眠，因此不能在中断中使用 mutex，中断中只能使用自旋锁。 ②、和信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数。 ③、因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并且 mutex 不能递归上锁和解锁。 互斥体 API 函数 1234567DEFINE_MUTEX(name) &#x2F;&#x2F;定义并初始化一个 mutex 变量。void mutex_init(mutex *lock) &#x2F;&#x2F;初始化 mutex。void mutex_lock(struct mutex *lock)&#x2F;&#x2F;获取mutex，也就是给 mutex 上锁。如果获取不到就进休眠。void mutex_unlock(struct mutex *lock) &#x2F;&#x2F;释放 mutex，也就给 mutex 解锁。int mutex_trylock(struct mutex *lock)&#x2F;&#x2F;尝试获取 mutex，如果成功就返回 1，如果失败就返回 0。int mutex_is_locked(struct mutex *lock)&#x2F;&#x2F;判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。int mutex_lock_interruptible(struct mutex *lock)&#x2F;&#x2F;使用此函数获取信号量失败进入休眠以后可以被信号打断。 互斥体的使用如下所示： 12345struct mutex lock; &#x2F;* 定义一个互斥体 *&#x2F;mutex_init(&amp;lock); &#x2F;* 初始化互斥体 *&#x2F;mutex_lock(&amp;lock); &#x2F;* 上锁 *&#x2F;&#x2F;* 临界区 *&#x2F;mutex_unlock(&amp;lock); &#x2F;* 解锁 *&#x2F; 2、实验程序编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#x2F;***************************************************************文件名 : mutex.c描述 : 互斥体实验，使用互斥体来实现对实现设备的互斥访问***************************************************************&#x2F;&#x2F;* gpioled设备结构体 *&#x2F;struct gpioled_dev&#123; struct mutex lock; &#x2F;* 互斥体 *&#x2F;&#125;;struct gpioled_dev gpioled; &#x2F;* led设备 *&#x2F;&#x2F;* * @description : 打开设备 * @param - inode : 传递给驱动的inode * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量 * 一般在open的时候将private_data指向设备结构体。 * @return : 0 成功;其他 失败 *&#x2F;static int led_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data &#x3D; &amp;gpioled; &#x2F;* 设置私有数据 *&#x2F; &#x2F;* 获取互斥体,可以被信号打断 *&#x2F; if (mutex_lock_interruptible(&amp;gpioled.lock)) &#123; return -ERESTARTSYS; &#125;#if 0 mutex_lock(&amp;gpioled.lock); &#x2F;* 不能被信号打断 *&#x2F;#endif return 0;&#125;&#x2F;* * @description : 关闭&#x2F;释放设备 * @param - filp : 要关闭的设备文件(文件描述符) * @return : 0 成功;其他 失败 *&#x2F;static int led_release(struct inode *inode, struct file *filp)&#123; struct gpioled_dev *dev &#x3D; filp-&gt;private_data; &#x2F;* 释放互斥锁 *&#x2F; mutex_unlock(&amp;dev-&gt;lock); return 0;&#125;&#x2F;* * @description : 驱动入口函数 * @param : 无 * @return : 无 *&#x2F;static int __init led_init(void)&#123; int ret &#x3D; 0; &#x2F;* 初始化互斥体 *&#x2F; mutex_init(&amp;gpioled.lock); return 0;&#125; 第 43 行，定义互斥体 lock。 第 60~65 行，在 open 函数中调用 mutex_lock_interruptible 或者 mutex_lock 获取 mutex，成功的话就表示可以使用 LED 灯，失败的话就会进入休眠状态，和信号量一样。 第 124 行，在 release 函数中调用 mutex_unlock 函数释放 mutex，这样其他应用程序就可以获取 mutex 了。 第 148 行，在驱动入口函数中调用 mutex_init 初始化 mutex。互斥体和二值信号量类似，只不过互斥体是专门用于互斥访问的。","link":"","tags":[]},{"title":"Linux驱动-并发与竞争简介","date":"2021-04-14T14:51:29.000Z","path":"2021/04/14/Linux驱动-并发与竞争简介/","text":"Linux是一个多任务操作系统，肯定会存在多个任务共同操作同一段内存或者设备的情况，多个任务甚至中断都能访问的资源叫做共享资源，。在驱动开发中要注意对 共享资源的保护，也就是要处理对共享资源的并发访问。在 Linux 驱动编写过程中对于并发控制的管理非常重要，学习如何在 Linux 驱动中处理并发。 并发与竞争1、并发与竞争简介并发就是多个“用户”同时访问同一个共享资源。 Linux 系统是个多任务操作系统，会存在多个任务同时访问同一片内存区域，这些任务可能会相互覆盖这段内存中的数据，造成内存数据混乱。针对这个问题必须要做处理，严重的话可能会导致系统崩溃。现在的 Linux 系统并发产生的原因很复杂，总结一下有下面几个主要原因： ①、多线程并发访问，Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。②、抢占式并发访问，，Linux 内核支持抢占，也就是说调度程序可以在任意时刻抢占正在运行的线程，从而运行其他的线程。③、中断程序并发访问，硬件中断的权利可是很大的。④、SMP(多核)核间并发访问，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并发访问。 并发访问带来的问题就是竞争 所谓的临界区就是共享数据段，对于临界区必须保证一次只有一个线程访问，也就是要保证临界区是原子访问的，原子访问就表示这一个访问是一个步骤，不能再进行拆分。如果多个线程同时操作临界区就表示存在竞争，我们在编写驱动的时候一定要注意避免并发和防止竞争访问。 2、保护内容是什么要防止并发访问共享资源，换句话说就是要保护共享资源，防止进行并发访问。我们保护的不是代码，而是数据！某个线程的局部变量不需要保护，我们要保护的是多个线程都会访问的共享数据。 并发和竞争的处理方法1、原子操作2、自旋锁3、信号量4、互斥体","link":"","tags":[]},{"title":"Linux驱动-pinctrl和gpio子系统BEEP","date":"2021-04-14T14:36:06.000Z","path":"2021/04/14/Linux驱动-pinctrl和gpio子系统BEEP/","text":"编写蜂鸣器驱动需要做： ①、在设备树中添加 SNVS_TAMPER1 引脚的 pinctrl 信息。 ②、在设备树中创建蜂鸣器节点，在蜂鸣器节点中加入 GPIO 信息。 ③、编写驱动程序和测试 APP，和第四十五章的 LED 驱动程序和测试 APP 基本一样。 修改设备树文件1、添加 pinctrl 节点I.MX6U-ALPHA开发板上的BEEP使用了SNVS_TAMPER1这个PIN，打开imx6ull-alientek\u0002emmc.dts，在 iomuxc 节点的 imx6ul-evk 子节点下创建一个名为“pinctrl_beep”的子节点， 12345pinctrl_beep: beepgrp &#123; fsl,pins &#x3D; &lt; MX6ULL_PAD_SNVS_TAMPER1__GPIO5_IO01 0x10B0 &#x2F;* beep *&#x2F; &gt;;&#125;; 第 3 行，将 SNVS_TAMPER1 这 个 PIN 复用为 GPIO5_IO01 ， 2、添加 BEEP 设备节点在根节点“/”下创建 BEEP 节点，节点名为“beep”， 123456789beep &#123; #address-cells &#x3D; &lt;1&gt;; #size-cells &#x3D; &lt;1&gt;; compatible &#x3D; &quot;atkalpha-beep&quot;; pinctrl-names &#x3D; &quot;default&quot;; pinctrl-0 &#x3D; &lt;&amp;pinctrl_beep&gt;; beep-gpio &#x3D; &lt;&amp;gpio5 1 GPIO_ACTIVE_HIGH&gt;; status &#x3D; &quot;okay&quot;;&#125;; 第 6 行，pinctrl-0 属性设置蜂鸣器所使用的 PIN 对应的 pinctrl 节点。第 7 行，beep-gpio 属性指定了蜂鸣器所使用的 GPIO。 3、检查 PIN 是否被其他外设使用 ①、检查 pinctrl 设置。 ②、如果这个 PIN 配置为 GPIO 的话，检查这个 GPIO 有没有被别的外设使用。 在本章实验中蜂鸣器使用的 PIN 为 SNVS_TAMPER1，因此先检查 PIN 为 SNVS_TAMPER1这个 PIN有没有被其他的 pinctrl 节点使用，如果有使用的话就要屏蔽掉，然后再检查GPIO5_IO01 这个 GPIO 有没有被其他外设使用，如果有的话也要屏蔽掉。 蜂鸣器驱动程序编写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#x2F;***************************************************************文件名 : beep.c描述 : 蜂鸣器驱动程序。***************************************************************&#x2F;&#x2F;* beep设备结构体 *&#x2F;struct beep_dev&#123; dev_t devid; &#x2F;* 设备号 *&#x2F; struct cdev cdev; &#x2F;* cdev *&#x2F; struct class *class; &#x2F;* 类 *&#x2F; struct device *device; &#x2F;* 设备 *&#x2F; int major; &#x2F;* 主设备号 *&#x2F; int minor; &#x2F;* 次设备号 *&#x2F; struct device_node *nd; &#x2F;* 设备节点 *&#x2F; int beep_gpio; &#x2F;* beep所使用的GPIO编号 *&#x2F;&#125;;struct beep_dev beep; &#x2F;* beep设备 *&#x2F;&#x2F;* * @description : 驱动入口函数 * @param : 无 * @return : 无 *&#x2F;static int __init beep_init(void)&#123; int ret &#x3D; 0; &#x2F;* 设置BEEP所使用的GPIO *&#x2F; &#x2F;* 1、获取设备节点：beep *&#x2F; beep.nd &#x3D; of_find_node_by_path(&quot;&#x2F;beep&quot;); if(beep.nd &#x3D;&#x3D; NULL) &#123; printk(&quot;beep node not find!\\r\\n&quot;); return -EINVAL; &#125; else &#123; printk(&quot;beep node find!\\r\\n&quot;); &#125; &#x2F;* 2、 获取设备树中的gpio属性，得到BEEP所使用的BEEP编号 *&#x2F; beep.beep_gpio &#x3D; of_get_named_gpio(beep.nd, &quot;beep-gpio&quot;, 0); if(beep.beep_gpio &lt; 0) &#123; printk(&quot;can&#39;t get beep-gpio&quot;); return -EINVAL; &#125; printk(&quot;led-gpio num &#x3D; %d\\r\\n&quot;, beep.beep_gpio); &#x2F;* 3、设置GPIO5_IO01为输出，并且输出高电平，默认关闭BEEP *&#x2F; ret &#x3D; gpio_direction_output(beep.beep_gpio, 1); if(ret &lt; 0) &#123; printk(&quot;can&#39;t set gpio!\\r\\n&quot;); &#125; &#x2F;* 注册字符设备驱动 *&#x2F; &#x2F;* 1、创建设备号 *&#x2F; if (beep.major) &#123; &#x2F;* 定义了设备号 *&#x2F; beep.devid &#x3D; MKDEV(beep.major, 0); register_chrdev_region(beep.devid, BEEP_CNT, BEEP_NAME); &#125; else &#123; &#x2F;* 没有定义设备号 *&#x2F; alloc_chrdev_region(&amp;beep.devid, 0, BEEP_CNT, BEEP_NAME); &#x2F;* 申请设备号 *&#x2F; beep.major &#x3D; MAJOR(beep.devid); &#x2F;* 获取分配号的主设备号 *&#x2F; beep.minor &#x3D; MINOR(beep.devid); &#x2F;* 获取分配号的次设备号 *&#x2F; &#125; printk(&quot;beep major&#x3D;%d,minor&#x3D;%d\\r\\n&quot;,beep.major, beep.minor); &#x2F;* 2、初始化cdev *&#x2F; beep.cdev.owner &#x3D; THIS_MODULE; cdev_init(&amp;beep.cdev, &amp;beep_fops); &#x2F;* 3、添加一个cdev *&#x2F; cdev_add(&amp;beep.cdev, beep.devid, BEEP_CNT); &#x2F;* 4、创建类 *&#x2F; beep.class &#x3D; class_create(THIS_MODULE, BEEP_NAME); if (IS_ERR(beep.class)) &#123; return PTR_ERR(beep.class); &#125; &#x2F;* 5、创建设备 *&#x2F; beep.device &#x3D; device_create(beep.class, NULL, beep.devid, NULL, BEEP_NAME); if (IS_ERR(beep.device)) &#123; return PTR_ERR(beep.device); &#125; return 0;&#125;","link":"","tags":[]},{"title":"Linux驱动-pinctrl和gpio子系统","date":"2021-04-14T13:11:33.000Z","path":"2021/04/14/Linux驱动-pinctrl和gpio子系统/","text":"Linux 是一个庞大而完善的系统， 尤其是驱动框架，像 GPIO 这种最基本的驱动不可能采用“原始”的裸机驱动开发方式，Linux 内核提供了 pinctrl 和 gpio 子系统用于GPIO 驱动。 pinctrl 子系统pinctrl 子系统简介Linux 驱动讲究驱动分离与分层，pinctrl 和 gpio 子系统就是驱动分离与分层思想下的产物，驱动分离与分层其实就是按照面向对象编程的设计思想而设计的设备驱动框架。 传统的配置 pin 的方式就是直接操作相应的寄存器，但是这种配置 方式比较繁琐、而且容易出问题(比如 pin 功能冲突)。pinctrl 子系统就是为了解决这个问题而引入的，pinctrl 子系统主要工作内容如下： ①、获取设备树中 pin 信息。 ②、根据获取到的 pin 信息来设置 pin 的复用功能 ③、根据获取到的 pin 信息来设置 pin 的电气特性，比如上/下拉、速度、驱动能力等。 对于使用者来讲，只需要在设备树里面设置好某个 pin 的相关属性即可，其他的初始化工作均由 pinctrl 子系统来完成，pinctrl 子系统源码目录为 drivers/pinctrl。 PIN 配置信息详解要使用 pinctrl 子系统，我们需要在设备树里面设置 PIN 的配置信息，毕竟 pinctrl 子系统要根据你提供的信息来配置 PIN 功能，一般会在设备树里面创建一个节点来描述 PIN 的配置信息。 12345pinctrl_hog_1: hoggrp-1 &#123; fsl,pins &#x3D; &lt; MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 0x17059 &#x2F;* SD1 CD *&#x2F; &gt;; &#125;; 我们在imx6ul-pinfunc.h中找到： 1MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 0x0090 0x031C 0x0000 0x5 0x0 12&lt;mux_reg conf_reg input_reg mux_mode input_val&gt;0x0090 0x031C 0x0000 0x5 0x0 IOMUXC父节点首地址0x020e0000，因此UART1_RTS_B这个PIN的mux(复用)寄存器地址 就是：0x020e0000+0x0090=0x020e 0090。 conf_reg：0x020e0000+0x031C=0x020e 031C，这个寄存器就是UART1_RTS_B的电气属性配置寄存器。 input_reg，便宜为0，表示UART1_RTS_B这个PIN没有input功能。 mux_mode：5表示复用为GPIO1_IO19，将其写入0x020e 0090 input_val：就是写入input_reg寄存器的值。 0x17059：为PIN的电气属性配置寄存器值。 PIN 驱动程序讲解如何找到IMX6UL对应的pinctrl子系统驱动，设备树里面的设备节点是如何根驱动匹配的呢？通过compatible，此属性是字符串列表。驱动文件里面有一个描述驱动兼容性的东西，当设备树节点的compatible属性和驱动里面的兼容性字符串匹配，也就是一模一样的时候就表示设备和驱动匹配了。 所以我们只需要全局搜索，设备节点里面的compatible属性的值，看看在哪个.c文件里面有，那么此.c文件就是驱动文件。 ​ 找到pinctrl-imx6ul.c文件，那么此文件就是6UL/6ULL的pinctrl驱动文件。 ​ 当驱动和设备匹配以后执行，probe函数。也就是 imx6ul_pinctrl_probe ​ -&gt;imx_pinctrl_probe ​ -&gt; 此函数会初始化imx_pinctrl_desc，为pinctrl_desc类型的结构体。重点是： ​ imx_pinctrl_desc-&gt;pctlops = &imx_pctrl_ops; ​ imx_pinctrl_desc-&gt;pmxops = &imx_pmx_ops; ​ imx_pinctrl_desc-&gt;confops = &imx_pinconf_ops; ​ 最后通过pinctrl_register函数向系统注册一个imx_pinctrl_desc ​ -&gt;imx_pinctrl_probe_dt ​ -&gt;imx_pinctrl_parse_functions ​ -&gt;imx_pinctrl_parse_groups ​ -&gt; pin_reg-&gt;mux_reg = mux_reg; ​ pin_reg-&gt;conf_reg = conf_reg; ​ pin-&gt;input_reg = be32_to_cpu(*list++); ​ pin-&gt;mux_mode = be32_to_cpu(*list++); ​ pin-&gt;input_val = be32_to_cpu(*list++); ​ config = be32_to_cpu(*list++); ​ if (config &amp; IMX_PAD_SION) ​ pin-&gt;mux_mode |= IOMUXC_CONFIG_SION; ​ pin-&gt;config = config &amp; ~IMX_PAD_SION; imx_pinconf_set函数设置PIN的电气属性 imx_pmx_set函数设置PIN的复用 设备树中添加 pinctrl 节点1、创建对应的节点 同一个外设的 PIN 都放到一个节点里面，打开 imx6ull-alientek-emmc.dts，在 iomuxc 节点中的“imx6ul-evk”子节点下添加“pinctrl_test”节点，注意！节点前缀一定要为“pinctrl_” 2、添加“fsl,pins”属性 设备树是通过属性来保存信息的，因此我们需要添加一个属性，属性名字一定要为“fsl,pins”， 为对于 I.MX 系列 SOC 而言，pinctrl 驱动程序是通过读取“fsl,pins”属性值来获取 PIN 的配置信息， 3、在“fsl,pins”属性中添加 PIN 配置信息 最后在“fsl,pins”属性中添加具体的 PIN 配置信息，完成以后如下所示： 1234pinctrl_test: testgrp &#123; fsl,pins &#x3D; &lt; MX6UL_PAD_GPIO1_IO00__GPIO1_IO00 config &#x2F;*config 是具体设置值*&#x2F;&gt;; 总结：pinctrl 子系统，pinctrl 子系统重点是设置 PIN(有的 SOC 叫做 PAD)的复用和电气属性。 gpio 子系统gpio 子系统顾名思义，就是用于初始化 GPIO 并且提供相应的 API 函数，比如设置 GPIO 为输入输出，读取 GPIO 的值等。gpio 子系统的主要目的就是方便驱动开发者使用 gpio，驱动开发者在设备树中添加 gpio 相关信息，然后就可以在驱动程序中使用 gpio 子系统提供的 API函数来操作 GPIO，Linux 内核向驱动开发者屏蔽掉了 GPIO 的设置过程，极大的方便了驱动开发者使用 GPIO。 gpiolib(gpio库)：分两部分，一部分给原厂编写GPIO底层驱动的，另一部分给驱动开发人员使用GPIO操作函数的。使用gpiochip_add向系统添加gpio_chip，这些都是半导体原厂做的，这部分就是最底层的GPIO驱动。 gpio 子系统 API 函数对于驱动开发人员，设置好设备树以后就可以使用 gpio 子系统提供的 API 函数来操作指定 的 GPIO，gpio 子系统向驱动开发人员屏蔽了具体的读写寄存器过程。这就是驱动分层与分离的好处。驱动中对gpio的操作函数： 1、首先，获取到GPIO所处的设备节点，比如of_find_node_by_path。 2、获取GPIO编号, of_get_named_gpio函数，返回值就是GPIO编号。 3、请求此编号的GPIO，gpio_request函数 4、设置GPIO，输入或输出，gpio_direction_input或gpio_direction_output。 5、如果是输入，那么通过gpio_get_value函数读取GPIO值，如果是输出，通过gpio_set_value设置GPIO值。 1、gpio_request 函数gpio_request 函数用于申请一个 GPIO 管脚，在使用一个 GPIO 之前一定要使用 gpio_request进行申请 1int gpio_request(unsigned gpio, const char *label) gpio：要申请的 gpio 标号，使用 of_get_named_gpio 函数从设备树获取指定 GPIO 属性信息，此函数会返回这个 GPIO 的标号。label：给 gpio 设置个名字。返回值：0，申请成功；其他值，申请失败。 2、gpio_free 函数如果不使用某个 GPIO 了，那么就可以调用 gpio_free 函数进行释放。 1void gpio_free(unsigned gpio) gpio：要释放的 gpio 标号。返回值：无。 3、gpio_direction_input 函数此函数用于设置某个 GPIO 为输入 1int gpio_direction_input(unsigned gpio) gpio：要设置为输入的 GPIO 标号。返回值：0，设置成功；负值，设置失败。 4、gpio_direction_output 函数此函数用于设置某个 GPIO 为输出，并且设置默认输出值， 1int gpio_direction_output(unsigned gpio, int value) gpio：要设置为输出的 GPIO 标号。value：GPIO 默认输出值。返回值：0，设置成功；负值，设置失败。 5、gpio_get_value 函数此函数用于获取某个 GPIO 的值(0 或 1)，此函数是个宏，定义所示： 12#define gpio_get_value __gpio_get_valueint __gpio_get_value(unsigned gpio) gpio：要获取的 GPIO 标号。返回值：非负值，得到的 GPIO 值；负值，获取失败。 6、gpio_set_value 函数此函数用于设置某个 GPIO 的值，此函数是个宏，定义如下 12#define gpio_set_value __gpio_set_valuevoid __gpio_set_value(unsigned gpio, int value) gpio：要设置的 GPIO 标号。value：要设置的值。返回值：无 设备树中添加 gpio 节点1、创建 test 设备节点 2、添加 pinctrl 信息 3、添加 GPIO 属性信息最后需要在 test 节点中添加 GPIO 属性信息，表明 test 所使用的 GPIO 是哪个引脚，添加完成以后如下所示： 12345test &#123; pinctrl-names &#x3D; &quot;default&quot;; pinctrl-0 &#x3D; &lt;&amp;pinctrl_test&gt;; gpio &#x3D; &lt;&amp;gpio1 0 GPIO_ACTIVE_LOW&gt;;&#125;; 第一行，在根节点“/”下创建 test 设备子节点， 第 2 行，添加 pinctrl-names 属性，此属性描述 pinctrl 名字为“default”。 第 3 行，添加 pinctrl-0 节点，此节点引用 45.1.3 中创建的 pinctrl_test 节点，表示 tset 设备的所使用的 PIN 信息保存在 pinctrl_test 节点中。 第 4 行，test 设备所使用的 gpio。 与 gpio 相关的 OF 函数在驱动程序中需要读取 gpio 属性内容，Linux 内核提供了几个与 GPIO 有关的 OF 函数， 1、of_gpio_named_count 函数of_gpio_named_count 函数用于获取设备树某个属性里面定义了几个 GPIO 信息，要注意的是空的 GPIO 信息也会被统计到，比如： 1234gpios &#x3D; &lt;0 &amp;gpio1 1 2 0 &amp;gpio2 3 4&gt;; 上述代码的“gpios”节点一共定义了 4 个 GPIO，但是有 2 个是空的，没有实际的含义。通过 of_gpio_named_count 函数统计出来的 GPIO 数量就是 4 个，此函数原型如下： 1int of_gpio_named_count(struct device_node *np, const char *propname) np：设备节点。propname：要统计的 GPIO 属性。返回值：正值，统计到的 GPIO 数量；负值，失败。 2、of_gpio_count 函数和 of_gpio_named_count 函数一样，但是不同的地方在于，此函数统计的是“gpios”这个属性的 GPIO 数量，而 of_gpio_named_count 函数可以统计任意属性的 GPIO 信息，函数原型如下所示： 1int of_gpio_count(struct device_node *np) np：设备节点。返回值：正值，统计到的 GPIO 数量；负值，失败。 3、of_get_named_gpio 函数 此函数获取 GPIO 编号，因为 Linux 内核中关于 GPIO 的 API 函数都要使用 GPIO 编号，此函数会将设备树中类似&lt;&amp;gpio5 7 GPIO_ACTIVE_LOW&gt;的属性信息转换为对应的 GPIO 编号，此函数在驱动中使用很频繁！ 1int of_get_named_gpio(struct device_node *np, const char *propname, int index) np：设备节点。propname：包含要获取 GPIO 信息的属性名。 index：GPIO 索引，因为一个属性里面可能包含多个 GPIO，此参数指定要获取哪个 GPIO的编号，如果只有一个 GPIO 信息的话此参数为 0。返回值：正值，获取到的 GPIO 编号；负值，失败。","link":"","tags":[]},{"title":"Linux驱动-Linux设备树LED","date":"2021-04-14T12:38:13.000Z","path":"2021/04/14/Linux驱动-Linux设备树LED/","text":"一、设备树LED驱动原理使用设备树来向 Linux 内核传递相关的寄存器物理地址，Linux 驱动文件使用OF函数从设备树中获取所需的属性值，然后使用获取到的属性值来初始化相关的 IO。重点内容如下： ①、在 imx6ull-alientek-emmc.dts 文件中创建相应的设备节点。 ②、编写驱动程序(在第四十二章实验基础上完成)，获取设备树中的相关属性值。 ③、使用获取到的有关属性值来初始化 LED 所使用的 GPIO。 二、修改设备树文件在根节点“/”下创建一个名为“alphaled”的子节点，打开 imx6ull-alientek-emmc.dts 文件， 在根节点“/”最后面输入如下所示内容： 123456781 alphaled &#123; 2 #address-cells &#x3D; &lt;1&gt;;3 #size-cells &#x3D; &lt;1&gt;;4 compatible &#x3D; &quot;atkalpha-led&quot;; 5 status &#x3D; &quot;okay&quot;; 6 reg &#x3D; &lt; 0X020C406C 0X04 &#x2F;* CCM_CCGR1_BASE *&#x2F;7 0X020E0068 0X04 &#x2F;* SW_MUX_GPIO1_IO03_BASE *&#x2F;8 0X020E02F4 0X04 &#x2F;* SW_PAD_GPIO1_IO03_BASE *&#x2F;9 0X0209C000 0X04 &#x2F;* GPIO1_DR_BASE *&#x2F;10 0X0209C004 0X04 &gt;; &#x2F;* GPIO1_GDIR_BASE *&#x2F;11 &#125;; 第 2、3 行，属性#address-cells 和#size-cells 都为 1，表示 reg 属性中起始地址占用一个字长 (cell)，地址长度也占用一个字长(cell)。 第 4 行，属性 compatbile 设置 alphaled 节点兼容性为“atkalpha-led”。 第 5 行，属性 status 设置状态为“okay”。 第 6~10 行，reg 属性，非常重要！reg 属性设置了驱动里面所要使用的寄存器物理地址，比 如第 6 行的“0X020C406C 0X04”表示 I.MX6ULL 的 CCM_CCGR1 寄存器，其中寄存器首地 址为 0X020C406C，长度为 4 个字节。 三、编写驱动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&#x2F;* dtsled设备结构体 *&#x2F;struct dtsled_dev&#123; ……………… struct device_node *nd; &#x2F;* 设备节点 *&#x2F;&#125;;………………&#x2F;* * @description : 驱动出口函数 * @param : 无 * @return : 无 *&#x2F;static int __init led_init(void)&#123; u32 val &#x3D; 0; int ret; u32 regdata[14]; const char *str; struct property *proper; &#x2F;* 获取设备树中的属性数据 *&#x2F; &#x2F;* 1、获取设备节点：alphaled *&#x2F; dtsled.nd &#x3D; of_find_node_by_path(&quot;&#x2F;alphaled&quot;); if(dtsled.nd &#x3D;&#x3D; NULL) &#123; printk(&quot;alphaled node nost find!\\r\\n&quot;); return -EINVAL; &#125; else &#123; printk(&quot;alphaled node find!\\r\\n&quot;); &#125; &#x2F;* 2、获取compatible属性内容 *&#x2F; proper &#x3D; of_find_property(dtsled.nd, &quot;compatible&quot;, NULL); if(proper &#x3D;&#x3D; NULL) &#123; printk(&quot;compatible property find failed\\r\\n&quot;); &#125; else &#123; printk(&quot;compatible &#x3D; %s\\r\\n&quot;, (char*)proper-&gt;value); &#125; &#x2F;* 3、获取status属性内容 *&#x2F; ret &#x3D; of_property_read_string(dtsled.nd, &quot;status&quot;, &amp;str); if(ret &lt; 0)&#123; printk(&quot;status read failed!\\r\\n&quot;); &#125; else &#123; printk(&quot;status &#x3D; %s\\r\\n&quot;,str); &#125; &#x2F;* 4、获取reg属性内容 *&#x2F; ret &#x3D; of_property_read_u32_array(dtsled.nd, &quot;reg&quot;, regdata, 10); if(ret &lt; 0) &#123; printk(&quot;reg property read failed!\\r\\n&quot;); &#125; else &#123; u8 i &#x3D; 0; printk(&quot;reg data:\\r\\n&quot;); for(i &#x3D; 0; i &lt; 10; i++) printk(&quot;%#X &quot;, regdata[i]); printk(&quot;\\r\\n&quot;); &#125; IMX6U_CCM_CCGR1 &#x3D; of_iomap(dtsled.nd, 0); SW_MUX_GPIO1_IO03 &#x3D; of_iomap(dtsled.nd, 1); SW_PAD_GPIO1_IO03 &#x3D; of_iomap(dtsled.nd, 2); GPIO1_DR &#x3D; of_iomap(dtsled.nd, 3); GPIO1_GDIR &#x3D; of_iomap(dtsled.nd, 4); &#x2F;* 2、使能GPIO1时钟 *&#x2F; val &#x3D; readl(IMX6U_CCM_CCGR1); val &amp;&#x3D; ~(3 &lt;&lt; 26); &#x2F;* 清楚以前的设置 *&#x2F; val |&#x3D; (3 &lt;&lt; 26); &#x2F;* 设置新值 *&#x2F; writel(val, IMX6U_CCM_CCGR1); &#x2F;* 3、设置GPIO1_IO03的复用功能，将其复用为 * GPIO1_IO03，最后设置IO属性。 *&#x2F; writel(5, SW_MUX_GPIO1_IO03); &#x2F;*寄存器SW_PAD_GPIO1_IO03设置IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 00 默认下拉 *bit [13]: 0 kepper功能 *bit [12]: 1 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 110 R0&#x2F;6驱动能力 *bit [0]: 0 低转换率 *&#x2F; writel(0x10B0, SW_PAD_GPIO1_IO03); &#x2F;* 4、设置GPIO1_IO03为输出功能 *&#x2F; val &#x3D; readl(GPIO1_GDIR); val &amp;&#x3D; ~(1 &lt;&lt; 3); &#x2F;* 清除以前的设置 *&#x2F; val |&#x3D; (1 &lt;&lt; 3); &#x2F;* 设置为输出 *&#x2F; writel(val, GPIO1_GDIR); &#x2F;* 5、默认关闭LED *&#x2F; val &#x3D; readl(GPIO1_DR); val |&#x3D; (1 &lt;&lt; 3); writel(val, GPIO1_DR); &#x2F;* 注册字符设备驱动 *&#x2F; &#x2F;* 1、创建设备号 *&#x2F; if (dtsled.major) &#123; &#x2F;* 定义了设备号 *&#x2F; dtsled.devid &#x3D; MKDEV(dtsled.major, 0); register_chrdev_region(dtsled.devid, DTSLED_CNT, DTSLED_NAME); &#125; else &#123; &#x2F;* 没有定义设备号 *&#x2F; alloc_chrdev_region(&amp;dtsled.devid, 0, DTSLED_CNT, DTSLED_NAME); &#x2F;* 申请设备号 *&#x2F; dtsled.major &#x3D; MAJOR(dtsled.devid); &#x2F;* 获取分配号的主设备号 *&#x2F; dtsled.minor &#x3D; MINOR(dtsled.devid); &#x2F;* 获取分配号的次设备号 *&#x2F; &#125; printk(&quot;dtsled major&#x3D;%d,minor&#x3D;%d\\r\\n&quot;,dtsled.major, dtsled.minor); &#x2F;* 2、初始化cdev *&#x2F; dtsled.cdev.owner &#x3D; THIS_MODULE; cdev_init(&amp;dtsled.cdev, &amp;dtsled_fops); &#x2F;* 3、添加一个cdev *&#x2F; cdev_add(&amp;dtsled.cdev, dtsled.devid, DTSLED_CNT); &#x2F;* 4、创建类 *&#x2F; dtsled.class &#x3D; class_create(THIS_MODULE, DTSLED_NAME); if (IS_ERR(dtsled.class)) &#123; return PTR_ERR(dtsled.class); &#125; &#x2F;* 5、创建设备 *&#x2F; dtsled.device &#x3D; device_create(dtsled.class, NULL, dtsled.devid, NULL, DTSLED_NAME); if (IS_ERR(dtsled.device)) &#123; return PTR_ERR(dtsled.device); &#125; return 0;&#125; 在设备结构体 dtsled_dev 中添加了成员变量 nd，nd 是 device_node 结构体类型指针，表示设备节点。如果我们要读取设备树某个节点的属性值，首先要先得到这个节点，一般在设备结构体中添加 device_node 指针变量来存放这个节点。 通过 of_find_node_by_path 函数得到 alphaled 节点，后续其他的 OF 函数要使用 device_node。 通过 of_find_property 函数获取 alphaled 节点的 compatible 属性，返回值为 property 结构体类型指针变量，property 的成员变量 value 表示属性值。 通过 of_property_read_string 函数获取 alphaled 节点的 status 属性值。 通过 of_property_read_u32_array 函数获取 alphaled 节点的 reg 属性所有值，并且将获取到的值都存放到 regdata 数组中 第 192 行将获取到的 reg 属性值依次输出到终端上。 使用 of_iomap 函数一次性完成读取 reg 属性以及内存映射，of_iomap 函数是设备树推荐使用的 OF 函数。","link":"","tags":[]},{"title":"Linux驱动-Linux设备树","date":"2021-04-14T07:37:33.000Z","path":"2021/04/14/Linux驱动-Linux设备树/","text":"一、设备树简介设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(Device Tree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等。板级信息文件都是.c 或.h 文件，如果都编码进 Linux 内核中，会导致 Linux 内核“虚胖”臃肿。 ARM 社区就引入了 设备树(Flattened Device Tree)，将这些描述板级硬件信息的内容都从 Linux 内中分离开来，用一个专属的文件格式来描述，这个专属的文件就叫做设备树，文件扩展名为.dts。 一个 SOC 可以作出很多不同的板子，这些不同的板子肯定是有共同的信息，将这些共同的信息提取出来作为一个通用的文件.dtsi ，.dtsi 描述 SOC 级信息(也就是 SOC 有 几个 CPU、主频是多少、各个外设控制器信息等)。,类似于 C 语言中的头文件。一般.dts 描述板级信息(也就是开发板上有哪些 IIC 设备、SPI 设备等)。 二、DTS、DTB 和 DTCDTS 是设备树源码文件，DTB 是将DTS 编译以后得到的二进制文件。将.dts 编译为.dtb 需要用到 DTC 工具！如果要编译 DTS 文件的话只需要进入到 Linux 源码根目录下，然后执行如下命令： 1make dtbs 三、DTS 语法1、 .dtsi 头文件设备树也支持头文件，设备树的头文件扩展名为.dtsi。使用“#include”来引用“imx6ull.dtsi”这个.dtsi 头文件。 因此在.dts 设备树文件中，可以通过 “#include”来引用.h、.dtsi 和.dts 文件。只是，我们在编写设备树头文件的时候最好选择.dtsi 后缀。 一般.dtsi 文件用于描述 SOC 的内部外设信息，比如 CPU 架构、主频、外设寄存器地址范围，如 UART、IIC 等。 2、设备节点设备树是采用树形结构来描述板子上的设备信息的文件，每个设备都是一个节点，叫做设备节点，每个节点都通过一些属性信息来描述节点信息，属性就是键—值对。 在设备树中节点命名格式如下： 1node-name@unit-address 其中“node-name”是节点名字，为 ASCII 字符串，节点名字应该能够清晰的描述出节点的功能，比如“uart1”就表示这个节点是 UART1 外设。“unit-address”一般表示设备的地址或寄存器首地址，如果某个节点没有地址或者寄存器的话“unit-address”可以不要，比如“cpu@0”、 “interrupt-controller@00a01000”。 1label: node-name@unit-address 用“：”隔开成了两部分，“：” 前面的是节点标签(label)，“：”后面的是节点名字。引入 label 的目的就是为了方便访问节点，可以直接通过&amp;label 来访问这个节点。 设备树源码中常用的几种数据形式如下所示： ①、字符串 1compatible &#x3D; &quot;arm,cortex-a7&quot;; 上述代码设置 compatible 属性的值为字符串“arm,cortex-a7”。 ②、32 位无符号整数 1reg &#x3D; &lt;0&gt;; 上述代码设置 reg 属性的值为 0，reg 的值也可以设置为一组值，比如：reg = &lt;0 0x123456 100&gt;; ③、字符串列表 属性值也可以为字符串列表，字符串和字符串之间采用“,”隔开，如下所示： 1compatible &#x3D; &quot;fsl,imx6ull-gpmi-nand&quot;, &quot;fsl, imx6ul-gpmi-nand&quot;; 3、标准属性节点是由一堆的属性组成，节点都是具体的设备，不同的设备需要的属性不同，用户可以自定义属性。 1、compatible 属性 compatible 属性也叫做“兼容性”属性，这是非常重要的一个属性！compatible 属性的值是一个字符串列表，compatible 属性用于将设备和驱动绑定起来。字符串列表用于选择设备所要使用的驱动程。 1compatible &#x3D; &quot;manufacturer,model&quot; manufacturer 表示厂商，model 一般是模块对应的驱动名字。一般驱动程序文件都会有一个 OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的 compatible 属性值和 OF 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动。 2、model 属性model 属性值也是一个字符串，一般 model 属性描述设备模块信息，比如名字什么的，比如： 1model &#x3D; &quot;wm8960-audio&quot;; 3、status 属性status 属性看名字就知道是和设备状态有关的，status 属性值也是字符串，字符串是设备的状态信息。 “okay” ——表明设备是可操作的。 “disabled” ——表明设备当前是不可操作的，但是在未来可以变为可操作的，比如热插拔设备插入以后。至于 disabled 的具体含义还要看设备的绑定文档。 “fail” ——表明设备不可操作，设备检测到了一系列的错误，而且设备也不大可能变得可操作。 “fail-sss” ——含义和“fail”相同，后面的 sss 部分是检测到的错误内容。 4、#address-cells 、#size-cells 、reg 属性这两个属性的值都是无符号 32 位整形，#address-cells 和#size-cells 这两个属性可以用在任何拥有子节点的设备中，用于描述子节点的地址信息。#address-cells 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)，#size-cells 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)。#address-cells 和#size-cells 表明了子节点应该如何编写 reg 属性值。 reg 一般用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息，所以reg属性都是和地址有关的内容。和地址相关的信息有两种：起始地址和地址长度，reg 属性的格式一为： 1reg &#x3D; &lt;address1 length1 address2 length2 address3 length3……&gt; 每个“address length”组合表示一个地址范围，其中 address 是起始地址，length 是地址长度，#address-cells 表明 address 这个数据所占用的字长，#size-cells 表明 length 这个数据所占用字长。 5、ranges 属性ranges属性值可以为空或者按照(child-bus-address,parent-bus-address,length)格式编写的数字矩阵，ranges 是一个地址映射/转换表，ranges 属性每个项目由子地址、父地址和地址空间长度这三部分组成：child-bus-address：子总线地址空间的物理地址，由父节点的#address-cells 确定此物理地址所占用的字长。parent-bus-address：父总线地址空间的物理地址，同样由父节点的#address-cells 确定此物理地址所占用的字长。length：子地址空间的长度，由父节点的#size-cells 确定此地址长度所占用的字长。如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换，对于I.MX6ULL 来说，子地址空间和父地址空间完全相同。 4、特殊节点“/”是根节点，每个设备树文件只有一个根节点。在根节点“/”中有两个特殊的子节点：aliases 和 chosen。 aliases 子节点 单词 aliases 的意思是“别名”，因此 aliases 节点的主要功能就是定义别名，定义别名的目的就是为了方便访问节点。不过一般会在节点命名的时候会加上 label，然后通过&amp;label来访问节点，这样也很方便，而且设备树里面大量的使用&amp;label 的形式来访问节点。 chosen 子节点 chosen 并不是一个真实的设备，chosen 节点主要是为了 uboot 向 Linux 内核传递数据，重点是 bootargs 参数。一般.dts 文件中 chosen 节点通常为空或者内容很少。 在启动 Linux 内核之前，只有 uboot 设置bootargs 环境变量的值，并且 uboot也知道.dtb 设备树文件在 DRAM 中的位置。uboot 中的 fdt_chosen 函数在设备树的 chosen 节点中加入了 bootargs属性，并且还设置了 bootargs 属性值。 四、设备树常用 OF 操作函数Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资料里面也被叫做 OF 函数。 查找节点的 OF 函数设备都是以节点的形式“挂”到设备树上的，因此要想获取这个设备的其他属性信息，必须先获取到这个设备的节点。Linux 内核使用 device_node 结构体来描述一个节点， 123456789101112131415161718192021struct device_node &#123; const char *name; &#x2F;* 节点名字 *&#x2F; const char *type; &#x2F;* 设备类型 *&#x2F; phandle phandle; const char *full_name; &#x2F;* 节点全名 *&#x2F; struct fwnode_handle fwnode; struct property *properties; &#x2F;* 属性 *&#x2F; struct property *deadprops; &#x2F;* removed 属性 *&#x2F; struct device_node *parent; &#x2F;* 父节点 *&#x2F; struct device_node *child; &#x2F;* 子节点 *&#x2F; struct device_node *sibling; struct kobject kobj; unsigned long _flags; void *data;#if defined(CONFIG_SPARC) const char *path_component_name; unsigned int unique_id; struct of_irq_controller *irq_trans;#endif&#125;; 1、of_find_node_by_name 函数of_find_node_by_name 函数通过节点名字查找指定的节点，函数原型如下： 1struct device_node *of_find_node_by_name(struct device_node *from,const char *name); from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。name：要查找的节点名字。返回值：找到的节点，如果为 NULL 表示查找失败 2、of_find_node_by_type 函数of_find_node_by_type 函数通过 device_type 属性查找指定的节点，函数原型如下： 1struct device_node *of_find_node_by_type(struct device_node *from, const char *type) from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。type：要查找的节点对应的 type 字符串，也就是 device_type 属性值。返回值：找到的节点，如果为 NULL 表示查找失败。 3、of_find_compatible_node 函数of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点， 12struct device_node *of_find_compatible_node(struct device_node *from,const char *type, const char *compatible) from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。type：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为 NULL，表示忽略掉 device_type 属性。compatible：要查找的节点所对应的 compatible 属性列表。返回值：找到的节点，如果为 NULL 表示查找失败 4、of_find_matching_node_and_match 函数of_find_matching_node_and_match 函数通过 of_device_id 匹配表来查找指定的节点 12struct device_node *of_find_matching_node_and_match(struct device_node *from, const struct of_device_id *matches, const struct of_device_id **match) from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。matches：of_device_id 匹配表，也就是在此匹配表里面查找节点。match：找到的匹配的 of_device_id。返回值：找到的节点，如果为 NULL 表示查找失败 5、of_find_node_by_path 函数of_find_node_by_path 函数通过路径来查找指定的节点，函数原型如下： 1inline struct device_node *of_find_node_by_path(const char *path) path：带有全路径的节点名，可以使用节点的别名，比如“/backlight”就是 backlight 这个节点的全路径。返回值：找到的节点，如果为 NULL 表示查找失败 查找父/子节点的 OF 函数1、of_get_parent 函数of_get_parent 函数用于获取指定节点的父节点(如果有父节点的话)，函数原型如下： 1struct device_node *of_get_parent(const struct device_node *node) node：要查找的父节点的节点。返回值：找到的父节点 2、of_get_next_child 函数of_get_next_child 函数用迭代的查找子节点，函数原型如下： 12struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev) node：父节点。prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可设置为NULL，表示从第一个子节点开始。返回值：找到的下一个子节点。 提取属性值的 OF 函数节点的属性信息里面保存了驱动所需要的内容，因此对于属性值的提取非常重要，Linux 内核中使用结构体 property 表示属性， 123456789struct property &#123; char *name; &#x2F;* 属性名字 *&#x2F; int length; &#x2F;* 属性长度 *&#x2F; void *value; &#x2F;* 属性值 *&#x2F; struct property *next; &#x2F;* 下一个属性 *&#x2F; unsigned long _flags; unsigned int unique_id; struct bin_attribute attr;&#125;; 1、of_find_property 函数of_find_property 函数用于查找指定的属性，函数原型如下： 1property *of_find_property(const struct device_node *np, const char *name, int *lenp) np：设备节点。name： 属性名字。lenp：属性值的字节数返回值：找到的属性。 2、of_property_count_elems_of_size 函数用于获取属性中元素的数量，比如 reg 属性值是一个数组，那么使用此函数可以获取到这个数组的大小： 12int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size) np：设备节点。proname： 需要统计元素数量的属性名字。elem_size：元素长度。返回值：得到的属性元素数量。 3、of_property_read_u32_index 函数of_property_read_u32_index 函数用于从属性中获取指定标号的 u32 类型数据值(无符号 32 位)，比如某个属性有多个 u32 类型的值，那么就可以使用此函数来获取指定标号的数据值， 12int of_property_read_u32_index(const struct device_node *np,const char *propname, u32 index, u32 *out_value) np：设备节点。proname： 要读取的属性名字。index：要读取的值标号。out_value：读取到的值返回值：0 读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。 4、of_property_read_u32_array 函数 读取属性中 u32 类型的数组数据， 12int of_property_read_u32_array(const struct device_node *np,const char *propname, u32 *out_values,size_t sz) np：设备节点。proname： 要读取的属性名字。out_value：读取到的数组值，分别为 u8、u16、u32 和 u64。sz：要读取的数组元素数量。返回值：0，读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。 5、of_property_read_u32 函数 有些属性只有一个整形值，这四个函数就是用于读取这种只有一个整形值的属性，用于读取 u32类型属性值， 12int of_property_read_u32(const struct device_node *np, const char *propname, u32 *out_value) np：设备节点。proname： 要读取的属性名字。out_value：读取到的数组值。返回值：0，读取成功，负值，读取失败，-EINVAL 表示属性不存在，-ENODATA 表示没有要读取的数据，-EOVERFLOW 表示属性值列表太小。 6、of_property_read_string 函数of_property_read_string 函数用于读取属性中字符串值，函数原型如下： 12int of_property_read_string(struct device_node *np, const char *propname, const char **out_string) np：设备节点。proname： 要读取的属性名字。out_string：读取到的字符串值。返回值：0，读取成功，负值，读取失败。 7、of_n_addr_cells 函数、of_n_size_cells 函数of_n_addr_cells 函数用于获取#address-cells 属性值，of_size_cells 函数用于获取#size-cells 属性值 12int of_n_addr_cells(struct device_node *np)int of_n_size_cells(struct device_node *np) np：设备节点。返回值：获取到的#address-cells/size-cells 属性值。 其他常用的 OF 函数1、of_device_is_compatible 函数用于查看节点的 compatible 属性是否有包含 compat 指定的字符串，也就是检查设备节点的兼容性 1int of_device_is_compatible(const struct device_node *device, const char *compat) device：设备节点。compat：要查看的字符串。返回值：0，节点的 compatible 属性中不包含 compat 指定的字符串；正数，包含 compat 指定的字符串。 2、of_get_address 函数of_get_address 函数用于获取地址相关属性，主要是“reg”或者“assigned-addresses”属性值，函数属性如下： 12const __be32 *of_get_address(struct device_node *dev, int index, u64 *size, unsigned int *flags) dev：设备节点。index：要读取的地址标号。size：地址长度。flags：参数，比如 IORESOURCE_IO、IORESOURCE_MEM 等返回值：读取到的地址数据首地址，为 NULL 的话表示读取失败 3、of_translate_address 函数of_translate_address 函数负责将从设备树读取到的地址转换为物理地址，函数原型如下： 1u64 of_translate_address(struct device_node *dev,const __be32 *in_addr) 函数参数和返回值含义如下：dev：设备节点。in_addr：要转换的地址。返回值：得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败 4、of_address_to_resource 函数IIC、SPI、GPIO 等这些外设都有对应的寄存器，这些寄存器其实就是一组内存空间，Linux内核使用 resource 结构体来描述一段内存空间，“resource”翻译出来就是“资源”，因此用 resource结构体描述的都是设备资源信息。 1234567struct resource &#123; resource_size_t start; resource_size_t end; const char *name; unsigned long flags; struct resource *parent, *sibling, *child;&#125;; 对于 32 位的 SOC 来说，resource_size_t 是 u32 类型的。其中 start 表示开始地址，end 表示结束地址，name 是这个资源的名字，flags 是资源标志位，一般表示资源类型，最常见的资源标志就 是 IORESOURCE_MEM 、 IORESOURCE_REG 和IORESOURCE_IRQ 等。 of_address_to_resource 函数看名字像是从设备树里面提取资源值，但是本质上就是将 reg 属性值，然后将其转换为 resource 结构体类型 1int of_address_to_resource(struct device_node *dev, int index, struct resource *r) dev：设备节点。index：地址资源标号。r：得到的 resource 类型的资源值。返回值：0，成功；负值，失败。 5、of_iomap 函数of_iomap 函数用于直接内存映射，以前我们会通过 ioremap 函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过 of_iomap 函数来获取内存地址所对应的虚拟地址，不需要使用 ioremap 函数了。在采用设备树以后，大部分的驱动都使用 of_iomap 函数了。of_iomap 函数本质上也是将 reg 属性中地址信息转换为虚拟地址，如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段。 1void __iomem *of_iomap(struct device_node *np, int index) np：设备节点。index：reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为 0。返回值：经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。","link":"","tags":[]},{"title":"Linux驱动-字符设备驱动LED","date":"2021-04-14T06:49:01.000Z","path":"2021/04/14/Linux驱动-字符设备驱动LED/","text":"编写实验程序一、编写实验程序1、驱动设备程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240&#x2F;***************************************************************文件名 : newchrled.c描述 : LED驱动文件。***************************************************************&#x2F;#define NEWCHRLED_CNT 1 &#x2F;* 设备号个数 *&#x2F;#define NEWCHRLED_NAME &quot;newchrled&quot; &#x2F;* 名字 *&#x2F;#define LEDOFF 0 &#x2F;* 关灯 *&#x2F;#define LEDON 1 &#x2F;* 开灯 *&#x2F; &#x2F;* 寄存器物理地址 *&#x2F;#define CCM_CCGR1_BASE (0X020C406C) #define SW_MUX_GPIO1_IO03_BASE (0X020E0068)#define SW_PAD_GPIO1_IO03_BASE (0X020E02F4)#define GPIO1_DR_BASE (0X0209C000)#define GPIO1_GDIR_BASE (0X0209C004)&#x2F;* 映射后的寄存器虚拟地址指针 *&#x2F;static void __iomem *IMX6U_CCM_CCGR1;static void __iomem *SW_MUX_GPIO1_IO03;static void __iomem *SW_PAD_GPIO1_IO03;static void __iomem *GPIO1_DR;static void __iomem *GPIO1_GDIR;&#x2F;* newchrled设备结构体 *&#x2F;struct newchrled_dev&#123; dev_t devid; &#x2F;* 设备号 *&#x2F; struct cdev cdev; &#x2F;* cdev *&#x2F; struct class *class; &#x2F;* 类 *&#x2F; struct device *device; &#x2F;* 设备 *&#x2F; int major; &#x2F;* 主设备号 *&#x2F; int minor; &#x2F;* 次设备号 *&#x2F;&#125;;struct newchrled_dev newchrled; &#x2F;* led设备 *&#x2F;&#x2F;* * @description : LED打开&#x2F;关闭 * @param - sta : LEDON(0) 打开LED，LEDOFF(1) 关闭LED * @return : 无 *&#x2F;void led_switch(u8 sta)&#123; u32 val &#x3D; 0; if(sta &#x3D;&#x3D; LEDON) &#123; val &#x3D; readl(GPIO1_DR); val &amp;&#x3D; ~(1 &lt;&lt; 3); writel(val, GPIO1_DR); &#125;else if(sta &#x3D;&#x3D; LEDOFF) &#123; val &#x3D; readl(GPIO1_DR); val|&#x3D; (1 &lt;&lt; 3); writel(val, GPIO1_DR); &#125; &#125;&#x2F;* * @description : 打开设备 * @param - inode : 传递给驱动的inode * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量 * 一般在open的时候将private_data指向设备结构体。 * @return : 0 成功;其他 失败 *&#x2F;static int led_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data &#x3D; &amp;newchrled; &#x2F;* 设置私有数据 *&#x2F; return 0;&#125;&#x2F;* * @description : 从设备读取数据 * @param - filp : 要打开的设备文件(文件描述符) * @param - buf : 返回给用户空间的数据缓冲区 * @param - cnt : 要读取的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 读取的字节数，如果为负值，表示读取失败 *&#x2F;static ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)&#123; return 0;&#125;&#x2F;* * @description : 向设备写数据 * @param - filp : 设备文件，表示打开的文件描述符 * @param - buf : 要写给设备写入的数据 * @param - cnt : 要写入的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 写入的字节数，如果为负值，表示写入失败 *&#x2F;static ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)&#123; int retvalue; unsigned char databuf[1]; unsigned char ledstat; retvalue &#x3D; copy_from_user(databuf, buf, cnt); if(retvalue &lt; 0) &#123; printk(&quot;kernel write failed!\\r\\n&quot;); return -EFAULT; &#125; ledstat &#x3D; databuf[0]; &#x2F;* 获取状态值 *&#x2F; if(ledstat &#x3D;&#x3D; LEDON) &#123; led_switch(LEDON); &#x2F;* 打开LED灯 *&#x2F; &#125; else if(ledstat &#x3D;&#x3D; LEDOFF) &#123; led_switch(LEDOFF); &#x2F;* 关闭LED灯 *&#x2F; &#125; return 0;&#125;&#x2F;* * @description : 关闭&#x2F;释放设备 * @param - filp : 要关闭的设备文件(文件描述符) * @return : 0 成功;其他 失败 *&#x2F;static int led_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;&#x2F;* 设备操作函数 *&#x2F;static struct file_operations newchrled_fops &#x3D; &#123; .owner &#x3D; THIS_MODULE, .open &#x3D; led_open, .read &#x3D; led_read, .write &#x3D; led_write, .release &#x3D; led_release,&#125;;&#x2F;* * @description : 驱动出口函数 * @param : 无 * @return : 无 *&#x2F;static int __init led_init(void)&#123; u32 val &#x3D; 0; &#x2F;* 初始化LED *&#x2F; &#x2F;* 1、寄存器地址映射 *&#x2F; IMX6U_CCM_CCGR1 &#x3D; ioremap(CCM_CCGR1_BASE, 4); SW_MUX_GPIO1_IO03 &#x3D; ioremap(SW_MUX_GPIO1_IO03_BASE, 4); SW_PAD_GPIO1_IO03 &#x3D; ioremap(SW_PAD_GPIO1_IO03_BASE, 4); GPIO1_DR &#x3D; ioremap(GPIO1_DR_BASE, 4); GPIO1_GDIR &#x3D; ioremap(GPIO1_GDIR_BASE, 4); &#x2F;* 2、使能GPIO1时钟 *&#x2F; val &#x3D; readl(IMX6U_CCM_CCGR1); val &amp;&#x3D; ~(3 &lt;&lt; 26); &#x2F;* 清楚以前的设置 *&#x2F; val |&#x3D; (3 &lt;&lt; 26); &#x2F;* 设置新值 *&#x2F; writel(val, IMX6U_CCM_CCGR1); &#x2F;* 3、设置GPIO1_IO03的复用功能，将其复用为 * GPIO1_IO03，最后设置IO属性。 *&#x2F; writel(5, SW_MUX_GPIO1_IO03); &#x2F;*寄存器SW_PAD_GPIO1_IO03设置IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 00 默认下拉 *bit [13]: 0 kepper功能 *bit [12]: 1 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 110 R0&#x2F;6驱动能力 *bit [0]: 0 低转换率 *&#x2F; writel(0x10B0, SW_PAD_GPIO1_IO03); &#x2F;* 4、设置GPIO1_IO03为输出功能 *&#x2F; val &#x3D; readl(GPIO1_GDIR); val &amp;&#x3D; ~(1 &lt;&lt; 3); &#x2F;* 清除以前的设置 *&#x2F; val |&#x3D; (1 &lt;&lt; 3); &#x2F;* 设置为输出 *&#x2F; writel(val, GPIO1_GDIR); &#x2F;* 5、默认关闭LED *&#x2F; val &#x3D; readl(GPIO1_DR); val |&#x3D; (1 &lt;&lt; 3); writel(val, GPIO1_DR); &#x2F;* 注册字符设备驱动 *&#x2F; &#x2F;* 1、创建设备号 *&#x2F; if (newchrled.major) &#123; &#x2F;* 定义了设备号 *&#x2F; newchrled.devid &#x3D; MKDEV(newchrled.major, 0); register_chrdev_region(newchrled.devid, NEWCHRLED_CNT, NEWCHRLED_NAME); &#125; else &#123; &#x2F;* 没有定义设备号 *&#x2F; alloc_chrdev_region(&amp;newchrled.devid, 0, NEWCHRLED_CNT, NEWCHRLED_NAME); &#x2F;* 申请设备号 *&#x2F; newchrled.major &#x3D; MAJOR(newchrled.devid); &#x2F;* 获取分配号的主设备号 *&#x2F; newchrled.minor &#x3D; MINOR(newchrled.devid); &#x2F;* 获取分配号的次设备号 *&#x2F; &#125; printk(&quot;newcheled major&#x3D;%d,minor&#x3D;%d\\r\\n&quot;,newchrled.major, newchrled.minor); &#x2F;* 2、初始化cdev *&#x2F; newchrled.cdev.owner &#x3D; THIS_MODULE; cdev_init(&amp;newchrled.cdev, &amp;newchrled_fops); &#x2F;* 3、添加一个cdev *&#x2F; cdev_add(&amp;newchrled.cdev, newchrled.devid, NEWCHRLED_CNT); &#x2F;* 4、创建类 *&#x2F; newchrled.class &#x3D; class_create(THIS_MODULE, NEWCHRLED_NAME); if (IS_ERR(newchrled.class)) &#123; return PTR_ERR(newchrled.class); &#125; &#x2F;* 5、创建设备 *&#x2F; newchrled.device &#x3D; device_create(newchrled.class, NULL, newchrled.devid, NULL, NEWCHRLED_NAME); if (IS_ERR(newchrled.device)) &#123; return PTR_ERR(newchrled.device); &#125; return 0;&#125;&#x2F;* * @description : 驱动出口函数 * @param : 无 * @return : 无 *&#x2F;static void __exit led_exit(void)&#123; &#x2F;* 取消映射 *&#x2F; iounmap(IMX6U_CCM_CCGR1); iounmap(SW_MUX_GPIO1_IO03); iounmap(SW_PAD_GPIO1_IO03); iounmap(GPIO1_DR); iounmap(GPIO1_GDIR); &#x2F;* 注销字符设备驱动 *&#x2F; cdev_del(&amp;newchrled.cdev);&#x2F;* 删除cdev *&#x2F; unregister_chrdev_region(newchrled.devid, NEWCHRLED_CNT); &#x2F;* 注销设备号 *&#x2F; device_destroy(newchrled.class, newchrled.devid); class_destroy(newchrled.class);&#125;module_init(led_init);module_exit(led_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;zuozhongkai&quot;); led_switch 函数，用于控制开发板上的 LED 灯亮灭，当参数 sta 为 LEDON(0)的时候打开 LED 灯，sta 为 LEDOFF(1)的时候关闭 LED 灯。 chrdevbase_open 函数，当应用程序调用 open 函数的时候此函数就会调用， 一般在此函 数中将设备结构体作为参数 filp 的私有数据(filp-&gt;private_data)。 chrdevbase_read 函数，应用程序调用 read 函数从设备中读取数据的时候此函数会执行。。因为内核空间不能直接操作用户空间的内存，因此需要借助 copy_to_user 函数来完成内核空间的数据到用户空间的复制。参数 to 表示目的，参数 from 表示源，参数 n 表示要复制的数据长度。如果复制成功，返回值为 0，反之返回负数。 1static inline long copy_to_user(void __user *to, const void *from, unsigned long n) chrdevbase_write 函数，应用程序调用 write 函数向设备写数据的时候此函数 就会执行。函数 copy_from_user 将 buf 中的数据复制到写缓冲区 writebuf 中，因为用户空间内存不能直接访问内核空间的内存，所以需要 借助函数 copy_from_user 将用户空间的数据复制到 writebuf 这个内核空间中。 chrdevbase_release 函数，应用程序调用 close 关闭设备文件的时候此函数会执行，一般会在此函数里面执行一些释放操作。 设备文件操作结构体 led_fops 的定义和初始化。 驱动入口函数 led_init，此函数实现了 LED 的初始化工作，先通过ioremap 函数获取物理寄存器地址映射后的虚拟地址，得到寄存器对应的虚拟地址以后就可以完成相关初始化工作了。比如是能 GPIO1 时钟、设置 GPIO1_IO03 复用功能、配置 GPIO1_IO03 的属性等等。然后申请设备号、添加字符设备、创建类和设备。采用动态申请设备号的方法，使用 printk 在终端上显示出申请到的主设备号和次设备号。 在驱动出口函数 led_exit 中注销字符新设备、删除类和设备。 2、编写测试 APP 程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#x2F;***************************************************************文件名 : ledApp.c描述 : chrdevbase驱测试APP。使用方法 ：.&#x2F;ledtest &#x2F;dev&#x2F;led 0 关闭LED .&#x2F;ledtest &#x2F;dev&#x2F;led 1 打开LED ***************************************************************&#x2F;#define LEDOFF 0#define LEDON 1&#x2F;* * @description : main主程序 * @param - argc : argv数组元素个数 * @param - argv : 具体参数 * @return : 0 成功;其他 失败 *&#x2F;int main(int argc, char *argv[])&#123; int fd, retvalue; char *filename; unsigned char databuf[1]; if(argc !&#x3D; 3)&#123; printf(&quot;Error Usage!\\r\\n&quot;); return -1; &#125; filename &#x3D; argv[1]; &#x2F;* 打开led驱动 *&#x2F; fd &#x3D; open(filename, O_RDWR); if(fd &lt; 0)&#123; printf(&quot;file %s open failed!\\r\\n&quot;, argv[1]); return -1; &#125; databuf[0] &#x3D; atoi(argv[2]); &#x2F;* 要执行的操作：打开或关闭 *&#x2F; &#x2F;* 向&#x2F;dev&#x2F;led文件写入数据 *&#x2F; retvalue &#x3D; write(fd, databuf, sizeof(databuf)); if(retvalue &lt; 0)&#123; printf(&quot;LED Control Failed!\\r\\n&quot;); close(fd); return -1; &#125; retvalue &#x3D; close(fd); &#x2F;* 关闭文件 *&#x2F; if(retvalue &lt; 0)&#123; printf(&quot;file %s close failed!\\r\\n&quot;, argv[1]); return -1; &#125; return 0;&#125; 数组 usrdata 是测试 APP 要向 chrdevbase 设备写入的数据。 判断运行测试 APP 的时候输入的参数是不是为 3 个，main 函数的 argc 参数表示参数数量，argv[]保存着具体的参数，如果参数不为 3 个的话就表示测试 APP 用法错误。 1.&#x2F;chrdevbaseApp &#x2F;dev&#x2F;chrdevbase 1 上述命令一共有三个参数“./chrdevbaseApp”、“/dev/chrdevbase”和“1”，这三个参数分别对应 argv[0]、argv[1]和 argv[2]。第一个参数表示运行 chrdevbaseAPP 这个软件，第二个参数表示测试APP要打开/dev/chrdevbase这个设备。第三个参数就是要执行的操作，1表示从chrdevbase 中读取数据，2 表示向 chrdevbase 写数据。 第 40 行，获取要打开的设备文件名字，argv[1]保存着设备名字。 第 43 行，调用 C 库中的 open 函数打开设备文件：/dev/chrdevbase。 第 49 行，判断 argv[2]参数的值是 1 还是 2，因为输入命令的时候其参数都是字符串格式的，因此需要借助 atoi 函数将字符串格式的数字转换为真实的数字。 第 50 行，当 argv[2]为 1 的时候表示要从 chrdevbase 设备中读取数据，一共读取 50 字节的 数据，读取到的数据保存在 readbuf 中，读取成功以后就在终端上打印出读取到的数据。 第 59 行，当 argv[2]为 2 的时候表示要向 chrdevbase 设备写数据。 第 69 行，对 chrdevbase 设备操作完成以后就关闭设备。chrdevbaseApp.c 内容还是很简单的，就是最普通的文件打开、关闭和读写操作。 3、编译驱动程序Makefile**123456789101112KERNELDIR :&#x3D; &#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;IMX6ULL&#x2F;linux&#x2F;temp&#x2F;linux-imx-rel_imx_4.1.15_2.1.0_ga_alientekCURRENT_PATH :&#x3D; $(shell pwd)obj-m :&#x3D; led.obuild: kernel_moduleskernel_modules: $(MAKE) -C $(KERNELDIR) M&#x3D;$(CURRENT_PATH) modulesclean: $(MAKE) -C $(KERNELDIR) M&#x3D;$(CURRENT_PATH) clean 第 1 行，KERNELDIR 表示开发板所使用的 Linux 内核源码目录，使用绝对路径。 第 2 行，CURRENT_PATH 表示当前路径，直接通过运行“pwd”命令来获取当前所处路径。 第 3 行，obj-m 表示将 chrdevbase.c 这个文件编译为 chrdevbase.ko 模块。 第 8 行，具体的编译命令，后面的 modules 表示编译模块，-C 表示将当前的工作目录切 换到指定目录中，也就是 KERNERLDIR 目录。M 表示模块源码目录，“make modules”命令中加入 M=dir 以后程序会自动到指定的 dir 目录中读取模块的源码并将其编译为.ko 文件。 二、运行测试加载驱动模块 为了方便测试，Linux 系统选择通过 TFTP 从网络启动，并且使用 NFS 挂载网络根文件系统，确保 uboot 中 bootcmd 环境变量的值为： 1tftp 80800000 zImage;tftp 83000000 imx6ull-alientek-emmc.dtb;bootz 80800000 - 83000000 bootrags 环境变量的值为： 12console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;nfs rw nfsroot&#x3D;192.168.1.250:&#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;nfs&#x2F; rootfs ip&#x3D;192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0:off depmod 命令即可自动生成modules.dep，modprobe 命令加载 chrdevbase.ko 驱动文件，/proc/devices 文件可查看当前系统中的所有设备。 123depmodmodprobe chrdevbase.kocat &#x2F;proc&#x2F;devices &#x2F;&#x2F;查看设备 卸载驱动模块 如果不再使用某个设备的话可以将其驱动卸载掉，比如输入如下命令卸载掉 chrdevbase 这个设备： 1rmmod chrdevbase.ko","link":"","tags":[]},{"title":"Linux驱动-驱动开放简介","date":"2021-04-13T15:02:49.000Z","path":"2021/04/13/Linux驱动-驱动开发简介/","text":"一、裸机驱动开发回顾​ 1、底层，跟寄存器打交道，有些MCU提供了库。 二、Linux驱动开发思维​ 1、Linux下驱动开发直接操作寄存器不现实。​ 2、根据Linux下的各种驱动框架进行开发。一定要满足框架，也就是Linux下各种驱动框架的掌握。​ 3、驱动最终表现就是/dev/xxx文件。打开、关闭、读写、。。。​ 4、现在新的内核支持设备树，这个一个.dts文件，此文件 描述了板子的设备信息。 三、Linux驱动开发分类linux驱动分为三大类：1、字符设备驱动，最多的，从最简单的点灯到 I2C、SPI、音频等都属于字符设备驱动的类型。 2、块设备驱动。所谓的块设备驱动就是存储器设备的驱动，比如 EMMC、NAND、SD 卡和 U 盘等存储设备，因为这些存储设备的特点是以存储块为基础，因此叫做块设备。 3、网络设备驱动， 一个设备不说是一定只属于某一个类型。比如USB WIFI,SDIO WIFI，属于网络设备驱动，因为他又有USB和SDIO，因此也属于字符设备驱动。 块设备和网络设备驱动要比字符设备驱动复杂，就是因为其复杂所以半导体厂商一般都给我们编写好了，大多数情况下都是直接可以使 用的。 四、应用程序和驱动的交互原理驱动就是获取外设、或者传感器数据，控制外设。数据会提交给应用程序。Linux驱动编译既要编写一个驱动，还要我们编写一个简单的测试应用程序APP。单片机下驱动和应用都是放到一个文件里面，也就是杂糅到一起。Linux下驱动和应用是完全分开的。 在 Linux 中一切皆为文件，驱动加载成功以后会在“/dev”目录下生成一个相应的文件，应用程序通过对这个名为“/dev/xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。 用户空间(用户态)和内核空间(内核态)：Linux操作系统内核和驱动程序运行在内核空间、应用程序运行在用户空间。应用程序想要访问内核资源，怎么办，有三种方法：系统调用、异常(中断)和陷入。 应用程序不会直接调用系统调用，而是通过API函数来间接的调用系统调用，比如POSIX、API和C库等。unix类操作系统中最常用的编程接口就是POSIX。 应用程序使用open函数打开一个设备文件。 每个系统调用都有一个系统调用号。系统调用处于内核空间，应用程序无法直接访问，因此需要“陷入“到内核，方法就是软中断。陷入内核以后还要指定系统调用号。 ​ 编写驱动的时候也需要编写驱动对应的open、close，write函数。字符设备驱动fileoptions_struct.驱动是分驱动框架的，要按照驱动框架来编写，对于字符设备驱动来说，重点编写应用程序对应的open、close、read、write等函数。驱动最终是被应用调用的，在写驱动的时候要考虑应用开发的便利性。 五、C 库文件操作基本函数编写测试 APP 就是编写 Linux 应用，需要用到 C 库里面和文件操作有关的一些函数，比如open、read、write 和 close 这四个函数。 在 Ubuntu 中输入“man 2 open”即可查看 open 函数的详细内容， ①、open 函数 1int open(const char *pathname, int flags) pathname：要打开的设备或者文件名。 flags：文件打开模式，以下三种模式必选其一： O_RDONLY (只读模式 )、O_WRONLY (只写模式)、O_RDWR (读写模式)，其他的可选模式，通过逻辑或来选择多种模式：O_NONBLOCK （如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继 I/O 设置为非阻塞 ） 返回值：如果文件打开成功的话返回文件的文件描述符。 ④、close函数 1int close(int fd); fd：要关闭的文件描述符。 返回值：0 表示关闭成功，负值表示关闭失败。 ②、read 函数 1ssize_t read(int fd, void *buf, size_t count) fd：要读取的文件描述符，读取文件之前要先用 open 函数打开文件，open 函数打开文件成功以后会得到文件描述符。 buf：数据读取到此 buf 中。 count：要读取的数据长度，也就是字节数。 返回值：读取成功的话返回读取到的字节数；如果返回 0 表示读取到了文件末尾；如果返回负值，表示读取失败。 ③、write函数 1ssize_t write(int fd, const void *buf, size_t count); fd：要进行写操作的文件描述符，写文件之前要先用 open 函数打开文件，open 函数打开文件成功以后会得到文件描述符。 buf：要写入的数据。 count：要写入的数据长度，也就是字节数。 返回值：写入成功的话返回写入的字节数；如果返回 0 表示没有写入任何数据；如果返回 负值，表示写入失败。","link":"","tags":[]},{"title":"Linux驱动-字符设备驱动框架","date":"2021-04-13T15:00:15.000Z","path":"2021/04/13/Linux驱动-字符设备驱动框架/","text":"字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。最常见的点灯、按键、IIC、SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。 一、字符设备驱动开发步骤1、驱动模块的加载和卸载Linux 驱动有两种运行方式，第一种就是将驱动编译进 Linux 内核中，当 Linux 内核启动的时候就会自动运行驱动程序。第二种就是将驱动编译成模块(Linux 下模块扩展名为.ko)，在Linux 内核启动以后使用“modprobe”命令加载驱动模块。在调试驱动的时候一般都选择将其编译为模块，修改驱动以后只需要编译一下驱动代码即可，不需要编译整个 Linux 代码。而且在调试的时候只需要加载或者卸载驱动模块即可，不需要重启整个系统。 模块的加载和卸载注册函数如下： 12module_init(xxx_init); &#x2F;&#x2F;注册模块加载函数 module_exit(xxx_exit); &#x2F;&#x2F;注册模块卸载函数 module_init 函数用来向 Linux 内核注册一个模块加载函数，参数 xxx_init 就是需要注册的具体函数，当使用“modprobe”命令加载驱动的时候，xxx_init 这个函数就会被调用。module_exit() 函数用来向 Linux 内核注册一个模块卸载函数，参数 xxx_exit 就是需要注册的具体函数，当使用“rmmod”命令卸载具体驱动的时候 xxx_exit 函数就会被调用。 驱动编译完成以后扩展名为.ko，modprobe 会分析模块的依赖关系，然后会将所有的依赖模块都加载到内核中，推荐使用 modprobe 命令来加载驱动。驱动模块的卸载使用命令“rmmod”. 2、申请Linux 设备号Linux 中每个设备都有一个设备号，设备号由主设备号和次设备号两部分组成，主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备。Linux 提供了一个名为 dev_t 的数据类型表示设备号。 动态分配设备号 Linux 社区推荐使用动态分配设备号，在注册字符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号 1、如果没有指定设备号的话就使用如下函数来申请设备号： 1int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) dev：保存申请到的设备号。 baseminor：次设备号起始地址，alloc_chrdev_region 可以申请一段连续的多个设备号，这 些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递增。一般 baseminor 为 0，也就是说次设备号从 0 开始。 count：要申请的设备号数量。 name：设备名字。 2、如果给定了设备的主设备号和次设备号就使用如下所示函数来注册设备号即可： 1int register_chrdev_region(dev_t from, unsigned count, const char *name) 参数 from 是要申请的起始设备号，也就是给定的设备号；参数 count 是要申请的数量，一般都是一个；参数 name 是设备名字。 3、注销字符设备之后要释放掉设备号，不管是通过alloc_chrdev_region函数还是 register_chrdev_region 函数申请的设备号，统一使用如下释放函数： 1void unregister_chrdev_region(dev_t from, unsigned count) 此函数有两个参数： from：要释放的设备号。 count：表示从 from 开始，要释放的设备号数量。 3、新字符设备注册与注销对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模块的时候也需要注销掉字符设备。 1、字符设备结构 在 Linux 中使用 cdev 结构体表示一个字符设备， 12345678struct cdev &#123; struct kobject kobj; struct module *owner; const struct file_operations *ops; struct list_head list; dev_t dev; unsigned int count; &#125;; 有两个重要的成员变量：ops 和 dev，这两个就是字符设备文件操作函数集合file_operations 以及设备号 dev_t。 2、cdev_init 函数定义好 cdev 变量以后就要使用 cdev_init 函数对其进行初始化，cdev_init 函数原型如下： 1void cdev_init(struct cdev *cdev, const struct file_operations *fops) 参数 cdev 就是要初始化的 cdev 结构体变量，参数 fops 就是字符设备文件操作函数集合。 3、cdev_add 函数cdev_add 函数用于向 Linux 系统添加字符设备(cdev 结构体变量)，首先使用 cdev_init 函数完成对 cdev 结构体变量的初始化，然后使用 cdev_add 函数向 Linux 系统添加这个字符设备。 1int cdev_add(struct cdev *p, dev_t dev, unsigned count) 参数 p 指向要添加的字符设备(cdev 结构体变量)，参数 dev 就是设备所使用的设备号，参数 count 是要添加的设备数量。 4、cdev_del 函数卸载驱动的时候一定要使用 cdev_del 函数从 Linux 内核中删除相应的字符设备 1void cdev_del(struct cdev *p) 参数 p 就是要删除的字符设备。 示例 12345678910struct cdev testcdev; &#x2F;* 设备操作函数 *&#x2F;static struct file_operations test_fops &#x3D; &#123; .owner &#x3D; THIS_MODULE, &#125;;testcdev.owner &#x3D; THIS_MODULE;cdev_init(&amp;testcdev, &amp;test_fops); &#x2F;* 初始化 cdev 结构体变量 *&#x2F;cdev_add(&amp;testcdev, devid, 1); &#x2F;* 添加字符设备 *&#x2F;cdev_del(&amp;testcdev); &#x2F;* 删除 cdev *&#x2F; 4、自动创建设备节点驱动加载成功需要在/dev 目录下创建一个与之对应的设备节点文件，应用程序就是通过操作这个设备节点文件来完成对具体设备的操作。/dev/chrdevbase 这个文件相当于chrdevbase 设备在用户空间中的实现。 在驱动中实现自动创建设备节点的功能以后，使用 modprobe 加载驱动模块成功的话就会自动在/dev 目录下创建对应的设备文件。 mdev 机制 udev 是一个用户程序，在 Linux 下通过 udev 来实现设备文件的创建与删除，udev 可以检 测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。比如使用modprobe 命令成功加载驱动模块以后就自动在/dev 目录下创建对应的设备节点文件,使用rmmod 命令卸载驱动模块以后就删除掉/dev 目录下的设备节点文件。使用 busybox 构建根文件系统的时候，busybox会创建一个 udev 的简化版本—mdev，所以在嵌入式 Linux 中我们使用mdev 来实现设备节点文件的自动创建与删除，Linux 系统中的热插拔事件也由 mdev 管理。 下面通过 mdev 来实现设备文件节点的自动创建与删除 1.创建和删除类 自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在 cdev_add 函数后面添加自动创建设备节点相关代码。首先要创建一个 class 类，class 是个结构体，class_create 是类创建函数。 1struct class *class_create (struct module *owner, const char *name) 参数 owner一般为 THIS_MODULE，参数name是类名字。返回值是个指向结构体 class 的指针，就是创建的类。 卸载驱动程序的时候需要删除掉类，类删除函数为 class_destroy，函数原型如下： 1void class_destroy(struct class *cls); 参数 cls 就是要删除的类。 2.创建和删除设备 创建好类以后还不能实现自动创建设备节点，还需要在这个类下创建一个设备。使用 device_create 函数在类下面创建设备，device_create 函数原型如下： 12struct device *device_create(struct class *class, struct device *parent,dev_t devt, void *drvdata, const char *fmt, ...) device_create 是个可变参数函数，参数 class 就是设备要创建哪个类下面；参数 parent 是父设备，一般为 NULL，也就是没有父设备；参数 devt 是设备号；参数 drvdata 是设备可能会使用的一些数据，一般为 NULL；参数 fmt 是设备名字，如果设置 fmt=xxx 的话，就会生成/dev/xxx这个设备文件。返回值就是创建好的设备。 同样的，卸载驱动的时候需要删除掉创建的设备，设备删除函数为 device_destroy， 1void device_destroy(struct class *class, dev_t devt) 参数 classs 是要删除的设备所处的类，参数 devt 是要删除的设备号。 5、设置文件私有数据每个硬件设备都有一些属性，比如主设备号(dev_t)，类(class)、设备(device)、开关状态(state) 等等，对于一个设备的所有属性信息将其做成一个结构体。编写驱动 open 函数的时候将设备结构体作为私有数据添加到设备文件中。 12345678910111213141516struct test_dev&#123; dev_t devid; &#x2F;* 设备号 *&#x2F; struct cdev cdev; &#x2F;* cdev *&#x2F; struct class *class; &#x2F;* 类 *&#x2F; struct device *device; &#x2F;* 设备 *&#x2F; int major; &#x2F;* 主设备号 *&#x2F; int minor; &#x2F;* 次设备号 *&#x2F;&#125;;struct test_dev testdev;&#x2F;* open 函数 *&#x2F;static int test_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data &#x3D; &amp;testdev; &#x2F;* 设置私有数据 *&#x2F; return 0;&#125; 在 open 函数里面设置好私有数据以后，在 write、read、close 等函数中直接读取 private_data即可得到设备结构体。 6、实现设备的具体操作函数file_operations 结构体就是设备的具体操作函数，在初始化 file_operations 之前我们要分析一下需求，也就是要对设备进行哪些操作，只有确定了需求以后才知道应该实现哪些操作函数。 设备打开和关闭是最基本的要求，几乎所有的设备都得提供打开和关闭的功能。因此需要实现 file_operations 中的 open 和 release 这两个函数。如果应用程序需要通过 read 和 write 这两个函数进行读写操作。所以需要实现 file_operations 中的 read 和 write 这两个函数。 7、添加 LICENSE 和作者信息最后需要在驱动中加入 LICENSE 信息和作者信息，其中 LICENSE 是必须添加的，否则的话编译的时候会报错，作者信息可以添加也可以不添加。LICENSE 和作者信息的添加使用如下两个函数： 12MODULE_LICENSE() &#x2F;&#x2F;添加模块 LICENSE 信息 MODULE_AUTHOR() &#x2F;&#x2F;添加模块作者信息 二、地址映射MMU 全称叫做 Memory Manage Unit，也就是内存管理单元。MMU 主要完成的功能如下： ①、完成虚拟空间到物理空间的映射。 ②、内存保护，设置存储器的访问权限，设置虚拟存储空间的缓冲特性。 虚拟空间到物理空间的映射，也叫做地址映射。虚拟地址(VA,Virtual Address)、物理地址(PA，PhyscicalAddress)。对于 32 位的处理器来说，虚拟地址范围是 2^32=4GB，我们的开发板上有 512MB 的 DDR3，这 512MB 的内存就是物理内存，经过 MMU 可以将其映射到整个 4GB 的虚拟空间，物理内存只有 512MB，虚拟内存有 4GB，那么肯定存在多个虚拟地址映射到同一个物理地址上去。Linux 内核启动的时候会初始化 MMU，设置好内存映射，设置好以后 CPU 访问的都是虚拟地 址。 物理内存和虚拟内存之间的转换，需要用到两个函数：ioremap 和 iounmap。 1、ioremap 函数 ioremap 函 数 用 于 获 取 指 定 物 理 地 址 空 间 对 应 的 虚 拟 地 址 空 间 ， 12345#define ioremap(cookie,size) __arm_ioremap((cookie), (size), MT_DEVICE)void __iomem * __arm_ioremap(phys_addr_t phys_addr, size_t size, unsigned int mtype)&#123; return arch_ioremap_caller(phys_addr, size, mtype,__builtin_return_address(0));&#125; ioremap 是个宏，有两个参数：cookie 和 size，真正起作用的是函数__arm_ioremap，此函数有三个参数和一个返回值。 phys_addr：要映射给的物理起始地址。 size：要映射的内存空间大小。 对于 I.MX6ULL 来说一个寄存器是 4 字节(32 位)的，因此映射的内存长度为 4。 mtype：ioremap 的类型，可以选择 MT_DEVICE、MT_DEVICE_NONSHARED、 MT_DEVICE_CACHED 和 MT_DEVICE_WC，ioremap 函数选择 MT_DEVICE。 返回值：__iomem 类型的指针，指向映射后的虚拟空间首地址。 2、iounmap 函数 卸载驱动的时候需要使用 iounmap 函数释放掉 ioremap 函数所做的映射，iounmap 只有一个参数 addr，此参数就是要取消映射的虚拟地址空间首地址。 1void iounmap (volatile void __iomem *addr) 三、I/O 内存访问函数I/O 是输入/输出的意思，并不是单片机的 GPIO 引脚。当外部寄存器或内存映射到 IO 空间时，称为 I/O 端口。 当外部寄存器或内存映射到内存空间时，称为 I/O 内存。对于 ARM 来说没有 I/O 空间这个概念，因此 ARM 体系下只有 I/O 内存(可以直接理解为内存)。 使用 ioremap 函数将寄存器的物理地址映射到虚拟地址以后，使用一组操作函数来对映射后的内存进行读写操作。 1、读操作函数 123u8 readb(const volatile void __iomem *addr)u16 readw(const volatile void __iomem *addr) u32 readl(const volatile void __iomem *addr) readb、readw 和 readl 这三个函数分别对应 8bit、16bit 和 32bit 读操作，参数 addr 就是要读取写内存地址，返回值就是读取到的数据。 2、写操作函数 123void writeb(u8 value, volatile void __iomem *addr) void writew(u16 value, volatile void __iomem *addr) void writel(u32 value, volatile void __iomem *addr) writeb、writew 和 writel 这三个函数分别对应 8bit、16bit 和 32bit 写操作，参数 value 是要写入的数值，addr 是要写入的地址。","link":"","tags":[]},{"title":"Linux移植-内核MfgTool烧写","date":"2021-04-13T11:21:56.000Z","path":"2021/04/13/Linux移植-内核MfgTool烧写/","text":"前面移植好了 uboot 、 linux kernle、根文件系统。都是通过网络来测试的。在实际的产品开发中肯定不可能通过网络来运行，因此我们需要将 uboot、linux kernel、.dtb(设备树)和 rootfs 这四个文件烧写到板子上的 EMMC、NAND 或 QSPI Flash 等其他存储设备上，这样不管有没有网络我们的产品都可以正常运行。以下为如何使用 NXP 官方提供的 MfgTool 工具通过 USB OTG 口来烧写系统。 一、MfgTool工具简介mfgtool是NXP官方做的向I.MX系列烧写系统的软件，运行在windows下。可以烧写uboot.imx、zImage、dtb，rootfs。通过USB烧写。Mfgtool里面默认存放了NXP官方开发板的系统文件。 基本原理 MfgTool 其实是先通过 USB OTG 先将 uboot、kernel 和.dtb(设备树)这是三个文件下载到开发板的 DDR 中，注意不需要下载 rootfs。就相当于直接在开发板的 DDR上启动 Linux 系统，等 Linux 系统启动以后再向 EMMC 中烧写完整的系统，包括 uboot、linuxkernel、.dtb(设备树)和 rootfs，因此 MfgTool 工作过程主要分两个阶段： ①、将 firmware 目录中的 uboot、linux kernel 和.dtb(设备树)，然后通过 USB OTG 将这个文件下载到开发板的 DDR 中，目的就是在 DDR 中启动 Linux 系统，为后面的烧写做准备。 ②、经过第①步的操作，此时 Linux 系统已经运行起来了，系统运行起来以后就可以很方 便的完成对 EMMC 的格式化、分区等操作。EMMC 分区建立好以后就可以从 files 中读取要烧写的 uboot、linux kernel、.dtb(设备树)和 rootfs 这 4 个文件，然后将其烧写到 EMMC 中。 mfgtools-with-rootfs\\mfgtools\\Profiles\\Linux\\OS Firmware下有：files和firmware两个文件夹。 Firmware里面保存着第一步的uboot.imx、zImage、dtb。 files里面保存着最终烧写到开发板中的uboo.imx、zImage、dtb以及rootfs。 烧写脚本就是各种.vbs文件在L4.1.15_2.0.0-ga_mfg-tools\\mfgtools-with-rootfs\\mfgtools下有很多.vbs文件。.vbs脚本其实本质上是打开mfgtool2.exe，然后跟一堆的参数，linux，eMMc，board=sabresd、mmc=1、6uluboot=14x14evk、6uldtb=14x14-evk。 ucl2.xml文件 路径L4.1.15_2.0.0-ga_mfg-tools\\mfgtools-with-rootfs\\mfgtools\\Profiles\\Linux\\OS Firmware。ucl2.xml文件负责在files和firmware里面挑选合适的文件。 如果是MX6ULL的话，根据：%lite% = l ，%6uluboot% = 14x14evk uboot就是：firmware/u-boot-imx6ul%lite%%6uluboot%_sd.imx展开以后就是firmware/u-boot-imx6ull14x14evk_sd.imxfirmware/zImage-imx6ul%lite%-%6ulldtb%%ldo%.dtb展开以后就是firmware/zImage-imx6ull-14x14-evk.dtb。 二、烧写自己的系统烧写自己的系统。1、firmare下的文件名 u-boot-imx6ull14x14evk_emmc.imx uboot zImage kernel zImage-imx6ull-14x14-evk-emmc.dtb dtb 2、files下的文件名 u-boot-imx6ull14x14evk_emmc.imx ubootzImage kernelzImage-imx6ull-14x14-evk -emmc.dtb dtbrootfs_nogpu.tar.bz2 rootfs 三、改造自己的烧写工具1、确定自己的系统文件命名 2、创建自己的.vbs 3、改造ucl2.xml文件 4、启动测试经过测试，uboot可以运行，但是Linux内核没启动。 可以看出，uboot读取的dtb文件名为imx6ull-14x14-evk.dtb。实际的dtb文件名为：Imx6ull-alientek-emmc.dtb。所以要修改bootcmd命令。内容如下： 12setenv bootcmd &#39;mmc dev 1;fatload mmc 1:1 80800000 zImage;fatload mmc 1:1 83000000imx6ull-alientek-emmc.dtb;bootz 80800000 - 83000000&#39; 设置好以后可以启动系统，但是根文件系统加载错误，原因是bootargs设置错误，重新设置bootargs: 1setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;mmcblk1p2 rootwait rw&#39;","link":"","tags":[]},{"title":"Linux移植-内核根文件系统","date":"2021-04-13T09:28:41.000Z","path":"2021/04/13/Linux移植-内核根文件系统/","text":"一、根文件系统简介根文件系统也叫做rootfs。学习STM32的W25Q256、SD卡的时候接触过FATFS文件系统。Rootfs？=FATFS。不等于！ FATFS这类的文件系统属于Linux内核的一部分，属于软件代码。ROOTFS根文件系统=“根”、“文件”、“系统”。根文件系统就是一堆的文件、比如软件、配置文件等，这些文件是Linux运行所必须的，将他们组合在一起就构成了跟文件系统。根文件系统就是一个“文件夹”，此“文件夹”有很多个文件，这些文件是linux运行所必须的，但是无法放到内核里面去的。比如命令、库、配置文件等等。所有这些软件需要我们自己构建。/就是Linux根文件系统。 根文件系统首先是内核启动时所 mount(挂载)的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。 二、BusyBox构建根文件系统构建根文件系统，busybox。BusyBox 就是一个大的工具箱，这个工具箱里面集成了 Linux 的许多工具和命令。还有很多成熟化的根文件系统构建方式，buildroot，yocto。构建的根文件系统通过nfs网络挂载，也就是根文件系统存放到ubuntu下，开发板启动以后通过nfs服务使用ubuntu下的根文件系统。1、修改makefile，添加交叉编译器 修改ARCH和CROSS_COMPILE。 2、busybox支持中文字符 3、配置busyboxmake defconfig。make menuconfig打开图形化配置界面 4、编译busybox 编译完成以后，在 busybox 生成 bin、sbin 和 usr 这三个目录，以及 linuxrc 这个文件。Linux 内核 init 进程最后会查找用户空间的 init 程序，找到以后就会运行这个用户空间的 init 程序，从而切换到用户态。如果 bootargs 设置 init=/linuxrc，那么 linuxrc 就是可以作为用户空间的 init 程序，所以用户态空间的 init 程序是 busybox 来生成的。 5、拷贝库文件。 交叉编译器里面有很多的库文件，把其库文件都放到我们的根文件系统中。先是rootfs/lib目录，然后是rootfs/usr/lib目录。 6、创建其他文件夹 三、根文件系统初步测试为了方便测试，我们采用nfs网络挂载根文件系统。uboot 里面的 bootargs 环境变量会设置“root”（根文件）的值，所以我们将 root 的值改为NFS 挂载即可。 12root&#x3D;&#x2F;dev&#x2F;nfs nfsroot&#x3D;192.168.1.250:&#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;nfs&#x2F;rootfs,proto&#x3D;tcp rwip&#x3D;192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0:off “proto=tcp”表示使用 TCP 协议，“rw”表示 nfs 挂载的根文件系统为可读可写。 12setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;nfs nfsroot&#x3D;192.168.1.250: &#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;nfs&#x2F;rootfs,proto&#x3D;tcp rw ip&#x3D;192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0:off&#39;&#x2F;&#x2F;重新设置 bootargs 环境变量 要求： 1、linux内核网络驱动要工作正常。 2、设置uboot的bootargs，也就是linux内核的命令行参数。 从ubuntu的tftpboot里面加载我们前面移植的uboot、zImage和dtb，设置bootcmd。 测试的时候发现： 也就是提示文件系统为只读，这是因为booargs参数没设置全。 四、完善根文件系统创建/etc/init.d/rcS 文件 创建/etc/fstab 文件 创建/etc/inittab 文件","link":"","tags":[]},{"title":"Linux移植-内核移植","date":"2021-04-13T09:02:30.000Z","path":"2021/04/13/Linux移植-内核移植/","text":"一、NXP官方开发板Linux内核编译编译NXP官方EVK开发板对应的Linux系统，默认配置文件存放路径arch/arm/configs。最终编译出：zImage，和 imx6ull-14x14-evk-emmc.dtb，imx6ull-14x14-evk.dtb。 将zImage和 imx6ull-14x14-evk-emmc.dtb拷贝到tftpboot目录下，然后在uboot中通过tftp服务启动。 二、使能8线EMMCLinux 内核驱动里面 EMMC 默认是 4 线模式的，4 线模式肯定没有 8 线模式的速度快，所以将 EMMC 的驱动修改为 8 线模式。修改设备树，imx6ull-alientek-emmc.dts。节点usdhc2。 123456789&amp;usdhc2 &#123; pinctrl-names &#x3D; &quot;default&quot;, &quot;state_100mhz&quot;, &quot;state_200mhz&quot;; pinctrl-0 &#x3D; &lt;&amp;pinctrl_usdhc2_8bit&gt;; pinctrl-1 &#x3D; &lt;&amp;pinctrl_usdhc2_8bit_100mhz&gt;; pinctrl-2 &#x3D; &lt;&amp;pinctrl_usdhc2_8bit_200mhz&gt;; bus-width &#x3D; &lt;8&gt;; non-removable; status &#x3D; &quot;okay&quot;;&#125;; 三、网络驱动修改为何要一开始就修改网络驱动？？在做Linux驱动开发的时候一般都是通过网络调试的。修改网络复位IO和PHY ID以后，Linux内核内部通用PHY驱动已经正常工作。 LAN8720的生产厂家是SMSC。使能SMSC驱动，然后重新编译Linux内核，并启动，tftp启动。 四、在Linux中添加自己的开发板​ 2、一个就是imx6_alientek_emmc_defconfig默认配置文件。​ 3、imx6ull-alientek-emmc.dts编译出来就是.dtb文件。 复制arch/arm/configs/imx_v7_mfg_defconfig文件为imx_alientek_emmc_defconfig。 复制arch/arm/boot/dts/imx6ull-14x14-evk.dts文件为imx6ull-alientek-emmc.dts 修改arch/arm/boot/dts/Makefile， 四、CPU主频和网络驱动修改1、修改驱动之前，要先保证板子能够正常启动。2、根文件系统处理好，使用现成根文件系统。保证EMMC烧写了系统，设置bootcmd和bootargs。Bootcmd设置默认从网络启动，通过TFTP。Setenv bootcmd ‘tftp 80800000 zImage;tftp 83000000 imx6ull-alientek-emmc.dtb;bootz 80800000 - 83000000;’ Bootargs设置，根文件系统存放在EMMC的分区2里面，root=/dev/mmcblk1p2命令如下： Setenv bootargs ‘console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw’ 现在的问题就是EMMC驱动有问题，在imx6ull-alientek-emmc.dts中找到usdhc2节点。将usdhc2改为： 123456789&amp;usdhc2 &#123; pinctrl-names &#x3D; &quot;default&quot;, &quot;state_100mhz&quot;, &quot;state_200mhz&quot;; pinctrl-0 &#x3D; &lt;&amp;pinctrl_usdhc2_8bit&gt;; pinctrl-1 &#x3D; &lt;&amp;pinctrl_usdhc2_8bit_100mhz&gt;; pinctrl-2 &#x3D; &lt;&amp;pinctrl_usdhc2_8bit_200mhz&gt;; bus-width &#x3D; &lt;8&gt;; non-removable; status &#x3D; &quot;okay&quot;;&#125;; 完了以后编译设备树。使用如下命令： 1Make dtbs。 1、配置主频超频到696MHz，NXP官方宣传为700MHz。打开imx6ull.dtsi文件，","link":"","tags":[]},{"title":"Linux移植-内核启动流程","date":"2021-04-13T07:51:53.000Z","path":"2021/04/13/Linux移植-内核启动流程/","text":"一、vmlinux.lds简介从arch/arm/kernel/vmlinux.lds分析Linux内核第一行启动代码。找到ENTRY(stext) 入口函数是stext，image和zImage是经过压缩的，Linux内核会先进行解压缩，解压缩完成以后就要运行Linux内核。要求：​ 1、MMU关闭​ 2、D cache关闭​ 3、I cache无所谓​ 4、r0 = 0。​ 5、r1 = machine nr​ 6、r2=atags 或设备树 二、Linux入口stext​ __vet_atags 函数验证atags或dtb是否有效，如果使用设备树的话就是dtb。 __create_page_tables 创建页表。​ ldr r13, =__mmap_switched 也就是r13保存__mmap_switched。​ __enable_mmu 使能MMU​ -&gt; __turn_mmu_on​ -&gt;_mmap_switched​ -&gt;start_kernel 启动内核。​ Linux内核第一阶段。 三、__mmap_switched函数四、start_kernel函数​ Linux内核第二阶段​ start_kernel​ -&gt; rest_init​ -&gt; kernel_thread(kernel_init, NULL, CLONE_FS); 创建kernel_init进程。也就是init进程，PID=1​ -&gt; kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES); 创建kthreadd进程，进程PID为2。​ -&gt; cpu_startup_entry 进入空闲进程，也就是主进程退化为空闲进程，idle。 启动开发板，输入：ps -A，列出当前系统所有进程。 五、reset_init函数​ 六、init进程​ kernel_init​ -&gt; kernel_init_freeable​ -&gt; 设置标准输入、标准输出、标准错误使用console，比如ttymxc0​ -&gt; ramdisk_execute_command = “/init”; ​ -&gt; 检查/init是否存在，存在的话就运行。​ -&gt; uboot传递给Linux内核的bootargs可以自定init=xxx，或者叫命令行参数。 有一些开发板会设置init=linuxrc。 -&gt; 试着运行/sbin/init。 -&gt; /etc/init -&gt; /bin/init -&gt; /bin/sh 可以看出，最终引出根文件系统。 ​","link":"","tags":[]},{"title":"Linux移植-内核Makefile详解","date":"2021-04-13T07:31:04.000Z","path":"2021/04/13/Linux移植-内核Makefile详解/","text":"一、Linux顶层Makefile基本流程​ hdr-arch = arm 二、make xxx_defconfig过程​ %config: scripts_basic outputmakefile FORCE ​ $(Q)$(MAKE) $(build)=scripts/kconfig $@ scripts_basic: ​ $(Q)$(MAKE) $(build)=scripts/basic include scripts/Kbuild.include build := -f $(srctree)/scripts/Makefile.build obj $(Q)$(MAKE) $(build)=scripts/basic $(Q)$(MAKE) $(build)=scripts/kconfig $@ make -f ./scripts/Makefile.build obj= scripts/basic -&gt;生成fixdep和bin2c make -f ./scripts/Makefile.build obj=scripts/kconfig xxx_defconfig -&gt; scripts/kconfig/conf –defconfig=arch/arm/configs/%_defconfig Kconfig -&gt;.config 三、make过程​ 通过make或make all来编译Linux内核。默认目标： _all: _all: all all: vmlinux vmlinux: scripts/link-vmlinux.sh $(vmlinux-deps) FORCE ifdef CONFIG_HEADERS_CHECK ​ $(Q)$(MAKE) -f $(srctree)/Makefile headers_check endif ifdef CONFIG_SAMPLES ​ $(Q)$(MAKE) $(build)=samples endif ifdef CONFIG_BUILD_DOCSRC ​ $(Q)$(MAKE) $(build)=Documentation endif ifdef CONFIG_GDB_SCRIPTS ​ $(Q)ln -fsn cd $(srctree) &amp;&amp; /bin/pwd/scripts/gdb/vmlinux-gdb.py endif ​ +$(call if_changed,link-vmlinux) vmlinux-deps := $(KBUILD_LDS) $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN) KBUILD_LDS := arch/$(SRCARCH)/kernel/vmlinux.lds 展开就是： KBUILD_LDS := arch/arm/kernel/vmlinux.lds 连接脚本 KBUILD_VMLINUX_INIT := $(head-y) $(init-y) export KBUILD_VMLINUX_MAIN := $(core-y) $(libs-y) $(drivers-y) $(net-y) head-y := arch/arm/kernel/head.o init-y := init/ init-y := $(patsubst %/, %/built-in.o, $(init-y)) init-y= init/built-in.o drivers-y := drivers/ sound/ firmware/ net-y := net/ drivers-y := $(patsubst %/, %/built-in.o, $(drivers-y)) net-y := $(patsubst %/, %/built-in.o, $(net-y)) drivers-y= drivers/built-in.o sound/built-in.o firmware/built-in.o net-y = net/built-in.o libs-y := lib/ libs-y := arch/arm/lib/ $(libs-y) libs-y := arch/arm/lib lib/ libs-y1 := $(patsubst %/, %/lib.a, $(libs-y)) libs-y2 := $(patsubst %/, %/built-in.o, $(libs-y)) libs-y := $(libs-y1) $(libs-y2) libs-y := lib/lib.a arch/arm/lib/lib.a lib/built-in.o arch/arm/lib/built-in.o ​ 所有的.o和.a库文件准备好以后，就可以连接生成vmlinux。命令为： +$(call if_changed,link-vmlinux)此命令最终展开为： cmd_link-vmlinux = /bin/bash scripts/link-vmlinux.sh arm-linux-gnueabihf-ld -EL -p –noundefined -X –pic-veneer –build-id 四、built-in.o文件编译生成过程vmlinux-deps = arch/arm/kernel/vmlinux.lds arch/arm/kernel/head.o init/built-in.o usr/built-in.o arch/arm/vfp/built-in.o arch/arm/vdso/built-in.o arch/arm/kernel/built-in.o arch/arm/mm/built-in.o arch/arm/common/built-in.o arch/arm/probes/built-in.o arch/arm/net/built-in.o arch/arm/crypto/built-in.o arch/arm/firmware/built-in.o arch/arm/mach-imx/built-in.o kernel/built-in.o mm/built-in.o fs/built-in.o ipc/built-in.o security/built-in.o crypto/built-in.o block/built-in.o arch/arm/lib/lib.a lib/lib.a arch/arm/lib/built-in.o lib/built-in.o drivers/built-in.o sound/built-in.o firmware/built-in.o net/built-in.o vmlinux-dirs := $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \\ ​ $(core-y) $(core-m) $(drivers-y) $(drivers-m) \\ ​ $(net-y) $(net-m) $(libs-y) $(libs-m))) vmlinux-dirs = init usr arch/arm/vfp arch/arm/vdso arch/arm/kernel arch/arm/mm arch/arm/common arch/arm/probes arch/arm/net arch/arm/crypto arch/arm/firmware arch/arm/mach-imx kernel mm fs ipc security crypto block drivers sound firmware net arch/arm/lib lib $(vmlinux-dirs): prepare scripts ​ $(Q)$(MAKE) $(build)=$@ ​ make -f ./scripts/Makefile.build obj=$@ 展开 make -f ./scripts/Makefile.build obj=init 默认目标为__build，规则就是： __build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \\ ​ $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \\ ​ $(subdir-ym) $(always) ​ @: ​ 简化完成以后就是： __build: $(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) $(always)@: cmd_link_o_target = $(if $(strip $(obj-y)),\\ ​ $(LD) $(ld_flags) -r -o $@ $(filter $(obj-y), $^) \\ ​ $(cmd_secanalysis),\\ ​ rm -f $@; $(AR) rcs$(KBUILD_ARFLAGS) $@) $(builtin-target): $(obj-y) FORCE ​ $(call if_changed,link_o_target) 相当于调用cmd_link_o_target。 builtin-target := $(obj)/built-in.o $(obj)/built-in.o: $(obj-y) FORCE ​ $(call if_changed,link_o_target) 相当于调用cmd_link_o_target。 五、make zImage过程​ 我们需要zImage文件，但是前面一直说的是生成vmlinux， BOOT_TARGETS = zImage Image xipImage bootpImage uImage $(BOOT_TARGETS): vmlinux ​ $(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/$@ zImage Image xipImage bootpImage uImage: vmlinux ​ $(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/$@ 展开 ​ make -f ./scripts/Makefile.build obj=arch/arm/boot MACHINE=arch/arm/boot/zImage","link":"","tags":[]},{"title":"Linux移植-uboot移植","date":"2021-04-13T06:44:05.000Z","path":"2021/04/13/Linux移植-uboot移植/","text":"半导体厂商会将 uboot 移植到他们自己的原厂开发板上，测试好以后就会将这个 uboot 发布出去，这就是原厂 BSP 包。我们一般做产品的时候就会参考原厂的开发板做硬件，然 后在原厂提供的 BSP 包上做修改，将 uboot 或者 linux kernel 移植到我们的硬件上。这个就是uboot 移植的一般流程： ①、在 uboot 中找到参考的开发平台，一般是原厂的开发板。 ②、参考原厂开发板移植 uboot 到我们所使用的开发板上。 一、NXP官方Uboot编译与测试使用 mx6ull_14x14_evk_emmc_defconfig 作为默认配置文件。 NXP 官方 I.MX6ULL EVK 开发板的 uboot 在正点原子 EMMC版本 I.MX6ULL 开发板上的运行情况： ①、uboot 启动正常，DRAM 识别正确，SD 卡和 EMMC 驱动正常。 ②、uboot 里面的 LCD 驱动默认是给 4.3 寸 480x272 分辨率的，如果使用的其他分辨率的屏幕需要修改驱动。 ③、网络不能工作，识别不出来网络信息，需要修改驱动。 接下来我们要做的工作如下： ①、前面我们一直使用着 NXP 官方开发板的 uboot 配置，接下来需要在 uboot 中添加我们自己的开发板，也就是正点原子的 I.MX6ULL 开发板。 ②、解决 LCD 驱动和网络驱动的问题。 二、移植NXP官方uboot到ALPHA开发板2.1 添加板子默认配置文件 借鉴NXP官方6ULL EVK开发板，默认配置文件也用他的， 2.2添加板子对应的头文件不同的板子，有一些需要配置的信息，一般是在一个头文件里面配置，每个板子有一个。对于NXP官方的6ULL EVK板子，这个头文件就是。复 制include/configs/mx6ullevk.h，并重命名为 mx6ull_alientek_emmc.h， 2.3 添加板子对应的板级文件夹每个板子都有特有的文件，也叫做板级文件。这里我们将mx6ullevk 的板级文件直接拷贝过来。 2.4 修改uboot的配置界面 2.5 使用新添加的板子配置并编译Uboot 2.6 LCD驱动修改 1、确定LCD IO初始化正确，mx6ull_alientek_emmc.c中的lcd_pads。 2、LCD参数，mx6ull_alientek_emmc.c中的displays。fb_videomode表示RGB LCD参数。 MX6ULL_LCDIF1_BASE_ADDR (AIPS2_OFF_BASE_ADDR + 0x48000) AIPS2_OFF_BASE_ADDR (ATZ2_BASE_ADDR + 0x80000) ATZ2_BASE_ADDR AIPS2_ARB_BASE_ADDR AIPS2_ARB_BASE_ADDR 0x02100000 MX6ULL_LCDIF1_BASE_ADDR = 0x02100000 + 0x80000 + 0x48000 = 0x21c8000 ​ Panel环境变量表示LCD ID。 2.7 网络驱动修改 6ULL网络方案采用内部MAC+外部PHY，6ULL官方开发板使用的PHY芯片就是KSZ8081。正点原子的ALPHA开发板没有使用KSZ8081，我们使用的LAN8720A。因此要修改驱动。 LAN872有一个管理接口，叫做MDIO，两根线，MDIO和MDC，一个MDIO接口可以管理32个PHY芯片。MIDO通过PHY ADDR来确定访问那个PHY芯片。ALPHA开发板ENET1的PHY ADDR是0x0，ENET2的PHY ADDR是0X1.每个LAN8720都有一个复位引脚，ENET1是SNVS_TAMPER7，ENET2是SNVS_TAMPER8。 LAN8720驱动，因为所有的PHY，其前32个寄存器一模一样，因此uboot里面已经写好了通用PHY驱动，所以理论上不需要修改。 驱动修改1、修改PHY ADDR2、删除原有的74LV595相关代码。3、添加ALPHA开发板的网络复位IO 2.8 其他需要修改的地方 三、bootcmd和bootargs环境变量3.1 bootcmd环境变量 宏CONFIG_BOOTCOMMAND也可以设置bootcmd的值。 &quot;run findfdt;&quot; \\ &quot;mmc dev $&#123;mmcdev&#125;;&quot; \\ &quot;mmc dev $&#123;mmcdev&#125;; if mmc rescan; then &quot; \\ &quot;if run loadbootscript; then &quot; \\ &quot;run bootscript; &quot; \\ &quot;else &quot; \\ &quot;if run loadimage; then &quot; \\ &quot;run mmcboot; &quot; \\ &quot;else run netboot; &quot; \\ &quot;fi; &quot; \\ &quot;fi; &quot; \\ &quot;else run netboot; fi&quot; Findfdt 设置fdt_file环境变量，也就是dtb文件名字。 1234mmc dev 1 &#x2F;&#x2F;切换到emmcfatload mmc 1:1 80800000 zImagefatload mmc 1:1 83000000 imx6ull-14x14-evk.dtbbooz 80800000 - 83000000 &quot;loadbootscript=&quot; \\ &quot;fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;script&#125;;\\0&quot; \\ 展开：fatload mmc 1:1 80800000 boot.scr 12loadimage&#x3D;fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;image&#125;\\0&quot; \\展开：fatload mmc 1:1 80800000 zImage 12&quot;loadfdt&#x3D;fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;fdt_addr&#125; $&#123;fdt_file&#125;\\0&quot; \\展开：fatload mmc 1:1 83000000 imx6ull-14x14-evk.dtb 12bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;;booz 80800000 - 83000000 3.2 bootargs环境变量 宏CONFIG_BOOTARGS也可以设置bootargs的值 mmcargs=setenv bootargs console=${console},${baudrate} “ CONFIG_BOOTARGS_CMA_SIZE \\ 123&quot;root&#x3D;$&#123;mmcroot&#125;\\0&quot; \\展开以后就是：bootargs console&#x3D; ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;mmcblk1p2 Bootargs是会传递给Linux内核，设置了一些东西，Bootargs环境变量也叫做命令行参数。 四、uboot启动Linux测试4.1 从EMMC启动 从 EMMC 启动也就是将编译出来的 Linux 镜像文件 zImage 和设备树文件保存在 EMMC中，uboot 从 EMMC 中读取这两个文件并启动，这个是我们产品最终的启动方式。 1、首先查看EMMC里面是否有系统，linux镜像zImage和.dtb文件。先将当前设备切换到EMMC： 12345mmc dev 1 &#x2F;&#x2F;切换到EMMCfatls mmc 1:1 &#x2F;&#x2F;查看EMMC分区1里面的文件fatload mmc 1:1 80800000 zImage &#x2F;&#x2F;将zimage下载到DDR的0x80800000处fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb &#x2F;&#x2F;将dtb读取到0X83000000bootz 80800000 – 83000000 &#x2F;&#x2F;启动内核 如果内核启动成功，说明uboot支持emmc启动，验证成功。 4.2 从网络启动 从网络启动 linux 系统的唯一目的就是为了调试！不管是为了调试 linux 系统还是 linux 下的驱动，每次修改 linux 系统文件或者 linux 下的某个驱动以后都要将其烧写到 EMMC 中去测试，这样太麻烦了。可以设置 linux 从网络启动，也就是将 linux 镜像文件和根文件系统都放到 Ubuntu 下某个指定的文件夹中，每次重新编译 linux 内核或者某个 linux 驱动以后只需要使用 cp 命令将其拷贝到这个指定的文件夹中即可，这样就不用需要频繁的烧写 EMMC，加快了开发速度。 我们可以通过 nfs 或者 tftp 从 Ubuntu 中下载 zImage 和设备树文件，根文件系统的话可以通过 nfs 挂载。 现通过tftp下载，将 zImage 和设备树文件放到 Ubuntu 下的 tftp 目录中， 123tftp 80800000 zImage &#x2F;&#x2F;从tftp服务器下载zimagetftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb &#x2F;&#x2F;从tftp服务器下载.dtb bootz 80800000 – 83000000 &#x2F;&#x2F;启动系统 五、uboot DDR初始化1、裸机imxdownload软件下载，会在bin文件头部添加IVT DCD数据， 2、ubootuboot编译生成u-boot.imx。u-boot.imx已经包含了IVT DCD数据。u-boot.imx的头部信息是怎么添加的？u-boot.imx的DCD中的DDR初始化代码该怎么修改？uboot编译会输出 ./tools/mkimage -n board/freescale/mx6ull_alientek_emmc/imximage.cfg.cfgtmp -T imximage -e 0x87800000 -d u-boot.bin u-boot.imx 可以看出uboot使用/tools/mkimage工具，向u-boot.bin添加board/freescale/mx6ull_alientek_emmc/imximage.cfg.cfgtmp文件信息，从而得到u-boot.imx。 默认只有imximage.cfg文件，imximage.cfg里面保存的就是DCD数据。DDR初始化也此文件里面。我们要修改DDR初始化代码，就需要修改imximage.cfg文件。此文件默认拷贝的NXP给IMX6ULL EVK开发板写的，默认是给512MB DDR3L写的。 六、总结①、不管是购买的开发板还是自己做的开发板，基本都是参考半导体厂商的 dmeo 板，而半导体厂商会在他们自己的开发板上移植好uboot、linux kernel 和 rootfs 等，最终制作好 BSP包提供给用户。我们可以在官方提供的 BSP包的基础上添加我们的板子，也就是俗称的移植。 ②、我们购买的开发板或者自己做的板子一般都不会原封不动的照抄半导体厂商的 demo板，都会根据实际的情况来做修改，既然有修改就必然涉及到 uboot 下驱动的移植。 ③、一般 uboot 中需要解决串口、NAND、EMMC 或 SD 卡、网络和 LCD 驱动，因为 uboot的主要目的就是启动 Linux 内核，所以不需要考虑太多的外设驱动。 ④、在 uboot 中添加自己的板子信息，根据自己板子的实际情况来修改 uboot 中的驱动。","link":"","tags":[]},{"title":"","date":"2021-04-12T15:24:43.000Z","path":"2021/04/12/Linux移植-uboot启动流程/","text":"一、连接脚本u-boot.lds详解程序的链接是由链接脚本来决定的，所以通过链接脚本可以找到程序的入口。如果没有编译过 uboot 的话链接 脚本为 arch/arm/cpu/u-boot.lds。但是这个不是最终使用的链接脚本，最终的链接脚本是在这个链接脚本的基础上生成的。 ​ 1、从u-boot.lds可知，uboot入口地址为_start ​ __image_copy_start -》 0x87800000 ​ .vetcors -&gt; 0x87800000 存放中断向量表 ​ arch/arm/cpu/armv7/start.o start.c ​ __image_copy_end -》 0x8785dc6c __rel_dyn_start -&gt; 0x8785dc6c rel段 __rel_dyn_end -&gt; 0x878668a4 __end -》 0x878668a4 _image_binary_end -》 0x878668a4 __bss_start -》 0x8785dc6c bss段。 __bss_end -》 0x878a8d74 二、uboot启动流程​ 1、reset函数 ​ bicne=bic + ne ​ ①、reset函数目的是将处理器设置为SVC模式，并且关闭FIQ和IRQ. ​ ②、设置中断向量。 ​ ③、初始化CP15 ​ ④、 ​ 2、lowlevel_init函数 ​ CONFIG_SYS_INIT_SP_ADDR #define CONFIG_SYS_INIT_SP_ADDR \\ ​ (CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET) #define CONFIG_SYS_INIT_SP_OFFSET \\ ​ (CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE) #define CONFIG_SYS_INIT_RAM_SIZE IRAM_SIZE #define IRAM_SIZE 0x00020000 #define CONFIG_SYS_INIT_RAM_ADDR IRAM_BASE_ADDR #define IRAM_BASE_ADDR 0x00900000 6ULL内部OCRAM #define GENERATED_GBL_DATA_SIZE 256 0x00900000 + CONFIG_SYS_INIT_SP_OFFSE =&gt; 0x00900000 + CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE =&gt; 0x00900000 \\+** 0x00020000 – 256 = 0x0091ff00 设置SP指针、R9寄存器 ​ 3、s_init函数 ​ 空函数。 ​ 4、_main函数 ​ 5、board_init_f函数 ​ initcall_run_lis此函数会调用一系列的函数，这些函数保存在init_sequence_f数组里面， version_string[] = U_BOOT_VERSION_STRING #define U_BOOT_VERSION_STRING U_BOOT_VERSION “ (“ U_BOOT_DATE “ - “ \\ ​ U_BOOT_TIME “ “ U_BOOT_TZ “)” CONFIG_IDENT_STRING U_BOOT_VERSION = U-Boot 2016.03 TOTAL_MALLOC_LEN (CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE) CONFIG_SYS_MALLOC_LEN (16 * SZ_1M) CONFIG_ENV_SIZE SZ_8K mx6ullevk.c mx6ullevk.h这两个文件长打交道 ​ 6、relocate_code函数 ​ relocate_code函数有一个参数，r0=gd-&gt;relocaddr=0X9FF47000，uboot重定位后的首地址。 ​ r1=0X87800000 源地址起始地址。 ​ r4=0X9FF47000-0X87800000=0X18747000 偏移。 ​ r2=0x8785dc6c ​ 当简单粗暴的将uboot从0X87800000拷贝到其他地方以后，关于函数调用、全局变量引用就会出问题。Uboot对于这个的处理方法就是采用位置无关码，这个就需要借助于.rel.dyn段。 8785dcf8 : 8785dcf8: 00000000 andeq r0, r0, r0 878042b4 : 878042b4: e59f300c ldr r3, [pc, #12] ; 878042c8 &lt;rel_test+0x14&gt; 878042b8: e3a02064 mov r2, #100 ; 0x64 878042bc: e59f0008 ldr r0, [pc, #8] ; 878042cc &lt;rel_test+0x18&gt; 878042c0: e5832000 str r2, [r3] 878042c4: ea00d64c b 87839bfc 878042c8: 8785dcf8 ; instruction: 0x8785dcf8 878042cc: 87842aaf strhi r2, [r4, pc, lsr #21] 设置r3为878042b4+8+12=878042c8的值，r3=8785dcf8。这里并没有直接去读取rel_a的地址，而是借助了878042c。 ​ 878042c8叫做Label。 重定位以后 9ffa4cf8 : 9ffa4cf8: 00000000 andeq r0, r0, r0 9ff4b2b4: 9ff4b2b4: e59f300c ldr r3, [pc, #12] ; 878042c8 &lt;rel_test+0x14&gt; 9ff4b2b8: e3a02064 mov r2, #100 ; 0x64 9ff4b2bc: e59f0008 ldr r0, [pc, #8] ; 878042cc &lt;rel_test+0x18&gt; 9ff4b2c0: e5832000 str r2, [r3] 9ff4b2c4: ea00d64c b 87839bfc 9ff4b2c8: 8785dcf8 ; instruction: 0x8785dcf8 9ff4b2cc: 87842aaf strhi r2, [r4, pc, lsr #21] Label中的值还是原来的！必须要将8785dcf8换为重定位后的rel_a地址。读取9ff4b2c8里面的数据，也就是老的rel_a的地址=8785dcf8+0x18747000=0x9ffa4cf8 重定位以后，需要对所有的Label保存的数据加上偏移！！ 8785dcec: 87800020 strhi r0, [r0, r0, lsr #32] 8785dcf0: 00000017 andeq r0, r0, r7, lsl r0 …… 8785e2fc: 878042c8 strhi r4, [r0, r8, asr #5] 8785e300: 00000017 andeq r0, r0, r7, lsl r0 878042c8+offset = 读取新的Label处的数据+offset ​ 完成这个功能在连接的时候需要加上”-pie” ​ 7、relocate_vectors函数 ​ 设置VBAR寄存器为重定位后的中断向量表起始地址。 ​ 8、board_init_r函数 ​ Board_init_r函数和board_init_f函数很类似。board_init_r也是执行init_sequence_r初始化序列。 ​ ​ 9、run_main_loop函数 ​ run_main_loop ​ -&gt; main_loop ​ -&gt; bootdelay_process 获取bootdelay的值，然后保存到stored_bootdelay 全局变量里面，获取bootcmd环境变量值，并且将其 返回 -&gt; autoboot_command 参数是bootcmd的值。 ​ -&gt; abortboot 参数为boot delay，此函数会处理倒计时 ​ -&gt; abortboot_normal 参数为boot delay，此函数会处理倒计时 -&gt; cli_loop uboot命令模式处理函数。 ​ -&gt; parse_file_outer ​ -&gt; parse_stream_outer ​ -&gt; parse_stream 解析输入的字符，得到命令 ​ -&gt; run_list 运行命令 ​ -&gt; run_list_real ​ -&gt; run_pipe_real ​ -&gt; cmd_process 处理命令，也就是执行命令 ​ ​ 10、cli_loop函数 ​ 11、cmd_process函数 ​ Uboot使用U_BOOT_CMD来定义一个命令。CONFIG_CMD_XXX来使能uboot中的某个命令。 ​ U_BOOT_CMD最终是定义了一个cmd_tbl_t类型的变量，所有的命令最终都是存放在.u_boot_list段里面。cmd_tbl_t的cmd成员变量就是具体的命令执行函数，命令执行函数都是do_xxx。 ​ cmd_process ​ -&gt;find_cmd 从.u_boot_list段里面查找命令，当找到对应的命令以后以返回值的 形式给出，为cmd_tbl_t类型 ​ -&gt;cmd_call ​ -&gt;cmdtp-&gt;cmd 直接引用cmd成员变量 三、bootz启动Linux内核过程​ Uboot启动Linux内核使用bootz命令，bootm。。bootz是如何启动Linux内核？uboot的生命是怎么终止的呢？linux又是怎么启动的呢？ ​ 1、image全局变量 bootm_headers_t images; ​ 2、do_bootz函数 tftp 80800000 zImage tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb bootz 80800000 - 83000000 ​ bootz命令的执行函数，do_xxxx，do_bootz是bootz的执行函数。 do_bootz ​ -&gt; bootz_start ​ -&gt; do_bootm_states 阶段为BOOTM_STATE_START ​ -&gt; bootm_start 对images全局变量清零， ​ -&gt; images-&gt;ep = 0X80800000 ​ -&gt;bootz_setup 判断zImage是否正确 ​ -&gt; bootm_find_images ​ · -&gt; boot_get_fdt 找到设备树，然后将设备树起始地址和长度，写入到images 的ft_addr和ft_len成员变量中。 ​ ​ -&gt; bootm_disable_interrupts 关闭中断相关 ​ -&gt; images.os.os = IH_OS_LINUX; 表示要启动Linux系统 ​ -&gt; do_bootm_states 状态BOOTM_STATE_OS_PREP 、BOOTM_STATE_OS_FAKE_GO 、 BOOTM_STATE_OS_GO, ​ -&gt; bootm_os_get_boot_func 查找Linux内核启动函数。找到Linux内核启动函数 do_bootm_linux，赋值给boot_fn。 ​ -&gt; boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images); 就是do_bootm_linux。 ​ -&gt; boot_prep_linux 启动之前的一些工作，对于使用设备树来说，他会将 Bootargs传递给Linux内核，通过设备树完成。也就是向 Linux内核传参。 ​ -&gt; boot_selected_os BOOTM_STATE_OS_GO, do_bootm_linux ​ -&gt; do_bootm_linux，BOOTM_STATE_OS_GO ​ -&gt; boot_jump_linux ​ -&gt; machid= gd-&gt;bd-&gt;bi_arch_number; ​ -&gt; void (*kernel_entry)(int zero, int arch, uint params); ​ -&gt; kernel_entry = (void (*)(int, int, uint))images-&gt;ep; 0X80800000。 ​ -&gt; announce_and_cleanup 输出Starting kernel…… ​ -&gt; kernel_entry(0, machid, r2); 启动Linux内核。Uboot的最终使命，启动Linux内核。 ​ zimage_header 的zi_magic为zimage的幻数，魔术数。应该为0x016f2818。前面有9个32位的数据，那么9*4=36，0~35，第36个字节的数据开始就是zimage的幻数。 ​ ​ 3、do_bootm_states函数 ​ 4、bootm_os_get_boot_func函数 ​ 5、do_bootm_linux函数","link":"","tags":[]},{"title":"IMX6U移植-uboot-Makefile","date":"2021-04-12T15:04:55.000Z","path":"2021/04/12/Linux移植-uboot-Makefile/","text":"一、Uboot源码目录分析1、因为uboot会使用到一些经过编译才会生成的文件，因此我们在分析uboot的时候，需要先编译一下uboot。 2、arch\\arm\\cpu\\u-boot.lds就是整个UBOOT的连接脚本 3、board\\freescale\\mx6ullevk。重点。 4、configs目录是uboot的默认配置文件目录。此目录下都是以_defconfig结尾的。这些配置文件对应不同的板子。在编译 uboot 之前一定要使用 defconfig 来配置 uboot！ 使用 “make xxx_defconfig”命令即可配置 uboot。当我们执行make xxx_defconfig以后就会生成.config问价，此文件保存了详细的uboot配置信息。 1make mx6ull_14x14_ddr512_emmc_defconfig 5、我们移植uboot的时候重点要关注：board\\freescale和·\\configs，主要是_defconfig 6、当我们执行make xxx_defconfig以后就会生成.config问价，此文件保存了详细的uboot配置信息。在.config 中会有大量的变量值为‘y’，这些为‘y’的变量一般用于控制某项功能是否使能，为‘y’的话就表示功能使能， 7、顶层README，描述了 uboot 的详细信息，包括 uboot 该如何编译、uboot 中各文件夹的含 义、相应的命令等等,非常重要，建议大家阅读。 二、顶层Makefile分析Makefile 是支持嵌套的，也就是顶层 Makefile 可以调用子目录中的 Makefile 文件。每个功能模块目录下都有一个 Makefile，这个 Makefile 只处理本模块的编译链接工作。顶层 Makefile会调用其它的模块的 Makefile 文件。 AS= $(CROSS_COMPILE)as AS = arm-linux-gnueabihf-as 2、变量值 ARCH = arm CPU = armv7 BOARD = mx6ullevk VENDOR = freescale SOC = mx6 CPUDIR = arch/arm/cpu/armv7 BOARDDIR = freescale/mx6ullevk 编译处理过程make distclean make mx6ull_14x14_ddr512_emmc_defconfigmake xxx_defconfig的规则： %config: scripts_basic outputmakefile FORCE $(Q)$(MAKE) $(build)=scripts/kconfig $@ 1、目标为scripts_basic scripts_basic: $(Q)$(MAKE) $(build)=scripts/basic展开以后就是： make -f ./scripts/Makefile.build obj= scripts/basic build定义在scripts\\Kbuild.include build := -f $(srctree)/scripts/Makefile.build objbuild := -f ./scripts/Makefile.build obj 2、outputmakefile， 因为KBUILD_SRC，因此outputmakefile无效。 最终要执行的命令make -f ./scripts/Makefile.build obj=scripts/basic · Make -f ./scripts/Makefile.build obj=scripts/kconfig xxx_defconfig 第一条命令：src = scripts/basickbuild-dir = ./scripts/basickbuild-file = ./scripts/basic/Makefileinclude ./scripts/basic/Makefile __build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) $(subdir-ym) $(always) @: __build: $(builtin-target) $(lib-target) $(extra-y) $(subdir-ym) $(always) @: scripts/basic/fixdep __build: scripts/basic/fixdep因此需要编译出scripts/basic/fixdep，对应的.c是scripts/basic/fixdep.c， 第二条命令：Make -f ./scripts/Makefile.build obj=scripts/kconfig xxx_defconfig src = scripts/kconfigkbuild-dir = ./scripts/ kconfigkbuild-file = ./scripts/ kconfig/Makefileinclude ./scripts/kconfig/Makefile %_defconfig: $(obj)/conf $(Q)$&lt; $(silent) –defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig) xxx_defconfig: scripts/kconfig/conf $(Q)$&lt; $(silent) –defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig) scripts/kconfig/conf –defconfig=arch/../configs/ xxx_defconfig Kconfig make V=1 -j12 默认目标PHONY := _all_all:_all: allall: $(ALL-y)ALL-y += u-boot.srec u-boot.bin u-boot.sym System.map u-boot.cfg binary_size_check u-boot.bin: u-boot-nodtb.bin FORCE $(call if_changed,copy) u-boot-nodtb.bin: u-boot FORCE $(call if_changed,objcopy) $(call DO_STATIC_RELA,$&lt;,$@,$(CONFIG_SYS_TEXT_BASE)) $(BOARD_SIZE_CHECK) u-boot: $(u-boot-init) $(u-boot-main) u-boot.lds FORCE $(call if_changed,u-boot__) u-boot-init := $(head-y)u-boot-main := $(libs-y) head-y= arch/arm/cpu/armv7/start.o libs-y=保存源码的目录libs-y += lib/ -》lib/built-in.olibs-y保存大量的built-in.o u-boot就是将start.o 和大量的built-in.o链接在一起。 假如CONFIG_ONENAND_U_BOOT =yALL-$(CONFIG_ONENAND_U_BOOT)ALL-y += u-boot-onenand.bin 四、链接链接脚本为u-boot.lds，uboot链接首地址为0X87800000，在mx6_common.h文件中设置CONFIG_SYS_TEXT_BASE=0X87800000","link":"","tags":[]},{"title":"Linux移植-uboot简介","date":"2021-04-12T13:51:24.000Z","path":"2021/04/12/Linux移植-uboot简介/","text":"系统移植简介在移植 Linux之前，需要先移植一个 bootloader 代码，这个 bootloader 代码用于启动 Linux 内核，bootloader有很多，常用的就是 U-Boot。移植好 U-Boot 以后再移植 Linux 内核，移植完 Linux 内核以后 Linux 还不能正常启动，还需要再移植一个根文件系统(rootfs)，根文件系统里面包含了一些最 常用的命令和文件。所以 U-Boot、Linux kernel 和 rootfs 这三者一起构成了一个可以正常使用、功能完善的 Linux 系统。 Linux 系统要启动就必须需要一个bootloader 程序，也就说芯片上电以后先运行一段 bootloader程序。这段bootloader程序会先初始化DDR等外设，然后将Linux内核从flash(NAND，NOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核。bootloader最主要的工作就是启动 Linux 内核，bootloader 和 Linux 内核的关系就跟 PC 上的 BIOS 和 Windows 的关系一样，bootloader 就相当于 BIOS。 U-Boot 简介uboot 的全称是 Universal Boot Loader，uboot 是一个遵循 GPL 协议的开源软件，uboot 官方的 uboot 源码是给半导体厂商准备的，半导体厂商会下载 uboot 官方的 uboot 源码，然后将自家相应的芯片移植进去。也就是说半导体厂商会自己维护一个版本的 uboot，这个版本的 uboot 相当于是他们定制的。 U-Boot 初次编译首先在 Ubuntu 中安装 ncurses 库，否则编译会报错，安装命令如下： 1sudo apt-get install libncurses5-dev 如果使用的是 512MB+8G 的 EMMC 核心板，使用如下命令来编译对应的 uboot： 1234make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- distclean make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- (加空格) mx6ull_14x14_ddr512_emmc_defconfig make V&#x3D;1 ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- -j12 这三条命令中 ARCH=arm 设置目标为 arm 架构，CROSS_COMPILE 指定所使用的交叉编译器。 第一条命令相当于“make distclean”，目的是清除工程，一般在第一次编译的时候最好清理一下工程。 第二条指令相当于“make mx6ull_14x14_ddr512_emmc_defconfig”，用于配置 uboot， 配置文件为 mx6ull_14x14_ddr512_emmc_defconfig。 最后一条指令相当于 “make -j12”， 其中 V=1 用于设置编译过程的信息输出级别；-j 用于设置主机使用多少线程编译uboot。 编译完成以后 uboot 源码多了一些文件，其中 u-boot.bin 就是编译出来的 uboot二进制文件。uboot是个裸机程序，因此需要在其前面加上头部才能在I.MX6U上执行 u-boot.imx 文件就是添加头部(IVT、DCD等数据)以后的 u-boot.bin，u-boot.imx 就是最终要烧写到开发板中的 uboot 镜像文件。 U-Boot 烧写与启动将 uboot烧写到 SD 卡中，然后通过 SD 卡来启动来运行 uboot。使用 imxdownload 软件烧写。 12chmod 777 imxdownload &#x2F;&#x2F;给予 imxdownload 可执行权限，一次即可 .&#x2F;imxdownload u-boot.bin &#x2F;dev&#x2F;sdd 在 3 秒倒计时结束以后如果没有按下回车键的话 uboot 就会使用默认参数来启动 Linux 内核了。Linux 内核一旦启动，uboot 就会寿终正寝。 如果在 3 秒倒计时 结束之前按下回车键，那么就会进入 uboot 的命令行模式。 U-Boot 命令使用uboot 支持的命令很多，而且也可以在 uboot 中自定义命令。 命令bdinfo用于查看板子信息，命令printenv用于输出环境变量信息。 命令 setenv 用于设置或者修改环境变量的值。命令saveenv 用于保存修改后的环境变量，一般环境变量是存放在外部 flash 中的uboot 启动的时候会将环境变量从 flash 读取到 DRAM 中。所以使用命令 setenv 修改的是 DRAM 中的环境变量值，修改以后要使用 saveenv 命令将修改后的环境变量保存到 flash 中，否则的话 uboot 下一次重启会继续使用以前的环境变量值。 网络操作命令nfs 命令 nfs(Network File System)网络文件系统，通过 nfs 可以在计算机之间通过网络来分享资源，比如我们将 linux 镜像和设备树文件放到 Ubuntu 中，然后在 uboot 中使用 nfs 命令将 Ubuntu 中的 linux 镜像和设备树下载到开发板的 DRAM 中。这样做的目的是为了方便调试 linux 镜像和设备树，也就是网络调试。 通过网络调试是 Linux 开发中最常用的调试方法。原因是嵌入式 linux开发不像单片机开发可以直接通过 JLINK 或 STLink 等仿真器将代码直接烧写到单片机内部的 flash 中，嵌入式 Linux 通常是烧写到 EMMC、NANDFlash、SPI Flash 等外置 flash 中，但是嵌入式 Linux 开发也没有 MDK，IAR 这样的 IDE，更没有烧写算法，因此不可能通过点击一个 “download”按钮就将固件烧写到外部 flash 中。网络调试的优势就显现出来了，可以通过网络将编译好的 linux 镜像和设备树文件下载到 DRAM 中，然后就可以直接运行。 12nfs [loadAddress] [[hostIPaddr:]bootfilename] nfs 80800000 192.168.1.250:&#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;nfs&#x2F;zImage loadAddress 是要保存的 DRAM 地址，[[hostIPaddr:]bootfilename]是要下载的文件地址。 tftp 命令 tftp 命令的作用和 nfs 命令一样，都是用于通过网络下载东西到 DRAM 中，只是 tftp 命令使用的 TFTP 协议，Ubuntu 主机作为 TFTP 服务器。 12tftpboot [loadAddress] [[hostIPaddr:]bootfilename] tftp 80800000 zImage loadAddress 是文件在 DRAM 中 的存 放 地 址 ，[[hostIPaddr:]bootfilename]是要从 Ubuntu 中下载的文件。但是和 nfs 命令的区别在于，tftp 命令不需要输入文件在 Ubuntu 中的完整路径，只需要输入文件名即可。 EMMC 和 SD 卡操作命令mmc info 命令用于输出当前选中的 mmc info 设备的信息。 mmc rescan 命令用于扫描当前开发板上所有的 MMC 设备。 mmc list 命令用于来查看当前开发板一共有几个 MMC 设备。 “mmc part”来查看候 SD 卡或者 EMMC 分区， mmc dev 命令用于切换当前 MMC 设备， 123mmc dev [dev] [part] mmc dev 0 &#x2F;&#x2F;切换到 SD 卡，0 为 SD 卡，1 为 eMMCmmc dev 1 2 &#x2F;&#x2F;将 EMMC 的分区 2 设置为当前 MMC 设置 [dev]用来设置要切换的 MMC 设备号，[part]是分区号。如果不写分区号的话默认为分区 0。 mmc read 命令用于读取 mmc 设备的数据 12mmc read addr blk# cnt mmc read 80800000 600 10 &#x2F;&#x2F;读取数据 addr 是数据读取到 DRAM 中的地址，blk 是要读取的块起始地址(十六进制)，一个块是 512字节，这里的块和扇区是一个意思，在 MMC 设备中我们通常说扇区，cnt 是要读取的块数量(十六进制)。 BOOT 操作命令bootz 命令 要启动 Linux，需要先将 Linux 镜像文件拷贝到 DRAM 中，如果使用到设备树的话也需要将设备树拷贝到 DRAM 中。然后使用 bootz 命令来启动，bootz 命令用于启动 zImage 镜像文件 1bootz [addr [initrd[:size]] [fdt]] 命令 bootz 有三个参数，addr 是 Linux 镜像文件在 DRAM 中的位置，initrd 是 initrd 文件在DRAM 中的地址，如果不使用 initrd 的话使用‘-’代替即可，fdt 就是设备树文件在 DRAM 中的地址。 使用tftp命令通过网络从Ubuntu将 zImage 下载到 DRAM 的 0X80800000 地址处，然后将设备树 imx6ull-alientek-emmc.dtb 下载到 DRAM 中的 0X83000000 地址处，最后之后命令 bootz 启动： 123tftp 80800000 zImage tftp 83000000 imx6ull-alientek-emmc.dtb bootz 80800000 – 83000000 使用fatload 从 EMMC的分区 1 中将 zImage 和 imx6ull-alientek-emmc.dtb 拷贝到 DRAM 中，然后使用命令 bootz 启动： 123fatload mmc 1:1 80800000 zImagefatload mmc 1:1 83000000 imx6ull-alientek-emmc.dtbbootz 80800000 - 83000000 bootm 命令 bootm 和 bootz 功能类似，但是 bootm 用于启动 uImage 镜像文件。 boot 命令 boot 会读取环境变量 bootcmd 来启动 Linux 系统。bootcmd这个环境变量保存着引导命令，其实就是启动的命令集合，具体的引导命令内容是可以修改的。 使用 tftp 命令从网络启动 Linux 那么就可以设置 bootcmd 为“tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000”，然后使用 saveenv 将 bootcmd 保存起来。然后直接输入 boot 命令即可从网络启动 Linux 系统： 1234setenv bootcmd &#39;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000&#39; saveenv boot 如果想从 EMMC 启动那就设置 bootcmd 为“fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-alientek_emmc.dtb; bootz 80800000 - 83000000”，然后使用 boot 命令启动即可： 1234setenv bootcmd &#39;fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-alientek_emmc.dtb; bootz 80800000 - 83000000&#39; savenev boot","link":"","tags":[]},{"title":"IMX6U-PWM","date":"2021-04-12T09:27:23.000Z","path":"2021/04/12/IMX6U-PWM/","text":"一、PWM简介PWM 全称是 PulseWidth Modulation，也就是脉冲宽度调制， 频率是开关速度，把一次开关算作一个周 期，那么频率就是 1 秒内进行了多少次开关。 占空比是一个周期内高电平时间和低电平时间的比例，一个周期内高电平时间越长占空比就越大，反之占空比就越小。占空比用百分数表示，如果一个周期内全是低电平那么占空比就是 0%，提高占空比就会提高背光亮度，降低占空比就会降低背光亮度。 二、I.MX6U的PWM详解I.MX6U一共有 8 路 PWM 信号，每个 PWM 包含一个 16 位的计数器和一个 4 x 16 的数据 FIFO。 ​ 1、6ULL的PWM是16位计数器，​ 2、有4个16位的FIFO。​ 3、一个12位的分频器​ 4、正点原子LCD屏幕的背光IO连接到了GPIO1_IO08上。GPIO1_IO08可以复用位PWM1_OUT信号。PWM计数器从0X0000开始计数，当计数器的值等于PWMPR+1的时候定时器就会重新开始下一个周期的运行，因此PWMPR寄存器控制着PWM频率。FIFO保存着采样值，控制着占空比。当我们向PWMSAR寄存器写采样值的时候会写道FIFO里面，内每当读取一次PWMSAR寄存器，FIFO里面的数据都会减一，或者每产生一个PWM信号，FIFO的数据也会减一。直到FIFO为空，那么就无法再产生PWM信号。FIFO为空的时候会产生中断，我们可以在中断中向FIFO写入采样数据，也就是向PWMSAR写数据，相当于 PWMx_PWMSAR 控制着占空比。PWMCR寄存器，bit0是PWM使能信号，bit2:1设置为0，每个周期使用FIFO里面的一个数据。Bit15:4，PWM分频设置，可以设置04095，对应14096分频。Bit17:16设置PWM时钟源，设置为1，表示使用ipg_clk=66MHz。bit19:18，设置为0。Bit27：26，设置为01，表示当FIFO里面空余位置大于2的时候FIFO为空。PWMIR寄存器，bit0设置为1，开启FIFO空中断。 三、实验程序编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&#x2F;***************************************************************文件名 : bsp_backlight.c描述 : LCD背光PWM驱动文件。***************************************************************&#x2F;&#x2F;* 背光设备 *&#x2F;struct backlight_dev_struc backlight_dev;&#x2F;* * @description : pwm1中断处理函数 * @param : 无 * @return : 无 *&#x2F;void pwm1_irqhandler(void)&#123; if(PWM1-&gt;PWMSR &amp; (1 &lt;&lt; 3)) &#x2F;* FIFO为空中断 *&#x2F; &#123; &#x2F;* 将占空比信息写入到FIFO中,其实就是设置占空比 *&#x2F; pwm1_setduty(backlight_dev.pwm_duty); PWM1-&gt;PWMSR |&#x3D; (1 &lt;&lt; 3); &#x2F;* 写1清除中断标志位 *&#x2F; &#125;&#125;&#x2F;* * @description : 初始化背光PWM * @param : 无 * @return : 无 *&#x2F;void backlight_init(void)&#123; unsigned char i &#x3D; 0; &#x2F;* 1、背光PWM IO初始化 *&#x2F; IOMUXC_SetPinMux(IOMUXC_GPIO1_IO08_PWM1_OUT, 0); &#x2F;* 复用为PWM1_OUT *&#x2F; &#x2F;* 配置PWM IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 10 100K上拉 *bit [13]: 1 pull功能 *bit [12]: 1 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 010 驱动能力为R0&#x2F;2 *bit [0]: 0 低转换率 *&#x2F; IOMUXC_SetPinConfig(IOMUXC_GPIO1_IO08_PWM1_OUT, 0XB090); &#x2F;* 2、初始化PWM1 *&#x2F; &#x2F;* * 初始化寄存器PWMCR * bit[27:26] : 01 当FIFO中空余位置大于等于2的时候FIFO空标志值位 * bit[25] : 0 停止模式下PWM不工作 * bit[24] : 0 休眠模式下PWM不工作 * bit[23] : 0 等待模式下PWM不工作 * bit[22] : 0 调试模式下PWM不工作 * bit[21] : 0 关闭字节交换 * bit[20] : 0 关闭半字数据交换 * bit[19:18] : 00 PWM输出引脚在计数器重新计数的时候输出高电平 * 在计数器计数值达到比较值以后输出低电平 * bit[17:16] : 01 PWM时钟源选择IPG CLK &#x3D; 66MHz * bit[15:4] : 65 分频系数为65+1&#x3D;66，PWM时钟源 &#x3D; 66MHZ&#x2F;66&#x3D;1MHz * bit[3] : 0 PWM不复位 * bit[2:1] : 00 FIFO中的sample数据每个只能使用一次。 * bit[0] : 0 先关闭PWM，后面再使能 *&#x2F; PWM1-&gt;PWMCR &#x3D; 0; &#x2F;* 寄存器先清零 *&#x2F; PWM1-&gt;PWMCR |&#x3D; (1 &lt;&lt; 26) | (1 &lt;&lt; 16) | (65 &lt;&lt; 4); &#x2F;* 设置PWM周期为1000,那么PWM频率就是1M&#x2F;1000 &#x3D; 1KHz。 *&#x2F; pwm1_setperiod_value(1000); &#x2F;* 设置占空比，默认50%占空比 ,写四次是因为有4个FIFO *&#x2F; backlight_dev.pwm_duty &#x3D; 50; for(i &#x3D; 0; i &lt; 4; i++) &#123; pwm1_setduty(backlight_dev.pwm_duty); &#125; &#x2F;* 使能FIFO空中断，设置寄存器PWMIR寄存器的bit0为1 *&#x2F; PWM1-&gt;PWMIR |&#x3D; 1 &lt;&lt; 0; system_register_irqhandler(PWM1_IRQn, (system_irq_handler_t)pwm1_irqhandler, NULL); &#x2F;* 注册中断服务函数 *&#x2F; GIC_EnableIRQ(PWM1_IRQn); &#x2F;* 使能GIC中对应的中断 *&#x2F; PWM1-&gt;PWMSR &#x3D; 0; &#x2F;* PWM中断状态寄存器清零 *&#x2F; pwm1_enable(); &#x2F;* 使能PWM1 *&#x2F; &#125;&#x2F;* * @description : 使能PWM * @param : 无 * @return : 无 *&#x2F;void pwm1_enable(void)&#123; PWM1-&gt;PWMCR |&#x3D; 1 &lt;&lt; 0; &#125;&#x2F;* * @description : 设置Sample寄存器，Sample数据会写入到FIFO中， * 所谓的Sample寄存器，就相当于比较寄存器，假如PWMCR中的POUTC * 设置为00的时候。当PWM计数器中的计数值小于Sample的时候 * 就会输出高电平，当PWM计数器值大于Sample的时候输出底电平, * 因此可以通过设置Sample寄存器来设置占空比 * @param - value : 寄存器值，范围0~0XFFFF * @return : 无 *&#x2F;void pwm1_setsample_value(unsigned int value)&#123; PWM1-&gt;PWMSAR &#x3D; (value &amp; 0XFFFF); &#125;&#x2F;* * @description : 设置PWM周期，就是设置寄存器PWMPR，PWM周期公式如下 * PWM_FRE &#x3D; PWM_CLK &#x2F; (PERIOD + 2)， 比如当前PWM_CLK&#x3D;1MHz * 要产生1KHz的PWM，那么PERIOD &#x3D; 1000000&#x2F;1K - 2 &#x3D; 998 * @param - value : 周期值，范围0~0XFFFF * @return : 无 *&#x2F;void pwm1_setperiod_value(unsigned int value)&#123; unsigned int regvalue &#x3D; 0; if(value &lt; 2) regvalue &#x3D; 2; else regvalue &#x3D; value - 2; PWM1-&gt;PWMPR &#x3D; (regvalue &amp; 0XFFFF);&#125;&#x2F;* * @description : 设置PWM占空比 * @param - value : 占空比0~100，对应0%~100% * @return : 无 *&#x2F;void pwm1_setduty(unsigned char duty)&#123; unsigned short preiod; unsigned short sample; backlight_dev.pwm_duty &#x3D; duty; preiod &#x3D; PWM1-&gt;PWMPR + 2; sample &#x3D; preiod * backlight_dev.pwm_duty &#x2F; 100; pwm1_setsample_value(sample);&#125;","link":"","tags":[]},{"title":"IMX6U_I2C_触摸屏","date":"2021-04-12T08:51:26.000Z","path":"2021/04/12/IMX6U-I2C-触摸屏/","text":"一、多点电容触摸屏简介ATK-7016 这款屏幕其实是由 TFT LCD+触摸屏组合起来的。底下是 LCD 面板，上面是触摸面板，将两个封装到一起就成了带有触摸屏的 LCD 屏幕。电容触摸屏也是需要一个驱动 IC的，驱动 IC一般会提供一个 I2C 接口给主控制器，主控制器可以通过 I2C 接口来读取驱动 IC 里面的触摸坐标数据。 ATK-7016 的电容触摸屏部分有 4 个 IO 用于连接主控制器：SCL、SDA、RST 和 INT，SCL 和 SDA 是 I2C 引脚，RST 是复位引脚，INT 是中断引脚。一般通过 INT 引脚来通知主控制器有触摸点按下，然后在 INT 中断服务函数中读取触摸数据。也可以不使用中断功能，采用轮询的方式不断查询是否有触摸点按下，触摸屏IP: CT_INT，触摸中断线，连接到了GPIO1_IO09 I2C2_SCL：连接到了UART5_TXD I2C2_SDA：连接到了UART5_RXD RESET：连接到了SNVS_TAMPER9 电容触摸芯片输出的触摸点坐标信息为对应的屏幕像素点信息，因此不需要校准。电阻屏需要校准。 二、FT54x6电容触摸芯片简介1、IIC接口，最大400KHz2、正点原子7寸屏幕FT5426的IIC地址为0X38.寄存器 DEVICE_MODE 0X00，需要设置为0X0，表示正常运行模式。 ID_G_LIB_VERSION_H以及ID_G_LIB_VERSION_L 0XA1和0XA2。表示固件版本号。 ID_G_MODE 0XA4，设置为1，表示采用中断方式上报触摸信息。 TD_STATUS 0X02，当前触摸点的个数，1~5。 TOUCH1_XH 0X03开始记录着触摸屏的触摸点坐标信息，一个触摸点6个寄存器，一共需要5*6=30个寄存器。一直读取到0X20 一个触摸点坐标信息用12bit表示，其中H寄存器的bit3:0这4个bit为高4位，L寄存器的bit7:0为低8位。对于XH寄存器，bit7:6表示事件，很重要。YH寄存器的bit7:4表示触摸ID， 三、实验程序编写123456789101112131415161718192021222324252627282930313233&#x2F;***************************************************************文件名 : bsp_touchscreen.h描述 : 触摸屏驱动头文件,触摸芯片为FT5426***************************************************************&#x2F;&#x2F;* 宏定义 *&#x2F;#define FT5426_ADDR 0X38 &#x2F;* FT5426设备地址 *&#x2F;#define FT5426_DEVICE_MODE 0X00 &#x2F;* 模式寄存器 *&#x2F;#define FT5426_IDGLIB_VERSION 0XA1 &#x2F;* 固件版本寄存器 *&#x2F;#define FT5426_IDG_MODE 0XA4 &#x2F;* 模式寄存器 *&#x2F;#define FT5426_TD_STATUS 0X02 &#x2F;* 触摸状态寄存器 *&#x2F;#define FT5426_TOUCH1_XH 0X03 &#x2F;* 触摸点坐标寄存器,一个触摸点用6个寄存器存储坐标数据*&#x2F; #define FT5426_XYCOORDREG_NUM 30 &#x2F;* 触摸点坐标寄存器数量 *&#x2F;#define FT5426_INIT_FINISHED 1 &#x2F;* 触摸屏初始化完成 *&#x2F;#define FT5426_INIT_NOTFINISHED 0 &#x2F;* 触摸屏初始化未完成 *&#x2F;#define FT5426_TOUCH_EVENT_DOWN 0x00 &#x2F;* 按下 *&#x2F;#define FT5426_TOUCH_EVENT_UP 0x01 &#x2F;* 释放 *&#x2F;#define FT5426_TOUCH_EVENT_ON 0x02 &#x2F;* 接触 *&#x2F;#define FT5426_TOUCH_EVENT_RESERVED 0x03 &#x2F;* 没有事件 *&#x2F;&#x2F;* 触摸屏结构体 *&#x2F;struct ft5426_dev_struc&#123; unsigned char initfalg; &#x2F;* 触摸屏初始化状态 *&#x2F; unsigned char intflag; &#x2F;* 标记中断有没有发生 *&#x2F; unsigned char point_num; &#x2F;* 触摸点 *&#x2F; unsigned short x[5]; &#x2F;* X轴坐标 *&#x2F; unsigned short y[5]; &#x2F;* Y轴坐标 *&#x2F;&#125;;extern struct ft5426_dev_struc ft5426_dev; ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225&#x2F;***************************************************************文件名 : bsp_touchscreen.c描述 : 触摸屏驱动文件，触摸芯片为FT5426***************************************************************&#x2F;struct ft5426_dev_struc ft5426_dev;&#x2F;* * @description : 初始化触摸屏，其实就是初始化FT5426 * @param : 无 * @return : 无 *&#x2F;void touchscreen_init(void)&#123; unsigned char reg_value[2]; ft5426_dev.initfalg &#x3D; FT5426_INIT_NOTFINISHED; &#x2F;* 1、初始化IIC2 IO * I2C2_SCL -&gt; UART5_TXD * I2C2_SDA -&gt; UART5_RXD *&#x2F; IOMUXC_SetPinMux(IOMUXC_UART5_TX_DATA_I2C2_SCL,1); IOMUXC_SetPinMux(IOMUXC_UART5_RX_DATA_I2C2_SDA,1); &#x2F;* 配置I2C2 IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 1 默认47K上拉 *bit [13]: 1 pull功能 *bit [12]: 1 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 110 驱动能力为R0&#x2F;6 *bit [0]: 1 高转换率 *&#x2F; IOMUXC_SetPinConfig(IOMUXC_UART5_TX_DATA_I2C2_SCL,0x70B0); IOMUXC_SetPinConfig(IOMUXC_UART5_RX_DATA_I2C2_SDA,0X70B0); &#x2F;* 2、初始化触摸屏中断IO和复位IO *&#x2F; gpio_pin_config_t ctintpin_config; IOMUXC_SetPinMux(IOMUXC_GPIO1_IO09_GPIO1_IO09,0); &#x2F;* 复用为GPIO1_IO9 *&#x2F; IOMUXC_SetPinMux(IOMUXC_SNVS_SNVS_TAMPER9_GPIO5_IO09,0);&#x2F;* 复用为GPIO5_IO9 *&#x2F; IOMUXC_SetPinConfig(IOMUXC_GPIO1_IO09_GPIO1_IO09,0xF080); IOMUXC_SetPinConfig(IOMUXC_SNVS_SNVS_TAMPER9_GPIO5_IO09,0X10B0); &#x2F;* 中断IO初始化 *&#x2F; ctintpin_config.direction &#x3D; kGPIO_DigitalInput; ctintpin_config.interruptMode &#x3D; kGPIO_IntRisingOrFallingEdge; gpio_init(GPIO1, 9, &amp;ctintpin_config); GIC_EnableIRQ(GPIO1_Combined_0_15_IRQn); &#x2F;* 使能GIC中对应的中断 *&#x2F; system_register_irqhandler(GPIO1_Combined_0_15_IRQn, (system_irq_handler_t)gpio1_io9_irqhandler, NULL); &#x2F;* 注册中断服务函数 *&#x2F; gpio_enableint(GPIO1, 9); &#x2F;* 使能GPIO1_IO18的中断功能 *&#x2F; &#x2F;* 复位IO初始化 *&#x2F; ctintpin_config.direction&#x3D;kGPIO_DigitalOutput; ctintpin_config.interruptMode&#x3D;kGPIO_NoIntmode; ctintpin_config.outputLogic&#x3D;1; gpio_init(GPIO5, 9, &amp;ctintpin_config); &#x2F;* 3、初始化I2C *&#x2F; i2c_init(I2C2); &#x2F;* 4、初始化FT5426 *&#x2F; gpio_pinwrite(GPIO5, 9, 0); &#x2F;* 复位FT5426 *&#x2F; delayms(20); gpio_pinwrite(GPIO5, 9, 1); &#x2F;* 停止复位FT5426 *&#x2F; delayms(20); ft5426_write_byte(FT5426_ADDR, FT5426_DEVICE_MODE, 0); &#x2F;* 进入正常模式 *&#x2F; ft5426_write_byte(FT5426_ADDR, FT5426_IDG_MODE, 1); &#x2F;* FT5426中断模式 *&#x2F; ft426_read_len(FT5426_ADDR, FT5426_IDGLIB_VERSION, 2, reg_value); printf(&quot;Touch Frimware Version:%#X\\r\\n&quot;, ((unsigned short)reg_value[0] &lt;&lt; 8) + reg_value[1]); ft5426_dev.initfalg &#x3D; FT5426_INIT_FINISHED; &#x2F;* 标记FT5426初始化完成 *&#x2F; ft5426_dev.intflag &#x3D; 0;&#125;&#x2F;* * @description : GPIO1_IO9最终的中断处理函数 * @param : 无 * @return : 无 *&#x2F;void gpio1_io9_irqhandler(void)&#123; if(ft5426_dev.initfalg &#x3D;&#x3D; FT5426_INIT_FINISHED) &#123; &#x2F;&#x2F;ft5426_dev.intflag &#x3D; 1; ft5426_read_tpcoord(); &#125; gpio_clearintflags(GPIO1, 9); &#x2F;* 清除中断标志位 *&#x2F;&#125;&#x2F;* * @description : 向FT5429写入数据 * @param - addr: 设备地址 * @param - reg : 要写入的寄存器 * @param - data: 要写入的数据 * @return : 操作结果 *&#x2F;unsigned char ft5426_write_byte(unsigned char addr,unsigned char reg, unsigned char data)&#123; unsigned char status&#x3D;0; unsigned char writedata&#x3D;data; struct i2c_transfer masterXfer; &#x2F;* 配置I2C xfer结构体 *&#x2F; masterXfer.slaveAddress &#x3D; addr; &#x2F;* 设备地址 *&#x2F; masterXfer.direction &#x3D; kI2C_Write; &#x2F;* 写入数据 *&#x2F; masterXfer.subaddress &#x3D; reg; &#x2F;* 要写入的寄存器地址 *&#x2F; masterXfer.subaddressSize &#x3D; 1; &#x2F;* 地址长度一个字节 *&#x2F; masterXfer.data &#x3D; &amp;writedata; &#x2F;* 要写入的数据 *&#x2F; masterXfer.dataSize &#x3D; 1; &#x2F;* 写入数据长度1个字节 *&#x2F; if(i2c_master_transfer(I2C2, &amp;masterXfer)) status&#x3D;1; return status;&#125;&#x2F;* * @description : 从FT5426读取一个字节的数据 * @param - addr: 设备地址 * @param - reg : 要读取的寄存器 * @return : 读取到的数据。 *&#x2F;unsigned char ft5426_read_byte(unsigned char addr,unsigned char reg)&#123; unsigned char val&#x3D;0; struct i2c_transfer masterXfer; masterXfer.slaveAddress &#x3D; addr; &#x2F;* 设备地址 *&#x2F; masterXfer.direction &#x3D; kI2C_Read; &#x2F;* 读取数据 *&#x2F; masterXfer.subaddress &#x3D; reg; &#x2F;* 要读取的寄存器地址 *&#x2F; masterXfer.subaddressSize &#x3D; 1; &#x2F;* 地址长度一个字节 *&#x2F; masterXfer.data &#x3D; &amp;val; &#x2F;* 接收数据缓冲区 *&#x2F; masterXfer.dataSize &#x3D; 1; &#x2F;* 读取数据长度1个字节 *&#x2F; i2c_master_transfer(I2C2, &amp;masterXfer); return val;&#125;&#x2F;* * @description : 从FT5429读取多个字节的数据 * @param - addr: 设备地址 * @param - reg : 要读取的开始寄存器地址 * @param - len : 要读取的数据长度. * @param - buf : 读取到的数据缓冲区 * @return : 无 *&#x2F;void ft426_read_len(unsigned char addr,unsigned char reg,unsigned char len,unsigned char *buf)&#123; struct i2c_transfer masterXfer; masterXfer.slaveAddress &#x3D; addr; &#x2F;* 设备地址 *&#x2F; masterXfer.direction &#x3D; kI2C_Read; &#x2F;* 读取数据 *&#x2F; masterXfer.subaddress &#x3D; reg; &#x2F;* 要读取的寄存器地址 *&#x2F; masterXfer.subaddressSize &#x3D; 1; &#x2F;* 地址长度一个字节 *&#x2F; masterXfer.data &#x3D; buf; &#x2F;* 接收数据缓冲区 *&#x2F; masterXfer.dataSize &#x3D; len; &#x2F;* 读取数据长度1个字节 *&#x2F; i2c_master_transfer(I2C2, &amp;masterXfer);&#125; &#x2F;* * @description : 读取当前触摸点个数 * @param : 无 * @return : 无 *&#x2F;void ft5426_read_tpnum(void)&#123; ft5426_dev.point_num &#x3D; ft5426_read_byte(FT5426_ADDR, FT5426_TD_STATUS);&#125;&#x2F;* * @description : 读取当前所有触摸点的坐标 * @param : 无 * @return : 无 *&#x2F;void ft5426_read_tpcoord(void)&#123; unsigned char i &#x3D; 0; unsigned char type &#x3D; 0; &#x2F;&#x2F;unsigned char id &#x3D; 0; unsigned char pointbuf[FT5426_XYCOORDREG_NUM]; ft5426_dev.point_num &#x3D; ft5426_read_byte(FT5426_ADDR, FT5426_TD_STATUS); &#x2F;* * 从寄存器FT5426_TOUCH1_XH开始，连续读取30个寄存器的值，这30个寄存器 * 保存着5个点的触摸值，每个点占用6个寄存器。 *&#x2F; ft426_read_len(FT5426_ADDR, FT5426_TOUCH1_XH, FT5426_XYCOORDREG_NUM, pointbuf); for(i &#x3D; 0; i &lt; ft5426_dev.point_num ; i++) &#123; unsigned char *buf &#x3D; &amp;pointbuf[i * 6]; &#x2F;* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下： * bit7:6 Event flag 0:按下 1:释放 2：接触 3：没有事件 * bit5:4 保留 * bit3:0 X轴触摸点的11~8位。 *&#x2F; ft5426_dev.x[i] &#x3D; ((buf[2] &lt;&lt; 8) | buf[3]) &amp; 0x0fff; ft5426_dev.y[i] &#x3D; ((buf[0] &lt;&lt; 8) | buf[1]) &amp; 0x0fff; type &#x3D; buf[0] &gt;&gt; 6; &#x2F;* 获取触摸类型 *&#x2F; &#x2F;* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下： * bit7:4 Touch ID 触摸ID，表示是哪个触摸点 * bit3:0 Y轴触摸点的11~8位。 *&#x2F; &#x2F;&#x2F;id &#x3D; (buf[2] &gt;&gt; 4) &amp; 0x0f; if(type &#x3D;&#x3D; FT5426_TOUCH_EVENT_DOWN || type &#x3D;&#x3D; FT5426_TOUCH_EVENT_ON )&#x2F;* 按下 *&#x2F; &#123; &#125; else &#123; &#x2F;* 释放 *&#x2F; &#125; &#125; &#125;","link":"","tags":[]},{"title":"IMX6U-SPI","date":"2021-04-12T07:06:28.000Z","path":"2021/04/12/IMX6U-SPI/","text":"一、SPI协议详解​ 1、SPI相比I2C最大的优势有两点：一个是速度快，最高可以大几十M，甚至上百MHz，第二个就是SPI是个全双工。 ​ 2、SPI接口和I2C一样，一个SPI接口可以连接多个SPI外设，SPI通过CS引脚/数据线，片选引脚来选择和哪个SPI外设通信。SPI通信前先将指定的SPI外设对应的CS引脚拉低来选中此设备。一般 SPI 需要4 根线，但是也可以使用三根线(单向传输). 标准的 4 线 SPI ①、CS/SS，Slave Select/Chip Select，这个是片选信号线，用于选择需要进行通信的从设备。I2C 主机是通过发送从机设备地址来选择需要进行通信的从机设备的，SPI 主机不需要发送从机 设备，直接将相应的从机设备片选信号拉低即可。 ②、SCK，Serial Clock，串行时钟，和 I2C 的 SCL 一样，为 SPI 通信提供时钟。 ③、MOSI/SDO，Master Out Slave In/Serial Data Output，简称主出从入信号线，这根数据线只能用于主机向从机发送数据，也就是主机输出，从机输入。 ④、MISO/SDI，Master In Slave Out/Serial Data Input，简称主入从出信号线，这根数据线只能用户从机向主机发送数据，也就是主机输入，从机输出。 SPI 有四种工作模式，通过串行时钟极性(CPOL)和相位(CPHA)的搭配来得到四种工作模式： 一般使用CPOL=0、CPHA=0。 ①、CPOL=0，串行时钟空闲状态为低电平。 ②、CPOL=1，串行时钟空闲状态为高电平，此时可以通过配置时钟相位(CPHA)来选择具体的传输协议。 ③、CPHA=0，串行时钟的第一个跳变沿(上升沿或下降沿)采集数据。 ④、CPHA=1，串行时钟的第二个跳变沿(上升沿或下降沿)采集数据。 二、6ULL SPI接口详解​ 1、6ULL的SPI接口叫做ECSPI，支持全双工、主丛可配置。​ 2、6ULL一个SPI主接口有4个硬件片选，分别为SS0~SS3。可以使用软件片选，这样一个SPI接口所能连接的外设就无限制了。 寄存器： ​ 1、RXDATA寄存器为接收到的数据。 ​ 2、TXDATA寄存器为发送数据寄存器。 ​ 3、CONREG，控制寄存器，bit0置1，使能SPI。Bit3置1，表示当向TXFIFO写入数据以后马上开启SPI突发访问，也就是发送数据。Bit7:4设置SPI通道主从模式，bit7为通道3，bit4为通道0，我们使用到了SS0，也就是通道0，因此需要设置bit4为1。Bit19：18设置为00，我们使用到SS0，也就是通道0。Bit31:30设置突发访问长度，我们设置为7，也就是8bit突发长度，一个字节。 ​ 4、CONFIGREG，配置寄存器，bit0为PHA，设置为0，表示串行时钟的第一个跳变沿开始采集数据。设置bit4为PO，设置为0，表示SCLK空闲的时候为低电平。Bit8设置0。Bit12设置 为0。Bit16设置为0，表示空闲的时候数据线为高。Bit20设置为0，表示SCLK空闲的时候为低。 ​ 5、STATREG寄存器，bit0表示TXFIFO为空，我们在发送数据之前要等待TXFIFO为空，也就是等待bit0为1。Bit3表示RXFIFO是否有数据，为1的时候示RXFIFO至少有1个字的数据，我们在接收数据的时候要等到bit3为1。 ​ 6、PERIODREG，采样周期寄存器，bit14:0设置wait states时间，我们设置为0X2000。Bit15设置wait states的时钟源为SPI CLK，将此位设置0。Bit21:16表示片选信号的延时，可设置0-63，这里设置为0. ​ 7、SPI时钟设置！​ SPI时钟源最终来源于pll3_sw_clk=480MHz/8=60MHz，设置CSCDR2寄存器的bit18为0，也就是ECSPI时钟源为60MHz。bit24:19设置为0，表示1分频，因此最终进入到SPI外设的时钟源为60MHz​ ECSPI模块还需要对时钟进行两级分频，由ECSPI_CONREG寄存器设置。Bit15:12设置前级分频，可以设置00xf，表示116分频。Bit11:8设置2级分频，设置2^n分频，n=0~15. 三、ICM20608简介ICM-20608是通过读写寄存器来配置和读取传感器数据，使用 SPI 接口读写寄存器需要 16 个时钟或者更多(如果读写操作包括多个字节的话)，第一个字节包含要读写的寄存器地址，寄存器地址最高位是读写标志位，如果是读 的话寄存器地址最高位要为 1，如果是写的话寄存器地址最高位要为 0，剩下的 7 位才是实际的 寄存器地址，寄存器地址后面跟着的就是读写的数据。 ALPHA开发板上通过ECSPI3接口连接了一个6轴传感器，引脚如下： ECSPI3_SCLK : UART2_RX ECSPI3_MOSI：UART2_CTS ECSPI3_SS0：UART2_TXD ECSPI3_MISO: UART2_RTS 四、实验程序编写​ 1、我们在使用浮点计算的时候程序卡死了，因为我们没有开始6UL的硬件浮点运算。我们在编译的时候没有使用浮点。解决此问题需要两点：​ ①、开启6UL的硬件浮点单元​ ②、编译的是时候指定硬件浮点。​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#x2F;***************************************************************文件名 : bsp_spi.c描述 : SPI驱动文件。***************************************************************&#x2F;&#x2F;* * @description : 初始化SPI * @param - base : 要初始化的SPI * @return : 无 *&#x2F;void spi_init(ECSPI_Type *base)&#123; &#x2F;* 1、配置SPI3 *&#x2F; base-&gt;CONREG &#x3D; 0; &#x2F;* 先清除控制寄存器 *&#x2F; &#x2F;* 配置CONREG寄存器 * bit0 : 1 使能ECSPI * bit3 : 1 当向TXFIFO写入数据以后立即开启SPI突发。 * bit[7:4] : 0001 SPI通道0主模式，根据实际情况选择， * 开发板上的BMP280接在SS0上，所以设置通道2为主模式 * bit[19:18]: 00 选中通道0(其实不需要，因为片选信号我们我们自己控制) * bit[31:20]: 0x7 突发长度为8个bit。 *&#x2F; base-&gt;CONREG |&#x3D; (1 &lt;&lt; 0) | (1 &lt;&lt; 3) | (1 &lt;&lt; 4) | (7 &lt;&lt; 20); &#x2F;* 配置CONREG寄存器 *&#x2F; &#x2F;* * ECSPI通道0设置,即设置CONFIGREG寄存器 * bit0: 0 通道0 PHA为0 * bit4: 0 通道0 SCLK高电平有效 * bit8: 0 通道0片选信号 当SMC为1的时候此位无效 * bit12： 0 通道0 POL为0 * bit16： 0 通道0 数据线空闲时高电平 * bit20: 0 通道0 时钟线空闲时低电平 *&#x2F; base-&gt;CONFIGREG &#x3D; 0; &#x2F;* 设置通道寄存器 *&#x2F; &#x2F;* * ECSPI通道0设置，设置采样周期 * bit[14:0] : 0X2000 采样等待周期，比如当SPI时钟为10MHz的时候 * 0X2000就等于1&#x2F;10000 * 0X2000 &#x3D; 0.8192ms，也就是连续 * 读取数据的时候每次之间间隔0.8ms * bit15 : 0 采样时钟源为SPI CLK * bit[21:16]: 0 片选延时，可设置为0~63 *&#x2F; base-&gt;PERIODREG &#x3D; 0X0000; &#x2F;* 设置采样周期寄存器 *&#x2F; &#x2F;* * ECSPI的SPI时钟配置，SPI的时钟源来源于pll3_sw_clk&#x2F;8&#x3D;480&#x2F;8&#x3D;60MHz * 通过设置CONREG寄存器的PER_DIVIDER(bit[11:8])和POST_DIVEDER(bit[15:12])来 * 对SPI时钟源分频，获取到我们想要的SPI时钟： * SPI CLK &#x3D; (SourceCLK &#x2F; PER_DIVIDER) &#x2F; (2^POST_DIVEDER) * 比如我们现在要设置SPI时钟为10MHz，那么PER_DIVEIDER和POST_DEIVIDER设置如下： * PER_DIVIDER &#x3D; 0X5。 * POST_DIVIDER &#x3D; 0X0。 * SPI CLK &#x3D; 60000000&#x2F;(0X9 + 1) &#x3D; 60000000&#x3D;6MHz *&#x2F; base-&gt;CONREG &amp;&#x3D; ~((0XF &lt;&lt; 12) | (0XF &lt;&lt; 8)); &#x2F;* 清除PER_DIVDER和POST_DIVEDER以前的设置 *&#x2F; base-&gt;CONREG |&#x3D; (0X9 &lt;&lt; 12); &#x2F;* 设置SPI CLK &#x3D; 6MHz *&#x2F;&#125;&#x2F;* * @description : SPI通道0发送&#x2F;接收一个字节的数据 * @param - base : 要使用的SPI * @param - txdata : 要发送的数据 * @return : 无 *&#x2F;unsigned char spich0_readwrite_byte(ECSPI_Type *base, unsigned char txdata)&#123; uint32_t spirxdata &#x3D; 0; uint32_t spitxdata &#x3D; txdata; &#x2F;* 选择通道0 *&#x2F; base-&gt;CONREG &amp;&#x3D; ~(3 &lt;&lt; 18); base-&gt;CONREG |&#x3D; (0 &lt;&lt; 18); while((base-&gt;STATREG &amp; (1 &lt;&lt; 0)) &#x3D;&#x3D; 0)&#123;&#125; &#x2F;* 等待发送FIFO为空 *&#x2F; base-&gt;TXDATA &#x3D; spitxdata; while((base-&gt;STATREG &amp; (1 &lt;&lt; 3)) &#x3D;&#x3D; 0)&#123;&#125; &#x2F;* 等待接收FIFO有数据 *&#x2F; spirxdata &#x3D; base-&gt;RXDATA; return spirxdata;&#125; ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231&#x2F;***************************************************************文件名 : bsp_icm20608.c描述 : ICM20608驱动文件。***************************************************************&#x2F;struct icm20608_dev_struc icm20608_dev; &#x2F;* icm20608设备 *&#x2F;&#x2F;* * @description : 初始化ICM20608 * @param : 无 * @return : 0 初始化成功，其他值 初始化失败 *&#x2F;unsigned char icm20608_init(void)&#123; unsigned char regvalue; gpio_pin_config_t cs_config; &#x2F;* 1、ESPI3 IO初始化 * ECSPI3_SCLK -&gt; UART2_RXD * ECSPI3_MISO -&gt; UART2_RTS * ECSPI3_MOSI -&gt; UART2_CTS *&#x2F; IOMUXC_SetPinMux(IOMUXC_UART2_RX_DATA_ECSPI3_SCLK, 0); IOMUXC_SetPinMux(IOMUXC_UART2_CTS_B_ECSPI3_MOSI, 0); IOMUXC_SetPinMux(IOMUXC_UART2_RTS_B_ECSPI3_MISO, 0); &#x2F;* 配置SPI SCLK MISO MOSI IO属性 *bit 16: 0 HYS关闭 *bit [15:14]: 00 默认100K下拉 *bit [13]: 0 keeper功能 *bit [12]: 1 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 110 驱动能力为R0&#x2F;6 *bit [0]: 1 高转换率 *&#x2F; IOMUXC_SetPinConfig(IOMUXC_UART2_RX_DATA_ECSPI3_SCLK, 0x10B1); IOMUXC_SetPinConfig(IOMUXC_UART2_CTS_B_ECSPI3_MOSI, 0x10B1); IOMUXC_SetPinConfig(IOMUXC_UART2_RTS_B_ECSPI3_MISO, 0x10B1); IOMUXC_SetPinMux(IOMUXC_UART2_TX_DATA_GPIO1_IO20, 0); IOMUXC_SetPinConfig(IOMUXC_UART2_TX_DATA_GPIO1_IO20, 0X10B0); cs_config.direction &#x3D; kGPIO_DigitalOutput; cs_config.outputLogic &#x3D; 0; gpio_init(GPIO1, 20, &amp;cs_config); &#x2F;* 2、初始化SPI *&#x2F; spi_init(ECSPI3); icm20608_write_reg(ICM20_PWR_MGMT_1, 0x80); &#x2F;* 复位，复位后为0x40,睡眠模式 *&#x2F; delayms(50); icm20608_write_reg(ICM20_PWR_MGMT_1, 0x01); &#x2F;* 关闭睡眠，自动选择时钟 *&#x2F; delayms(50); regvalue &#x3D; icm20608_read_reg(ICM20_WHO_AM_I); printf(&quot;icm20608 id &#x3D; %#X\\r\\n&quot;, regvalue); if(regvalue !&#x3D; ICM20608G_ID &amp;&amp; regvalue !&#x3D; ICM20608D_ID) return 1; icm20608_write_reg(ICM20_SMPLRT_DIV, 0x00); &#x2F;* 输出速率是内部采样率 *&#x2F; icm20608_write_reg(ICM20_GYRO_CONFIG, 0x18); &#x2F;* 陀螺仪±2000dps量程 *&#x2F; icm20608_write_reg(ICM20_ACCEL_CONFIG, 0x18); &#x2F;* 加速度计±16G量程 *&#x2F; icm20608_write_reg(ICM20_CONFIG, 0x04); &#x2F;* 陀螺仪低通滤波BW&#x3D;20Hz *&#x2F; icm20608_write_reg(ICM20_ACCEL_CONFIG2, 0x04); &#x2F;* 加速度计低通滤波BW&#x3D;21.2Hz *&#x2F; icm20608_write_reg(ICM20_PWR_MGMT_2, 0x00); &#x2F;* 打开加速度计和陀螺仪所有轴 *&#x2F; icm20608_write_reg(ICM20_LP_MODE_CFG, 0x00); &#x2F;* 关闭低功耗 *&#x2F; icm20608_write_reg(ICM20_FIFO_EN, 0x00); &#x2F;* 关闭FIFO *&#x2F; return 0;&#125; &#x2F;* * @description : 写ICM20608指定寄存器 * @param - reg : 要读取的寄存器地址 * @param - value: 要写入的值 * @return : 无 *&#x2F;void icm20608_write_reg(unsigned char reg, unsigned char value)&#123; &#x2F;* ICM20608在使用SPI接口的时候寄存器地址 * 只有低7位有效,寄存器地址最高位是读&#x2F;写标志位 * 读的时候要为1，写的时候要为0。 *&#x2F; reg &amp;&#x3D; ~0X80; ICM20608_CSN(0); &#x2F;* 使能SPI传输 *&#x2F; spich0_readwrite_byte(ECSPI3, reg); &#x2F;* 发送寄存器地址 *&#x2F; spich0_readwrite_byte(ECSPI3, value); &#x2F;* 发送要写入的值 *&#x2F; ICM20608_CSN(1); &#x2F;* 禁止SPI传输 *&#x2F;&#125; &#x2F;* * @description : 读取ICM20608寄存器值 * @param - reg : 要读取的寄存器地址 * @return : 读取到的寄存器值 *&#x2F;unsigned char icm20608_read_reg(unsigned char reg)&#123; unsigned char reg_val; &#x2F;* ICM20608在使用SPI接口的时候寄存器地址 * 只有低7位有效,寄存器地址最高位是读&#x2F;写标志位 * 读的时候要为1，写的时候要为0。 *&#x2F; reg |&#x3D; 0x80; ICM20608_CSN(0); &#x2F;* 使能SPI传输 *&#x2F; spich0_readwrite_byte(ECSPI3, reg); &#x2F;* 发送寄存器地址 *&#x2F; reg_val &#x3D; spich0_readwrite_byte(ECSPI3, 0XFF); &#x2F;* 读取寄存器的值 *&#x2F; ICM20608_CSN(1); &#x2F;* 禁止SPI传输 *&#x2F; return(reg_val); &#x2F;* 返回读取到的寄存器值 *&#x2F;&#125;&#x2F;* * @description : 读取ICM20608连续多个寄存器 * @param - reg : 要读取的寄存器地址 * @return : 读取到的寄存器值 *&#x2F;void icm20608_read_len(unsigned char reg, unsigned char *buf, unsigned char len)&#123; unsigned char i; &#x2F;* ICM20608在使用SPI接口的时候寄存器地址，只有低7位有效, * 寄存器地址最高位是读&#x2F;写标志位读的时候要为1，写的时候要为0。 *&#x2F; reg |&#x3D; 0x80; ICM20608_CSN(0); &#x2F;* 使能SPI传输 *&#x2F; spich0_readwrite_byte(ECSPI3, reg); &#x2F;* 发送寄存器地址 *&#x2F; for(i &#x3D; 0; i &lt; len; i++) &#x2F;* 顺序读取寄存器的值 *&#x2F; &#123; buf[i] &#x3D; spich0_readwrite_byte(ECSPI3, 0XFF); &#125; ICM20608_CSN(1); &#x2F;* 禁止SPI传输 *&#x2F;&#125;&#x2F;* * @description : 获取陀螺仪的分辨率 * @param : 无 * @return : 获取到的分辨率 *&#x2F;float icm20608_gyro_scaleget(void)&#123; unsigned char data; float gyroscale; data &#x3D; (icm20608_read_reg(ICM20_GYRO_CONFIG) &gt;&gt; 3) &amp; 0X3; switch(data) &#123; case 0: gyroscale &#x3D; 131; break; case 1: gyroscale &#x3D; 65.5; break; case 2: gyroscale &#x3D; 32.8; break; case 3: gyroscale &#x3D; 16.4; break; &#125; return gyroscale;&#125;&#x2F;* * @description : 获取加速度计的分辨率 * @param : 无 * @return : 获取到的分辨率 *&#x2F;unsigned short icm20608_accel_scaleget(void)&#123; unsigned char data; unsigned short accelscale; data &#x3D; (icm20608_read_reg(ICM20_ACCEL_CONFIG) &gt;&gt; 3) &amp; 0X3; switch(data) &#123; case 0: accelscale &#x3D; 16384; break; case 1: accelscale &#x3D; 8192; break; case 2: accelscale &#x3D; 4096; break; case 3: accelscale &#x3D; 2048; break; &#125; return accelscale;&#125;&#x2F;* * @description : 读取ICM20608的加速度、陀螺仪和温度原始值 * @param : 无 * @return : 无 *&#x2F;void icm20608_getdata(void)&#123; float gyroscale; unsigned short accescale; unsigned char data[14]; icm20608_read_len(ICM20_ACCEL_XOUT_H, data, 14); gyroscale &#x3D; icm20608_gyro_scaleget(); accescale &#x3D; icm20608_accel_scaleget(); icm20608_dev.accel_x_adc &#x3D; (signed short)((data[0] &lt;&lt; 8) | data[1]); icm20608_dev.accel_y_adc &#x3D; (signed short)((data[2] &lt;&lt; 8) | data[3]); icm20608_dev.accel_z_adc &#x3D; (signed short)((data[4] &lt;&lt; 8) | data[5]); icm20608_dev.temp_adc &#x3D; (signed short)((data[6] &lt;&lt; 8) | data[7]); icm20608_dev.gyro_x_adc &#x3D; (signed short)((data[8] &lt;&lt; 8) | data[9]); icm20608_dev.gyro_y_adc &#x3D; (signed short)((data[10] &lt;&lt; 8) | data[11]); icm20608_dev.gyro_z_adc &#x3D; (signed short)((data[12] &lt;&lt; 8) | data[13]); &#x2F;* 计算实际值 *&#x2F; icm20608_dev.gyro_x_act &#x3D; ((float)(icm20608_dev.gyro_x_adc) &#x2F; gyroscale) * 100; icm20608_dev.gyro_y_act &#x3D; ((float)(icm20608_dev.gyro_y_adc) &#x2F; gyroscale) * 100; icm20608_dev.gyro_z_act &#x3D; ((float)(icm20608_dev.gyro_z_adc) &#x2F; gyroscale) * 100; icm20608_dev.accel_x_act &#x3D; ((float)(icm20608_dev.accel_x_adc) &#x2F; accescale) * 100; icm20608_dev.accel_y_act &#x3D; ((float)(icm20608_dev.accel_y_adc) &#x2F; accescale) * 100; icm20608_dev.accel_z_act &#x3D; ((float)(icm20608_dev.accel_z_adc) &#x2F; accescale) * 100; icm20608_dev.temp_act &#x3D; (((float)(icm20608_dev.temp_adc) - 25 ) &#x2F; 326.8 + 25) * 100;&#125;","link":"","tags":[]},{"title":"IMX6U-RTC实时时钟","date":"2021-04-11T15:07:12.000Z","path":"2021/04/11/IMX6U-RTC实时时钟/","text":"实时时钟是很常用的一个外设，通过实时时钟我们就可以知道年、月、日和时间等信息。因此在需要记录时间的场合就需要实时时钟，可以使用专用的实时时钟芯片来完成此功能，I.MX6U 内部的SNVS 就提供了 RTC 功能。 一、RTC原理详解6U内部自带到了一个RTC外设，确切的说是SNVC。6U的RTC分为LP和HP。LP叫做SRTC，HP是RTC，但是HP的RTC掉电以后数据就丢失了，即使用了纽扣电池也没用。所以必须要使用LP，也就是SRTC。RTC分为SNVS_LP和SNVS_HP，如果做产品，建议使用外置RTC芯片，PCF8563。RTC很类似定时器，外接32.768KHz的晶振，然后就开始计时，RTC使用两个寄存器来保存计数值。 其实不管是 SNVS_HP 里面的 RTC，还是 SNVS_LP 里面的 SRTC，其本质就是一个定时器，和EPIT 定时器一样，只要给它提供时钟，它就会一直运行。SRTC 需要 外界提供一个 32.768KHz 的时钟，I.MX6U-ALPHA 核心板上的 32.768KHz 的晶振就是提供这个时钟的。寄存器 SNVS_LPSRTCMR 和 SNVS_LPSRTCLR 保存着秒数，直接读取这两个寄存 器的值就知道过了多长时间了。一般以 1970 年 1 月 1 日为起点，加上经过的秒数即可得到现在 的时间和日期，原理还是很简单的。SRTC 也是带有闹钟功能的，可以在寄存器 SNVS_LPAR 中 写入闹钟时间值，当时钟值和闹钟值匹配的时候就会产生闹钟中断，要使用时钟功能的话还需要进行一些设置， RTC使用很简单，打开RTC，然后RTC就开始工作，我们要做的就是不断地读取RTC计数寄存器，获取时间值，或者向RTC计数器写入时间值，也就是调整时间。SNVS_HPCOMR的bit31置1，表示所有的软件都可以访问SNVS所有寄存器。Bit8也是和安全有关的，我们置1，也可以不置1. SNVS_LPCR寄存器，bit0置1，开始SRTC功能。 SNVS_LPSRTCMR的bit14:0为RTC计数寄存器的高15位 SNVS_LPSRTCLR是低32为RTC计数器，与LPSRTCMR共同组成了SRTC计数器，，每1秒数据加1。 6U的RTC模式从1970年1月1日0时0点0分0秒。 二、实验程序编写12345678910111213141516171819202122232425262728293031&#x2F;***************************************************************文件名 : bsp_rtc.c描述 : RTC驱动头文件。***************************************************************&#x2F;&#x2F;* 相关宏定义 *&#x2F; #define SECONDS_IN_A_DAY (86400) &#x2F;* 一天86400秒 *&#x2F;#define SECONDS_IN_A_HOUR (3600) &#x2F;* 一个小时3600秒 *&#x2F;#define SECONDS_IN_A_MINUTE (60) &#x2F;* 一分钟60秒 *&#x2F;#define DAYS_IN_A_YEAR (365) &#x2F;* 一年365天 *&#x2F;#define YEAR_RANGE_START (1970) &#x2F;* 开始年份1970年 *&#x2F;#define YEAR_RANGE_END (2099) &#x2F;* 结束年份2099年 *&#x2F;&#x2F;* 时间日期结构体 *&#x2F; struct rtc_datetime&#123; unsigned short year; &#x2F;* 范围为:1970 ~ 2099 *&#x2F; unsigned char month; &#x2F;* 范围为:1 ~ 12 *&#x2F; unsigned char day; &#x2F;* 范围为:1 ~ 31 (不同的月，天数不同).*&#x2F; unsigned char hour; &#x2F;* 范围为:0 ~ 23 *&#x2F; unsigned char minute; &#x2F;* 范围为:0 ~ 59 *&#x2F; unsigned char second; &#x2F;* 范围为:0 ~ 59 *&#x2F;&#125;;&#x2F;* 函数声明 *&#x2F;void rtc_init(void);void rtc_enable(void);void rtc_disable(void);unsigned int rtc_coverdate_to_seconds(struct rtc_datetime *datetime);unsigned int rtc_getseconds(void);void rtc_setdatetime(struct rtc_datetime *datetime);void rtc_getdatetime(struct rtc_datetime *datetime); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219&#x2F;***************************************************************文件名 : bsp_rtc.c描述 : RTC驱动文件。***************************************************************&#x2F;&#x2F;* * 描述:初始化RTC *&#x2F;void rtc_init(void)&#123; &#x2F;* * 设置HPCOMR寄存器 * bit[31] 1 : 允许访问SNVS寄存器，一定要置1 * bit[8] 1 : 此位置1，需要签署NDA协议才能看到此位的详细说明， * 这里不置1也没问题 *&#x2F; SNVS-&gt;HPCOMR |&#x3D; (1 &lt;&lt; 31) | (1 &lt;&lt; 8); #if 0 struct rtc_datetime rtcdate; rtcdate.year &#x3D; 2018U; rtcdate.month &#x3D; 12U; rtcdate.day &#x3D; 13U; rtcdate.hour &#x3D; 14U; rtcdate.minute &#x3D; 52; rtcdate.second &#x3D; 0; rtc_setDatetime(&amp;rtcdate); &#x2F;&#x2F;初始化时间和日期#endif rtc_enable(); &#x2F;&#x2F;使能RTC&#125;&#x2F;* * 描述: 开启RTC *&#x2F;void rtc_enable(void)&#123; &#x2F;* * LPCR寄存器bit0置1，使能RTC *&#x2F; SNVS-&gt;LPCR |&#x3D; 1 &lt;&lt; 0; while(!(SNVS-&gt;LPCR &amp; 0X01));&#x2F;&#x2F;等待使能完成 &#125;&#x2F;* * 描述: 关闭RTC *&#x2F;void rtc_disable(void)&#123; &#x2F;* * LPCR寄存器bit0置0，关闭RTC *&#x2F; SNVS-&gt;LPCR &amp;&#x3D; ~(1 &lt;&lt; 0); while(SNVS-&gt;LPCR &amp; 0X01);&#x2F;&#x2F;等待关闭完成&#125;&#x2F;* * @description : 判断指定年份是否为闰年，闰年条件如下: * @param - year: 要判断的年份 * @return : 1 是闰年，0 不是闰年 *&#x2F;unsigned char rtc_isleapyear(unsigned short year)&#123; unsigned char value&#x3D;0; if(year % 400 &#x3D;&#x3D; 0) value &#x3D; 1; else &#123; if((year % 4 &#x3D;&#x3D; 0) &amp;&amp; (year % 100 !&#x3D; 0)) value &#x3D; 1; else value &#x3D; 0; &#125; return value;&#125;&#x2F;* * @description : 将时间转换为秒数 * @param - datetime: 要转换日期和时间。 * @return : 转换后的秒数 *&#x2F;unsigned int rtc_coverdate_to_seconds(struct rtc_datetime *datetime)&#123; unsigned short i &#x3D; 0; unsigned int seconds &#x3D; 0; unsigned int days &#x3D; 0; unsigned short monthdays[] &#x3D; &#123;0U, 0U, 31U, 59U, 90U, 120U, 151U, 181U, 212U, 243U, 273U, 304U, 334U&#125;; for(i &#x3D; 1970; i &lt; datetime-&gt;year; i++) &#123; days +&#x3D; DAYS_IN_A_YEAR; &#x2F;* 平年，每年365天 *&#x2F; if(rtc_isleapyear(i)) days +&#x3D; 1;&#x2F;* 闰年多加一天 *&#x2F; &#125; days +&#x3D; monthdays[datetime-&gt;month]; if(rtc_isleapyear(i) &amp;&amp; (datetime-&gt;month &gt;&#x3D; 3)) days +&#x3D; 1;&#x2F;* 闰年，并且当前月份大于等于3月的话加一天 *&#x2F; days +&#x3D; datetime-&gt;day - 1; seconds &#x3D; days * SECONDS_IN_A_DAY + datetime-&gt;hour * SECONDS_IN_A_HOUR + datetime-&gt;minute * SECONDS_IN_A_MINUTE + datetime-&gt;second; return seconds; &#125;&#x2F;* * @description : 设置时间和日期 * @param - datetime: 要设置的日期和时间 * @return : 无 *&#x2F;void rtc_setdatetime(struct rtc_datetime *datetime)&#123; unsigned int seconds &#x3D; 0; unsigned int tmp &#x3D; SNVS-&gt;LPCR; rtc_disable(); &#x2F;* 设置寄存器HPRTCMR和HPRTCLR的时候一定要先关闭RTC *&#x2F; &#x2F;* 先将时间转换为秒 *&#x2F; seconds &#x3D; rtc_coverdate_to_seconds(datetime); SNVS-&gt;LPSRTCMR &#x3D; (unsigned int)(seconds &gt;&gt; 17); &#x2F;* 设置高16位 *&#x2F; SNVS-&gt;LPSRTCLR &#x3D; (unsigned int)(seconds &lt;&lt; 15); &#x2F;* 设置地16位 *&#x2F; &#x2F;* 如果此前RTC是打开的在设置完RTC时间以后需要重新打开RTC *&#x2F; if (tmp &amp; 0x1) rtc_enable();&#125;&#x2F;* * @description : 将秒数转换为时间 * @param - seconds : 要转换的秒数 * @param - datetime: 转换后的日期和时间 * @return : 无 *&#x2F;void rtc_convertseconds_to_datetime(unsigned int seconds, struct rtc_datetime *datetime)&#123; unsigned int x; unsigned int secondsRemaining, days; unsigned short daysInYear; &#x2F;* 每个月的天数 *&#x2F; unsigned char daysPerMonth[] &#x3D; &#123;0U, 31U, 28U, 31U, 30U, 31U, 30U, 31U, 31U, 30U, 31U, 30U, 31U&#125;; secondsRemaining &#x3D; seconds; &#x2F;* 剩余秒数初始化 *&#x2F; days &#x3D; secondsRemaining &#x2F; SECONDS_IN_A_DAY + 1; &#x2F;* 根据秒数计算天数,加1是当前天数 *&#x2F; secondsRemaining &#x3D; secondsRemaining % SECONDS_IN_A_DAY; &#x2F;*计算天数以后剩余的秒数 *&#x2F; &#x2F;* 计算时、分、秒 *&#x2F; datetime-&gt;hour &#x3D; secondsRemaining &#x2F; SECONDS_IN_A_HOUR; secondsRemaining &#x3D; secondsRemaining % SECONDS_IN_A_HOUR; datetime-&gt;minute &#x3D; secondsRemaining &#x2F; 60; datetime-&gt;second &#x3D; secondsRemaining % SECONDS_IN_A_MINUTE; &#x2F;* 计算年 *&#x2F; daysInYear &#x3D; DAYS_IN_A_YEAR; datetime-&gt;year &#x3D; YEAR_RANGE_START; while(days &gt; daysInYear) &#123; &#x2F;* 根据天数计算年 *&#x2F; days -&#x3D; daysInYear; datetime-&gt;year++; &#x2F;* 处理闰年 *&#x2F; if (!rtc_isleapyear(datetime-&gt;year)) daysInYear &#x3D; DAYS_IN_A_YEAR; else &#x2F;*闰年，天数加一 *&#x2F; daysInYear &#x3D; DAYS_IN_A_YEAR + 1; &#125; &#x2F;*根据剩余的天数计算月份 *&#x2F; if(rtc_isleapyear(datetime-&gt;year)) &#x2F;* 如果是闰年的话2月加一天 *&#x2F; daysPerMonth[2] &#x3D; 29; for(x &#x3D; 1; x &lt;&#x3D; 12; x++) &#123; if (days &lt;&#x3D; daysPerMonth[x]) &#123; datetime-&gt;month &#x3D; x; break; &#125; else &#123; days -&#x3D; daysPerMonth[x]; &#125; &#125; datetime-&gt;day &#x3D; days;&#125;&#x2F;* * @description : 获取RTC当前秒数 * @param : 无 * @return : 当前秒数 *&#x2F;unsigned int rtc_getseconds(void)&#123; unsigned int seconds &#x3D; 0; seconds &#x3D; (SNVS-&gt;LPSRTCMR &lt;&lt; 17) | (SNVS-&gt;LPSRTCLR &gt;&gt; 15); return seconds;&#125;&#x2F;* * @description : 获取当前时间 * @param - datetime: 获取到的时间，日期等参数 * @return : 无 *&#x2F;void rtc_getdatetime(struct rtc_datetime *datetime)&#123; unsigned int seconds &#x3D; 0; seconds &#x3D; rtc_getseconds(); rtc_convertseconds_to_datetime(seconds, datetime); &#125;","link":"","tags":[]},{"title":"IMX6U-LCD显示","date":"2021-04-11T12:14:42.000Z","path":"2021/04/11/IMX6U-LCD显示/","text":"一、RGBLCD显示原理简介1、像素点RGBLCD屏幕他都是有由一个个的彩色小灯构成的。彩色点阵屏每个像素点有三个小灯，红色、绿色和蓝色，也叫做RGB。RGB就是光的三原色。通过调整RGB三种颜色的比例，就可以实现姹紫千红的世界。 2、分辨率​ 要想显示文字，图片，视频等等就需要很多个像素点，分辨率说的就是像素点的个数，1080P、720P、2K、4K，8K。1080P=19201080，表示一行有1920个像素点，一列有1080个。显示器有尺寸！24村，27村、55寸。尺寸不变的情况下，分辨率越高，显示效果越精细。4K=38402160相当于4个1080P 3、像素格式​ 如何将RGB三种颜色进行量化，每种颜色用8bit表示，RGB就需要888共24bit。可以描述出2^24=中颜色16777216=1677万种颜色。现在流行10bit，HDR10，支持HDR效果的10bit面板，RGB10 10 10。在RGB888的基础上在加上8bit的ALPHA通道，也就是透明通道，ARGB8888=32位。 4、LCD屏幕接口RGB格式的屏幕，一般叫做RGB接口屏。屏幕接口有：MIPI、LVDS、MCU、RGB接口。 正点原子屏幕ID：使用ID可以识别出不同的屏幕，在RGBLCD屏幕上对R7，G7，B7焊接上拉或下拉电阻实现不同的ID。正点原子的ALLPHA地板RGB屏幕接口用了3个3157模拟开关。原因是防止LCD屏幕上的ID电阻影响到6ULL的启动。 5、LCD时间参数和LCD时序​ 水平： ​ HSYNC：水平同步信号，行同步信号，当出现HSYNC信号的时候表示新的一行开始显示 ​ 1、产生HSYNC信号，表示新的一行开始显示，HSYNC信号得维持一段时间，这个时间叫做HSPW。 ​ 2、HSYNC信号完成以后，需要一段时间延时，这段时间叫做HBP。 ​ 3、显示1024个像素点的数据，1024个clk。 ​ 3、一行像素显示完成以后，到HSYNC下一行信号的产生之间有个延时，叫做HFP。 ​ 因此真正显示一行所需的时间计时HSPW+HBP+WIDTH(屏幕水平像素点个数，比如1024)+HFP=20+140+1024+160=1344CLK. ​ 垂直： ​ VSYNC：垂直同步信号，帧同步信号，当出现VSYNC信号的时候表示新的一帧开始显示。 ​ 1、VSYNC信号，持续一段时间，位VSPW。 ​ 2、VSYNC信号完成以后，需要一段时间，叫做VBP ​ 3、VBP信号结束以后，就是要显示的行数，比如600行， ​ 4、所有的行显示完成以后，一段VFP延时， ​ （VSPW+VBP+height(600)+VFP）* （HSPW+HBP+WIDTH(1024)+HFP）= ​ 像素时钟： 6、显存采用 ARGB8888 格式的话一个像素需要 4 个字节的内存来存放像素数据，那么 1024600 分辨率就需要 1024600*4=2457600B≈2.4MB 内存。但是 RGB LCD 内部是没有内存的，所以就需要在开发板上的 DDR3 中分出一段内存作为 RGB LCD 屏幕的显存，我们如果要在屏幕上显示什么图像的话直接操作这部分显存即可。 显示存储空间，采用ARGB8888=32bit=4B。这4个字节的数据表示一个像素点的信息，必须得存起来。10246004=2.5MB。因此需要流出2.5MB的内存给LCD用，方法很简单，直接定义一个32位的数组，u32 lcdframe[1024*600]; 二、6ULL-LCDIF控制器接口原理1、我们使用DOTCLK接口，也就是VSYNC、HSYNC、ENABLE(DE)和DOTCLK(PCLK) 2、LCDIF_CTRL寄存器，bit0必须置1，bit1设置数据格式24位全部有效，设置为0。Bit5设置LCDIF接口工作在主机模式下，要置1。Bit9:8设置输入像素格式位24bit，写3。Bit11：10，设置数据传输宽度位24bit，写3。Bit13：12设置数据交换，我们不需要交换设置位0。Bit15:14设置输入数据交换，不交换设置位0。Bit17置1，LCDIF工作在DOTCLK模式下。Bit19必须置1，因为工作在DOTCL模式。Bit31是复位功能必须置0. 3、LCDIF_CTRL1寄存器的bit19:16设置位0X7。24位的格式， 4、LCDIF_TRANSFER_COUNT寄存器的bit15：0是LCD一行的像素数，1024。Bit31:16是LCD一共有多少行，600行。 5、LCDIF_VDCTRL0寄存器，bit17:0为vspw参数。Bit20设置vsync信号的宽度单位 ，设置为1。Bit21设置为1。Bit24设置ENABLE信号极性，为0的时候是低电平有效，为1是高电平，我们设置为1。Bit25设置CLK信号极性，设置为0.。bit26设置HSYNC信号极性，设置0，低电平有效，bit27设置VSYNC信号极性，设置为0，低电平有效。Bit28设置1，开始ENABLE信号。Bit29设置为0，VSYNC输出。 6、LCDIF_VDCTRL1寄存器为两个VSYNC信号之间的长度，那就是VSPW+ VBPD+HEIGHT+VFP。 7、CDIF_VDCTRL2寄存器bit17：0是两个HSYNC信号之间的长度，那就是hspw+hbp+width+hfp。Bit31:18为hspw。 8、LCDIF_VDCTRL3寄存器，bit15:0是vbp+vspw。Bit27:16是hbp+hspw。 9、LCDIF_VDCTRL4寄存器，bit17:0是一行有多少个像素点，1024 10、LCDIF_CUR_BUF，LCD当前缓存，显存首地址。 11、LCDIF_NEXT_BUF,LCD下一帧数据首地址。 12、LCD IO初始化 三、LCD像素时钟的设置LCD需要一个CLK信号，这个时钟信号是6ULL的CLK引脚发送给RGB LCD的。比如7寸1024*600的屏幕需要51.2MHz的CLK。 LCDIF_CLK_ROOT就是6ULL的像素时钟。我们设置PLL5(video PLL)为LCD的时钟源， PLL5 CLK=Fref*DIV_SELECT=，DIV_SELECT就是CCM_ANALOG_PLL_VIDEO的bit6:0，也就是DIV_SELEC位，可选范围27-54。设置PLL_VIDEO寄存器的bit20:19为2，表示1分频。设置CCM_ANALOG_MISC2寄存器的bit31:30为0，也就是VIDOE_DIV为0，1分频。 不用小数分频器，因此CCM_ANALOG_PLL_VIDEO_NUM=0，在设置CCM_ALALOG_PLL_VIDEO_DENOM=0。 CCM_CSCDR2寄存器的bit17:15，设置LCDIF_PRE_CLK_SEL，选择LCDIF_CLK_ROOT的时钟源，设置为0x2。表示LCDIF时钟源为PLL5。Bit14:12为LCDIF_PRED位，设置前级分频，可以设置07，分别对应18分频。 CCM_CBCMR寄存器，bit25:23为LCDIF_PODF，设置第二级分频，可以设置为07，分别对应18分频。 继续设置CCM_CSCDR2寄存器的bit11：9为LCDIF_CLK_SEL，选择LCD CLK的最终时钟源，设置为0，LCDIF的最终时钟源来源于pre-muxed LCDIF clock 四、LCD驱动程序编写1、初始化 LCD 所使用的 IO 首先肯定是初始化 LCD 所示使用的 IO，将其复用为 eLCDIF 接口 IO。 2、设置 LCD 的像素时钟 查阅所使用的 LCD 屏幕数据手册，或者自己计算出的时钟像素，然后设置 CCM 相应的寄 存器。 3、配置 eLCDIF 接口 设置 LCDIF 的寄存器 CTRL、CTRL1、TRANSFER_COUNT、VDCTRL0~4、CUR_BUF 和 NEXT_BUF。根据 LCD 的数据手册设置相应的参数。 4、编写API 函数 驱动 LCD 屏幕的目的就是显示内容，所以需要编写一些基本的 API 函数，比如画点、画线、画圆函数，字符串显示函数等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451&#x2F;***************************************************************文件名 : bsp_lcd.c描述 : LCD驱动文件。***************************************************************&#x2F;* 液晶屏参数结构体 *&#x2F;struct tftlcd_typedef tftlcd_dev;&#x2F;* * @description : 始化LCD * @param : 无 * @return : 无 *&#x2F;void lcd_init(void)&#123; unsigned short lcdid &#x3D; 0; lcdid &#x3D; lcd_read_panelid(); &#x2F;* 读取屏幕ID值 *&#x2F; printf(&quot;LCD ID&#x3D;%#X\\r\\n&quot;, lcdid); lcdgpio_init(); &#x2F;* 初始化IO *&#x2F; lcd_reset(); &#x2F;* 复位LCD *&#x2F; delayms(10); &#x2F;* 延时10ms *&#x2F; lcd_noreset(); &#x2F;* 结束复位 *&#x2F; &#x2F;* TFTLCD参数结构体初始化 *&#x2F; tftlcd_dev.height &#x3D; 600; tftlcd_dev.width &#x3D; 1024; tftlcd_dev.vspw &#x3D; 3; tftlcd_dev.vbpd &#x3D; 20; tftlcd_dev.vfpd &#x3D; 12; tftlcd_dev.hspw &#x3D; 20; tftlcd_dev.hbpd &#x3D; 140; tftlcd_dev.hfpd &#x3D; 160; lcdclk_init(32, 3, 5); &#x2F;* 初始化LCD时钟 51.2MHz *&#x2F; tftlcd_dev.pixsize &#x3D; 4; &#x2F;* ARGB8888模式，每个像素4字节 *&#x2F; tftlcd_dev.framebuffer &#x3D; LCD_FRAMEBUF_ADDR; tftlcd_dev.backcolor &#x3D; LCD_WHITE; &#x2F;* 背景色为白色 *&#x2F; tftlcd_dev.forecolor &#x3D; LCD_BLACK; &#x2F;* 前景色为黑色 *&#x2F; &#x2F;* 初始化ELCDIF的CTRL寄存器 * bit [31] 0 : 停止复位 * bit [19] 1 : 旁路计数器模式 * bit [17] 1 : LCD工作在dotclk模式 * bit [15:14] 00 : 输入数据不交换 * bit [13:12] 00 : CSC不交换 * bit [11:10] 11 : 24位总线宽度 * bit [9:8] 11 : 24位数据宽度,也就是RGB888 * bit [5] 1 : elcdif工作在主模式 * bit [1] 0 : 所有的24位均有效 *&#x2F; LCDIF-&gt;CTRL |&#x3D; (1 &lt;&lt; 19) | (1 &lt;&lt; 17) | (0 &lt;&lt; 14) | (0 &lt;&lt; 12) | (3 &lt;&lt; 10) | (3 &lt;&lt; 8) | (1 &lt;&lt; 5) | (0 &lt;&lt; 1); &#x2F;* * 初始化ELCDIF的寄存器CTRL1 * bit [19:16] : 0X7 ARGB模式下，传输24位数据，A通道不用传输 *&#x2F; LCDIF-&gt;CTRL1 &#x3D; 0X7 &lt;&lt; 16; &#x2F;* * 初始化ELCDIF的寄存器TRANSFER_COUNT寄存器 * bit [31:16] : 高度 * bit [15:0] : 宽度 *&#x2F; LCDIF-&gt;TRANSFER_COUNT &#x3D; (tftlcd_dev.height &lt;&lt; 16) | (tftlcd_dev.width &lt;&lt; 0); &#x2F;* * 初始化ELCDIF的VDCTRL0寄存器 * bit [29] 0 : VSYNC输出 * bit [28] 1 : 使能ENABLE输出 * bit [27] 0 : VSYNC低电平有效 * bit [26] 0 : HSYNC低电平有效 * bit [25] 0 : DOTCLK上升沿有效 * bit [24] 1 : ENABLE信号高电平有效 * bit [21] 1 : DOTCLK模式下设置为1 * bit [20] 1 : DOTCLK模式下设置为1 * bit [17:0] : vsw参数 *&#x2F; LCDIF-&gt;VDCTRL0 &#x3D; 0; &#x2F;&#x2F;先清零 LCDIF-&gt;VDCTRL0 &#x3D; (0 &lt;&lt; 29) | (1 &lt;&lt; 28) | (0 &lt;&lt; 27) | (0 &lt;&lt; 26) | (0 &lt;&lt; 25) | (1 &lt;&lt; 24) | (1 &lt;&lt; 21) | (1 &lt;&lt; 20) | (tftlcd_dev.vspw &lt;&lt; 0); &#x2F;* * 初始化ELCDIF的VDCTRL1寄存器 * 设置VSYNC总周期 *&#x2F; LCDIF-&gt;VDCTRL1 &#x3D; tftlcd_dev.height + tftlcd_dev.vspw + tftlcd_dev.vfpd + tftlcd_dev.vbpd; &#x2F;&#x2F;VSYNC周期 &#x2F;* * 初始化ELCDIF的VDCTRL2寄存器 * 设置HSYNC周期 * bit[31:18] ：hsw * bit[17:0] : HSYNC总周期 *&#x2F; LCDIF-&gt;VDCTRL2 &#x3D; (tftlcd_dev.hspw &lt;&lt; 18) | (tftlcd_dev.width + tftlcd_dev.hspw + tftlcd_dev.hfpd + tftlcd_dev.hbpd); &#x2F;* * 初始化ELCDIF的VDCTRL3寄存器 * 设置HSYNC周期 * bit[27:16] ：水平等待时钟数 * bit[15:0] : 垂直等待时钟数 *&#x2F; LCDIF-&gt;VDCTRL3 &#x3D; ((tftlcd_dev.hbpd + tftlcd_dev.hspw) &lt;&lt; 16) | (tftlcd_dev.vbpd + tftlcd_dev.vspw); &#x2F;* * 初始化ELCDIF的VDCTRL4寄存器 * 设置HSYNC周期 * bit[18] 1 : 当使用VSHYNC、HSYNC、DOTCLK的话此为置1 * bit[17:0] : 宽度 *&#x2F; LCDIF-&gt;VDCTRL4 &#x3D; (1&lt;&lt;18) | (tftlcd_dev.width); &#x2F;* * 初始化ELCDIF的CUR_BUF和NEXT_BUF寄存器 * 设置当前显存地址和下一帧的显存地址 *&#x2F; LCDIF-&gt;CUR_BUF &#x3D; (unsigned int)tftlcd_dev.framebuffer; LCDIF-&gt;NEXT_BUF &#x3D; (unsigned int)tftlcd_dev.framebuffer; lcd_enable(); &#x2F;* 使能LCD *&#x2F; delayms(10); lcd_clear(LCD_WHITE); &#x2F;* 清屏 *&#x2F; &#125;&#x2F;* * 读取屏幕ID， * 描述：LCD_DATA23&#x3D;R7(M0);LCD_DATA15&#x3D;G7(M1);LCD_DATA07&#x3D;B7(M2); * M2:M1:M0 * 0 :0 :0 &#x2F;&#x2F;4.3寸480*272 RGB屏,ID&#x3D;0X4342 * 0 :0 :1 &#x2F;&#x2F;7寸800*480 RGB屏,ID&#x3D;0X7084 * 0 :1 :0 &#x2F;&#x2F;7寸1024*600 RGB屏,ID&#x3D;0X7016 * 1 :0 :1 &#x2F;&#x2F;10.1寸1280*800,RGB屏,ID&#x3D;0X1018 * 1 :0 :0 &#x2F;&#x2F;4.3寸800*480 RGB屏,ID&#x3D;0X4384 * @param : 无 * @return : 屏幕ID *&#x2F;unsigned short lcd_read_panelid(void)&#123; unsigned char idx &#x3D; 0; &#x2F;* 配置屏幕ID信号线 *&#x2F; IOMUXC_SetPinMux(IOMUXC_LCD_VSYNC_GPIO3_IO03, 0); IOMUXC_SetPinConfig(IOMUXC_LCD_VSYNC_GPIO3_IO03, 0X10B0); &#x2F;* 打开模拟开关 *&#x2F; gpio_pin_config_t idio_config; idio_config.direction &#x3D; kGPIO_DigitalOutput; idio_config.outputLogic &#x3D; 1; gpio_init(GPIO3, 3, &amp;idio_config); &#x2F;* 读取ID值，设置G7 B7 R7为输入 *&#x2F; IOMUXC_SetPinMux(IOMUXC_LCD_DATA07_GPIO3_IO12, 0); &#x2F;* B7(M2) *&#x2F; IOMUXC_SetPinMux(IOMUXC_LCD_DATA15_GPIO3_IO20, 0); &#x2F;* G7(M1) *&#x2F; IOMUXC_SetPinMux(IOMUXC_LCD_DATA23_GPIO3_IO28, 0); &#x2F;* R7(M0) *&#x2F; IOMUXC_SetPinConfig(IOMUXC_LCD_DATA07_GPIO3_IO12, 0xF080); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA15_GPIO3_IO20, 0xF080); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA23_GPIO3_IO28, 0xF080); idio_config.direction &#x3D; kGPIO_DigitalInput; gpio_init(GPIO3, 12, &amp;idio_config); gpio_init(GPIO3, 20, &amp;idio_config); gpio_init(GPIO3, 28, &amp;idio_config); idx &#x3D; (unsigned char)gpio_pinread(GPIO3, 28); &#x2F;* 读取M0 *&#x2F; idx |&#x3D; (unsigned char)gpio_pinread(GPIO3, 20) &lt;&lt; 1; &#x2F;* 读取M1 *&#x2F; idx |&#x3D; (unsigned char)gpio_pinread(GPIO3, 12) &lt;&lt; 2; &#x2F;* 读取M2 *&#x2F; if(idx&#x3D;&#x3D;0)return ATK4342; &#x2F;&#x2F;4.3寸屏,480*272分辨率 else if(idx&#x3D;&#x3D;1)return ATK7084; &#x2F;&#x2F;7寸屏,800*480分辨率 else if(idx&#x3D;&#x3D;2)return ATK7016; &#x2F;&#x2F;7寸屏,1024*600分辨率 else if(idx&#x3D;&#x3D;4)return ATK4384; &#x2F;&#x2F;4寸屏,800*480分辨率 else if(idx&#x3D;&#x3D;5)return ATK1018; &#x2F;&#x2F;10.1寸屏,1280*800分辨率 else return 0;&#125;&#x2F;* * IO引脚: LCD_DATA00 -&gt; LCD_B0 * LCD_DATA01 -&gt; LCD_B1 * LCD_DATA02 -&gt; LCD_B2 * LCD_DATA03 -&gt; LCD_B3 * LCD_DATA04 -&gt; LCD_B4 * LCD_DATA05 -&gt; LCD_B5 * LCD_DATA06 -&gt; LCD_B6 * LCD_DATA07 -&gt; LCD_B7 * * LCD_DATA08 -&gt; LCD_G0 * LCD_DATA09 -&gt; LCD_G1 * LCD_DATA010 -&gt; LCD_G2 * LCD_DATA011 -&gt; LCD_G3 * LCD_DATA012 -&gt; LCD_G4 * LCD_DATA012 -&gt; LCD_G4 * LCD_DATA013 -&gt; LCD_G5 * LCD_DATA014 -&gt; LCD_G6 * LCD_DATA015 -&gt; LCD_G7 * * LCD_DATA016 -&gt; LCD_R0 * LCD_DATA017 -&gt; LCD_R1 * LCD_DATA018 -&gt; LCD_R2 * LCD_DATA019 -&gt; LCD_R3 * LCD_DATA020 -&gt; LCD_R4 * LCD_DATA021 -&gt; LCD_R5 * LCD_DATA022 -&gt; LCD_R6 * LCD_DATA023 -&gt; LCD_R7 * * LCD_CLK -&gt; LCD_CLK * LCD_VSYNC -&gt; LCD_VSYNC * LCD_HSYNC -&gt; LCD_HSYNC * LCD_DE -&gt; LCD_DE * LCD_BL -&gt; GPIO1_IO08 *&#x2F; &#x2F;* * @description : LCD GPIO初始化 * @param : 无 * @return : 无 *&#x2F;void lcdgpio_init(void)&#123; gpio_pin_config_t gpio_config; &#x2F;* 1、IO初始化复用功能 *&#x2F; IOMUXC_SetPinMux(IOMUXC_LCD_DATA00_LCDIF_DATA00,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA01_LCDIF_DATA01,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA02_LCDIF_DATA02,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA03_LCDIF_DATA03,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA04_LCDIF_DATA04,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA05_LCDIF_DATA05,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA06_LCDIF_DATA06,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA07_LCDIF_DATA07,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA08_LCDIF_DATA08,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA09_LCDIF_DATA09,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA10_LCDIF_DATA10,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA11_LCDIF_DATA11,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA12_LCDIF_DATA12,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA13_LCDIF_DATA13,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA14_LCDIF_DATA14,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA15_LCDIF_DATA15,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA16_LCDIF_DATA16,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA17_LCDIF_DATA17,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA18_LCDIF_DATA18,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA19_LCDIF_DATA19,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA20_LCDIF_DATA20,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA21_LCDIF_DATA21,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA22_LCDIF_DATA22,0); IOMUXC_SetPinMux(IOMUXC_LCD_DATA23_LCDIF_DATA23,0); IOMUXC_SetPinMux(IOMUXC_LCD_CLK_LCDIF_CLK,0); IOMUXC_SetPinMux(IOMUXC_LCD_ENABLE_LCDIF_ENABLE,0); IOMUXC_SetPinMux(IOMUXC_LCD_HSYNC_LCDIF_HSYNC,0); IOMUXC_SetPinMux(IOMUXC_LCD_VSYNC_LCDIF_VSYNC,0); IOMUXC_SetPinMux(IOMUXC_GPIO1_IO08_GPIO1_IO08,0); &#x2F;* 背光BL引脚 *&#x2F; &#x2F;* 2、配置LCD IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 0 默认22K上拉 *bit [13]: 0 pull功能 *bit [12]: 0 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 111 驱动能力为R0&#x2F;7 *bit [0]: 1 高转换率 *&#x2F; IOMUXC_SetPinConfig(IOMUXC_LCD_DATA00_LCDIF_DATA00,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA01_LCDIF_DATA01,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA02_LCDIF_DATA02,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA03_LCDIF_DATA03,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA04_LCDIF_DATA04,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA05_LCDIF_DATA05,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA06_LCDIF_DATA06,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA07_LCDIF_DATA07,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA08_LCDIF_DATA08,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA09_LCDIF_DATA09,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA10_LCDIF_DATA10,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA11_LCDIF_DATA11,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA12_LCDIF_DATA12,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA13_LCDIF_DATA13,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA14_LCDIF_DATA14,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA15_LCDIF_DATA15,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA16_LCDIF_DATA16,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA17_LCDIF_DATA17,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA18_LCDIF_DATA18,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA19_LCDIF_DATA19,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA20_LCDIF_DATA20,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA21_LCDIF_DATA21,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA22_LCDIF_DATA22,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_DATA23_LCDIF_DATA23,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_CLK_LCDIF_CLK,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_ENABLE_LCDIF_ENABLE,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_HSYNC_LCDIF_HSYNC,0xB9); IOMUXC_SetPinConfig(IOMUXC_LCD_VSYNC_LCDIF_VSYNC,0xB9); IOMUXC_SetPinConfig(IOMUXC_GPIO1_IO08_GPIO1_IO08,0xB9); &#x2F;* 背光BL引脚 *&#x2F; &#x2F;* GPIO初始化 *&#x2F; gpio_config.direction &#x3D; kGPIO_DigitalOutput; &#x2F;* 输出 *&#x2F; gpio_config.outputLogic &#x3D; 1; &#x2F;* 默认关闭背光 *&#x2F; gpio_init(GPIO1, 8, &amp;gpio_config); &#x2F;* 背光默认打开 *&#x2F; gpio_pinwrite(GPIO1, 8, 1); &#x2F;* 打开背光 *&#x2F;&#125;&#x2F;* * @description : LCD时钟初始化, LCD时钟计算公式如下： * LCD CLK &#x3D; 24 * loopDiv &#x2F; prediv &#x2F; div * @param - loopDiv : loopDivider值 * @param - prediv : lcdifprediv值 * @param - div : lcdifdiv值 * @return : 无 *&#x2F;void lcdclk_init(unsigned char loopDiv, unsigned char prediv, unsigned char div)&#123; &#x2F;* 先初始化video pll * VIDEO PLL &#x3D; OSC24M * (loopDivider + (denominator &#x2F; numerator)) &#x2F; postDivider *不使用小数分频器，因此denominator和numerator设置为0 *&#x2F; CCM_ANALOG-&gt;PLL_VIDEO_NUM &#x3D; 0; &#x2F;* 不使用小数分频器 *&#x2F; CCM_ANALOG-&gt;PLL_VIDEO_DENOM &#x3D; 0; &#x2F;* * PLL_VIDEO寄存器设置 * bit[13]: 1 使能VIDEO PLL时钟 * bit[20:19] 2 设置postDivider为1分频 * bit[6:0] : 32 设置loopDivider寄存器 *&#x2F; CCM_ANALOG-&gt;PLL_VIDEO &#x3D; (2 &lt;&lt; 19) | (1 &lt;&lt; 13) | (loopDiv &lt;&lt; 0); &#x2F;* * MISC2寄存器设置 * bit[31:30]: 0 VIDEO的post-div设置，时钟源来源于postDivider，1分频 *&#x2F; CCM_ANALOG-&gt;MISC2 &amp;&#x3D; ~(3 &lt;&lt; 30); CCM_ANALOG-&gt;MISC2 &#x3D; 0 &lt;&lt; 30; &#x2F;* LCD时钟源来源与PLL5，也就是VIDEO PLL *&#x2F; CCM-&gt;CSCDR2 &amp;&#x3D; ~(7 &lt;&lt; 15); CCM-&gt;CSCDR2 |&#x3D; (2 &lt;&lt; 15); &#x2F;* 设置LCDIF_PRE_CLK使用PLL5 *&#x2F; &#x2F;* 设置LCDIF_PRE分频 *&#x2F; CCM-&gt;CSCDR2 &amp;&#x3D; ~(7 &lt;&lt; 12); CCM-&gt;CSCDR2 |&#x3D; (prediv - 1) &lt;&lt; 12; &#x2F;* 设置分频 *&#x2F; &#x2F;* 设置LCDIF分频 *&#x2F; CCM-&gt;CBCMR &amp;&#x3D; ~(7 &lt;&lt; 23); CCM-&gt;CBCMR |&#x3D; (div - 1) &lt;&lt; 23; &#x2F;* 设置LCD时钟源为LCDIF_PRE时钟 *&#x2F; CCM-&gt;CSCDR2 &amp;&#x3D; ~(7 &lt;&lt; 9); &#x2F;* 清除原来的设置 *&#x2F; CCM-&gt;CSCDR2 |&#x3D; (0 &lt;&lt; 9); &#x2F;* LCDIF_PRE时钟源选择LCDIF_PRE时钟 *&#x2F;&#125;&#x2F;* * @description : 复位ELCDIF接口 * @param : 无 * @return : 无 *&#x2F;void lcd_reset(void)&#123; LCDIF-&gt;CTRL &#x3D; 1&lt;&lt;31; &#x2F;* 强制复位 *&#x2F;&#125;&#x2F;* * @description : 结束复位ELCDIF接口 * @param : 无 * @return : 无 *&#x2F;void lcd_noreset(void)&#123; LCDIF-&gt;CTRL &#x3D; 0&lt;&lt;31; &#x2F;* 取消强制复位 *&#x2F;&#125;&#x2F;* * @description : 使能ELCDIF接口 * @param : 无 * @return : 无 *&#x2F;void lcd_enable(void)&#123; LCDIF-&gt;CTRL |&#x3D; 1&lt;&lt;0; &#x2F;* 使能ELCDIF *&#x2F;&#125;&#x2F;* * @description : 画点函数 * @param - x : x轴坐标 * @param - y : y轴坐标 * @param - color : 颜色值 * @return : 无 *&#x2F;inline void lcd_drawpoint(unsigned short x,unsigned short y,unsigned int color)&#123; *(unsigned int*)((unsigned int)tftlcd_dev.framebuffer + tftlcd_dev.pixsize * (tftlcd_dev.width * y+x))&#x3D;color;&#125;&#x2F;* * @description : 读取指定点的颜色值 * @param - x : x轴坐标 * @param - y : y轴坐标 * @return : 读取到的指定点的颜色值 *&#x2F;inline unsigned int lcd_readpoint(unsigned short x,unsigned short y)&#123; return *(unsigned int*)((unsigned int)tftlcd_dev.framebuffer + tftlcd_dev.pixsize * (tftlcd_dev.width * y + x));&#125;&#x2F;* * @description : 清屏 * @param - color : 颜色值 * @return : 读取到的指定点的颜色值 *&#x2F;void lcd_clear(unsigned int color)&#123; unsigned int num; unsigned int i &#x3D; 0; unsigned int *startaddr&#x3D;(unsigned int*)tftlcd_dev.framebuffer; &#x2F;&#x2F;指向帧缓存首地址 num&#x3D;(unsigned int)tftlcd_dev.width * tftlcd_dev.height; &#x2F;&#x2F;缓冲区总长度 for(i &#x3D; 0; i &lt; num; i++) &#123; startaddr[i] &#x3D; color; &#125; &#125;&#x2F;* * @description : 以指定的颜色填充一块矩形 * @param - x0 : 矩形起始点坐标X轴 * @param - y0 : 矩形起始点坐标Y轴 * @param - x1 : 矩形终止点坐标X轴 * @param - y1 : 矩形终止点坐标Y轴 * @param - color : 要填充的颜色 * @return : 读取到的指定点的颜色值 *&#x2F;void lcd_fill(unsigned short x0, unsigned short y0, unsigned short x1, unsigned short y1, unsigned int color)&#123; unsigned short x, y; if(x0 &lt; 0) x0 &#x3D; 0; if(y0 &lt; 0) y0 &#x3D; 0; if(x1 &gt;&#x3D; tftlcd_dev.width) x1 &#x3D; tftlcd_dev.width - 1; if(y1 &gt;&#x3D; tftlcd_dev.height) y1 &#x3D; tftlcd_dev.height - 1; for(y &#x3D; y0; y &lt;&#x3D; y1; y++) &#123; for(x &#x3D; x0; x &lt;&#x3D; x1; x++) lcd_drawpoint(x, y, color); &#125;&#125;","link":"","tags":[]},{"title":"IMX6U-DDR3","date":"2021-04-11T11:49:13.000Z","path":"2021/04/11/IMX6U-DDR3/","text":"一、DDR31、传输速率 2、tRCD 3、CL参数 4、tRC 5、tRAS ①、控制线 ODT：片上终端使能，ODT 使能和禁止片内终端电阻。 ZQ：输出驱动校准的外部参考引脚，此引脚应该外接一个 240 欧的电阻到 VSSQ 上，一般 就是直接接地了。 RESET：复位引脚，低电平有效 CKE：时钟使能引脚。 A12**：A12 是地址引脚，但是有也有另外一个功能，因此也叫做 BC 引脚，A12 会在 READ 和 WRITE 命令期间被采样，以决定 burst chop 是否会被执行。 CK 和 **CK#**：时钟信号，DDR3 的时钟线是差分时钟线，所有的控制和地址信号都会在 CK对的上升沿和 CK#的下降沿交叉处被采集。 **CS#**：片选信号，低电平有效。 **RAS#**、CAS#和WE#：行选通信号、列选通信号和写使能信号。 ②、地址线 A[14:0]为地址线，A0A14，一共 15 根地址线，根据 NT5CC256M16ER-EK 的数据手册可 知，列地址为 A0A9，共 10 根，行地址为 A0~A14，共 15 根，因此一个 BANK 的大小就是2^102^152=32MB2=64MB，根据图 23.1.4.2 可知一共有 8 个 BANK，因此 DDR3L 的容量就 是 648=512MB。 **③、BANK **选择线 一片 DDR3 有 8 个 BANK，因此需要 3 个线才能实现 8 个 BANK 的选择，BA0~BA2 就是 用于完成 BANK 选择的。 ④、BANK 区域 ：DDR3 一般都是 8 个 BANK 区域。 ⑤、数据线 ，因为是 16 位宽的，因此有 16 根数据线，分别为 DQ0~DQ15。 ⑥、数据选通引脚 DQS 和 DQS#是数据选通引脚，为差分信号，读的时候是输出，写的时候是输入。LDQS(有 的叫做 DQSL)和 LDQS#(有的叫做 DQSL#)对应低字节，也就是 DQ07，UDQS(有的叫做 DQSU) 和 UDQS#(有的叫做 DQSU#)，对应高字节，也就是 DQ815。 ⑦、数据输入屏蔽引脚 ：DM 是写数据收入屏蔽引脚。 三、I.MX6U MMDC控制器MMDC 外设包含一个内核 (MMDC_CORE)和 PHY(MMDC_PHY) MMDC 内核：内核负责通过 AXI 接口与系统进行通信、DDR 命令生成、DDR 命令优化、 读/写数据路径。 MMDC PHY：PHY 负责时序调整和校准，使用特殊的校准机制以保障数据能够在 400MHz 被准确捕获。 ​ 1、多模支持DDR3/DDR3L LPDDR2 x16位​ 2、MMDC最高支持DDR3频率是400MHz，800MT/S​ 3、MMDC提供的DDR3连接信号。6ULL给DDR提供了专用的IO， DDR时钟配置DDR使用的时钟源为MMDC_CLK_ROOT=PLL2_PFD2=396MHz。在前面历程已经设置为396MHz。CBCMR寄存器的PRE_PERIPH2_CLK_SE位来选择，也就是bit22:21，设置pre_periph2时钟源，设置为01，也就是PLL2_PFD2作为pre_periph2时钟源。CBCDR寄存器的PERIPH2_CLK_SEL位，也就是bit26，设置为0，PLL2作为MMDC时钟源，396MHz。CBCDR寄存器的FABRIC_MMDC_PODF位，bit5:3，设置0，也就是1分频。最终MMDC_CLK_ROOT=396MHz。 四、DDR校准 Write leveling calibration MMDC_MPWLDECTRL0 ch0 (0x021b080c) = 0x00000000 MMDC_MPWLDECTRL1 ch0 (0x021b0810) = 0x0007000 Read DQS Gating calibration MPDGCTRL0 PHY0 (0x021b083c) = 0x01380138 MPDGCTRL1 PHY0 (0x021b0840) = 0x00000000 Read calibration MPRDDLCTL PHY0 (0x021b0848) = 0x40402E32 Write calibration MPWRDLCTL PHY0 (0x021b0850) = 0x40403432 所谓的校准结果其实就是得到了一些寄存器对应的值，比如 MMDC_MPWLDECTRL0 寄 存器地址为 0X021B080C，此寄存器是 PHY 写平衡延时寄存器 0，经过校准以后此寄存器的值 应该为 0X00000000 ， 以 此 类 推 。 我 们 需 要 修 改 ALIENTEK_512MB.inc 文 件 ， 找 到 MMDC_MPWLDECTRL0、MMDC_MPWLDECTRL1、MPDGCTRL0 PHY0、MPDGCTRL1 PHY0、 MPRDDLCTL PHY0 和 MPWRDLCTL PHY0 这 6 个寄存器，然后将其值改为示例代码 23.5.3.1 中 的 校 准 后 的 值 。 注 意 ， 在 ALIENTEK_512MB.inc 中 可 能 找 不 到 MMDC_MPWLDECTRL1(0x021b0810)和 MPDGCTRL1 PHY0(0x021b0840)这两个寄存器，找不到就不用修改了","link":"","tags":[]},{"title":"RAM与ROM","date":"2021-04-11T09:51:51.000Z","path":"2021/04/11/RAM与ROM/","text":"RAM：随机存储器，可以随时进行读写操作，速度很快，掉电以后数据会丢失。比如内存 条、SRAM、SDRAM、DDR 等都是 RAM。RAM 一般用来保存程序数据、中间结果，们可以随意的对 RAM 中任何地址的数据进行读写操作， 非常方便。 ROM：只读存储器，目前“只读存储器”这个定义不准确。手机是 4+64 或 6+128 配置，说的就是 RAM 为 4GB 或 6GB，ROM 为 64G 或 128GB。但是这个 ROM 是 Flash，比如 EMMC 或 UFS 存储器，因为历史原因，很多人还是将Flash 叫做 ROM。但是 EMMC 和 UFS，甚至是 NAND Flash，这些都是可以进行写操作的！只是写起来比较麻烦，要先发送要先进行擦除，然后在发送要写的地址或扇区，最后才是要写入的数据。相比于 RAM，向 ROM 或者 Flash 写入数据要复杂很多，因此意味着速度就会变慢(相比 RAM)， 但是 ROM 和 Flash 可以将容量做的很大，而且掉电以后数据不会丢失，适合用来存储资料。 综上所述，RAM 速度快，可以直接和 CPU 进行通信，但是掉电以后数据会丢失，容量不 容易做大(和同价格的 Flash 相比)。ROM(目前来说，更适合叫做 Flash)速度虽然慢，但是容量大、适合存储数据。I.MX6U-ALPHA 开发板的256MB/512MB 的 DDR3 就是 RAM，而 512MB NANF Flash 或 8GB EMMC 就是 ROM。 SRAM：全称叫做 Static Random-Access Memory，也就是静态随机存储器，这里的“静态” 说的就是只要 SRAM 上电，那么 SRAM 里面的数据就会一直保存着，直到 SRAM 掉电。对于RAM而言需要可以随机的读取任意一个地址空间内的数据，因此采用了地址线和数据线分离的方式，SRAM 最大的缺点就是成本高！SRAM 突出的特点就是无需刷新(SDRAM 需要刷新)，读写速度快！所以 SRAM 通常作为 SOC 的内部 RAM 使用或 Cache 使用， SDRAM：全称是 Synchronous Dynamic Random Access Memory，同步动态随机存储器，“同步”的意思是 SDRAM 工作需要时钟线，“动态”的意思是 SDRAM 中的数据需要不断的刷新来保证数据不会丢失，“随机” 的意思就是可以读写任意地址的数据。 与 SRAM 相比，SDRAM 集成度高、功耗低、成本低、适合做大容量存储，但是需要定时 刷新来保证数据不会丢失。因此 SDRAM 适合用来做内存条，SRAM 适合做高速缓存或 MCU 内部的 RAM。 SDRAM 目前已经发展到了第四代，分别为：SDRAM、DDR SDRAM、DDR2 SDRAM、DDR3 SDRAM、DDR4 SDRAM。 DDR 内存是 SDRAM 的升级版本，SDRAM 分为 SDR SDRAM、DDR SDRAM、DDR2 SDRAM、DDR3 SDRAM、DDR4 SDRAM。可以看出 DDR 本质上还是SDRAM，只是随着技术的不断发展，DDR 也在不断的更新换代。 DDR 全称是 Double Data Rate SDRAM，也就是双倍速率 SDRAM，看名字就知道 DDR 的速率(数据传输速率)比 SDRAM 高 1 倍！这 1 倍的速度不是简简单单的将 CLK 提高 1 倍， SDRAM 在一个 CLK 周期传输一次数据，DDR 在一个 CLK 周期传输两次数据，也就是在上升沿和下降沿各传输一次数据，这个概念叫做预取(prefetch)，相当于 DDR 的预取为 2bit，因此 DDR 的速度直接加倍！同样 133200MHz的频率，DDR 的传输速度就变为了 266400MT/S，所以大家常说的 DDR266、DDR400 就是这么来的。 DDR2 的 IO 时钟是 DDR 的 2 倍，因此 DDR 内核时钟依旧是 133200MHz 的时候，总线 速度就是 266400MHz。而且 DDR2 在 DDR 基础上进一步增加预取(prefetch)，增加到了 4bit， 相当于比 DDR 多读取一倍的数据，因此 DDR2 的数据传输速率就是 533~800MT/s，这个也是大家常说的 DDR2 533、DDR2 800。 DDR3 在 DDR2 的基础上将预取(prefetch)提高到 8bit，因此又获得了比 DDR2 高一倍的传 输速率，因此在总线时钟同样为 266400MHz 的情况下，DDR3 的传输速率就是 10661600MT/S。 I.MX6U 的 MMDC 外设用于连接 DDR，支持 LPDDR2、DDR3、DDR3L，最高支持 16 位数据 位宽。总线速度为 400MHz(实际是 396MHz)，数据传输速率最大为 800MT/S。 LPDDR3、DDR3 和 DDR3L 的区别，这三个都是 DDR3，但是区别主要在于工作电压，LPDDR3 叫做低功耗 DDR3，工作电压为 1.2V。DDR3 叫做标压 DDR3，工作电压为 1.5V，一般台式内存条都是 DDR3。DDR3L 是低压 DDR3，工作电压为 1.35V，一般手机、嵌入式、笔记本等都使用 DDR3L。 正点原子的 I.MX6U-ALPHA 开发板上接了一个 256MB/512MB 的 DDR3L.","link":"","tags":[]},{"title":"IMX6U-GPT定时器","date":"2021-04-11T08:46:40.000Z","path":"2021/04/11/IMX6U-GPT定时器/","text":"GPT 定时器简介I.MX6U 的 GPT 定时器全称为 General Purpose Timer，可实现高精度延时。GPT 定时器是一个 32 位向上定时器(也就是从 0X00000000 开始向上递增计数)，GPT 定时器也可以跟一个值进行比较，当计数器值和这个值相等的话就发生比较事件，产生比较中断。GPT 定时器有一个 12 位的分频器，可以对 GPT 定时器的时钟源进行分频，GPT 定时器特性如下： ①、一个可选时钟源的 32 位向上计数器。 ②、两个输入捕获通道，可以设置触发方式。 ③、三个输出比较通道，可以设置输出模式。 ④、可以生成捕获中断、比较中断和溢出中断。 ⑤、计数器可以运行在重新启动(restart)或(自由运行)free-run 模式。 GPT 定时器共有五个时钟源，分别为：ipg_clk_24M、GPT_CLK(外部时钟)、 ipg_clk、ipg_clk_32k 和 ipg_clk_highfreq。现选择 ipg_clk 为 GPT 的时钟源，ipg_clk=66MHz。 GPT 定时器有两种工作模式 重新启动(restart)模式：当 GPTx_CR(x=1，2)寄存器的 FRR 位清零的时候 GPT 工作在此模式。在此模式下，当计数值和比较寄存器中的值相等的话计数值就会清零，然后重新从0X00000000 开始向上计数，只有比较通道 1 才有此模式！向比较通道 1 的比较寄存器写入任何数据都会复位 GPT 计数器。对于其他两路比较通道（通道 2 和 3），当发生比较事件以后不会复位计数器。 自由运行(free-run)模式：当 GPTx_CR(x=1，2)寄存器的 FRR 位置 1 时候 GPT 工作在此模式下，此模式适用于所有三个比较通道，当比较事件发生以后并不会复位计数器，而是继续计数，直到计数值为 0XFFFFFFFF，然后重新回滚到 0X00000000。 定时器实现高精度延时原理高精度延时函数的实现肯定是要借助硬件定时器，如果设置 GPT 定时器的时钟源为 ipg_clk=66MHz，设置 66 分频，那么进入 GPT 定时器的最终时钟频率就是 66/66=1MHz，周期为 1us。GPT 的计数器每计一个数就表示“过去” 了 1us。如果计 10 个数就表示“过去”了 10us。通过读取寄存器 GPTx_CNT 中的值就知道计了个数，比如现在要延时 100us，那么进入延时函数以后纪录下寄存器 GPTx_CNT 中的值为 200， 当 GPTx_CNT 中的值为 300 的时候就表示 100us 过去了，也就是延时结束。GPTx_CNT 是个 32 位寄存器，如果时钟为 1MHz 的话，GPTx_CNT 最多可以实现 0XFFFFFFFFus=4294967295us≈4294s≈72min。也就是说 72 分钟以后 GPTx_CNT 寄存器就会回滚到 0X00000000，也就是溢出，所以需要在延时函数中要处理溢出的情况。 高精度延时的实现步骤如下 1、设置 GPT1 定时器首先设置 GPT1_CR 寄存器的 SWR(bit15)位来复位寄存器 GPT1。复位完成以后设置寄存器 GPT1_CR 寄存器的 CLKSRC(bit8:6)位，选择 GPT1 的时钟源为 ipg_clk。设置定时器 GPT1的工作模式。 2、设置 GPT1 的分频值设置寄存器 GPT1_PR 寄存器的 PRESCALAR(bit111:0)位，设置分频值。66分频 3、设置 GPT1 的比较值 如果要使用 GPT1 的输出比较中断，那么 GPT1 的输出比较寄存器 GPT1_OCR1 的值可以根据所需的中断时间来设置。本章例程不使用比较输出中断，所以将 GPT1_OCR1 设置为最大 值，即：0XFFFFFFFF。 4、使能 GPT1 定时器设置好 GPT1 定时器以后就可以使能了，设置 GPT1_CR 的 EN(bit0)位为 1 来使能 GPT1 定时器。 5、编写延时函数GPT1定时器已经开始运行了，可以根据前面介绍的高精度延时函数原理来编写延时函数，针对 us 和 ms 延时分别编写两个延时函数。 程序编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&#x2F;***************************************************************文件名 : bsp_delay.c描述 : 延时文件。使用定时器GPT实现高精度延时,添加了：delay_init 延时初始化函数gpt1_irqhandler gpt1定时器中断处理函数delayus us延时函数delayms ms延时函数***************************************************************&#x2F;#include &quot;bsp_delay.h&quot;&#x2F;* * @description : 延时有关硬件初始化,主要是GPT定时器 GPT定时器时钟源选择ipg_clk&#x3D;66Mhz * @param : 无 * @return : 无 *&#x2F;void delay_init(void)&#123; GPT1-&gt;CR &#x3D; 0; &#x2F;* 清零，bit0也为0，即停止GPT *&#x2F; GPT1-&gt;CR &#x3D; 1 &lt;&lt; 15; &#x2F;* bit15置1进入软复位 *&#x2F; while((GPT1-&gt;CR &gt;&gt; 15) &amp; 0x01); &#x2F;*等待复位完成 *&#x2F; &#x2F;* * GPT的CR寄存器,GPT通用设置 * bit22:20 000 输出比较1的输出功能关闭，也就是对应的引脚没反应 * bit9: 0 Restart模式,当CNT等于OCR1的时候就产生中断 * bit8:6 001 GPT时钟源选择ipg_clk&#x3D;66Mhz * bit *&#x2F; GPT1-&gt;CR &#x3D; (1&lt;&lt;6); &#x2F;* * GPT的PR寄存器，GPT的分频设置 * bit11:0 设置分频值，设置为0表示1分频， * 以此类推，最大可以设置为0XFFF，也就是最大4096分频 *&#x2F; GPT1-&gt;PR &#x3D; 65; &#x2F;* 设置为65，即66分频，因此GPT1时钟为66M&#x2F;(65+1)&#x3D;1MHz *&#x2F; &#x2F;* * GPT的OCR1寄存器，GPT的输出比较1比较计数值， * GPT的时钟为1Mz，那么计数器每计一个值就是就是1us。 * 为了实现较大的计数，我们将比较值设置为最大的0XFFFFFFFF, * 这样一次计满就是：0XFFFFFFFFus &#x3D; 4294967296us &#x3D; 4295s &#x3D; 71.5min * 也就是说一次计满最多71.5分钟，存在溢出 *&#x2F; GPT1-&gt;OCR[0] &#x3D; 0XFFFFFFFF; GPT1-&gt;CR |&#x3D; 1&lt;&lt;0; &#x2F;&#x2F;使能GPT1 &#x2F;* 一下屏蔽的代码是GPT定时器中断代码， * 如果想学习GPT定时器的话可以参考一下代码。 *&#x2F;#if 0 &#x2F;* * GPT的PR寄存器，GPT的分频设置 * bit11:0 设置分频值，设置为0表示1分频， * 以此类推，最大可以设置为0XFFF，也就是最大4096分频 *&#x2F; GPT1-&gt;PR &#x3D; 65; &#x2F;&#x2F;设置为1，即65+1&#x3D;66分频，因此GPT1时钟为66M&#x2F;66&#x3D;1MHz &#x2F;* * GPT的OCR1寄存器，GPT的输出比较1比较计数值， * 当GPT的计数值等于OCR1里面值时候，输出比较1就会发生中断 * 这里定时500ms产生中断，因此就应该为1000000&#x2F;2&#x3D;500000; *&#x2F; GPT1-&gt;OCR[0] &#x3D; 500000; &#x2F;* * GPT的IR寄存器，使能通道1的比较中断 * bit0： 0 使能输出比较中断 *&#x2F; GPT1-&gt;IR |&#x3D; 1 &lt;&lt; 0; &#x2F;* * 使能GIC里面相应的中断，并且注册中断处理函数 *&#x2F; GIC_EnableIRQ(GPT1_IRQn); &#x2F;&#x2F;使能GIC中对应的中断 system_register_irqhandler(GPT1_IRQn, (system_irq_handler_t)gpt1_irqhandler, NULL); &#x2F;&#x2F;注册中断服务函数 #endif &#125;#if 0&#x2F;* 中断处理函数 *&#x2F;void gpt1_irqhandler(void)&#123; static unsigned char state &#x3D; 0; state &#x3D; !state; &#x2F;* * GPT的SR寄存器，状态寄存器 * bit2： 1 输出比较1发生中断 *&#x2F; if(GPT1-&gt;SR &amp; (1&lt;&lt;0)) &#123; led_switch(LED2, state); &#125; GPT1-&gt;SR |&#x3D; 1&lt;&lt;0; &#x2F;* 清除中断标志位 *&#x2F;&#125;#endif &#x2F;* * @description : 微秒(us)级延时 * @param - value : 需要延时的us数,最大延时0XFFFFFFFFus * @return : 无 *&#x2F;void delayus(unsigned int usdelay)&#123; unsigned long oldcnt,newcnt; unsigned long tcntvalue &#x3D; 0; &#x2F;* 走过的总时间 *&#x2F; oldcnt &#x3D; GPT1-&gt;CNT; while(1) &#123; newcnt &#x3D; GPT1-&gt;CNT; if(newcnt !&#x3D; oldcnt) &#123; if(newcnt &gt; oldcnt) &#x2F;* GPT是向上计数器,并且没有溢出 *&#x2F; tcntvalue +&#x3D; newcnt - oldcnt; else &#x2F;* 发生溢出 *&#x2F; tcntvalue +&#x3D; 0XFFFFFFFF-oldcnt + newcnt; oldcnt &#x3D; newcnt; if(tcntvalue &gt;&#x3D; usdelay)&#x2F;* 延时时间到了 *&#x2F; break; &#x2F;* 跳出 *&#x2F; &#125; &#125;&#125;&#x2F;* * @description : 毫秒(ms)级延时 * @param - msdelay : 需要延时的ms数 * @return : 无 *&#x2F;void delayms(unsigned int msdelay)&#123; int i &#x3D; 0; for(i&#x3D;0; i&lt;msdelay; i++) &#123; delayus(1000); &#125;&#125;","link":"","tags":[]},{"title":"IMX6U-EPIT定时器","date":"2021-04-11T08:06:21.000Z","path":"2021/04/11/IMX6U-EPIT定时器/","text":"EPIT简介EPIT 的全称是：Enhanced Periodic Interrupt Timer，直译过来就是增强的周期中断定时器， 它主要是完成周期性中断定时的。I.MX6U 的 EPIT 定时器只是完成周期性中断定时的，仅此一项功能！至于输入捕获、PWM 输出等这些功能，I.MX6U 由其它的外设来完成。 EPIT 是一个 32 位定时器，在处理器几乎不用介入的情况下提供精准的定时中断，软件使能以后 EPIT 就会开始运行，EPIT 定时器有如下特点： ①、时钟源可选的 32 位向下计数器。 ②、12 位的分频值。 ③、当计数值和比较值相等的时候产生中断。 EPIT 共有 3 个时钟源可选择， ipg_clk、ipg_clk_32k 和 ipg_clk_highfreq。 选择ipg_clk=66MHz。可以对时钟源进行分频，12位的分频器，04095分别代表14096分频。 计数寄存器 (EPIT_CNR)：向下计数，给它一个初值，它就会从这个给定的初值开始递减，直到减为 0。 加载寄存器(**EPIT_LR)**：保存初值 比较寄存器(EPIT_CMPR)：比较寄存器里面保存的数值用于和计数寄存器里面的计数值比较，如果相等， 产生一个比较事件。 配置寄存器(EPIT_CR)：用于配置EPIT。 (EPITx_SR) ：只有一个位有效，那就是 OCIF(bit0)，这个位是比较中断标志位，为 0 的时候表示没有比较事件发生，为 1 的时候表示有比较事件发生。当比较中断发生以后需要手动清除此位，此位是写 1 清零的。 EPIT 可以设置引脚输出，如果设置了的话就会通过指定的引脚输出信号。 EPIT 定时器有两种工作模式：set-and-forget 和 free-running。 set-and-forget 模式：EPITx_CR(x=1，2)寄存器的 RLD 位置 1 的时候 EPIT 工作在此模式 下，在此模式下 EPIT 的计数器从加载寄存器 EPITx_LR 中获取初始值，不能直接向计数器寄存 器写入数据。不管什么时候，只要计数器计数到 0，那么就会从加载寄存器 EPITx_LR 中重新 加载数据到计数器中，周而复始。 free-running 模式：EPITx_CR 寄存器的 RLD 位清零的时候 EPIT 工作在此模式下，当计数 器计数到0以后会重新从0XFFFFFFFF开始计数，并不是从加载寄存器EPITx_LR中获取数据。 EPIT_CR寄存器用于配置EPIT。 EPIT 的配置步骤1、设置 EPIT1 的时钟源：设置寄存器 EPIT1_CR 寄存器的 CLKSRC(bit25:24)位，选择 EPIT1 的时钟源。 2、设置分频值：设置寄存器 EPIT1_CR 寄存器的 PRESCALAR(bit15:4)位，设置分频值。 3、设置工作模式：设置寄存器 EPIT1_CR 的 RLD(bit3)位，设置 EPTI1 的工作模式。 4、设置计数器的初始值来源：设置寄存器 EPIT1_CR 的 ENMOD(bit1)位，设置计数器的初始值来源。 5、使能比较中断：要使用到比较中断，因此需要设置寄存器EPIT1_CR的OCIEN(bit2)位，使能比较中断。 6、设置加载值和比较值：设置寄存器 EPIT1_LR 中的加载值和寄存器 EPIT1_CMPR 中的比较值，通过这两个寄存器就可以决定定时器的中断周期。 7、EPIT1 中断设置和中断服务函数编写：使能 GIC 中对应的 EPIT1 中断，注册中断服务函数，如果需要的话还可以设置中断优先级。最后编写中断服务函数。 8、使能 EPIT1 定时器：配置好 EPIT1 以后就可以使能 EPIT1 了，通过寄存器 EPIT1_CR 的 EN(bit0)位来设置。 实验原理EPIT_CR bit0为1，设置EPIT使能，bit1为1，设置计数器的初始值为记载寄存器的值。Bit2为1使能比较中断，bit3为1设置定时器工作在set-and-forget模式下。Bit15~bit4设置分频值。Bit25:24设置时钟源的选择，我们设置为1，那么EPIT的时钟源就为ipg_clock=66MHz EPIT_SR寄存器，只有bit0有效，表示中断状态，写1清零。当OCIF位为1的时候表示中断发生，为0的时候表示中断未发生。我们处理完定时器中断以后一定要清除中断标志位。 EPIT_LR寄存器设置计数器的加载值。计数器每次计时到0以后就会读取LR寄存器的值重新开始计时。 CMPR比较计数器，当计数器的值和CMPR相等以后就会产生比较中断。 使用EPIT实现500ms周期的定时器。我们在EPIT中断服务函数里面让LED灯亮灭。 实验程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#x2F;***************************************************************文件名 : bsp_epittimer.c描述 : EPIT定时器驱动文件。***************************************************************&#x2F;#include &quot;bsp_epittimer.h&quot;#include &quot;bsp_int.h&quot;#include &quot;bsp_led.h&quot;&#x2F;* * @description : 初始化EPIT定时器. * EPIT定时器是32位向下计数器,时钟源使用ipg&#x3D;66Mhz * @param - frac : 分频值，范围为0~4095，分别对应1~4096分频。 * @param - value : 倒计数值。 * @return : 无 *&#x2F;void epit1_init(unsigned int frac, unsigned int value)&#123; if(frac &gt; 0XFFF) frac &#x3D; 0XFFF; EPIT1-&gt;CR &#x3D; 0; &#x2F;* 先清零CR寄存器 *&#x2F; &#x2F;* * CR寄存器: * bit25:24 01 时钟源选择Peripheral clock&#x3D;66MHz * bit15:4 frac 分频值 * bit3: 1 当计数器到0的话从LR重新加载数值 * bit2: 1 比较中断使能 * bit1: 1 初始计数值来源于LR寄存器值 * bit0: 0 先关闭EPIT1 *&#x2F; EPIT1-&gt;CR &#x3D; (1&lt;&lt;24 | frac &lt;&lt; 4 | 1&lt;&lt;3 | 1&lt;&lt;2 | 1&lt;&lt;1); EPIT1-&gt;LR &#x3D; value; &#x2F;* 倒计数值 *&#x2F; EPIT1-&gt;CMPR &#x3D; 0; &#x2F;* 比较寄存器，当计数器值和此寄存器值相等的话就会产生中断 *&#x2F; &#x2F;* 使能GIC中对应的中断 *&#x2F; GIC_EnableIRQ(EPIT1_IRQn); &#x2F;* 注册中断服务函数 *&#x2F; system_register_irqhandler(EPIT1_IRQn, (system_irq_handler_t)epit1_irqhandler, NULL); EPIT1-&gt;CR |&#x3D; 1&lt;&lt;0; &#x2F;* 使能EPIT1 *&#x2F; &#125;&#x2F;* * @description : EPIT中断处理函数 * @param : 无 * @return : 无 *&#x2F;void epit1_irqhandler(void)&#123; static unsigned char state &#x3D; 0; state &#x3D; !state; if(EPIT1-&gt;SR &amp; (1&lt;&lt;0)) &#x2F;* 判断比较事件发生 *&#x2F; &#123; led_switch(LED0, state); &#x2F;* 定时器周期到，反转LED *&#x2F; &#125; EPIT1-&gt;SR |&#x3D; 1&lt;&lt;0; &#x2F;* 清除中断标志位 *&#x2F;&#125; epit1_init ，EPIT1 初始化函数，有两个参数 frac 和 value，其中 frac 是分频值，value 是加载值。在第 29 行设置比较寄存器为 0，也就是当计数器倒计数到 0 以后就会触发比较中断。Tout = ((frac +1 )* value) / Tclk;设置了 EPIT1 工作模式为 set-and-forget，并且时钟源为 ipg_clk=66MHz。 epit1_irqhandler，EPIT1 中断处理函数。读取 EPIT1_SR 寄存器，判断当 前的中断是否为比较事件，如果是的话就翻转 LED 灯。最后在退出中断处理函数的时候需要清除中断标志位。","link":"","tags":[]},{"title":"IMX6U中断","date":"2021-04-11T04:26:49.000Z","path":"2021/04/11/IMX6U中断/","text":"1、中断向量偏移​ 我们的裸机历程都是从0X87800000开始的，因此要设置中断向量偏移。 2、中断服务函数的编写一个是IRQ中断服务函数的编写，另一个就是在IRQ中断服务函数里面去查找并运行的具体的外设中断服务函数。 3、修改start.S​ 添加中断向量表，编写复位中断服务函数和IRQ中断服务函数。 ​ 编写复位中断服务函数，内容如下： ​ ①、关闭I,D Cache和MMU。 ​ ②、设置处理器9中工作模式下对应的SP指针。要使用中断那么必须设置IRQ模式下的SP指针。索性直接设置所有模式下的SP指针。 ​ ③、清除bss段。 ​ ④、跳到C函数，也就是main函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&#x2F;***************************************************************文件名 : start.s描述 : ZERO-I.MX6UL&#x2F;I.MX6ULL开发板启动文件，完成C环境初始化，C环境初始化完成以后跳转到C代码。**************************************************************&#x2F;.global _start &#x2F;* 全局标号 *&#x2F;&#x2F;* * 描述： _start函数，首先是中断向量表的创建 *&#x2F;_start: ldr pc, &#x3D;Reset_Handler &#x2F;* 复位中断 *&#x2F; ldr pc, &#x3D;Undefined_Handler &#x2F;* 未定义中断 *&#x2F; ldr pc, &#x3D;SVC_Handler &#x2F;* SVC(Supervisor)中断 *&#x2F; ldr pc, &#x3D;PrefAbort_Handler &#x2F;* 预取终止中断 *&#x2F; ldr pc, &#x3D;DataAbort_Handler &#x2F;* 数据终止中断 *&#x2F; ldr pc, &#x3D;NotUsed_Handler &#x2F;* 未使用中断 *&#x2F; ldr pc, &#x3D;IRQ_Handler &#x2F;* IRQ中断 *&#x2F; ldr pc, &#x3D;FIQ_Handler &#x2F;* FIQ(快速中断)未定义中断 *&#x2F;&#x2F;* 复位中断 *&#x2F; Reset_Handler: cpsid i &#x2F;* 关闭全局中断 *&#x2F; &#x2F;* 关闭I,DCache和MMU * 采取读-改-写的方式。 *&#x2F; mrc p15, 0, r0, c1, c0, 0 &#x2F;* 读取CP15的C1寄存器到R0中 *&#x2F; bic r0, r0, #(0x1 &lt;&lt; 12) &#x2F;* 清除C1寄存器的bit12位(I位)，关闭I Cache *&#x2F; bic r0, r0, #(0x1 &lt;&lt; 2) &#x2F;* 清除C1寄存器的bit2(C位)，关闭D Cache *&#x2F; bic r0, r0, #0x2 &#x2F;* 清除C1寄存器的bit1(A位)，关闭对齐 *&#x2F; bic r0, r0, #(0x1 &lt;&lt; 11) &#x2F;* 清除C1寄存器的bit11(Z位)，关闭分支预测 *&#x2F; bic r0, r0, #0x1 &#x2F;* 清除C1寄存器的bit0(M位)，关闭MMU *&#x2F; mcr p15, 0, r0, c1, c0, 0 &#x2F;* 将r0寄存器中的值写入到CP15的C1寄存器中 *&#x2F; #if 0 &#x2F;* 汇编版本设置中断向量表偏移 *&#x2F; ldr r0, &#x3D;0X87800000 dsb isb mcr p15, 0, r0, c12, c0, 0 dsb isb#endif &#x2F;* 设置各个模式下的栈指针， * 注意：IMX6UL的堆栈是向下增长的！ * 堆栈指针地址一定要是4字节地址对齐的！！！ * DDR范围:0X80000000~0X9FFFFFFF *&#x2F; &#x2F;* 进入IRQ模式 *&#x2F; mrs r0, cpsr bic r0, r0, #0x1f &#x2F;* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 *&#x2F; orr r0, r0, #0x12 &#x2F;* r0或上0x13,表示使用IRQ模式 *&#x2F; msr cpsr, r0 &#x2F;* 将r0 的数据写入到cpsr_c中 *&#x2F; ldr sp, &#x3D;0x80600000 &#x2F;* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB *&#x2F; &#x2F;* 进入SYS模式 *&#x2F; mrs r0, cpsr bic r0, r0, #0x1f &#x2F;* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 *&#x2F; orr r0, r0, #0x1f &#x2F;* r0或上0x13,表示使用SYS模式 *&#x2F; msr cpsr, r0 &#x2F;* 将r0 的数据写入到cpsr_c中 *&#x2F; ldr sp, &#x3D;0x80400000 &#x2F;* 设置SYS模式下的栈首地址为0X80400000,大小为2MB *&#x2F; &#x2F;* 进入SVC模式 *&#x2F; mrs r0, cpsr bic r0, r0, #0x1f &#x2F;* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 *&#x2F; orr r0, r0, #0x13 &#x2F;* r0或上0x13,表示使用SVC模式 *&#x2F; msr cpsr, r0 &#x2F;* 将r0 的数据写入到cpsr_c中 *&#x2F; ldr sp, &#x3D;0X80200000 &#x2F;* 设置SVC模式下的栈首地址为0X80200000,大小为2MB *&#x2F; cpsie i &#x2F;* 打开全局中断 *&#x2F;#if 0 &#x2F;* 使能IRQ中断 *&#x2F; mrs r0, cpsr &#x2F;* 读取cpsr寄存器值到r0中 *&#x2F; bic r0, r0, #0x80 &#x2F;* 将r0寄存器中bit7清零，也就是CPSR中的I位清零，表示允许IRQ中断 *&#x2F; msr cpsr, r0 &#x2F;* 将r0重新写入到cpsr中 *&#x2F;#endif b main &#x2F;* 跳转到main函数 *&#x2F;&#x2F;* 未定义中断 *&#x2F;Undefined_Handler: ldr r0, &#x3D;Undefined_Handler bx r0&#x2F;* SVC中断 *&#x2F;SVC_Handler: ldr r0, &#x3D;SVC_Handler bx r0&#x2F;* 预取终止中断 *&#x2F;PrefAbort_Handler: ldr r0, &#x3D;PrefAbort_Handler bx r0&#x2F;* 数据终止中断 *&#x2F;DataAbort_Handler: ldr r0, &#x3D;DataAbort_Handler bx r0&#x2F;* 未使用的中断 *&#x2F;NotUsed_Handler: ldr r0, &#x3D;NotUsed_Handler bx r0&#x2F;* IRQ中断！重点！！！！！ *&#x2F;IRQ_Handler: push &#123;lr&#125; &#x2F;* 保存lr地址 *&#x2F; push &#123;r0-r3, r12&#125; &#x2F;* 保存r0-r3，r12寄存器 *&#x2F; mrs r0, spsr &#x2F;* 读取spsr寄存器 *&#x2F; push &#123;r0&#125; &#x2F;* 保存spsr寄存器 *&#x2F; mrc p15, 4, r1, c15, c0, 0 &#x2F;* 从CP15的C0寄存器内的值到R1寄存器中 *&#x2F; add r1, r1, #0X2000 &#x2F;* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 *&#x2F; ldr r0, [r1, #0XC] &#x2F;* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器， * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据 * 这个中断号来绝对调用哪个中断服务函数 *&#x2F; push &#123;r0, r1&#125; &#x2F;* 保存r0,r1 *&#x2F; cps #0x13 &#x2F;* 进入SVC模式，允许其他中断再次进去 *&#x2F; push &#123;lr&#125; &#x2F;* 保存SVC模式的lr寄存器 *&#x2F; ldr r2, &#x3D;system_irqhandler &#x2F;* 加载C语言中断处理函数到r2寄存器中*&#x2F; blx r2 &#x2F;* 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 *&#x2F; pop &#123;lr&#125; &#x2F;* 执行完C语言中断服务函数，lr出栈 *&#x2F; cps #0x12 &#x2F;* 进入IRQ模式 *&#x2F; pop &#123;r0, r1&#125; str r0, [r1, #0X10] &#x2F;* 中断执行完成，写EOIR *&#x2F; pop &#123;r0&#125; msr spsr_cxsf, r0 &#x2F;* 恢复spsr *&#x2F; pop &#123;r0-r3, r12&#125; &#x2F;* r0-r3,r12出栈 *&#x2F; pop &#123;lr&#125; &#x2F;* lr出栈 *&#x2F; subs pc, lr, #4 &#x2F;* 将lr-4赋给pc *&#x2F;&#x2F;* FIQ中断 *&#x2F;FIQ_Handler: ldr r0, &#x3D;FIQ_Handler bx r0 复位中断服务函数 Reset_Handler， 第 19 行先调用指令“cpsid i”关闭 IRQ， 第 24 到 30 行是关闭 I/D Cache、MMU、对齐检测和分支预测。第 33 行到 42 行是汇编版本的中断向量表重映射。第 50 到 68 行是设置不同模式下的 sp 指针，分别设置 IRQ 模式、SYS 模式和 SVC 模式的栈指针，每种模式的栈大小都是 2MB。第 70 行调用指令“cpsie i”重新打开IRQ 中断，第 72 到 79 行是操作 CPSR 寄存器来打开 IRQ 中断。当初始化工作都完成以后就可 以进入到 main 函数了，第 81 行就是跳转到 main 函数。 中断服务函数 IRQ_Handler，这个是本章的重点，因为所有的外部中断 最终都会触发 IRQ 中断，所以 IRQ 中断服务函数主要的工作就是区分去当前发生的什么中断(中断 ID)？然后针对不同的外部中断做出不同的处理。第 111 到 115 行是保存现场，第 117 到122 行是获取当前中断号，中断号被保存到了 r0 寄存器中。第 131 和 132 行才是中断处理的重点，这两行相当于调用了函数 system_irqhandler，函数 system_irqhandler 是一个 C 语言函数， 此函数有一个参数，这个参数中断号，所以我们需要传递一个参数。 汇编中调用 C 函数如何实现参数传递呢？根据 ATPCS(ARM-Thumb Procedure Call Standard)定义的函数参数传递规则，在汇编调用 C 函数的时候建议形参不要超过 4 个，形参可以由 r0~r3 这四个寄存器来传递，如果形参大于 4 个，那么大于 4 个的部分要使用堆栈进行传递。所以给 r0 寄存器写入中断号就可以了函数 system_irqhandler 的参数传递，在 136 行已经向 r0 寄存器写入了中断号了。中断的真正处理过程其实是在函数 system_irqhandler 中完成，稍后需要编写函数 system_irqhandler。 第 137 行向 GICC_EOIR 寄存器写入刚刚处理完成的中断号，当一个中断处理完成以后必 须向 GICC_EOIR 寄存器写入其中断号表示中断处理完成。 第 139 到 143 行就是恢复现场。 第 144 行中断处理完成以后就要重新返回到曾经被中断打断的地方运行，这里为什么要将lr-4 然后赋给 pc 呢？而不是直接将 lr 赋值给 pc？ARM 的指令是三级流水线：取指、译指、执行，pc 指向的是正在取值的地址，这就是很多书上说的 pc=当前执行指令地址+8。 4、通用中断驱动文件编写在 start.S 文件中我们在中断服务函数 IRQ_Handler 中调用了 C 函数 system_irqhandler 来处 理具体的中断。此函数有一个参数，参数是中断号，但是函数 system_irqhandler 的具体内容还 没有实现，所以需要实现函数 system_irqhandler 的具体内容。不同的中断源对应不同的中断处 理函数，I.MX6U 有 160 个中断源，所以需要 160 个中断处理函数，我们可以将这些中断处理 函数放到一个数组里面，中断处理函数在数组中的标号就是其对应的中断号。当中断发生以后 函数 system_irqhandler 根据中断号从中断处理函数数组中找到对应的中断处理函数并执行即可。 12345678910111213141516171819&#x2F;***************************************************************文件名 : bsp_int.h***************************************************************&#x2F;&#x2F;* 中断服务函数形式 *&#x2F; typedef void (*system_irq_handler_t) (unsigned int giccIar, void *param);&#x2F;* 中断服务函数结构体*&#x2F;typedef struct _sys_irq_handle&#123; system_irq_handler_t irqHandler; &#x2F;* 中断服务函数 *&#x2F; void *userParam; &#x2F;* 中断服务函数参数 *&#x2F;&#125; sys_irq_handle_t;&#x2F;* 函数声明 *&#x2F;void int_init(void);void system_irqtable_init(void);void system_register_irqhandler(IRQn_Type irq, system_irq_handler_t handler, void *userParam);void system_irqhandler(unsigned int giccIar); void default_irqhandler(unsigned int giccIar, void *userParam); 中断处理结构体 sys_irq_handle_t 包含一个中断处理函数和中断处 理函数的用户参数。一个中断源就需要一个 sys_irq_handle_t 变量，I.MX6U 有 160 个中断源， 因此需要 160 个 sys_irq_handle_t 组成中断处理数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &quot;bsp_int.h&quot;&#x2F;***************************************************************文件名 : bsp_int.c描述 : 中断驱动文件。***************************************************************&#x2F;static unsigned int irqNesting;&#x2F;* 中断嵌套计数器 *&#x2F;static sys_irq_handle_t irqTable[NUMBER_OF_INT_VECTORS];&#x2F;* 中断服务函数表 *&#x2F;&#x2F;* * @description : 中断初始化函数 * @param : 无 * @return : 无 *&#x2F;void int_init(void)&#123; GIC_Init(); &#x2F;* 初始化GIC *&#x2F; system_irqtable_init(); &#x2F;* 初始化中断表 *&#x2F; __set_VBAR((uint32_t)0x87800000); &#x2F;* 中断向量表偏移，偏移到起始地址 *&#x2F;&#125;&#x2F;* * @description : 初始化中断服务函数表 * @param : 无 * @return : 无 *&#x2F;void system_irqtable_init(void)&#123; unsigned int i &#x3D; 0; irqNesting &#x3D; 0; &#x2F;* 先将所有的中断服务函数设置为默认值 *&#x2F; for(i &#x3D; 0; i &lt; NUMBER_OF_INT_VECTORS; i++) &#123; system_register_irqhandler((IRQn_Type)i,default_irqhandler, NULL); &#125;&#125;&#x2F;* * @description : 给指定的中断号注册中断服务函数 * @param - irq : 要注册的中断号 * @param - handler : 要注册的中断处理函数 * @param - usrParam : 中断服务处理函数参数 * @return : 无 *&#x2F;void system_register_irqhandler(IRQn_Type irq, system_irq_handler_t handler, void *userParam) &#123; irqTable[irq].irqHandler &#x3D; handler; irqTable[irq].userParam &#x3D; userParam;&#125;&#x2F;* * @description : C语言中断服务函数，irq汇编中断服务函数会调用此函数，此函数通过在中断服务列 表中查找指定中断号所对应的中断处理函数并执行。 * @param - giccIar : 中断号 * @return : 无 *&#x2F;void system_irqhandler(unsigned int giccIar) &#123; uint32_t intNum &#x3D; giccIar &amp; 0x3FFUL; &#x2F;* 检查中断号是否符合要求 *&#x2F; if ((intNum &#x3D;&#x3D; 1023) || (intNum &gt;&#x3D; NUMBER_OF_INT_VECTORS)) &#123; return; &#125; irqNesting++; &#x2F;* 中断嵌套计数器加一 *&#x2F; &#x2F;* 根据传递进来的中断号，在irqTable中调用确定的中断服务函数*&#x2F; irqTable[intNum].irqHandler(intNum, irqTable[intNum].userParam); irqNesting--; &#x2F;* 中断执行完成，中断嵌套寄存器减一 *&#x2F;&#125;&#x2F;* * @description : 默认中断服务函数 * @param - giccIar : 中断号 * @param - usrParam : 中断服务处理函数参数 * @return : 无 *&#x2F;void default_irqhandler(unsigned int giccIar, void *userParam) &#123; while(1) &#123; &#125;&#125; 中断初始化函数 int_init，在此函数中首先初始化了 GIC，然后初始化了中断 服务函数表，最终设置了中断向量表偏移。 是中断服务函数表初始化函数 system_irqtable_init，初始化 irqTable，给其赋初 值。 注册中断处理函数 system_register_irqhandler，此函数用来给指定的中断号注 册中断处理函数。如果要使用某个外设中断，那就必须调用此函数来给这个中断注册一个中断 处理函数。 调用的 system_irqhandler 函数，此函数根据中断号在中断 处理函数表 irqTable 中取出对应的中断处理函数并执行。 默认中断处理函数 default_irqhandler，这是一个空函数，主要用来给初始化 中断函数处理表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&#x2F;***************************************************************文件名 : bsp_gpio.c描述 : GPIO操作文件。日志 :修改gpio_init()函数，支持中断配置. 添加gpio_intconfig()函数，初始化中断 添加gpio_enableint()函数，使能中断 添加gpio_clearintflags()函数，清除中断标志位 ***************************************************************&#x2F;&#x2F;* * @description : GPIO初始化。 * @param - base : 要初始化的GPIO组。 * @param - pin : 要初始化GPIO在组内的编号。 * @param - config : GPIO配置结构体。 * @return : 无 *&#x2F;void gpio_init(GPIO_Type *base, int pin, gpio_pin_config_t *config)&#123; base-&gt;IMR &amp;&#x3D; ~(1U &lt;&lt; pin); if(config-&gt;direction &#x3D;&#x3D; kGPIO_DigitalInput) &#x2F;* GPIO作为输入 *&#x2F; &#123; base-&gt;GDIR &amp;&#x3D; ~( 1 &lt;&lt; pin); &#125; else &#x2F;* 输出 *&#x2F; &#123; base-&gt;GDIR |&#x3D; 1 &lt;&lt; pin; gpio_pinwrite(base,pin, config-&gt;outputLogic); &#x2F;* 设置默认输出电平 *&#x2F; &#125; gpio_intconfig(base, pin, config-&gt;interruptMode); &#x2F;* 中断功能配置 *&#x2F;&#125;&#x2F;* * @description : 设置GPIO的中断配置功能 * @param - base : 要配置的IO所在的GPIO组。 * @param - pin : 要配置的GPIO脚号。 * @param - pinInterruptMode: 中断模式，参考枚举类型gpio_interrupt_mode_t * @return : 无 *&#x2F;void gpio_intconfig(GPIO_Type* base, unsigned int pin, gpio_interrupt_mode_t pin_int_mode)&#123; volatile uint32_t *icr; uint32_t icrShift; icrShift &#x3D; pin; base-&gt;EDGE_SEL &amp;&#x3D; ~(1U &lt;&lt; pin); if(pin &lt; 16) &#x2F;* 低16位 *&#x2F; icr &#x3D; &amp;(base-&gt;ICR1); else &#x2F;* 高16位 *&#x2F; &#123; icr &#x3D; &amp;(base-&gt;ICR2); icrShift -&#x3D; 16; &#125; switch(pin_int_mode) &#123; case(kGPIO_IntLowLevel): *icr &amp;&#x3D; ~(3U &lt;&lt; (2 * icrShift)); break; case(kGPIO_IntHighLevel): *icr &#x3D; (*icr &amp; (~(3U &lt;&lt; (2 * icrShift)))) | (1U &lt;&lt; (2 * icrShift)); break; case(kGPIO_IntRisingEdge): *icr &#x3D; (*icr &amp; (~(3U &lt;&lt; (2 * icrShift)))) | (2U &lt;&lt; (2 * icrShift)); break; case(kGPIO_IntFallingEdge): *icr |&#x3D; (3U &lt;&lt; (2 * icrShift)); break; case(kGPIO_IntRisingOrFallingEdge): base-&gt;EDGE_SEL |&#x3D; (1U &lt;&lt; pin); break; default: break; &#125;&#125;&#x2F;* * @description : 使能GPIO的中断功能 * @param - base : 要使能的IO所在的GPIO组。 * @param - pin : 要使能的GPIO在组内的编号。 * @return : 无 *&#x2F;void gpio_enableint(GPIO_Type* base, unsigned int pin)&#123; base-&gt;IMR |&#x3D; (1 &lt;&lt; pin);&#125;&#x2F;* * @description : 禁止GPIO的中断功能 * @param - base : 要禁止的IO所在的GPIO组。 * @param - pin : 要禁止的GPIO在组内的编号。 * @return : 无 *&#x2F;void gpio_disableint(GPIO_Type* base, unsigned int pin)&#123; base-&gt;IMR &amp;&#x3D; ~(1 &lt;&lt; pin);&#125;&#x2F;* * @description : 清除中断标志位(写1清除) * @param - base : 要清除的IO所在的GPIO组。 * @param - pin : 要清除的GPIO掩码。 * @return : 无 *&#x2F;void gpio_clearintflags(GPIO_Type* base, unsigned int pin)&#123; base-&gt;ISR |&#x3D; (1 &lt;&lt; pin);&#125; gpio_intconfig：配置 GPIO 的中断功能。 gpio_enableint：GPIO 中断使能函数。 gpio_disableint：GPIO 中断禁止函数。 gpio_clearintflags：GPIO 中断标志位清除函数","link":"","tags":[]},{"title":"I.MX6U启动方式详解","date":"2021-04-10T13:09:13.000Z","path":"2021/04/10/IMX6U启动方式详解/","text":"启动方式选择BOOT 的处理过程是发生在 I.MX6U 芯片上电以后，芯片会根据 BOOT_MODE[1:0]的设置 来选择 BOOT 方式。BOOT_MODE[1:0]的值是可以改变的，有两种方式，一种是改写 eFUSE(熔 丝)，一种是修改相应的 GPIO 高低电平。第一种修改 eFUSE 的方式只能修改一次，后面就不能再修改了，所以我们不使用。我们使用的是通过修改 BOOT_MODE[1:0]对应的 GPIO 高低电平来选择启动方式，所有的开发板都使用的这种方式。 I.MX6U 有四个 BOOT 模式，这四个 BOOT 模式由 BOOT_MODE[1:0]来控制，也就是BOOT_MODE1 和 BOOT_MODE0 这两 IO，BOOT 模式配置如表 9.1.1 所示： BOOT_MODE[1:0] BOOT 类型 00 从 FUSE 启动 01 串行下载 10 内部 BOOT 模式 11 保留 串行下载 当 BOOT_MODE1 为 0，BOOT_MODE0 为 1 的时候此模式使能，串行下载的意思就是可以通过 USB 或者 UART 将代码下载到板子上的外置存储设备中，我们可以使用 OTG1 这个 USB 口向开发板上的 SD/EMMC、NAND 等存储设备下载代码。我们需要将 BOOT_MODE1 拨到“OFF”，将 BOOT_MODE0 拨到“ON”。这个下载是需要用到 NXP 提供的一个软件，一般用来最终量产的时候将代码烧写到外置存储设备中的，我们后面讲解如何使用。 内部 BOOT 模式 当 BOOT_MODE1 为 1，BOOT_MODE0 为 0 的时候此模式使能，在此模式下，芯片会执 行内部的 boot ROM 代码，这段 boot ROM 代码会进行硬件初始化(一部分外设)，然后从 boot 设 备(就是存放代码的设备、比如 SD/EMMC、NAND)中将代码拷贝出来复制到指定的 RAM 中，一般是 DDR。 BOOT ROM 初始化内容当我们设置 BOOT 模式为“内部 BOOT 模式”以后，I.MX6U 内部的 boot ROM 代码就会 执行，这个 boot ROM 代码首先肯定是初始化时钟，内部 boot ROM 为了加快执行速度会打开 MMU 和 Cache，下载镜像的时候 L1 ICache 会打 开，验证镜像的时候 L1 DCache、L2 Cache 和 MMU 都会打开。一旦镜像验证完成，boot ROM 就会关闭 L1 DCache、L2 Cache 和 MMU。中断向量偏移会被设置到 boot ROM 的起始位置，当 boot ROM 启动了用户代码以后就可以重新设置中断向量偏移了。一般是重新设置到我们用户代码的开始地方。","link":"","tags":[]},{"title":"I.MX6U的GPIO详解","date":"2021-04-10T12:00:19.000Z","path":"2021/04/10/IMX6U-GPIO详解/","text":"I.MX6U IO 命名“IOMUXC_SW_MUC_CTL_PAD_GPIO1_IO00”的就是 GPIO 命名，命名形式就是“IOMUXC_SW_MUC_CTL_PAD_XX_XX”，后面的“XX_XX”就是 GPIO 命名， 比如：GPIO1_IO01、UART1_TX_DATA、JTAG_MOD、SNVS_TAMPER1 等等。 I.MX6U 的 GPIO 并不像 STM32 一样以 PA0~15 这样命名，他是根据某个 IO 所拥有的功能来命名的。 GPIO1_IO01，这个肯定能做 GPIO， UART1_TX_DATA 肯定这个 IO 肯定能做为 UART1 的发送引脚。 I.MX6U 的其它 IO 也是可以复用为 GPIO 功能。同样的，GPIO1_IO00~GPIO_IO09 也是可以复用为其它外设引脚的。 I.MX6U IO 复用IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00的寄存器，寄存器地址为 0X020E005C，这个寄存器是 32 位的，但是只用到了最低 5位，其中bit0bit3(MUX_MODE)就是设置 GPIO1_IO00 的复用功能的。GPIO1_IO00 一共可以复用为 9 种功能 IO，分别对应 ALT0ALT8，其中 ALT5 就是作为 GPIO1_IO00。GPIO1_IO00 还可以作 为 I2C2_SCL、GPT1_CAPTURE1、ANATOP_OTG1_ID 等。这个就是 I.MX6U 的 IO 复用。 由此可见，I.MX6U 的 GPIO 不止 GPIO1_IO00~GPIO1_IO09 这 10 个，其它的 IO 都可以复用为 GPIO 来使用。I.MX6U 的 GPIO 一共有 5 组：GPIO1、GPIO2、GPIO3、GPIO4 和 GPIO5，其中 GPIO1 有 32 个 IO，GPIO2 有22 个 IO，GPIO3 有 29 个 IO、GPIO4 有 29 个 IO，GPIO5 最少，只有 12 个 IO，这样一共有 124 个 GPIO。 I.MX6U IO 配置12IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00 IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO00 上面两个都是跟 GPIO_IO00 有关的寄存器，名字上的区别就是红色部分，一个是“MUX”， 一个是“PAD”。 IOMUXC_SW_MUX_CTL_PAD_XX_XX 和 IOMUXC_SW_PAD_CTL_PAD_XX_XX 这两种寄存器都是配置 IO 的，注意是 IO！IOMUXC_SW_MUX_CTL_PAD_XX_XX配置GPIO1_IO00 复用功能的，IOMUXC_SW_PAD_CTL_PAD_XX_XX是用来配置 GPIO1_IO00 的IO 属性，包括速度设置、驱动能力设置、压摆率设置等等。 当 IO 用作 GPIO 的时候需要设置的寄存器，一共有八个：DR、GDIR、PSR、ICR1、ICR2、EDGE_SEL、IMR 和 ISR。 DR 寄存器，数据寄存器。此寄存器是 32 位的，一个 GPIO 组最大只有 32 个 IO，因此 DR 寄存器中的每个位都对应一个 GPIO。当 GPIO 被配置为输出功能以后，向DR寄存器指定的位写入数据那么相应的 IO 就会输出相应的高低电平，当 GPIO被配置为输入模式以后，此DR寄存器就保存着对应 IO 的电平值。 GDIR 寄存器，方向寄存器。用来设置某个 GPIO 的工作方向的，即输入/输出，GDIR 寄存器也是 32 位的，此寄存器用来设置某个 IO 的工作方向，是输入还是输出。同样的，每个 IO 对应一个位，如果要设置 GPIO 为输入的话就设置相应的位为 0，如果要设置为输出的话就设置为 1。 PSR 寄存器， GPIO 状态寄存器，同样的 PSR 寄存器也是一个 GPIO 对应一个位，读取相应的位即可获取对应的 GPIO 的状态，也就是 GPIO 的高低电平值。功能和输入状态下的 DR 寄存器一样。 ICR1和ICR2这两个寄存器，都是中断控制寄存器，ICR1用于配置低16个GPIO， ICR2 用于配置高 16 个 GPIO，ICR1 用于 IO015 的配置， ICR2 用于 IO1631 的配置。ICR1 寄存器中一个 GPIO 用两个位，这两个位用来配置中断的触发方式。 位设置 触发方式 00 低电平触发 01 高电平触发 10 上升沿触发 11 下降沿触发 以GPIO1_IO15为例，如果要设置GPIO1_IO15为上升沿触发中断，那么GPIO1.ICR1=2&lt;&lt;30，如果要设置 GPIO1 的 IO16~31 的话就需要设置 ICR2 寄存器了。 IMR 寄存器，中断屏蔽寄存器。IMR 寄存器也是一个 GPIO 对应一个位，IMR 寄存器用来控制 GPIO 的中断禁止和使能，如果使能某个 GPIO 的中断，那么设置相应的位为 1 即可，反之，如果要禁止中断，那么就设 置相应的位为 0 即可。 寄存器 ISR，中断状态寄存器。ISR 寄存器也是 32 位寄存器，一个 GPIO 对应一个位，只要某个 GPIO 的中断发生，那么 ISR 中相应的位就会被置 1。所以，我们可以通过读取 ISR 寄存器来判断 GPIO 中断是否发生， 相当于 ISR 中的这些位就是中断标志位。当我们处理完中断以后，必须清除中断标志位，清除 方法就是向 ISR 中相应的位写 1，也就是写 1 清零。 EDGE_SEL 寄存器，边沿选择寄存器。EDGE_SEL 寄存器用来设置边沿中断，这个寄存器会覆盖 ICR1 和 ICR2 的设置，同样是一 个 GPIO 对应一个位。如果相应的位被置 1，那么就相当与设置了对应的 GPIO 是上升沿和下降 沿(双边沿)触发。例如，我们设置 GPIO1.EDGE_SEL=1，那么就表示 GPIO1_IO01 是双边沿触发中断，无论 GFPIO1_CR1 的设置为多少，都是双边沿触发。 I.MX6U GPIO 时钟使能I.MX6U每个外设的时钟都可以独立的使能或禁止，这样可以关闭掉不使用的外设时钟，起到 省电的目的。如果要使用某个外设的话必须要先使能其时钟。CCM 里面 的外设时钟使能寄存器CMM 有 CCM_CCGR0~CCM_CCGR6 这 7 个寄存器，这 7 个寄存器控制着 I.MX6U 的所有外设时钟开关。 CCM_CCGR0 是个 32 为寄存器，其中每 2 位控制一个外设的时钟，比如 bit31:30 控制着GPIO2 的外设时钟，两个位就有 4 中操作方式。 位设置 时钟控制 00 所有模式下都关闭外设时钟。 01 只有在运行模式下打开外设时钟，等待模式和停止模式下均关闭外设时钟。 10 未使用(保留)。 11 除了停止模式以外，其他所有模式下时钟都打开。 要打开 GPIO2 的外设时钟，那么只需要设置CCM_CCGR0 的 bit31 和 bit30 都为 1 即可，也就是 CCM_CCGR0=3 &lt;&lt; 30。反之，如果要关闭GPIO2 的 外设时钟 ，CCM_CCGR0 的 bit31 和 bit30 都 为0 即 可 。 要将 I.MX6U 的 IO 作为 GPIO 使用，我们需要一下 几步： ①、使能 GPIO 对应的时钟。 ②、设置寄存器 IOMUXC_SW_MUX_CTL_PAD_XX_XX，设置 IO 的复用功能，使其复用 GPIO 功能。 ③、设置寄存器 IOMUXC_SW_PAD_CTL_PAD_XX_XX，设置 IO 的上下拉、速度等等。 ④、第②步已经将 IO 复用为了 GPIO 功能，所以需要配置 GPIO，设置输入/输出、是否使用中断、默认输出电平等。","link":"","tags":[]},{"title":"ARM汇编基础","date":"2021-04-10T09:47:50.000Z","path":"2021/04/10/ARM汇编基础/","text":"对于 Cortex-A 芯片来讲，大部分芯片在上电以后 C 语言环境还没准备好，所以第一行程序肯定是汇编的，至于要写多少汇编程序，那就看你能在哪一步把 C 语言环境准备好。所谓的C语言环境就是保证 C 语言能够正常运行。C 语言中的函数调用涉及到出栈入栈，出栈入栈就要对堆栈进行操作，所谓的堆栈其实就是一段内存，这段内存比较特殊，由 SP 指针访问，SP 指针指向栈顶。芯片一上电 SP 指针还没有初始化，所以 C 语言没法运行，对于有些芯片还需要初始化 DDR，因为芯片本身没有 RAM，或者内部 RAM 不开放给用户使用，用户代码需要在DDR 中行，因此一开始要用汇编来初始化 DDR 控制器。 GNU 汇编语法我们要编写的是 ARM汇编，编译使用的 GCC 交叉编译器，所以我们的汇编代码要符合 GNU 语法。GNU 汇编语法适用于所有的架构，并不是 ARM 独享的，GNU 汇编由一系列的语句组成，每行一条语句，每条语句有三个可选部分，如下： 1label：instruction @ comment label 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。 instruction 即指令，也就是汇编指令或伪指令。 @**符号，表示后面的是注释，其实在 GNU 汇编文件中我们也可以使用“/**”和“/”来注释。 comment 就是注释内容。 ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。 汇编系统预定义了一些段名： .text 表示代码段。 .data 初始化的数据段。 .bss 未初始化的数据段。 .rodata 只读数据段。 汇编程序的默认入口标号是_start， 12345.global _start _start: ldr r0, &#x3D;0x12 @r0&#x3D;0x12 .global 是伪操作，表示_start 是一个全局标号，类似 C 语言里面的全局变量一 样，常见的伪操作有： .byte 定义单字节数据，比如.byte 0x12。 .short 定义双字节数据，比如.short 0x1234。 .long 定义一个 4 字节数据，比如.long 0x12345678。 .equ 赋值语句，格式为：.equ 变量名，表达式，比如.equ num, 0x12，表示 num=0x12。 .align 数据字节对齐，比如：.align 4 表示 4 字节对齐。 .end 表示源文件结束。 .global 定义一个全局符号，格式为：.global symbol，比如：.global _start。 Cortex-A7 常用汇编指令处理器内部数据传输指令 MOV 指令用于将数据从一个寄存器拷贝到另外一个寄存器，或者将一个立即数传递到寄存器里面，使用示例如下： 12MOV R0，R1 @将寄存器 R1 中的数据传递给 R0，即 R0&#x3D;R1 MOV R0, #0X12 @将立即数 0X12 传递给 R0 寄存器，即 R0&#x3D;0X12 MRS 指令用于将特殊寄存器(如 CPSR 和 SPSR)中的数据传递给通用寄存器，要读取特殊寄存器的数据只能使用MRS 指令！使用示例如下： 1MRS R0, CPSR @将特殊寄存器 CPSR 里面的数据传递给 R0，即 R0&#x3D;CPSR MSR 指令和 MRS 刚好相反，MSR 指令用来将普通寄存器的数据传递给特殊寄存器，也就是写特殊寄存器，写特殊寄存器只能使用 MSR，使用示例如下： 1MSR CPSR, R0 @将 R0 中的数据复制到 CPSR 中，即 CPSR&#x3D;R0 存储器访问指令 ARM 不能直接访问存储器，比如 RAM 中的数据，I.MX6UL 中的寄存器就是 RAM 类型的，我们用汇编来配置 I.MX6UL 寄存器的时候需要借助存储器访问指令。 LDR 主要用于从存储加载数据到寄存器 Rx 中，LDR 也可以将一个立即数加载到寄存器 Rx 中，LDR 加载立即数的时候要使用“=”，而不是“#”。在嵌入式开发中，LDR 最常用的就是读取 CPU 的寄存器值。 12LDR R0**, &#x3D;**0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0**&#x3D;**0X0209C004 LDR R1**, [R0] @读取地址 0X0209C004 中的数据到 R1 寄存器中 STR 就是将数据写入到存储器中。 123LDR R0**, &#x3D;**0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0**&#x3D;**0X0209C004 LDR R1**, &#x3D;**0X20000002 @R1 保存要写入到寄存器的值，即 R1**&#x3D;**0X20000002 STR R1**, [**R0**]** @将 R1 中的值写入到 R0 中所保存的地址中 压栈和出栈指令 A 函数中调用 B 函数，当 B 函数执行完以后再回到 A 函数继续执行。要想 在跳回 A 函数以后代码能够接着正常运行，那就必须在跳到 B 函数之前将当前处理器状态保存起来(就是保存 R0R15 这些寄存器值)，当 B 函数执行完成以后再用前面保存的寄存器值恢复 R0R15 即可。保存 R0R15 寄存器的操作就叫做现场保护，恢复 R0R15 寄存器的操作就叫做 恢复现场。在进行现场保护的时候需要进行压栈(入栈)操作，恢复现场就要进行出栈操作。压栈 的指令为 PUSH，出栈的指令为 POP，PUSH 和 POP 是一种多存储和多加载指令，即可以一次 操作多个寄存器数据。 12PUSH 将寄存器列表存入栈中。 POP 从栈中恢复寄存器列表。 跳转指令 B 指令会将 PC 寄存器的值设置为跳转目标地址， 一旦执行 B 指 令，ARM 处理器就会立即跳转到指定的目标地址。如果要调用的函数不会再返回到原来的执行处，那就可以用 B 指令。 BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行。","link":"","tags":[]},{"title":"Cortex-A7架构","date":"2021-04-10T09:20:48.000Z","path":"2021/04/10/Cortex-A7_MPCore/","text":"Cortex-A7 MPCore 简介Cortex-A7 支持在一个处理器上选配 1~4 个内核。Cortex-A7 负责普通应用，因为 Cortex-A7省电。Cortex-A7 本身性能也不弱，不要看它叫做 Cortex-A7 但是它可是比 Cortex-A8 性能要强大，而且更省电。 在 28nm 工艺下，Cortex-A7 可以运行在 1.2~1.6GHz，并且单核面积不大于 0.45mm2(含有浮点单元、NEON 和 32KB 的 L1 缓存)，在典型场景下功耗小于 100mW， 这使得它非常适 合对功耗要求严格的移动设备，这意味着 Cortex-A7 在获得与 Cortex-A9 相似性能的情况下，其功耗更低。 Cortex-A7MPCore 使用 ARMv7-A 架构，主要特性如下： SIMDv2 扩展整形和浮点向量操作。 提供了与 ARM VFPv4 体系结构兼容的高性能的单双精度浮点指令，支持全功能的IEEE754。 支持大物理扩展(LPAE)，最高可以访问 40 位存储地址，也就是最高可以支持 1TB 的内存。 支持硬件虚拟化。 支持 Generic Interrupt Controller(GIC)V2.0。 支持 NEON，可以加速多媒体和信号处理算法。 Cortex-A 处理器运行模型 Cortex-A7 处理器有 9 种处理模式 模式 描述 User(USR) 用户模式，非特权模式，大部分程序运行的时候就处于此模式。 FIQ 快速中断模式，进入 FIQ 中断异常 IRQ 一般中断模式。 Supervisor(SVC) 超级管理员模式，特权模式，供操作系统使用。 Abort(ABT) 数据访问终止模式，用于虚拟存储以及存储保护。 Undef(UND) 未定义指令终止模式。 System(SYS) 系统模式，用于运行特权级的操作系统任务 Monitor(MON) 监视模式？这个模式用于安全扩展模式。 Hyp(HYP) 超级监视模式？用于虚拟化扩展。 除了 User(USR)用户模式以外，其它 8 种运行模式都是特权模式。这几个运行模式可以通过软件进行任意切换，也可以通过中断或者异常来进行切换。大多数的程序都运行在用户模式，用户模式下是不能访问系统所有资源的，有些资源是受限的，要想访问这些受限的资源就必须进行模式切换。但是用户模式是不能直接进行切换的，用户模式下需要借助 异常来完成模式切换，当要切换模式的时候，应用程序可以产生异常，在异常的处理过程中完 成处理器模式切换。 当中断或者异常发生以后，处理器就会进入到相应的异常模式种，每一种模式都有一组寄存器供异常处理程序使用，这样的目的是为了保证在进入异常模式以后，用户模式下的寄存器不会被破坏。 STM32 只有两种运行模式，特权模式和非特权模式，但是 Cortex-A 就有 9 种运行模式。 Cortex-A 寄存器组ARM 架构提供了 16 个 32 位的通用寄存器(R0R15)供软件使用，前 15 个(R0R14)可以用作通用的数据存储，R15 是程序计数器 PC，用来保存将要执行的指令。ARM 还提供了一个当前程序状态寄存器 CPSR 和一个备份程序状态寄存器 SPSR，SPSR 寄存器就是 CPSR 寄存器的备份。 Cortex-A7 有 9 种运行模式，每一种运行模式都有一组与之对应的寄存器组。每一种模式可见的寄存器包括 15 个通用寄存器(R0~R14)、一两个程序状态寄存器和一个 程序计数器 PC。在这些寄存器中，有些是所有模式所共用的同一个物理寄存器，有一些是各模式自己所独立拥有的。 通用寄存器R0~R15 就是通用寄存器，通用寄存器可以分为以下三类： ①、未备份寄存器，即 R0~R7。 ②、备份寄存器，即 R8~R14。 ③、程序计数器 PC，即 R15。 未备份寄存器 未备份寄存器指的是 R0~R7 这 8 个寄存器，因为在所有的处理器模式下这 8 个寄存器都是同一个物理寄存器，在不同的模式下，这 8 个寄存器中的数据就会被破坏。所以这 8 个寄存器并没有被用作特殊用途。 备份寄存器 备份寄存器中的 R8R12 这 5 个寄存器有两种物理寄存器，在快速中断模式下(FIQ)它们对应着 Rx_irq(x=812)物理寄存器，其他模式下对应着 Rx(8~12)物理寄存器。 备份寄存器 R13 一共有 8 个物理寄存器，其中一个是用户模式(User)和系统模式(Sys)共用的，剩下的 7 个分别对应 7 种不同的模式。R13 也叫做 SP，用来做为栈指针。基本上每种模式都有一个自己的 R13 物理寄存器，应用程序会初始化 R13，使其指向该模式专用的栈地址，这就是常说的初始化 SP 指针。 备份寄存器 R14 一共有 7 个物理寄存器，其中一个是用户模式(User)、系统模式(Sys)和超级监视模式(Hyp)所共有的，剩下的 6 个分别对应 6 种不同的模式。R14 也称为连接寄存器(LR)，LR 寄存器在 ARM 中主要用作如下两种用途： ①、每种处理器模式使用 R14(LR)来存放当前子程序的返回地址 ②、当异常发生以后，该异常模式对应的 R14 寄存器被设置成该异常模式将要返回的地址，R14 也可以当作普通寄存器使用。 程序计数器 R15 程序计数器 R15 也叫做 PC，R15 保存着当前执行的指令地址值加 8 个字节，这是因为 ARM的流水线机制导致的。ARM 处理器 3 级流水线：取指-&gt;译码-&gt;执行，这三级流水线循环执行，比如当前正在执行第一条指令的同时也对第二条指令进行译码，第三条指令也同时被取出存放在 R15(PC)中。我们喜欢以当前正在执行的指令作为参考点，也就是以第一条指令为参考点，那么 R15(PC)中存放的就是第三条指令，换句话说就是 R15(PC)总是指向当前正在执行的指令地址再加上 2 条指令的地址。对于 32 位的 ARM 处理器，每条指令是 4 个字节，所以: 1R15 (PC)值 &#x3D; 当前执行的程序位置 + 8 个字节。","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"ARM","slug":"ARM","permalink":"https://guoqiang-gump.github.io/tags/ARM/"}]},{"title":"IMX6U_I2C_ap3216c","date":"2021-03-03T16:22:32.000Z","path":"2021/03/04/IMX6U-I2C-ap3216c/","text":"一、IIC协议详解I2C 使用两条线在主控制器和从机之间进行数据通信。一条是 SCL(串行时钟线)，另外一条是 SDA(串行数据线)，这两条数据线需要接上拉电阻，总线空闲的时候 SCL 和 SDA 处于高电平。I2C总线支持多从机，通过从机地址来区分访问哪个从机。 起始位 I2C 通信起始标志，通过这个起始位告诉 I2C 从机开始 进行 I2C 通信了。在 SCL 为高电平的时候，SDA 出现下降沿就表示为起始位。 停止位 停止 I2C 通信的标志位，和起始位的功能相反。在 SCL 位高电平的时候，SDA 出现上升沿就表示为停止位。 数据传输 I2C 总线在数据传输的时候要保证在 SCL 高电平期间，SDA 上的数据稳定，因此 SDA 上的数据变化只能在 SCL 低电平期间发生。 应答信号 当 I2C 主机发送完 8 位数据以后会将 SDA 设置为输入状态，等待 I2C 从机应答，也就是等到 I2C 从机告诉主机它接收到数据了。应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败。 I2C 写时序 1)、开始信号。 2)、发送 I2C 设备地址，每个 I2C 器件都有一个设备地址，通过发送具体的设备地址来决定访问哪个 I2C 器件。这是一个 8 位的数据，其中高 7 位是设备地址，最后 1 位是读写位，为1 的话表示这是一个读操作，为 0 的话表示这是一个写操作。 3)、 I2C 器件地址后面跟着一个读写位，为 0 表示写操作，为 1 表示读操作。 4)、从机发送的 ACK 应答信号。 5)、重新发送开始信号。 6)、发送要写写入数据的寄存器地址。 7)、从机发送的 ACK 应答信号。 8)、发送要写入寄存器的数据。 9)、从机发送的 ACK 应答信号。 10)、停止信号。 I2C 读时序 I2C 单字节读时序比写时序要复杂一点，读时序分为 4 大步，第一步是发送设备地址，第二步是发送要读取的寄存器地址，第三步重新发送设备地址，最后一步就是 I2C 从器件输出要读取的寄存器值。 1)、主机发送起始信号。 2)、主机发送要读取的 I2C 从设备地址。 3)、读写控制位，因为是向 I2C 从设备发送数据，因此是写信号。 4)、从机发送的 ACK 应答信号。 5)、重新发送起始信号。 6)、主机发送要读取的寄存器地址。 7)、从机发送的 ACK 应答信号。 8)、重新发送 起始信号。 9)、重新发送要读取的 I2C 从设备地址。 10)、读写控制位，这里是读信号，表示接下来是从 I2C 从设备里面读取数据。 11)、从机发送的 ACK 应答信号。 12)、从 I2C 器件里面读取到的数据。 13)、主机发出 NO ACK 信号，表示读取完成，不需要从机再发送 ACK 信号了。 14)、主机发出停止信号，停止 I2C 通信。 二、6ULL I2C接口详解I.MX6U 的 I2C 支持两种模式：标准模式和快速模式，标准模式下 I2C 数据传输速率最高是 100Kbits/s，在快速模式下数据传输速率最高为 400Kbits/s。 时钟源选择perclk_clk_root=ipg_clk_root=66MHz 地址寄存器 I2Cx_IADR 只有 ADR(bit7:1)位有效，用来保存 I2C 从设备地址数据。当我们要访问某个 I2C 从设备的时候就需要将其设备地址写入到 ADR 里面。 分频寄存器 I2Cx_IFDR 也只有 IC(bit5:0)这个位，用来设置 I2C 的波特率。需要100kbit的速率，那66000000/100000=660。IC位设置位0X38或0X15的时候，为640分频，66000000/640=103.125Kbit. 数据寄存器I2Cx_I2DR，只有低 8 位有效，当要发送数据的时候将要发送的数据写入到此寄存器，如果要接收数据，直接读取此寄存器即可得到接收到的数据。 控制寄存器I2Cx_I2CR，bit7为I2C使能位，置1使能I2C。bit5为主从模式选择位，为0表示从机，为1表示主机。Bit4为发送/接收设置位，为0的时候是接收，为1的时候是发送 状态寄存器I2Cx_I2SR，bit7为传输完成位，为0表示正在发送，为1表示发送完成。Bit5是I2C忙闲位，为0的时候I2C总线空闲，为1的时候I2C总线忙。Bit0是读确认位，也就是ACK信号 三、AP3216C简介​ ALPHA开发板上有个AP3216C，这是一个IIC接口的器件，这是一个环境光传感器。AP3216C连接到了I2C1上: I2C1_SCL: 使用的是UART4_TXD这个IO，复用位ALT2 I2C1_SDA: 使用的是UART4_RXD这个IO。复用为ALT2 1、AP3216C是一个三合一的环境光传感器，ALS+PS+IRLED，ALS是环境光，PS是接近传感器，IR是红外LED灯。I2C接口，最高400Kbit/S的频率。 2、环境光传感器ALS，16bit输出。接近传感器PS，10bit输出。红外线强度IR传感器也是10bit 4、AP3216C的从机地址位0X1E。 5、0X0A是IR Ddata low。Bit7为0的时候表示IR和PS数据有效，为1的时候IR和PS数据无效。Bit1:0是IR的低2位。 6、0X0B是IR Data high，big7：0是高字节。与0X0A一起组成10bit的数据。 7、0X0C和0X0D分别位ALS的低8位和高8位。 8、0X0E的bit3:0是低4位数据，0X0F的bit5:0是高6位数据。加起来就是10位 9、0X00是系统配置寄存器，bit2:0设置AP3216C开始那些传感器，我们需要设置位011，也就是0x3，表示开始ALS+PS+IR。 四、实验程序编写12345678910111213141516171819202122232425262728293031323334&#x2F;***************************************************************文件名 : bsp_i2c.h描述 : IIC驱动文件。***************************************************************&#x2F;&#x2F;* 相关宏定义 *&#x2F;#define I2C_STATUS_OK (0)#define I2C_STATUS_BUSY (1)#define I2C_STATUS_IDLE (2)#define I2C_STATUS_NAK (3)#define I2C_STATUS_ARBITRATIONLOST (4)#define I2C_STATUS_TIMEOUT (5)#define I2C_STATUS_ADDRNAK (6)&#x2F;* * I2C方向枚举类型 *&#x2F;enum i2c_direction&#123; kI2C_Write &#x3D; 0x0, &#x2F;* 主机向从机写数据 *&#x2F; kI2C_Read &#x3D; 0x1, &#x2F;* 主机从从机读数据 *&#x2F;&#125; ;&#x2F;* * 主机传输结构体 *&#x2F;struct i2c_transfer&#123; unsigned char slaveAddress; &#x2F;* 7位从机地址 *&#x2F; enum i2c_direction direction; &#x2F;* 传输方向 *&#x2F; unsigned int subaddress; &#x2F;* 寄存器地址 *&#x2F; unsigned char subaddressSize; &#x2F;* 寄存器地址长度 *&#x2F; unsigned char *volatile data; &#x2F;* 数据缓冲区 *&#x2F; volatile unsigned int dataSize; &#x2F;* 数据缓冲区长度 *&#x2F;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304&#x2F;***************************************************************文件名 : bsp_i2c.c描述 : IIC驱动文件***************************************************************&#x2F;&#x2F;* * @description : 初始化I2C，波特率100KHZ * @param - base : 要初始化的IIC设置 * @return : 无 *&#x2F;void i2c_init(I2C_Type *base)&#123; &#x2F;* 1、配置I2C *&#x2F; base-&gt;I2CR &amp;&#x3D; ~(1 &lt;&lt; 7); &#x2F;* 要访问I2C的寄存器，首先需要先关闭I2C *&#x2F; &#x2F;* 设置波特率为100K * I2C的时钟源来源于IPG_CLK_ROOT&#x3D;66Mhz * IC2 时钟 &#x3D; PERCLK_ROOT&#x2F;dividison(IFDR寄存器) * 设置寄存器IFDR,IFDR寄存器参考IMX6UL参考手册P1260页，表29-3， * 根据表29-3里面的值，挑选出一个还是的分频数，比如本例程我们 * 设置I2C的波特率为100K， 因此当分频值&#x3D;66000000&#x2F;100000&#x3D;660. * 在表29-3里面查找，没有660这个值，但是有640，因此就用640, * 即寄存器IFDR的IC位设置为0X15 *&#x2F; base-&gt;IFDR &#x3D; 0X15 &lt;&lt; 0; &#x2F;* * 设置寄存器I2CR，开启I2C * bit[7] : 1 使能I2C,I2CR寄存器其他位其作用之前，此位必须最先置1 *&#x2F; base-&gt;I2CR |&#x3D; (1&lt;&lt;7);&#125;&#x2F;* * @description : 发送重新开始信号 * @param - base : 要使用的IIC * @param - addrss : 设备地址 * @param - direction : 方向 * @return : 0 正常 其他值 出错 *&#x2F;unsigned char i2c_master_repeated_start(I2C_Type *base, unsigned char address, enum i2c_direction direction)&#123; &#x2F;* I2C忙并且工作在从模式,跳出 *&#x2F; if(base-&gt;I2SR &amp; (1 &lt;&lt; 5) &amp;&amp; (((base-&gt;I2CR) &amp; (1 &lt;&lt; 5)) &#x3D;&#x3D; 0)) return 1; &#x2F;* * 设置寄存器I2CR * bit[4]: 1 发送 * bit[2]: 1 产生重新开始信号 *&#x2F; base-&gt;I2CR |&#x3D; (1 &lt;&lt; 4) | (1 &lt;&lt; 2); &#x2F;* * 设置寄存器I2DR * bit[7:0] : 要发送的数据，这里写入从设备地址 * 参考资料:IMX6UL参考手册P1249 *&#x2F; base-&gt;I2DR &#x3D; ((unsigned int)address &lt;&lt; 1) | ((direction &#x3D;&#x3D; kI2C_Read)? 1 : 0); return 0;&#125;&#x2F;* * @description : 发送开始信号 * @param - base : 要使用的IIC * @param - addrss : 设备地址 * @param - direction : 方向 * @return : 0 正常 其他值 出错 *&#x2F;unsigned char i2c_master_start(I2C_Type *base, unsigned char address, enum i2c_direction direction)&#123; if(base-&gt;I2SR &amp; (1 &lt;&lt; 5)) &#x2F;* I2C忙 *&#x2F; return 1; &#x2F;* * 设置寄存器I2CR * bit[5]: 1 主模式 * bit[4]: 1 发送 *&#x2F; base-&gt;I2CR |&#x3D; (1 &lt;&lt; 5) | (1 &lt;&lt; 4); &#x2F;* * 设置寄存器I2DR * bit[7:0] : 要发送的数据，这里写入从设备地址 * 参考资料:IMX6UL参考手册P1249 *&#x2F; base-&gt;I2DR &#x3D; ((unsigned int)address &lt;&lt; 1) | ((direction &#x3D;&#x3D; kI2C_Read)? 1 : 0); return 0;&#125;&#x2F;* * @description : 检查并清除错误 * @param - base : 要使用的IIC * @param - status : 状态 * @return : 状态结果 *&#x2F;unsigned char i2c_check_and_clear_error(I2C_Type *base, unsigned int status)&#123; &#x2F;* 检查是否发生仲裁丢失错误 *&#x2F; if(status &amp; (1&lt;&lt;4)) &#123; base-&gt;I2SR &amp;&#x3D; ~(1&lt;&lt;4); &#x2F;* 清除仲裁丢失错误位 *&#x2F; base-&gt;I2CR &amp;&#x3D; ~(1 &lt;&lt; 7); &#x2F;* 先关闭I2C *&#x2F; base-&gt;I2CR |&#x3D; (1 &lt;&lt; 7); &#x2F;* 重新打开I2C *&#x2F; return I2C_STATUS_ARBITRATIONLOST; &#125; else if(status &amp; (1 &lt;&lt; 0)) &#x2F;* 没有接收到从机的应答信号 *&#x2F; &#123; return I2C_STATUS_NAK; &#x2F;* 返回NAK(No acknowledge) *&#x2F; &#125; return I2C_STATUS_OK;&#125;&#x2F;* * @description : 停止信号 * @param - base : 要使用的IIC * @param : 无 * @return : 状态结果 *&#x2F;unsigned char i2c_master_stop(I2C_Type *base)&#123; unsigned short timeout &#x3D; 0xffff; &#x2F;* * 清除I2CR的bit[5:3]这三位 *&#x2F; base-&gt;I2CR &amp;&#x3D; ~((1 &lt;&lt; 5) | (1 &lt;&lt; 4) | (1 &lt;&lt; 3)); &#x2F;* 等待忙结束 *&#x2F; while((base-&gt;I2SR &amp; (1 &lt;&lt; 5))) &#123; timeout--; if(timeout &#x3D;&#x3D; 0) &#x2F;* 超时跳出 *&#x2F; return I2C_STATUS_TIMEOUT; &#125; return I2C_STATUS_OK;&#125;&#x2F;* * @description : 发送数据 * @param - base : 要使用的IIC * @param - buf : 要发送的数据 * @param - size : 要发送的数据大小 * @param - flags : 标志 * @return : 无 *&#x2F;void i2c_master_write(I2C_Type *base, const unsigned char *buf, unsigned int size)&#123; &#x2F;* 等待传输完成 *&#x2F; while(!(base-&gt;I2SR &amp; (1 &lt;&lt; 7))); base-&gt;I2SR &amp;&#x3D; ~(1 &lt;&lt; 1); &#x2F;* 清除标志位 *&#x2F; base-&gt;I2CR |&#x3D; 1 &lt;&lt; 4; &#x2F;* 发送数据 *&#x2F; while(size--) &#123; base-&gt;I2DR &#x3D; *buf++; &#x2F;* 将buf中的数据写入到I2DR寄存器 *&#x2F; while(!(base-&gt;I2SR &amp; (1 &lt;&lt; 1))); &#x2F;* 等待传输完成 *&#x2F; base-&gt;I2SR &amp;&#x3D; ~(1 &lt;&lt; 1); &#x2F;* 清除标志位 *&#x2F; &#x2F;* 检查ACK *&#x2F; if(i2c_check_and_clear_error(base, base-&gt;I2SR)) break; &#125; base-&gt;I2SR &amp;&#x3D; ~(1 &lt;&lt; 1); i2c_master_stop(base); &#x2F;* 发送停止信号 *&#x2F;&#125;&#x2F;* * @description : 读取数据 * @param - base : 要使用的IIC * @param - buf : 读取到数据 * @param - size : 要读取的数据大小 * @return : 无 *&#x2F;void i2c_master_read(I2C_Type *base, unsigned char *buf, unsigned int size)&#123; volatile uint8_t dummy &#x3D; 0; dummy++; &#x2F;* 防止编译报错 *&#x2F; &#x2F;* 等待传输完成 *&#x2F; while(!(base-&gt;I2SR &amp; (1 &lt;&lt; 7))); base-&gt;I2SR &amp;&#x3D; ~(1 &lt;&lt; 1); &#x2F;* 清除中断挂起位 *&#x2F; base-&gt;I2CR &amp;&#x3D; ~((1 &lt;&lt; 4) | (1 &lt;&lt; 3)); &#x2F;* 接收数据 *&#x2F; &#x2F;* 如果只接收一个字节数据的话发送NACK信号 *&#x2F; if(size &#x3D;&#x3D; 1) base-&gt;I2CR |&#x3D; (1 &lt;&lt; 3); dummy &#x3D; base-&gt;I2DR; &#x2F;* 假读 *&#x2F; while(size--) &#123; while(!(base-&gt;I2SR &amp; (1 &lt;&lt; 1))); &#x2F;* 等待传输完成 *&#x2F; base-&gt;I2SR &amp;&#x3D; ~(1 &lt;&lt; 1); &#x2F;* 清除标志位 *&#x2F; if(size &#x3D;&#x3D; 0) &#123; i2c_master_stop(base); &#x2F;* 发送停止信号 *&#x2F; &#125; if(size &#x3D;&#x3D; 1) &#123; base-&gt;I2CR |&#x3D; (1 &lt;&lt; 3); &#125; *buf++ &#x3D; base-&gt;I2DR; &#125;&#125;&#x2F;* * @description : I2C数据传输，包括读和写 * @param - base: 要使用的IIC * @param - xfer: 传输结构体 * @return : 传输结果,0 成功，其他值 失败; *&#x2F;unsigned char i2c_master_transfer(I2C_Type *base, struct i2c_transfer *xfer)&#123; unsigned char ret &#x3D; 0; enum i2c_direction direction &#x3D; xfer-&gt;direction; base-&gt;I2SR &amp;&#x3D; ~((1 &lt;&lt; 1) | (1 &lt;&lt; 4)); &#x2F;* 清除标志位 *&#x2F; &#x2F;* 等待传输完成 *&#x2F; while(!((base-&gt;I2SR &gt;&gt; 7) &amp; 0X1))&#123;&#125;; &#x2F;* 如果是读的话，要先发送寄存器地址，所以要先将方向改为写 *&#x2F; if ((xfer-&gt;subaddressSize &gt; 0) &amp;&amp; (xfer-&gt;direction &#x3D;&#x3D; kI2C_Read)) &#123; direction &#x3D; kI2C_Write; &#125; ret &#x3D; i2c_master_start(base, xfer-&gt;slaveAddress, direction); &#x2F;* 发送开始信号 *&#x2F; if(ret) &#123; return ret; &#125; while(!(base-&gt;I2SR &amp; (1 &lt;&lt; 1)))&#123;&#125;; &#x2F;* 等待传输完成 *&#x2F; ret &#x3D; i2c_check_and_clear_error(base, base-&gt;I2SR); &#x2F;* 检查是否出现传输错误 *&#x2F; if(ret) &#123; i2c_master_stop(base); &#x2F;* 发送出错，发送停止信号 *&#x2F; return ret; &#125; &#x2F;* 发送寄存器地址 *&#x2F; if(xfer-&gt;subaddressSize) &#123; do &#123; base-&gt;I2SR &amp;&#x3D; ~(1 &lt;&lt; 1); &#x2F;* 清除标志位 *&#x2F; xfer-&gt;subaddressSize--; &#x2F;* 地址长度减一 *&#x2F; base-&gt;I2DR &#x3D; ((xfer-&gt;subaddress) &gt;&gt; (8 * xfer-&gt;subaddressSize)); &#x2F;&#x2F;向I2DR寄存器写入子地址 while(!(base-&gt;I2SR &amp; (1 &lt;&lt; 1))); &#x2F;* 等待传输完成 *&#x2F; &#x2F;* 检查是否有错误发生 *&#x2F; ret &#x3D; i2c_check_and_clear_error(base, base-&gt;I2SR); if(ret) &#123; i2c_master_stop(base); &#x2F;* 发送停止信号 *&#x2F; return ret; &#125; &#125; while ((xfer-&gt;subaddressSize &gt; 0) &amp;&amp; (ret &#x3D;&#x3D; I2C_STATUS_OK)); if(xfer-&gt;direction &#x3D;&#x3D; kI2C_Read) &#x2F;* 读取数据 *&#x2F; &#123; base-&gt;I2SR &amp;&#x3D; ~(1 &lt;&lt; 1); &#x2F;* 清除中断挂起位 *&#x2F; i2c_master_repeated_start(base, xfer-&gt;slaveAddress, kI2C_Read); &#x2F;* 发送重复开始信号和从机地址 *&#x2F; while(!(base-&gt;I2SR &amp; (1 &lt;&lt; 1)))&#123;&#125;;&#x2F;* 等待传输完成 *&#x2F; &#x2F;* 检查是否有错误发生 *&#x2F; ret &#x3D; i2c_check_and_clear_error(base, base-&gt;I2SR); if(ret) &#123; ret &#x3D; I2C_STATUS_ADDRNAK; i2c_master_stop(base); &#x2F;* 发送停止信号 *&#x2F; return ret; &#125; &#125; &#125; &#x2F;* 发送数据 *&#x2F; if ((xfer-&gt;direction &#x3D;&#x3D; kI2C_Write) &amp;&amp; (xfer-&gt;dataSize &gt; 0)) &#123; i2c_master_write(base, xfer-&gt;data, xfer-&gt;dataSize); &#125; &#x2F;* 读取数据 *&#x2F; if ((xfer-&gt;direction &#x3D;&#x3D; kI2C_Read) &amp;&amp; (xfer-&gt;dataSize &gt; 0)) &#123; i2c_master_read(base, xfer-&gt;data, xfer-&gt;dataSize); &#125; return 0; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#define AP3216C_ADDR 0X1E &#x2F;* AP3216C器件地址 *&#x2F;&#x2F;* AP3316C寄存器 *&#x2F;#define AP3216C_SYSTEMCONG 0x00 &#x2F;* 配置寄存器 *&#x2F;#define AP3216C_INTSTATUS 0X01 &#x2F;* 中断状态寄存器 *&#x2F;#define AP3216C_INTCLEAR 0X02 &#x2F;* 中断清除寄存器 *&#x2F;#define AP3216C_IRDATALOW 0x0A &#x2F;* IR数据低字节 *&#x2F;#define AP3216C_IRDATAHIGH 0x0B &#x2F;* IR数据高字节 *&#x2F;#define AP3216C_ALSDATALOW 0x0C &#x2F;* ALS数据低字节 *&#x2F;#define AP3216C_ALSDATAHIGH 0X0D &#x2F;* ALS数据高字节 *&#x2F;#define AP3216C_PSDATALOW 0X0E &#x2F;* PS数据低字节 *&#x2F;#define AP3216C_PSDATAHIGH 0X0F &#x2F;* PS数据高字节 *&#x2F;&#x2F;***************************************************************文件名 : bsp_ap3216c.c描述 : AP3216C驱动文件。***************************************************************&#x2F;&#x2F;* * @description : 初始化AP3216C * @param : 无 * @return : 0 成功，其他值 错误代码 *&#x2F;unsigned char ap3216c_init(void)&#123; unsigned char data &#x3D; 0; &#x2F;* 1、IO初始化，配置I2C IO属性 * I2C1_SCL -&gt; UART4_TXD * I2C1_SDA -&gt; UART4_RXD *&#x2F; IOMUXC_SetPinMux(IOMUXC_UART4_TX_DATA_I2C1_SCL, 1); IOMUXC_SetPinMux(IOMUXC_UART4_RX_DATA_I2C1_SDA, 1); &#x2F;* *bit 16:0 HYS关闭 *bit [15:14]: 1 默认47K上拉 *bit [13]: 1 pull功能 *bit [12]: 1 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 110 驱动能力为R0&#x2F;6 *bit [0]: 1 高转换率 *&#x2F; IOMUXC_SetPinConfig(IOMUXC_UART4_TX_DATA_I2C1_SCL, 0x70B0); IOMUXC_SetPinConfig(IOMUXC_UART4_RX_DATA_I2C1_SDA, 0X70B0); i2c_init(I2C1); &#x2F;* 初始化I2C1 *&#x2F; &#x2F;* 2、初始化AP3216C *&#x2F; ap3216c_writeonebyte(AP3216C_ADDR, AP3216C_SYSTEMCONG, 0X04); &#x2F;* 复位AP3216C*&#x2F; delayms(50); &#x2F;* AP33216C复位至少10ms *&#x2F; ap3216c_writeonebyte(AP3216C_ADDR, AP3216C_SYSTEMCONG, 0X03);&#x2F;* 开启ALS、PS+IR*&#x2F; data &#x3D; ap3216c_readonebyte(AP3216C_ADDR, AP3216C_SYSTEMCONG);&#x2F;* 读取刚刚写进去的0X03 *&#x2F; if(data &#x3D;&#x3D; 0X03) return 0; &#x2F;* AP3216C正常 *&#x2F; else return 1; &#x2F;* AP3216C失败 *&#x2F;&#125;&#x2F;* * @description : 向AP3216C写入数据 * @param - addr: 设备地址 * @param - reg : 要写入的寄存器 * @param - data: 要写入的数据 * @return : 操作结果 *&#x2F;unsigned char ap3216c_writeonebyte(unsigned char addr,unsigned char reg, unsigned char data)&#123; unsigned char status&#x3D;0; unsigned char writedata&#x3D;data; struct i2c_transfer masterXfer; &#x2F;* 配置I2C xfer结构体 *&#x2F; masterXfer.slaveAddress &#x3D; addr; &#x2F;* 设备地址 *&#x2F; masterXfer.direction &#x3D; kI2C_Write; &#x2F;* 写入数据 *&#x2F; masterXfer.subaddress &#x3D; reg; &#x2F;* 要写入的寄存器地址 *&#x2F; masterXfer.subaddressSize &#x3D; 1; &#x2F;* 地址长度一个字节 *&#x2F; masterXfer.data &#x3D; &amp;writedata; &#x2F;* 要写入的数据 *&#x2F; masterXfer.dataSize &#x3D; 1; &#x2F;* 写入数据长度1个字节 *&#x2F; if(i2c_master_transfer(I2C1, &amp;masterXfer)) status&#x3D;1; return status;&#125;&#x2F;* * @description : 从AP3216C读取一个字节的数据 * @param - addr: 设备地址 * @param - reg : 要读取的寄存器 * @return : 读取到的数据。 *&#x2F;unsigned char ap3216c_readonebyte(unsigned char addr,unsigned char reg)&#123; unsigned char val&#x3D;0; struct i2c_transfer masterXfer; masterXfer.slaveAddress &#x3D; addr; &#x2F;* 设备地址 *&#x2F; masterXfer.direction &#x3D; kI2C_Read; &#x2F;* 读取数据 *&#x2F; masterXfer.subaddress &#x3D; reg; &#x2F;* 要读取的寄存器地址 *&#x2F; masterXfer.subaddressSize &#x3D; 1; &#x2F;* 地址长度一个字节 *&#x2F; masterXfer.data &#x3D; &amp;val; &#x2F;* 接收数据缓冲区 *&#x2F; masterXfer.dataSize &#x3D; 1; &#x2F;* 读取数据长度1个字节 *&#x2F; i2c_master_transfer(I2C1, &amp;masterXfer); return val;&#125;&#x2F;* * @description : 读取AP3216C的数据，读取原始数据，包括ALS,PS和IR, 注意！ * : 如果同时打开ALS,IR+PS的话两次数据读取的时间间隔要大于112.5ms * @param - ir : ir数据 * @param - ps : ps数据 * @param - ps : als数据 * @return : 无。 *&#x2F;void ap3216c_readdata(unsigned short *ir, unsigned short *ps, unsigned short *als)&#123; unsigned char buf[6]; unsigned char i; &#x2F;* 循环读取所有传感器数据 *&#x2F; for(i &#x3D; 0; i &lt; 6; i++) &#123; buf[i] &#x3D; ap3216c_readonebyte(AP3216C_ADDR, AP3216C_IRDATALOW + i); &#125; if(buf[0] &amp; 0X80) &#x2F;* IR_OF位为1,则数据无效 *&#x2F; *ir &#x3D; 0; else &#x2F;* 读取IR传感器的数据 *&#x2F; *ir &#x3D; ((unsigned short)buf[1] &lt;&lt; 2) | (buf[0] &amp; 0X03); *als &#x3D; ((unsigned short)buf[3] &lt;&lt; 8) | buf[2]; &#x2F;* 读取ALS传感器的数据 *&#x2F; if(buf[4] &amp; 0x40) &#x2F;* IR_OF位为1,则数据无效 *&#x2F; *ps &#x3D; 0; else &#x2F;* 读取PS传感器的数据 *&#x2F; *ps &#x3D; ((unsigned short)(buf[5] &amp; 0X3F) &lt;&lt; 4) | (buf[4] &amp; 0X0F); &#125;","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"I2C","slug":"I2C","permalink":"https://guoqiang-gump.github.io/tags/I2C/"}]},{"title":"IMX6U串口","date":"2021-03-03T16:10:18.000Z","path":"2021/03/04/IMX6U串口/","text":"一、串口协议简介UART 通信格式 串口全称叫做串行接口，通常也叫做 COM接口，串行接口指的是数据一个一个的顺序传输，通信线路简单。使用两条线即可实现双向通信，一条用于发送，一条用于接收。串口通信 距离远，但是速度相对会低，UART 全称是 UniversalAsynchronous Receiver/Trasmitter，也就是异步串行收发器。 UART 作为串口的一种，其工作原理也是将数据一位一位的进行传输，发送和接收各用一条线，因此通过 UART 接口与外界相连最少只需要三条线：TXD(发送)、RXD(接收)和 GND(地 线)。 UART 的通信格式： 空闲位：数据线在空闲状态的时候为逻辑“1”状态，也就是高电平，表示没有数据线空闲，没有数据传输。 起始位：当要传输数据的时候先传输一个逻辑“0”，也就是将数据线拉低，表示开始数据传输。 数据位：数据位就是实际要传输的数据，数据位数可选择 5~8 位，我们一般都是按照字节传输数据的，一个字节 8 位，因此数据位通常是 8 位的。低位在前，先传输，高位最后传输。 奇偶校验位：这是对数据中“1”的位数进行奇偶校验用的，可以不使用奇偶校验功能。 停止位：数据传输完成标志位，停止位的位数可以选择 1 位、1.5 位或 2 位高电平，一般都选择 1 位停止位。 波特率：波特率就是 UART 数据传输的速率，也就是每秒传输的数据位数，一般选择 9600、19200、115200 等。 二、IMX6U UART 简介I.MX6U 一共 有 8 个 UART，其主要特性如下： ①、兼容 TIA/EIA-232F 标准，速度最高可到 5Mbit/S。 ②、支持串行 IR 接口，兼容 IrDA，最高可到 115.2Kbit/s。 ③、支持 9 位或者多节点模式(RS-485)。 ④、1 或 2 位停止位。 ⑥、可编程的奇偶校验(奇校验和偶校验)。 ⑦、自动波特率检测(最高支持 115.2Kbit/S) UART 的时钟源是由寄存器 CCM_CSCDR1 的 UART_CLK_SEL(bit)位来选择的，当为 0 的时候 UART 的时钟源为 pll3_80m(80MHz)，如果为 1 的时候 UART 的时钟源为 osc_clk(24M)， 一般选择 pll3_80m 作为 UART 的时钟源。寄存器 CCM_CSCDR1 的 UART_CLK_PODF(bit5:0) 位是 UART 的时钟分频值，可设置 063，分别对应 164 分频，一般设置为 1 分频，因此最终进入 UART 的时钟为 80MHz。 三、IM6ULL串口UART原理UART_URXD寄存器保存串口接收到的数据。UART_UTXD寄存器为发送数据寄存器，如果需要通过串口发送数据，只需要将数据写入到UART_UTXD寄存器里面。 UART_UCR1UCR4都是串口的控制寄存器。UART_UCR1的bit0是UART的使能位，为1的时候使能UART。Bit14为自动检测波特率使能位，为1的时候使能波特率自动检测。UART_UCR2的bit0为软件复位位。为0的时候复位UART。Bit1使能UART的接收，我们要配置为1。Bit2为发送使能，要设置为1。Bit5设置数据位，0的话表示7位数据位，1的话表示8位数据位。Bit6设置停止位，0的话表示1位停止位，1的话表示2位。Bit7奇偶校验位，为0的时候是偶校验，为1的时候是计校验。Bit8校验使能位，为0的时候关闭校验。UART_UCR3的bit2必须为1！！！UART_UFCR寄存器的bit97设置分频值，UART的时钟源=PLL3/6=480/6=80MHz。 CSCDR1寄存器的UART_CLK_SEL位设置UART的时钟源，为0的时候UART时钟源为80MHz,为1的时候UART时钟源为24M晶振。CSCDR1寄存器的UART_CLK_PODF位控制分频，一般设置为1分频，因此UART_CLK_ROOT=80MHZ UART_UFCR、UART_UBIR和UART_UBMR这三个寄存器决定了串口波特率。 UART_USR2寄存器的bit0为1的时候表示有数据可以读取。Bit3为1的时候表示数据发送完成。 UART1 的配置步骤如下：1、设置 UART1 的时钟源设置 UART 的时钟源为 pll3_80m，设置寄存器 CCM_CSCDR1 的 UART_CLK_SEL 位为 0即可。2、初始化 UART1初始化 UART1 所使用 IO，设置 UART1 的寄存器 UART1_UCR1~UART1_UCR3，设置内容包括波特率，奇偶校验、停止位、数据位等等。3、使能 UART1UART1 初始化完成以后就可以使能 UART1 了，设置寄存器 UART1_UCR1 的位 UARTEN为 1。 三、实验程序编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279&#x2F;***************************************************************文件名 : bsp_uart.c描述 : 串口驱动文件。***************************************************************&#x2F;#include &quot;bsp_uart.h&quot;&#x2F;* * @description : 初始化串口1,波特率为115200 * @param : 无 * @return : 无 *&#x2F;void uart_init(void)&#123; &#x2F;* 1、初始化串口IO *&#x2F; uart_io_init(); &#x2F;* 2、初始化UART1 *&#x2F; uart_disable(UART1); &#x2F;* 先关闭UART1 *&#x2F; uart_softreset(UART1); &#x2F;* 软件复位UART1 *&#x2F; UART1-&gt;UCR1 &#x3D; 0; &#x2F;* 先清除UCR1寄存器 *&#x2F; &#x2F;* * 设置UART的UCR2寄存器，设置内容包括字长，停止位，校验模式，关闭RTS硬件流控 * bit14: 1 忽略RTS引脚 * bit8: 0 关闭奇偶校验 * bit6: 0 1位停止位 * bit5: 1 8位数据位 * bit2: 1 打开发送 * bit1: 1 打开接收 *&#x2F; UART1-&gt;UCR2 |&#x3D; (1&lt;&lt;14) | (1&lt;&lt;5) | (1&lt;&lt;2) | (1&lt;&lt;1); &#x2F;* * UART1的UCR3寄存器 * bit2: 1 必须设置为1！参考IMX6ULL参考手册3642页 *&#x2F; UART1-&gt;UCR3 |&#x3D; 1&lt;&lt;2; &#x2F;* * 设置UART的UCR1寄存器，关闭自动波特率 * bit14: 0 关闭自动波特率检测,我们自己设置波特率 *&#x2F; UART1-&gt;UCR1 &amp;&#x3D; ~(1&lt;&lt;14); &#x2F;* * 设置波特率 * 波特率计算公式:Baud Rate &#x3D; Ref Freq &#x2F; (16 * (UBMR + 1)&#x2F;(UBIR+1)) * 如果要设置波特率为115200，那么可以使用如下参数: * Ref Freq &#x3D; 80M 也就是寄存器UFCR的bit9:7&#x3D;101, 表示1分频 * UBMR &#x3D; 3124 * UBIR &#x3D; 71 * 因此波特率&#x3D; 80000000&#x2F;(16 * (3124+1)&#x2F;(71+1))&#x3D;80000000&#x2F;(16 * 3125&#x2F;72) &#x3D; (80000000*72) &#x2F; (16*3125) &#x3D; 115200 *&#x2F; UART1-&gt;UFCR &#x3D; 5&lt;&lt;7; &#x2F;&#x2F;ref freq等于ipg_clk&#x2F;1&#x3D;80Mhz UART1-&gt;UBIR &#x3D; 71; UART1-&gt;UBMR &#x3D; 3124; &#x2F;* 使能串口 *&#x2F; uart_enable(UART1);&#125;&#x2F;* * @description : 初始化串口1所使用的IO引脚 * @param : 无 * @return : 无 *&#x2F;void uart_io_init(void)&#123; &#x2F;* 1、初始化IO复用 * UART1_RXD -&gt; UART1_TX_DATA * UART1_TXD -&gt; UART1_RX_DATA *&#x2F; IOMUXC_SetPinMux(IOMUXC_UART1_TX_DATA_UART1_TX,0); &#x2F;* 复用为UART1_TX *&#x2F; IOMUXC_SetPinMux(IOMUXC_UART1_RX_DATA_UART1_RX,0); &#x2F;* 复用为UART1_RX *&#x2F; &#x2F;* 2、配置UART1_TX_DATA、UART1_RX_DATA的IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 00 默认100K下拉 *bit [13]: 0 keeper功能 *bit [12]: 1 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 110 驱动能力R0&#x2F;6 *bit [0]: 0 低转换率 *&#x2F; IOMUXC_SetPinConfig(IOMUXC_UART1_TX_DATA_UART1_TX,0x10B0); IOMUXC_SetPinConfig(IOMUXC_UART1_RX_DATA_UART1_RX,0x10B0);&#125;&#x2F;* * @description : 波特率计算公式， * 可以用此函数计算出指定串口对应的UFCR， * UBIR和UBMR这三个寄存器的值 * @param - base : 要计算的串口。 * @param - baudrate : 要使用的波特率。 * @param - srcclock_hz :串口时钟源频率，单位Hz * @return : 无 *&#x2F;void uart_setbaudrate(UART_Type *base, unsigned int baudrate, unsigned int srcclock_hz)&#123; uint32_t numerator &#x3D; 0u; &#x2F;&#x2F;分子 uint32_t denominator &#x3D; 0U; &#x2F;&#x2F;分母 uint32_t divisor &#x3D; 0U; uint32_t refFreqDiv &#x3D; 0U; uint32_t divider &#x3D; 1U; uint64_t baudDiff &#x3D; 0U; uint64_t tempNumerator &#x3D; 0U; uint32_t tempDenominator &#x3D; 0u; &#x2F;* get the approximately maximum divisor *&#x2F; numerator &#x3D; srcclock_hz; denominator &#x3D; baudrate &lt;&lt; 4; divisor &#x3D; 1; while (denominator !&#x3D; 0) &#123; divisor &#x3D; denominator; denominator &#x3D; numerator % denominator; numerator &#x3D; divisor; &#125; numerator &#x3D; srcclock_hz &#x2F; divisor; denominator &#x3D; (baudrate &lt;&lt; 4) &#x2F; divisor; &#x2F;* numerator ranges from 1 ~ 7 * 64k *&#x2F; &#x2F;* denominator ranges from 1 ~ 64k *&#x2F; if ((numerator &gt; (UART_UBIR_INC_MASK * 7)) || (denominator &gt; UART_UBIR_INC_MASK)) &#123; uint32_t m &#x3D; (numerator - 1) &#x2F; (UART_UBIR_INC_MASK * 7) + 1; uint32_t n &#x3D; (denominator - 1) &#x2F; UART_UBIR_INC_MASK + 1; uint32_t max &#x3D; m &gt; n ? m : n; numerator &#x2F;&#x3D; max; denominator &#x2F;&#x3D; max; if (0 &#x3D;&#x3D; numerator) &#123; numerator &#x3D; 1; &#125; if (0 &#x3D;&#x3D; denominator) &#123; denominator &#x3D; 1; &#125; &#125; divider &#x3D; (numerator - 1) &#x2F; UART_UBIR_INC_MASK + 1; switch (divider) &#123; case 1: refFreqDiv &#x3D; 0x05; break; case 2: refFreqDiv &#x3D; 0x04; break; case 3: refFreqDiv &#x3D; 0x03; break; case 4: refFreqDiv &#x3D; 0x02; break; case 5: refFreqDiv &#x3D; 0x01; break; case 6: refFreqDiv &#x3D; 0x00; break; case 7: refFreqDiv &#x3D; 0x06; break; default: refFreqDiv &#x3D; 0x05; break; &#125; &#x2F;* Compare the difference between baudRate_Bps and calculated baud rate. * Baud Rate &#x3D; Ref Freq &#x2F; (16 * (UBMR + 1)&#x2F;(UBIR+1)). * baudDiff &#x3D; (srcClock_Hz&#x2F;divider)&#x2F;( 16 * ((numerator &#x2F; divider)&#x2F; denominator). *&#x2F; tempNumerator &#x3D; srcclock_hz; tempDenominator &#x3D; (numerator &lt;&lt; 4); divisor &#x3D; 1; &#x2F;* get the approximately maximum divisor *&#x2F; while (tempDenominator !&#x3D; 0) &#123; divisor &#x3D; tempDenominator; tempDenominator &#x3D; tempNumerator % tempDenominator; tempNumerator &#x3D; divisor; &#125; tempNumerator &#x3D; srcclock_hz &#x2F; divisor; tempDenominator &#x3D; (numerator &lt;&lt; 4) &#x2F; divisor; baudDiff &#x3D; (tempNumerator * denominator) &#x2F; tempDenominator; baudDiff &#x3D; (baudDiff &gt;&#x3D; baudrate) ? (baudDiff - baudrate) : (baudrate - baudDiff); if (baudDiff &lt; (baudrate &#x2F; 100) * 3) &#123; base-&gt;UFCR &amp;&#x3D; ~UART_UFCR_RFDIV_MASK; base-&gt;UFCR |&#x3D; UART_UFCR_RFDIV(refFreqDiv); base-&gt;UBIR &#x3D; UART_UBIR_INC(denominator - 1); &#x2F;&#x2F;要先写UBIR寄存器，然后在写UBMR寄存器，3592页 base-&gt;UBMR &#x3D; UART_UBMR_MOD(numerator &#x2F; divider - 1); &#x2F;&#x2F;base-&gt;ONEMS &#x3D; UART_ONEMS_ONEMS(srcclock_hz &#x2F; (1000 * divider)); &#125;&#125;&#x2F;* * @description : 关闭指定的UART * @param - base: 要关闭的UART * @return : 无 *&#x2F;void uart_disable(UART_Type *base)&#123; base-&gt;UCR1 &amp;&#x3D; ~(1&lt;&lt;0); &#125;&#x2F;* * @description : 打开指定的UART * @param - base: 要打开的UART * @return : 无 *&#x2F;void uart_enable(UART_Type *base)&#123; base-&gt;UCR1 |&#x3D; (1&lt;&lt;0); &#125;&#x2F;* * @description : 复位指定的UART * @param - base: 要复位的UART * @return : 无 *&#x2F;void uart_softreset(UART_Type *base)&#123; base-&gt;UCR2 &amp;&#x3D; ~(1&lt;&lt;0); &#x2F;* UCR2的bit0为0，复位UART *&#x2F; while((base-&gt;UCR2 &amp; 0x1) &#x3D;&#x3D; 0); &#x2F;* 等待复位完成 *&#x2F;&#125;&#x2F;* * @description : 发送一个字符 * @param - c : 要发送的字符 * @return : 无 *&#x2F;void putc(unsigned char c)&#123; while(((UART1-&gt;USR2 &gt;&gt; 3) &amp;0X01) &#x3D;&#x3D; 0);&#x2F;* 等待上一次发送完成 *&#x2F; UART1-&gt;UTXD &#x3D; c &amp; 0XFF; &#x2F;* 发送数据 *&#x2F;&#125;&#x2F;* * @description : 发送一个字符串 * @param - str : 要发送的字符串 * @return : 无 *&#x2F;void puts(char *str)&#123; char *p &#x3D; str; while(*p) putc(*p++);&#125;&#x2F;* * @description : 接收一个字符 * @param : 无 * @return : 接收到的字符 *&#x2F;unsigned char getc(void)&#123; while((UART1-&gt;USR2 &amp; 0x1) &#x3D;&#x3D; 0);&#x2F;* 等待接收完成 *&#x2F; return UART1-&gt;URXD; &#x2F;* 返回接收到的数据 *&#x2F;&#125;&#x2F;* * @description : 防止编译器报错 * @param : 无 * @return : 无 *&#x2F;void raise(int sig_nr) &#123;&#125; 四、注意UART1_TXD使用的IO为UART1_TX_DATA，UART1_RXD所使用的IO为UART1_RX_DATA。 Putc和puts编译的时候会提示吧报错，要在Makefile中添加-fno-builtin。 SecuCRT打开以后串口接收到乱码，因为Linux默认用UTF-8编码，因此我们需要设置SecureCRT的编码模式为UTF-8。 移植的printf不支持浮点计算和输出！！！！！","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"串口","slug":"串口","permalink":"https://guoqiang-gump.github.io/tags/%E4%B8%B2%E5%8F%A3/"}]},{"title":"IMX6U定时","date":"2021-03-03T16:00:25.000Z","path":"2021/03/04/IMX6U定时/","text":"一、EPIT简介​ 1、EPIT是32位的一个向下计数器。 ​ 2、EPIT的时钟源可以选择，我们选择ipg_clk=66MHz。 ​ 3、可以对时钟源进行分频，12位的分频器，04095分别代表14096分频。 ​ 4、开启定时器以后，计数寄存器会每个时钟减1，如果和比较寄存器里面的值相等的话就会触发中断。 ​ EPIT有两种工作模式：Set-add-forget，一个是free-runing ​ 5、6ULL有两个EPIT定时器。 ​ EPIT_CR寄存器用于配置EPIT。 二、实验原理简介​ EPIT_CR bit0为1，设置EPIT使能，bit1为1，设置计数器的初始值为记载寄存器的值。Bit2为1使能比较中断，bit3为1设置定时器工作在set-and-forget模式下。Bit15~bit4设置分频值。Bit25:24设置时钟源的选择，我们设置为1，那么EPIT的时钟源就为ipg_clock=66MHz ​ EPIT_SR寄存器，只有bit0有效，表示中断状态，写1清零。当OCIF位为1的时候表示中断发生，为0的时候表示中断未发生。我们处理完定时器中断以后一定要清除中断标志位。 ​ EPIT_LR寄存器设置计数器的加载值。计数器每次计时到0以后就会读取LR寄存器的值重新开始计时。 ​ CMPR比较计数器，当计数器的值和CMPR相等以后就会产生比较中断。 ​ 使用EPIT实现500ms周期的定时器。我们在EPIT中断服务函数里面让LED灯亮灭。 三、实验程序编写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#x2F;***************************************************************描述 : EPIT定时器驱动文件。其他 : 配置EPIT定时器，实现EPIT定时器中断处理函数***************************************************************&#x2F;\\#include &quot;bsp_epittimer.h&quot;\\#include &quot;bsp_int.h&quot;\\#include &quot;bsp_led.h&quot;&#x2F;* \\* @description : 初始化EPIT定时器. \\* EPIT定时器是32位向下计数器,时钟源使用ipg&#x3D;66Mhz \\* @param - frac : 分频值，范围为0~4095，分别对应1~4096分频。 \\* @param - value : 倒计数值。 \\* @return : 无 *&#x2F;void epit1_init(unsigned int frac, unsigned int value)&#123; if(frac &gt; 0XFFF)​ frac &#x3D; 0XFFF; EPIT1-&gt;CR &#x3D; 0; &#x2F;* 先清零CR寄存器 *&#x2F; &#x2F;* \\* CR寄存器: \\* bit25:24 01 时钟源选择Peripheral clock&#x3D;66MHz \\* bit15:4 frac 分频值 \\* bit3: 1 当计数器到0的话从LR重新加载数值 \\* bit2: 1 比较中断使能 \\* bit1: 1 初始计数值来源于LR寄存器值 \\* bit0: 0 先关闭EPIT1 *&#x2F; EPIT1-&gt;CR &#x3D; (1&lt;&lt;24 | frac &lt;&lt; 4 | 1&lt;&lt;3 | 1&lt;&lt;2 | 1&lt;&lt;1) EPIT1-&gt;LR &#x3D; value; &#x2F;* 倒计数值 *&#x2F; EPIT1-&gt;CMPR &#x3D; 0; &#x2F;* 比较寄存器，当计数器值和此寄存器值相等的话就会产生中断 *&#x2F; &#x2F;* 使能GIC中对应的中断 *&#x2F; GIC_EnableIRQ(EPIT1_IRQn); &#x2F;* 注册中断服务函数 *&#x2F; system_register_irqhandler(EPIT1_IRQn, (system_irq_handler_t)epit1_irqhandler, NULL); EPIT1-&gt;CR |&#x3D; 1&lt;&lt;0; &#x2F;* 使能EPIT1 *&#x2F; &#125;&#x2F;* \\* @description : EPIT中断处理函数 \\* @param : 无 \\* @return : 无 *&#x2F;void epit1_irqhandler(void)&#123; static unsigned char state &#x3D; 0; state &#x3D; !state; if(EPIT1-&gt;SR &amp; (1&lt;&lt;0)) &#x2F;* 判断比较事件发生 *&#x2F; &#123;​ led_switch(LED0, state); &#x2F;* 定时器周期到，反转LED *&#x2F; &#125; EPIT1-&gt;SR |&#x3D; 1&lt;&lt;0; &#x2F;* 清除中断标志位 *&#x2F;&#125;","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"蜂鸣器","slug":"蜂鸣器","permalink":"https://guoqiang-gump.github.io/tags/%E8%9C%82%E9%B8%A3%E5%99%A8/"}]},{"title":"Cortex-A7中断系统详解","date":"2021-03-03T13:01:13.000Z","path":"2021/03/03/Cortex-A7中断系统详解/","text":"一、Cortex-A7中断系统1、Cortex-A中断向量表​ 中断向量表是一个表，这个表里面存放的是中断向量。中断服务程序的入口地址或存放中断服务程序的首地址成为中断向量，因此中断向量表是一系列中断服务程序入口地址组成的表。这些中断服务程序(函数)在中断向量表中的位置是由半导体厂商定好的，当某个中断被触发以 后就会自动跳转到中断向量表中对应的中断服务程序(函数)入口地址处。中断向量表在整个程序的最前面。 Cortex-A7 内核有 8 个异常中断，Cortex-A的中断向量表需要自己去定义。 向量地址 中断类型 中断模式 0X00 复位中断(Rest) 特权模式(SVC) 0X04 未定义指令中断(Undefined Instruction) 未定义指令中止模式(Undef) 0X08 软中断(Software Interrupt,SWI) 特权模式(SVC) 0X0C 指令预取中止中断(Prefetch Abort) 中止模式 0X10 数据访问中止中断(Data Abort) 中止模式 0X14 未使用(Not Used) 未使用 0X18 IRQ 中断(IRQ Interrupt) 外部中断模式(IRQ) 0X1C FIQ 中断(FIQ Interrupt) 快速中断模式(FIQ) 中断向量表里面都是中断服务函数的入口地址，Cortex-A7 一共有 8 个中断，而且还有一个中断向量未使用，实际只有 7 个中断。 ①、复位中断(Rest)，CPU 复位以后就会进入复位中断，我们可以在复位中断服务函数里面 做一些初始化工作，比如初始化 SP 指针、DDR 等等。 ②、未定义指令中断(Undefined Instruction)，如果指令不能识别的话就会产生此中断。 ③、软中断(Software Interrupt,SWI)，由 SWI 指令引起的中断，Linux 的系统调用会用 SWI指令来引起软中断，通过软中断来陷入到内核空间。 ④、指令预取中止中断(Prefetch Abort)，预取指令的出错的时候会产生此中断。 ⑤、数据访问中止中断(Data Abort)，访问数据出错的时候会产生此中断。 ⑥、IRQ 中断(IRQ Interrupt)，外部中断，前面已经说了，芯片内部的外设中断都会引起此中断的发生。 ⑦、FIQ 中断(FIQ Interrupt)，快速中断，如果需要快速处理中断的话就可以使用此中。 常用的就是复位中断和 IRQ 中断. 中断实验编写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#x2F;***************************************************************文件名 : start.s描述 : ZERO-I.MX6UL&#x2F;I.MX6ULL开发板启动文件，完成C环境初始化， C环境初始化完成以后跳转到C代码。**************************************************************&#x2F;.global _start &#x2F;* 全局标号 *&#x2F;&#x2F;* * 描述： _start函数，首先是中断向量表的创建 *&#x2F;_start: ldr pc, &#x3D;Reset_Handler &#x2F;* 复位中断 *&#x2F; ldr pc, &#x3D;Undefined_Handler &#x2F;* 未定义中断 *&#x2F; ldr pc, &#x3D;SVC_Handler &#x2F;* SVC(Supervisor)中断 *&#x2F; ldr pc, &#x3D;PrefAbort_Handler &#x2F;* 预取终止中断 *&#x2F; ldr pc, &#x3D;DataAbort_Handler &#x2F;* 数据终止中断 *&#x2F; ldr pc, &#x3D;NotUsed_Handler &#x2F;* 未使用中断 *&#x2F; ldr pc, &#x3D;IRQ_Handler &#x2F;* IRQ中断 *&#x2F; ldr pc, &#x3D;FIQ_Handler &#x2F;* FIQ(快速中断)未定义中断 *&#x2F;&#x2F;* 复位中断 *&#x2F; Reset_Handler:&#x2F;* 未定义中断 *&#x2F;Undefined_Handler: ldr r0, &#x3D;Undefined_Handler bx r0&#x2F;* SVC中断 *&#x2F;SVC_Handler: ldr r0, &#x3D;SVC_Handler bx r0&#x2F;* 预取终止中断 *&#x2F;PrefAbort_Handler: ldr r0, &#x3D;PrefAbort_Handler bx r0&#x2F;* 数据终止中断 *&#x2F;DataAbort_Handler: ldr r0, &#x3D;DataAbort_Handler bx r0&#x2F;* 未使用的中断 *&#x2F;NotUsed_Handler: ldr r0, &#x3D;NotUsed_Handler bx r0&#x2F;* IRQ中断！重点！！！！！ *&#x2F;IRQ_Handler: &#x2F;* FIQ中断 *&#x2F;FIQ_Handler: ldr r0, &#x3D;FIQ_Handler bx r0 第 4 到 11 行是中断向量表，当指定的中断发生以后就会调用对应的中断复位函数，比如复位中断发生以后就会执行第 4 行代码，也就是调用函数 Reset_Handler，函数 Reset_Handler就是复位中断的中断复位函数，其它的中断同理。 3、GIC中断控制器。I.MX6U(Cortex-A)的中断控制器叫做 GIC，当 GIC 接收到外部中断信号以后就会报给 ARM 内核，但是ARM 内核只提供了四个信号给 GIC 来汇报中断情况：VFIQ、VIRQ、FIQ 和 IRQ。 GIC接收众多的外部中断，然后对其进行处理，最终就只通过四个信号 报给 ARM 内核，这四个信号的含义如下： VFIQ:虚拟快速 FIQ。 VIRQ:虚拟快速 IRQ。 FIQ:快速中断 IRQ。 IRQ:外部中断 IRQ。 GIC 将众多的中断源分为分为三类： ①、SPI(Shared Peripheral Interrupt),共享中断，顾名思义，所有 Core 共享的中断，这个是最 常见的，那些外部中断都属于 SPI 中断(注意！不是 SPI 总线那个中断) 。比如按键中断、串口中断等等，这些中断所有的 Core 都可以处理，不限定特定 Core。 ②、PPI(Private Peripheral Interrupt)，私有中断，我们说了 GIC 是支持多核的，每个核肯定有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中断。 ③、SGI(Software-generated Interrupt)，软件中断，由软件触发引起的中断，通过向寄存器GICD_SGIR 写入数据来触发，系统会使用 SGI 中断来完成多核之间的通信。 4、IMX6U中断号中断源有很多，为了区分这些不同的中断源肯定要给他们分配一个唯一 ID，这些 ID 就是 中断 ID。I.MX6U 的中断源共有 128+32=160。 ID0ID15：这 16 个 ID 分配给 SGI。 ID16ID31：这 16 个 ID 分配给 PPI。ID32~ID159：这 128 个 ID 分配给 SPI 5、GIC 逻辑分块GIC 架构分为了两个逻辑块：Distributor 和 CPU Interface Distributor(分发器端)：此逻辑块负责处理各个中断事件的分发问题，也就是中断事件应该发送到哪个CPU Interface 上去。分发器收集所有的中断源，可以控制每个中断的优先级，它总是将优先级最高的中断事件发送到 CPU 接口端。 ①、全局中断使能控制。 ②、控制每一个中断的使能或者关闭。 ③、设置每个中断的优先级。 ④、设置每个中断的目标处理器列表。 ⑤、设置每个外部中断的触发模式：电平触发或边沿触发。 ⑥、设置每个中断属于组 0 还是组 1。 CPU Interface(CPU接口端)：CPU 接口端听名字就知道是和 CPU Core 相连接的，每个 CPU Core 都可以在 GIC 中找到一个与之对应的 CPU Interface。CPU 接口端就是分发器和 CPU Core 之间的桥梁，CPU 接口端主要工作如下： ①、使能或者关闭发送到 CPU Core 的中断请求信号。 ②、应答中断。 ③、通知中断处理完成。 ④、设置优先级掩码，通过掩码来设置哪些中断不需要上报给 CPU Core。 ⑤、定义抢占策略。 ⑥、当多个中断到来的时候，选择优先级最高的中断通知给 CPU Core。 6、CP15协处理器CP15 协处理器一般用于存储系统管理，但是在中断中也会使用到。CP15 协处理器一共有16 个 32 位寄存器。CP15 协处理器的访问通过如下另个指令完成： MRC: 将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中。 MCR: 将 ARM 寄存器的数据写入到 CP15 协处理器寄存器中 MRC 就是读 CP15 寄存器， MCR 就是写 CP15 寄存器， MCR 指令格式如下： 12MCR&#123;cond&#125; p15, &lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;, &lt;opc2&gt;MRC p15, 0, r0, c0,c0,0 现在要关闭I,D ache和MMU，打开Cortex-A7参考手册到105页，找到SCTLR寄存器。也就是系统控制寄存器，此寄存器bit0用于打开和关闭MMU，bit1控制对齐，bit2控制D Cache的打开和关闭。Bit11用于控制分支预测。Bit12用于控制I Cache。 ​ 中断向量偏移设置 ​ 将新的中断向量表首地址写入到CP15协处理器的VBAR寄存器。 123MCR&#123;cond&#125; p15, &lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;, &lt;opc2&gt;MRC p15,0,r0,c12,c0,0 MCR p15,0,r0,c12,c0,0 ​ IRQ中断服务函数 1mrc p15, 4, r1, c15, c0, 0 读取CP15的CBAR寄存器。 CBAR寄存器保存了GIC控制器的寄存器组首地址。GIC寄存器组偏移0x10000x1fff为GIC的分发器。0x20000x3fff为CPU接口端。意味我们可以访问GIC控制器了！ 代码中，R1寄存器吧保存着GIC控制器的CPU接口端基地址。读取CPU接口段的GICC_IAR寄存器的值保存到R0寄存器里面。可以从GICC_IAR的bit9~0读取中断ID，我们读取中断ID的目的就是为了得到对应的中断处理函数。 system_irqhandler就是具体的中断处理函数，此函数有一个参数，为GICC_IAR寄存器的值。system_irqhandler处理完具体的中断以后，需要将对应的中断ID值写入到GICC_EOIR寄存器里面。 7、中断使能中断使能包括两部分，一个是 IRQ 或者 FIQ 总中断使能，另一个就是 ID0~ID1019 这 1020 个中断源的使能。 IRQ 和 FIQ 总中断使能 寄存器 CPSR 的 I=1 禁止 IRQ，当 I=0 使能 IRQ；F=1 禁止 FIQ，F=0 使能 FIQ。 ID0~ID1019 中断使能和禁止 一个 bit 控制一个中断 ID 的使能，GICD_ISENABLER0 的 bit[15:0]对应ID150 的 SGI 中断，GICD_ISENABLER0 的 bit[31:16]对应 ID3116 的 PPI 中断。剩下的GICD_ISENABLER1~GICD_ISENABLER15 就是控制 SPI 中断的。 8、中断优先级设置 优先级数配置 Cortex-A7 的中断优先级也可以分为抢占优先级和子优先级，I.MX6U 选择了 32 个优先级，数字越小，优先级越高！在使用中断的时候需要初始化 GICC_PMR 寄存器，此寄存器用来决定使用几级优先级，GICC_PMR 寄存器只有低 8 位有效，I.MX6U 支持 32 个优先级，所以 GICC_PMR 要设置为 0b11111000。 抢占优先级和子优先级位数设置 抢占优先级和子优先级各占多少位是由寄存器 GICC_BPR 来决定的，寄存器 GICC_BPR 只有低 3 位有效，其值不同，抢占优先级和子优先级占用的位数也不同。为了简单起见，一般将所有的中断优先级位都配置为抢占优先级，比如 I.MX6U 的优先级位数为 5(32 个优先级)，所以可以设置 Binary point 为 2，表示 5 个优先级位全部为抢占优先级。 优先级设置 某个中断 ID 的中断优先级设置由寄存器 D_IPRIORITYR 来完成，如果优先级个数为 32 的话，使用寄 存器 D_IPRIORITYR 的 bit7:4 来设置优先级，也就是说实际的优先级要左移 3 位。比如要设置ID40 中断的优先级为 5，示例代码如下： 1GICD_IPRIORITYR[40] &#x3D; 5 &lt;&lt; 3; 优先级设置主要有三部分： ①、设置寄存器 GICC_PMR，配置优先级个数，比如 I.MX6U 支持 32 级优先级。 ②、设置抢占优先级和子优先级位数，一般为了简单起见，会将所有的位数都设置为抢占优先级。 ③、设置指定中断 ID 的优先级，也就是设置外设优先级。","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"中断","slug":"中断","permalink":"https://guoqiang-gump.github.io/tags/%E4%B8%AD%E6%96%AD/"}]},{"title":"IMX6U时钟系统详解","date":"2021-03-03T12:52:31.000Z","path":"2021/03/03/IMX6U时钟系统详解/","text":"I.MX6U 的系统主频为 528MHz，有些型号可以跑到 696MHz，但是默认情况下内部 bootrom 会将 I.MX6U 的主频设置为 396MHz。那么主频肯定要设置到 528MHz，其它的外设时钟也要设置到 NXP 推荐的值。 一、系统时钟来源I.MX6U-ALPHA 开发板的系统时钟来源于两部分：32.768KHz 和24MHz 的晶振，其中 32.768KHz 晶振是 I.MX6U 的 RTC 时钟源，24MHz 晶振是 I.MX6U 内核和其它外设的时钟源。 7 路 PLL 时钟源 NXP 将这些外设的时钟源进行了分组， 一共有 7 组，这 7 组时钟源都是从 24MHz 晶振 PLL 而来的，因此也叫做 7 组 PLL。 ①、 ARM_PLL（PLL1），此路 PLL 是供 ARM 内核使用的，ARM 内核时钟就是由此 PLL生成的，此 PLL 通过编程的方式最高可倍频到 1.3GHz。 ②、528_PLL(PLL2)，此路 PLL 也叫做 System_PLL，此路 PLL 是固定的 22 倍频，不可编程修改。因此，此路 PLL 时钟=24MHz * 22 = 528MHz，这也是为什么此 PLL 叫做 528_PLL 的原因。此 PLL 分出了 4 路 PFD，分别为：PLL2_PFD0~PLL2_PFD3，这 4 路 PFD 和 528_PLL共同作为其它很多外设的根时钟源。通常 528_PLL 和这 4 路 PFD 是 I.MX6U 内部系统总线的时钟源，比如内处理逻辑单元、DDR 接口、NAND/NOR 接口等等。 ③、USB1_PLL(PLL3)，此路 PLL 主要用于 USBPHY，此 PLL 也有四路 PFD，为：PLL3_PFD0~PLL3_PFD3，USB1_PLL 是固定的 20 倍频，因此 USB1_PLL=24MHz *20=480MHz。USB1_PLL虽然主要用于USB1PHY，但是其和四路PFD同样也可以作为其他外设的根时钟源。 ④、USB2_PLL(PLL7，没有写错！就是 PLL7，虽然序号标为 4，但是实际是 PLL7)，看名 字就知道此路PLL是给USB2PHY使用的。同样的，此路PLL固定为20倍频，因此也是480MHz。 ⑤、ENET_PLL(PLL6),此路 PLL 固定为 20+5/6 倍频，因此 ENET_PLL=24MHz * (20+5/6) = 500MHz。此路 PLL 用于生成网络所需的时钟，可以在此 PLL 的基础上生成 25/50/100/125MHz 的网络时钟。 ⑥、VIDEO_PLL(PLL5),此路 PLL 用于显示相关的外设，比如 LCD，此路 PLL 的倍频可以调整，PLL 的输出范围在 650MHz~1300MHz。此路 PLL 在最终输出的时候还可以进行分频，可选 1/2/4/8/16 分频。 ⑦、AUDIO_PLL(PLL4),此路 PLL 用于音频相关的外设，此路 PLL 的倍频可以调整，PLL的输出范围同样也是 650MHz~1300MHz，此路 PLL 在最终输出的时候也可以进行分频，可选1/2/4 分频。 二、时钟树CLOCK_SWITCHER、CLOCK ROOT GENERATOR 和SYSTEM CLOCKS。其中左边的 CLOCK_SWITCHER 就是我们上一小节讲解的那 7 路 PLL 和8 路 PFD，右边的 SYSTEM CLOCKS 就是芯片外设，中间的 CLOCK ROOT GENERATOR 是最复杂的！这一部分就像“月老”一样，给左边的CLOCK_SWITCHER和右边的SYSTEM CLOCKS进行牵线搭桥。外设时钟源是有多路可以选择的，CLOCK ROOT GENERATOR 就负责从 7 路PLL 和 8 路 PFD 中选择合适的时钟源给外设使用。具体操作肯定是设置相应的寄存器， 1、外设是如何选择合适的时钟​ 比如ESAI时钟源选择： ​ PLL4、PLL3_PFD2、PLL5、PLL3。 2、要初始化的PLL和PFD​ PLL1， ​ PLL2，以及PLL2_PFD0~PFD3. ​ PLL3以及PLL3_PFD0~PFD3. ​ 一般按照时钟树里面的值进行设置。 三、I.MX6U系统配置1、系统主频的配置​ ①、要设置ARM内核主频为528MHz，设置CACRR寄存器的ARM_PODF位为2分频，然后设置PLL1=1056MHz即可。CACRR的bit30为ARM_PODF位，可设置07，分别对应1~8分频。应该设置CACRR寄存器的ARM_PODF=1。 ​ ②、设置PLL1=1056MHz。PLL1=pll1_sw_clk。pll1_sw_clk有两路可以选择，分别为pll1_main_clk，和step_clk，通过CCSR寄存器的pll1_sw_clk_sel位(bit2)来选择。为0的时候选择pll1_main_clk，为1的时候选额step_clk。 ​ ③、在修改PLL1的时候，也就是设置系统时钟的时候需要给6ULL一个临时的时钟，也就是step_clk。在修改PLL1的时候需要将pll1_sw_clk切换到step_clk上。 ​ ③、设置step_clk。Step_clk也有两路来源，由CCSR的step_sel位(bit8)来设置，为0的时候设置step_clk为osc=24MHz。为1的时候不重要，不用。 ​ ④、时钟切换成功以后就可以修改PLL1的值。 ​ ⑤、通过CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位(bit6~0)来设置PLL1的频率，公式位：Output = frefDIV_SEL/2 1056=24DIV_SEL/2=&gt;DIEV_SEL=88。 ​ 设置CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位=88即可。PLL1=1056MHz ​ 还要设置CCM_ANALOG_PLL_ARM寄存器的ENABLE位(bit13)为1，也就是使能输出。 ​ ⑥、在切换回PLL1之前，设置置CACRR寄存器的ARM_PODF=1！！切记。 2、各个PLL时钟的配置​ PLL2和PLL3。PLL2固定为528MHz，PLL3固定为480MHz。 ​ ①、初始化PLL2_PFD0~PFD3。寄存器CCM_ANALOG_PFD_528用于设置4路PFD的时钟。比如PFD0= 52818/PFD0_FRAC。设置PFD0_FRAC位即可。比如PLL2_PFD0=352M=52818/PFD0_FRAC，因此FPD0_FRAC=27。 ​ ②、初始化PLL3_PFD0~PFD3 3、其他外设时钟源配置​ AHB_CLK_ROOT、PERCLK_CLK_ROOT以及IPG_CLK_ROOT。 ​ 因为PERCLK_CLK_ROOT和IPG_CLK_ROOT要用到AHB_CLK_ROOT，所以我们要初始化AHB_CLK_ROOT。 ​ ①、AHB_CLK_ROOT的初始化。 ​ AHB_CLK_ROOT=132MHz。 ​ 设置CBCMR寄存器的PRE_PERIPH_CLK_SEL位，设置CBCDR寄存器的PERIPH_CLK_SEL为0。设置CBCDR寄存器的AHB_PODF位为2，也就是3分频，因此396/3=132MHz。 ​ ②、IPG_CLK_ROOT初始化 ​ 设置CBCDR寄存器IPG_PODF=1，也就是2分频。 ​ ③、PERCLK_CLK_ROOT初始化 ​ 设置CSCMR1寄存器的PERCLK_CLK_SEL位为0，表示PERCLK的时钟源为IPG。 四、实验程序编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &quot;bsp_clk.h&quot;&#x2F;***************************************************************文件名 : bsp_clk.c描述 : 系统时钟驱动。***************************************************************&#x2F;&#x2F;* * @description : 使能I.MX6U所有外设时钟 * @param : 无 * @return : 无 *&#x2F;void clk_enable(void)&#123; CCM-&gt;CCGR0 &#x3D; 0XFFFFFFFF; CCM-&gt;CCGR1 &#x3D; 0XFFFFFFFF; CCM-&gt;CCGR2 &#x3D; 0XFFFFFFFF; CCM-&gt;CCGR3 &#x3D; 0XFFFFFFFF; CCM-&gt;CCGR4 &#x3D; 0XFFFFFFFF; CCM-&gt;CCGR5 &#x3D; 0XFFFFFFFF; CCM-&gt;CCGR6 &#x3D; 0XFFFFFFFF;&#125;&#x2F;* * @description : 初始化系统时钟，设置系统时钟为528Mhz，并且设置PLL2和PLL3各个 PFD时钟,所有的时钟频率均按照I.MX6U官方手册推荐的值. * @param : 无 * @return : 无 *&#x2F;void imx6u_clkinit(void)&#123; unsigned int reg &#x3D; 0; &#x2F;* 1、设置ARM内核时钟为528MHz *&#x2F; &#x2F;* 1.1、判断当前ARM内核是使用的那个时钟源启动的，正常情况下ARM内核是由pll1_sw_clk驱动的，而 * pll1_sw_clk有两个来源：pll1_main_clk和tep_clk(参考手册648页)。 * 如果我们要让ARM内核跑到528M的话那必须选择pll1_main_clk作为pll1的时钟源。 * 如果我们要修改pll1_main_clk时钟的话就必须先将pll1_sw_clk从pll1_main_clk切换到 * step_clk,当修改完pll1_main_clk以后在将pll1_sw_clk切换回pll1_main_clk。而step_clk的 * 时钟源可以选择板子上的24MHz晶振。 *&#x2F; if((((CCM-&gt;CCSR) &gt;&gt; 2) &amp; 0x1 ) &#x3D;&#x3D; 0) &#x2F;* 当前pll1_sw_clk使用的pll1_main_clk*&#x2F; &#123; CCM-&gt;CCSR &amp;&#x3D; ~(1 &lt;&lt; 8); &#x2F;* 配置step_clk时钟源为24MH OSC *&#x2F; CCM-&gt;CCSR |&#x3D; (1 &lt;&lt; 2); &#x2F;* 配置pll1_sw_clk时钟源为step_clk *&#x2F; &#125; &#x2F;* 1.2、设置pll1_main_clk为1056MHz,也就是528*2&#x3D;1056MHZ, * 因为pll1_sw_clk进ARM内核的时候会被二分频！ * 配置CCM_ANLOG-&gt;PLL_ARM寄存器 * bit13: 1 使能时钟输出 * bit[6:0]: 88, 由公式：Fout &#x3D; Fin * div_select &#x2F; 2.0，1056&#x3D;24*div_select&#x2F;2.0, * 得出：div_select&#x3D; 88 *&#x2F; CCM_ANALOG-&gt;PLL_ARM &#x3D; (1 &lt;&lt; 13) | ((88 &lt;&lt; 0) &amp; 0X7F); &#x2F;* 配置pll1_main_clk&#x3D;1056MHz *&#x2F; CCM-&gt;CCSR &amp;&#x3D; ~(1 &lt;&lt; 2); &#x2F;* 将pll_sw_clk时钟重新切换回pll1_main_clk *&#x2F; CCM-&gt;CACRR &#x3D; 1; &#x2F;* ARM内核时钟为pll1_sw_clk&#x2F;2&#x3D;1056&#x2F;2&#x3D;528Mhz *&#x2F; &#x2F;* 2、设置PLL2(SYS PLL)各个PFD *&#x2F; reg &#x3D; CCM_ANALOG-&gt;PFD_528; reg &amp;&#x3D; ~(0X3F3F3F3F); &#x2F;* 清除原来的设置 *&#x2F; reg |&#x3D; 32&lt;&lt;24; &#x2F;* PLL2_PFD3&#x3D;528*18&#x2F;32&#x3D;297Mhz *&#x2F; reg |&#x3D; 24&lt;&lt;16; &#x2F;* PLL2_PFD2&#x3D;528*18&#x2F;24&#x3D;396Mhz(DDR使用的时钟，最大400Mhz) *&#x2F; reg |&#x3D; 16&lt;&lt;8; &#x2F;* PLL2_PFD1&#x3D;528*18&#x2F;16&#x3D;594Mhz *&#x2F; reg |&#x3D; 27&lt;&lt;0; &#x2F;* PLL2_PFD0&#x3D;528*18&#x2F;27&#x3D;352Mhz *&#x2F; CCM_ANALOG-&gt;PFD_528&#x3D;reg; &#x2F;* 设置PLL2_PFD0~3 *&#x2F; &#x2F;* 3、设置PLL3(USB1)各个PFD *&#x2F; reg &#x3D; 0; &#x2F;* 清零 *&#x2F; reg &#x3D; CCM_ANALOG-&gt;PFD_480; reg &amp;&#x3D; ~(0X3F3F3F3F); &#x2F;* 清除原来的设置 *&#x2F; reg |&#x3D; 19&lt;&lt;24; &#x2F;* PLL3_PFD3&#x3D;480*18&#x2F;19&#x3D;454.74Mhz *&#x2F; reg |&#x3D; 17&lt;&lt;16; &#x2F;* PLL3_PFD2&#x3D;480*18&#x2F;17&#x3D;508.24Mhz *&#x2F; reg |&#x3D; 16&lt;&lt;8; &#x2F;* PLL3_PFD1&#x3D;480*18&#x2F;16&#x3D;540Mhz *&#x2F; reg |&#x3D; 12&lt;&lt;0; &#x2F;* PLL3_PFD0&#x3D;480*18&#x2F;12&#x3D;720Mhz *&#x2F; CCM_ANALOG-&gt;PFD_480&#x3D;reg; &#x2F;* 设置PLL3_PFD0~3 *&#x2F; &#x2F;* 4、设置AHB时钟 最小6Mhz， 最大132Mhz (boot rom自动设置好了可以不用设置)*&#x2F; CCM-&gt;CBCMR &amp;&#x3D; ~(3 &lt;&lt; 18); &#x2F;* 清除设置*&#x2F; CCM-&gt;CBCMR |&#x3D; (1 &lt;&lt; 18); &#x2F;* pre_periph_clk&#x3D;PLL2_PFD2&#x3D;396MHz *&#x2F; CCM-&gt;CBCDR &amp;&#x3D; ~(1 &lt;&lt; 25); &#x2F;* periph_clk&#x3D;pre_periph_clk&#x3D;396MHz *&#x2F; while(CCM-&gt;CDHIPR &amp; (1 &lt;&lt; 5));&#x2F;* 等待握手完成 *&#x2F; &#x2F;* 修改AHB_PODF位的时候需要先禁止AHB_CLK_ROOT的输出，但是 * 我没有找到关闭AHB_CLK_ROOT输出的的寄存器，所以就没法设置。 * 下面设置AHB_PODF的代码仅供学习参考不能直接拿来使用！！ * 内部boot rom将AHB_PODF设置为了3分频，即使我们不设置AHB_PODF， * AHB_ROOT_CLK也依旧等于396&#x2F;3&#x3D;132Mhz。 *&#x2F;#if 0 &#x2F;* 要先关闭AHB_ROOT_CLK输出，否则时钟设置会出错 *&#x2F; CCM-&gt;CBCDR &amp;&#x3D; ~(7 &lt;&lt; 10); &#x2F;* CBCDR的AHB_PODF清零 *&#x2F; CCM-&gt;CBCDR |&#x3D; 2 &lt;&lt; 10; &#x2F;* AHB_PODF 3分频，AHB_CLK_ROOT&#x3D;132MHz *&#x2F; while(CCM-&gt;CDHIPR &amp; (1 &lt;&lt; 1));&#x2F;* 等待握手完成 *&#x2F;#endif &#x2F;* 5、设置IPG_CLK_ROOT最小3Mhz，最大66Mhz (boot rom自动设置好了可以不用设置)*&#x2F; CCM-&gt;CBCDR &amp;&#x3D; ~(3 &lt;&lt; 8); &#x2F;* CBCDR的IPG_PODF清零 *&#x2F; CCM-&gt;CBCDR |&#x3D; 1 &lt;&lt; 8; &#x2F;* IPG_PODF 2分频，IPG_CLK_ROOT&#x3D;66MHz *&#x2F; &#x2F;* 6、设置PERCLK_CLK_ROOT时钟 *&#x2F; CCM-&gt;CSCMR1 &amp;&#x3D; ~(1 &lt;&lt; 6); &#x2F;* PERCLK_CLK_ROOT时钟源为IPG *&#x2F; CCM-&gt;CSCMR1 &amp;&#x3D; ~(7 &lt;&lt; 0); &#x2F;* PERCLK_PODF位清零，即1分频 *&#x2F; &#x2F;* 设置UART时钟源频率为80M *&#x2F; CCM-&gt;CSCDR1 &amp;&#x3D; ~(1 &lt;&lt; 6); &#x2F;* UART时钟源为pll3_80m *&#x2F; CCM-&gt;CSCDR1 &amp;&#x3D; ~0X3F; &#x2F;* UART时钟1分频 *&#x2F; &#x2F;* 设置ECSPI时钟源为60Mhz *&#x2F; CCM-&gt;CSCDR2 &amp;&#x3D; ~(1 &lt;&lt; 18); &#x2F;* ECSPI时钟源为pll3_60m*&#x2F; CCM-&gt;CSCDR2 &amp;&#x3D; ~(0X3F &lt;&lt; 19); &#x2F;* ECSPI 1分频 *&#x2F;&#125; 函数 clk_enable使能 I.MX6U 的所有外设时钟。 函数 imx6u_clkinit 先设置系统主频为 528MHz，然后根据分析的 I.MX6U 时钟系统来 设置 8 路 PFD，最后设置 AHB、IPG 和 PERCLK 的时钟频率。","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"时钟","slug":"时钟","permalink":"https://guoqiang-gump.github.io/tags/%E6%97%B6%E9%92%9F/"}]},{"title":"IMX6U按键","date":"2021-03-03T09:30:19.000Z","path":"2021/03/03/IMX6U按键/","text":"一、硬件原理图分析按键 KEY0 是连接到 I.MX6U 的 UART1_CTS 这个 IO 上的，KEY0接了一个 10K 的上拉电阻，因此 KEY0 没有按下的时候 UART1_CTS 应该是高电平，当 KEY0 按下以后 UART1_CTS 就是低电平。 二、实验程序编写​ 1、设置UART1_CTS复用为GPIO1_IO18 ​ 2、设置UART1_CTS的电气属性。 ​ 3、配置GPIO1_IO08为输入模式。 ​ 4、读取按键值，也就是GPIO1_IO08的高低电平 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#ifndef _BSP_GPIO_H#define _BSP_GPIO_H#define _BSP_KEY_H#include &quot;imx6ul.h&quot;&#x2F;***************************************************************文件名 : bsp_gpio.h描述 : GPIO操作文件头文件。***************************************************************&#x2F;&#x2F;* * 枚举类型和结构体定义 *&#x2F;typedef enum _gpio_pin_direction&#123; kGPIO_DigitalInput &#x3D; 0U, &#x2F;* 输入 *&#x2F; kGPIO_DigitalOutput &#x3D; 1U, &#x2F;* 输出 *&#x2F;&#125; gpio_pin_direction_t;&#x2F;* * GPIO中断触发类型枚举 *&#x2F;typedef enum _gpio_interrupt_mode&#123; kGPIO_NoIntmode &#x3D; 0U, &#x2F;* 无中断功能 *&#x2F; kGPIO_IntLowLevel &#x3D; 1U, &#x2F;* 低电平触发 *&#x2F; kGPIO_IntHighLevel &#x3D; 2U, &#x2F;* 高电平触发 *&#x2F; kGPIO_IntRisingEdge &#x3D; 3U, &#x2F;* 上升沿触发 *&#x2F; kGPIO_IntFallingEdge &#x3D; 4U, &#x2F;* 下降沿触发 *&#x2F; kGPIO_IntRisingOrFallingEdge &#x3D; 5U, &#x2F;* 上升沿和下降沿都触发 *&#x2F;&#125; gpio_interrupt_mode_t; &#x2F;* * GPIO配置结构体 *&#x2F; typedef struct _gpio_pin_config&#123; gpio_pin_direction_t direction; &#x2F;* GPIO方向:输入还是输出 *&#x2F; uint8_t outputLogic; &#x2F;* 如果是输出的话，默认输出电平 *&#x2F; gpio_interrupt_mode_t interruptMode; &#x2F;* 中断方式 *&#x2F;&#125; gpio_pin_config_t;&#x2F;* 函数声明 *&#x2F;void gpio_init(GPIO_Type *base, int pin, gpio_pin_config_t *config);int gpio_pinread(GPIO_Type *base, int pin);void gpio_pinwrite(GPIO_Type *base, int pin, int value);void gpio_intconfig(GPIO_Type* base, unsigned int pin, gpio_interrupt_mode_t pinInterruptMode);void gpio_enableint(GPIO_Type* base, unsigned int pin);void gpio_disableint(GPIO_Type* base, unsigned int pin);void gpio_clearintflags(GPIO_Type* base, unsigned int pin);#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &quot;bsp_gpio.h&quot;&#x2F;***************************************************************文件名 : bsp_gpio.h描述 : GPIO操作文件 **************************************************************&#x2F;&#x2F;* * @description : GPIO初始化。 * @param - base : 要初始化的GPIO组。 * @param - pin : 要初始化GPIO在组内的编号。 * @param - config : GPIO配置结构体。 * @return : 无 *&#x2F;void gpio_init(GPIO_Type *base, int pin, gpio_pin_config_t *config)&#123; base-&gt;IMR &amp;&#x3D; ~(1U &lt;&lt; pin); if(config-&gt;direction &#x3D;&#x3D; kGPIO_DigitalInput) &#x2F;* GPIO作为输入 *&#x2F; &#123; base-&gt;GDIR &amp;&#x3D; ~( 1 &lt;&lt; pin); &#125; else &#x2F;* 输出 *&#x2F; &#123; base-&gt;GDIR |&#x3D; 1 &lt;&lt; pin; gpio_pinwrite(base,pin, config-&gt;outputLogic); &#x2F;* 设置默认输出电平 *&#x2F; &#125; gpio_intconfig(base, pin, config-&gt;interruptMode); &#x2F;* 中断功能配置 *&#x2F;&#125;&#x2F;* * @description : 读取指定GPIO的电平值 。 * @param - base : 要读取的GPIO组。 * @param - pin : 要读取的GPIO脚号。 * @return : 无 *&#x2F; int gpio_pinread(GPIO_Type *base, int pin) &#123; return (((base-&gt;DR) &gt;&gt; pin) &amp; 0x1); &#125;&#x2F;* * @description : 指定GPIO输出高或者低电平 。 * @param - base : 要输出的的GPIO组。 * @param - pin : 要输出的GPIO脚号。 * @param - value : 要输出的电平，1 输出高电平， 0 输出低低电平 * @return : 无 *&#x2F;void gpio_pinwrite(GPIO_Type *base, int pin, int value)&#123; if (value &#x3D;&#x3D; 0U) &#123; base-&gt;DR &amp;&#x3D; ~(1U &lt;&lt; pin); &#x2F;* 输出低电平 *&#x2F; &#125; else &#123; base-&gt;DR |&#x3D; (1U &lt;&lt; pin); &#x2F;* 输出高电平 *&#x2F; &#125;&#125;&#x2F;* * @description : 设置GPIO的中断配置功能 * @param - base : 要配置的IO所在的GPIO组。 * @param - pin : 要配置的GPIO脚号。 * @param - pinInterruptMode: 中断模式，参考枚举类型gpio_interrupt_mode_t * @return : 无 *&#x2F;void gpio_intconfig(GPIO_Type* base, unsigned int pin, gpio_interrupt_mode_t pin_int_mode)&#123; volatile uint32_t *icr; uint32_t icrShift; icrShift &#x3D; pin; base-&gt;EDGE_SEL &amp;&#x3D; ~(1U &lt;&lt; pin); if(pin &lt; 16) &#x2F;* 低16位 *&#x2F; &#123; icr &#x3D; &amp;(base-&gt;ICR1); &#125; else &#x2F;* 高16位 *&#x2F; &#123; icr &#x3D; &amp;(base-&gt;ICR2); icrShift -&#x3D; 16; &#125; switch(pin_int_mode) &#123; case(kGPIO_IntLowLevel): *icr &amp;&#x3D; ~(3U &lt;&lt; (2 * icrShift)); break; case(kGPIO_IntHighLevel): *icr &#x3D; (*icr &amp; (~(3U &lt;&lt; (2 * icrShift)))) | (1U &lt;&lt; (2 * icrShift)); break; case(kGPIO_IntRisingEdge): *icr &#x3D; (*icr &amp; (~(3U &lt;&lt; (2 * icrShift)))) | (2U &lt;&lt; (2 * icrShift)); break; case(kGPIO_IntFallingEdge): *icr |&#x3D; (3U &lt;&lt; (2 * icrShift)); break; case(kGPIO_IntRisingOrFallingEdge): base-&gt;EDGE_SEL |&#x3D; (1U &lt;&lt; pin); break; default: break; &#125;&#125;&#x2F;* * @description : 使能GPIO的中断功能 * @param - base : 要使能的IO所在的GPIO组。 * @param - pin : 要使能的GPIO在组内的编号。 * @return : 无 *&#x2F;void gpio_enableint(GPIO_Type* base, unsigned int pin)&#123; base-&gt;IMR |&#x3D; (1 &lt;&lt; pin);&#125;&#x2F;* * @description : 禁止GPIO的中断功能 * @param - base : 要禁止的IO所在的GPIO组。 * @param - pin : 要禁止的GPIO在组内的编号。 * @return : 无 *&#x2F;void gpio_disableint(GPIO_Type* base, unsigned int pin)&#123; base-&gt;IMR &amp;&#x3D; ~(1 &lt;&lt; pin);&#125;&#x2F;* * @description : 清除中断标志位(写1清除) * @param - base : 要清除的IO所在的GPIO组。 * @param - pin : 要清除的GPIO掩码。 * @return : 无 *&#x2F;void gpio_clearintflags(GPIO_Type* base, unsigned int pin)&#123; base-&gt;ISR |&#x3D; (1 &lt;&lt; pin);&#125; 枚举类型 gpio_pin_direction_t 表示 GPIO 方向，输入或输出。 结构体 gpio_pin_config_t 是 GPIO 的配置结构体，里面有 GPIO 的方向和默认输出电平两个成员变量。 函数 gpio_init 用于初始化指定的 GPIO 引脚，最终配置的是 GDIR 寄存器。 函数 gpio_pinread 是读取指定的 GPIO 值，也就是读取 DR 寄存器的指定位 函数 gpio_pinwrite 是控制指定的 GPIO 引脚输入高电平(1)或者低电平(0)，就是设置 DR 寄 存器的指定位。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 #include &quot;bsp_key.h&quot;#include &quot;bsp_gpio.h&quot;#include &quot;bsp_delay.h&quot;&#x2F;***************************************************************描述 : 按键驱动文件。***************************************************************&#x2F;&#x2F;* * @description : 初始化按键 *&#x2F;void key_init(void)&#123; gpio_pin_config_t key_config; &#x2F;* 1、初始化IO复用, 复用为GPIO1_IO18 *&#x2F; IOMUXC_SetPinMux(IOMUXC_UART1_CTS_B_GPIO1_IO18,0); &#x2F;* 2、、配置UART1_CTS_B的IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 11 默认22K上拉 *bit [13]: 1 pull功能 *bit [12]: 1 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 000 关闭输出 *bit [0]: 0 低转换率 *&#x2F; IOMUXC_SetPinConfig(IOMUXC_UART1_CTS_B_GPIO1_IO18,0xF080); &#x2F;* 3、初始化GPIO *&#x2F; &#x2F;&#x2F;GPIO1-&gt;GDIR &amp;&#x3D; ~(1 &lt;&lt; 18); &#x2F;* GPIO1_IO18设置为输入 *&#x2F; key_config.direction &#x3D; kGPIO_DigitalInput; gpio_init(GPIO1,18, &amp;key_config); &#125;&#x2F;* * @description : 获取按键值 * @param : 无 * @return : 0 没有按键按下，其他值:对应的按键值 *&#x2F;int key_getvalue(void)&#123; int ret &#x3D; 0; static unsigned char release &#x3D; 1; &#x2F;* 按键松开 *&#x2F; if((release&#x3D;&#x3D;1)&amp;&amp;(gpio_pinread(GPIO1, 18) &#x3D;&#x3D; 0)) &#x2F;* KEY0 *&#x2F; &#123; delay(10); &#x2F;* 延时消抖 *&#x2F; release &#x3D; 0; &#x2F;* 标记按键按下 *&#x2F; if(gpio_pinread(GPIO1, 18) &#x3D;&#x3D; 0) ret &#x3D; KEY0_VALUE; &#125; else if(gpio_pinread(GPIO1, 18) &#x3D;&#x3D; 1) &#123; ret &#x3D; 0; release &#x3D; 1; &#x2F;* 标记按键释放 *&#x2F; &#125; return ret; &#125; key_init 是按键初始化函数，用来初始化按键所使用的 UART1_CTS 这个 IO。函数 key_init 先设置 UART1_CTS 复用为 GPIO1_IO18，然后配置 UART1_CTS 这个 IO 为速度为 100MHz，默认 22K 上拉。最后调用函数 gpio_init 来设置 GPIO1_IO18 为输入功能。 函数 key_getvalue 用于获取按键值，此函数没有参数，只有一个返回值，返回值表示按键值，返回值为 0 的话就表示没有按键按下，如果返回其他值的话就表示对应的按键按下了。获取按键值其实就是不断的读取 GPIO1_IO18 的值，如果按键按下的话相应的 IO 被拉低，那么GPIO1_IO18 值就为 0，如果按键未按下的话 GPIO1_IO18 的值就为 1。此函数中静态局部变量 release 表示按键是否释放。 三、问题与解决​ 问题：加上清除BSS段，代码不运行 ​ 解决：bss_start = 0X87800289。对于32位的SOC来说，一般访问是4字节访问的。0X0,0X4,0X8,0XC。芯片处理的时候以4字节访问，因此会从0X878000288开始清除BSS段。然而0X878000288不属于BSS段。所以我们需要对bss_start进行四字节对其。按照四字节对其的原理，bss_start=0X8780028C。所以需要设置bss_start为四字节对其。","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"按键","slug":"按键","permalink":"https://guoqiang-gump.github.io/tags/%E6%8C%89%E9%94%AE/"}]},{"title":"IMX6U蜂鸣器","date":"2021-03-02T16:11:05.000Z","path":"2021/03/03/IMX6U蜂鸣器/","text":"硬件原理图分析有源蜂鸣器内部带有震荡源，所以有源蜂鸣器只要通电就会叫。I.MX6U-ALPHA 开发板使用的是有源蜂鸣器，因此只要给其供电就会工作。 BEEP控制IO为SNVS_TAMPER1，当输出高电平的时候蜂鸣器关闭，输出低电平的时候蜂鸣器打开。 实验程序编写​ 1、初始化SNVS_TAMPER1这个IO复用为GPIO5_IO01 ​ 2、设置SNVS_TAMPER1这个IO的电气属性。 ​ 3、初始化GPIO ​ 4、控制GPIO输出高低电平。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;bsp_beep.h&quot;&#x2F;***************************************************************描述 : 蜂鸣器驱动文件。***************************************************************&#x2F;&#x2F;* * @description : 初始化蜂鸣器对应的IO *&#x2F;void beep_init(void)&#123; &#x2F;* 1、初始化IO复用，复用为GPIO5_IO01 *&#x2F; IOMUXC_SetPinMux(IOMUXC_SNVS_SNVS_TAMPER1_GPIO5_IO01,0); &#x2F;* 2、、配置GPIO1_IO03的IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 00 默认下拉 *bit [13]: 0 kepper功能 *bit [12]: 1 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 110 R0&#x2F;6驱动能力 *bit [0]: 0 低转换率 *&#x2F; IOMUXC_SetPinConfig(IOMUXC_SNVS_SNVS_TAMPER1_GPIO5_IO01,0X10B0); &#x2F;* 3、初始化GPIO,GPIO5_IO01设置为输出 *&#x2F; GPIO5-&gt;GDIR |&#x3D; (1 &lt;&lt; 1); &#x2F;* 4、设置GPIO5_IO01输出高电平，关闭蜂鸣器 *&#x2F; GPIO5-&gt;DR |&#x3D; (1 &lt;&lt; 1); &#125;&#x2F;* * @description : 蜂鸣器控制函数，控制蜂鸣器打开还是关闭 * @param - status : 0，关闭蜂鸣器，1 打开蜂鸣器 * @return : 无 *&#x2F;void beep_switch(int status)&#123; if(status &#x3D;&#x3D; ON) GPIO5-&gt;DR &amp;&#x3D; ~(1 &lt;&lt; 1); &#x2F;* 打开蜂鸣器 *&#x2F; else if(status &#x3D;&#x3D; OFF) GPIO5-&gt;DR |&#x3D; (1 &lt;&lt; 1); &#x2F;* 关闭蜂鸣器 *&#x2F;&#125;","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"蜂鸣器","slug":"蜂鸣器","permalink":"https://guoqiang-gump.github.io/tags/%E8%9C%82%E9%B8%A3%E5%99%A8/"}]},{"title":"IMX6U_C语言LED","date":"2021-03-02T16:00:05.000Z","path":"2021/03/03/IMX6U-C语言LED/","text":"C语言运行环境构建在开始部分用汇编来初始化一下 C 语言环境，比如初始化 DDR、设置堆栈指针 SP 等等，当这些工作都做完以后就可以进入 C 语言环境，也就是运行 C 语言代码，一般都是进入 main 函数。所以我们有两部分文件要做： ①、汇编文件 汇编文件只是用来完成 C 语言环境搭建。 ②、C 语言文件 C 语言文件就是完成我们的业务层代码的，其实就是我们实际例程要完成的功能。 设置处理器模式​ 设置6ULL处于SVC模式 下。设置CPSR寄存器的bit4-0，也就是M[4:0]为10011=0X13。读写状态寄存器需要用到MRS和MSR指令。MRS将CPSR寄存器数据读出到通用寄存器里面，MSR指令将通用寄存器的值写入到CPSR寄存器里面去。 设置sp指针​ Sp可以指向内部RAM，也可以指向DDR，我们将其指向DDR。Sp设置到哪里？512MB的范围0x80000000~0x9FFFFFFF。栈大小，0x200000=2MB。处理器栈增长方式，对于A7而言是向下增长的。设置sp指向0x80200000。 跳转到C语言​ 使用b指令，跳转到C语言函数，比如main函数。 汇编文件只是用来完成 C 语言环境搭建。 12345678910111213141516.global _start &#x2F;* 全局标号 *&#x2F;&#x2F;* * 描述： _start函数，程序从此函数开始执行，此函数主要功能是设置C * 运行环境。 *&#x2F;_start: &#x2F;* 进入SVC模式 *&#x2F; mrs r0, cpsr bic r0, r0, #0x1f &#x2F;* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 *&#x2F; orr r0, r0, #0x13 &#x2F;* r0或上0x13,表示使用SVC模式 *&#x2F; msr cpsr, r0 &#x2F;* 将r0 的数据写入到cpsr_c中 *&#x2F; ldr sp, &#x3D;0X80200000 &#x2F;* 设置栈指针 *&#x2F; b main &#x2F;* 跳转到main函数 *&#x2F; 第 1 行定义了一个全局标号_start。 第 7 行就是标号_start 开始的地方，相当于是一个_start 函数，这个_start 就是第一行代码。 第 10~13 行就是设置处理器进入 SVC 模式，在 6.2 小节的“Cortex-A 处理器运行模型”中 我们说过 Cortex-A 有九个运行模型，这里我们设置处理器运行在 SVC 模式下。处理器模式的 设置是通过修改 CPSR(程序状态)寄存器来完成的，在 6.3.2 小节中我们详细的讲解了 CPSR 寄 存器，其中 M[4:0](CPSR 的 bit[4:0])就是设置处理器运行模式的，参考表 6.3.2.2，如果要将处 理器设置为 SVC 模式，那么 M[4:0]就要等于 0X13。11~13 行代码就是先使用指令 MRS 将 CPSR 寄存器的值读取到 R0 中，然后修改 R0 中的值，设置 R0 的 bit[4:0]为 0X13，然后再使用指令 MSR 将修改后的 R0 重新写入到 CPSR 中。 第 15 行通过 ldr 指令设置 SVC 模式下的 SP 指针=0X80200000，因为 I.MX6U-ALPHA 开 发 板 上 的 DDR3 地 址 范 围 是 0X80000000~0XA0000000(512MB) 或 者 0X80000000~0X90000000(256MB)，不管是 512MB 版本还是 256MB 版本的，其 DDR3 起始地 址都是 0X80000000。由于 Cortex-A7 的堆栈是向下增长的，所以将 SP 指针设置为 0X80200000， 因此 SVC 模式的栈大小 0X80200000-0X80000000=0X200000=2MB，2MB 的栈空间已经很大了， 如果做裸机开发的话绰绰有余。 第 16 行就是跳转到 main 函数，main 函数就是 C 语言代码了。 几行代码，用来设置处理器运行到 SVC 模式下、然后初始 化 SP 指针、最终跳转到 C 文件的 main 函数中。 start.s 文件中却没有初始化 DDR3 的代码，DDR3 肯定是要初始化的，但是不需要在 start.s 文 件中完成。在 9.4.2 小节里面分析 DCD 数据的时候就已经讲过了，DCD 数据包含了 DDR 配置 参数，I.MX6U 内部的 Boot ROM 会读取 DCD 数据中的 DDR 配置参数然后完成 DDR 初始化 的。 C 语言部分实验程序编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&#x2F;**************************************************************描述 : I.MX6U开发板裸机实验2 C语言点灯使用C语言来点亮开发板上的LED灯，学习 和掌握如何用C语言来完成对I.MX6U处理器的GPIO初始化和控制。**************************************************************&#x2F;#include &quot;main.h&quot;&#x2F;* * @description : 使能I.MX6U所有外设时钟 *&#x2F;void clk_enable(void)&#123; CCM_CCGR0 &#x3D; 0xffffffff; CCM_CCGR1 &#x3D; 0xffffffff; CCM_CCGR2 &#x3D; 0xffffffff; CCM_CCGR3 &#x3D; 0xffffffff; CCM_CCGR4 &#x3D; 0xffffffff; CCM_CCGR5 &#x3D; 0xffffffff; CCM_CCGR6 &#x3D; 0xffffffff;&#125;&#x2F;* * @description : 初始化LED对应的GPIO *&#x2F;void led_init(void)&#123; &#x2F;* 1、初始化IO复用 *&#x2F; SW_MUX_GPIO1_IO03 &#x3D; 0x5; &#x2F;* 复用为GPIO1_IO03 *&#x2F; &#x2F;* 2、、配置GPIO1_IO03的IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 00 默认下拉 *bit [13]: 0 kepper功能 *bit [12]: 1 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 110 R0&#x2F;6驱动能力 *bit [0]: 0 低转换率 *&#x2F; SW_PAD_GPIO1_IO03 &#x3D; 0X10B0; &#x2F;* 3、初始化GPIO *&#x2F; GPIO1_GDIR &#x3D; 0X0000008; &#x2F;* GPIO1_IO03设置为输出 *&#x2F; &#x2F;* 4、设置GPIO1_IO03输出低电平，打开LED0 *&#x2F; GPIO1_DR &#x3D; 0X0;&#125;&#x2F;* * @description : 打开LED灯 *&#x2F;void led_on(void)&#123; &#x2F;* * 将GPIO1_DR的bit3清零 *&#x2F; GPIO1_DR &amp;&#x3D; ~(1&lt;&lt;3); &#125;&#x2F;* * @description : 关闭LED灯 *&#x2F;void led_off(void)&#123; &#x2F;* * 将GPIO1_DR的bit3置1 *&#x2F; GPIO1_DR |&#x3D; (1&lt;&lt;3);&#125; 链接脚本1234567891011121314SECTIONS&#123; . &#x3D; 0X87800000; .text : &#123; start.o main.o *(.text) &#125; .rodata ALIGN(4) : &#123;*(.rodata*)&#125; .data ALIGN(4) : &#123; *(.data) &#125; __bss_start &#x3D; .; .bss ALIGN(4) : &#123; *(.bss) *(COMMON) &#125; __bss_end &#x3D; .;&#125; 第 2 行设置定位计数器为0X87800000，因为我们的链接地址就是0X87800000。 第5行设置链接到开始位置的文件为start.o，因为 start.o 里面包含着第一个要执行的指令，所以一定要链接到最开始的地方。 第 6 行是 main.o这个文件，其实可以不用写出来，因为 main.o 的位置就无所谓了，可以由编译器自行决定链接 位置。 在第 11、13 行有“__bss_start”和“__bss_end”这两个东西？这个是什么呢？“__bss_start” 和“__bss_end”是符号，第 11、13 这两行其实就是对这两个符号进行赋值，其值为定位符“.”， 这两个符号用来保存.bss 段的起始地址和结束地址。前面说了.bss 段是定义了但是没有被初始化的变量，我们需要手动对.bss 段的变量清零的，因此我们需要知道.bss 段的起始和结束地址， 这样我们直接对这段内存赋 0 即可完成清零。 通过第 11、13 行代码，.bss 段的起始地址和结束 地址就保存在了“__bss_start”和“__bss_end”中，我们就可以直接在汇编或者 C 文件里面使 用这两个符号。","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"C语言","slug":"C语言","permalink":"https://guoqiang-gump.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"IMX6U编译与烧写","date":"2021-03-02T15:32:19.000Z","path":"2021/03/02/IMX6U编译与烧写/","text":"编译程序​ 1、编译程序 ①、使用arm-linux-gnueabihf-gcc将.c .s文件变为.o ②、将所有的.o文件连接为elf格式的可执行文件。 ③、将elf文件转为bin文件。 ④、将elf文件转为汇编，反汇编。 链接： ​ 链接就是将所有.o文件链接在一起，并且链接到指定的地方。本实验链接的时候要指定链接起始地址。链接起始地址就是代码运行的起始地址。 ​ 对于6ULL来说，链接起始地址应该指向RAM地址。RAM分为内部RAM和外部RAM，也就是 DDR。6ULL内部RAM地址范围0X9000000X91FFFF。也可以放到外部DDR中，对于I.MX6U-ALPHA开发板，512MB字节DDR版本的核心板，DDR范围就是0X800000000X9FFFFFFF。对于256MB的DDR来说，那就0X80000000~0X8FFFFFFF。 ​ 本系列视频，裸机代码的链接起始地址为0X87800000。要使用DDR，那么必须要初始化DDR，对于I.MX来说bin文件不能直接运行，需要添加一个头部，这个头部信息包含了DDR的初始化参数，I.MX系列SOC内部boot rom会从SD卡，EMMC等外置存储中读取头部信息，然后初始化DDR，并且将bin文件拷贝到指定的地方。 ​ Bin的运行地址一定要和链接起始地址一致。位置无关代码除外。 编译代码arm-linux-gnueabihf-gcc 编译文件 1arm-linux-gnueabihf-gcc -g -c led.s -o led.o 上述命令就是将 led.s 编译为 led.o，其中“-g”选项是产生调试信息，GDB 能够使用这些调试信息进行代码调试。“-c”选项是编译源文件，但是不链接。“-o”选项是指定编译产生的文件名字，这里我们指定 led.s 编译完成以后的文件名字为 led.o。 arm-linux-gnueabihf-ld 链接文件 本试验最终的可执行文件其运行起始地址，也就是链接地址。这里我们要区分“存储地址”和“运行地址”这两个概念，“存储地址”就是可执 行文件存储在哪里，可执行文件的存储地址可以随意选择。“运行地址”就是代码运行的时候所处的地址，这个我们在链接的时候就已经确定好了，代码要运行，那就必须处于运行地址处，否则代码肯定运行出错。比如 I.MX6U 支持 SD 卡、EMMC、NAND 启动，因此代码可以 存储到 SD 卡、EMMC 或者 NAND 中，但是要运行的话就必须将代码从 SD 卡、EMMC 或者NAND 中拷贝到其运行地址(链接地址)处，“存储地址”和“运行地址”可以一样。 裸机例程都是烧写到 SD 卡中，上电以后 I.MX6U 的内部 boot rom 程序会将 可执行文件拷贝到链接地址处，这个链接地址可以在 I.MX6U 的内部 128KB RAM 中 (0X900000~0X91FFFF)，也可以在外部的 DDR 中。所有裸机例程的链接地址都在 DDR 中，链接起始地址为 0X87800000。之所以选择 0X87800000 这个地址是因为后面要讲的 Uboot 其链接地址就是 0X87800000，这样我们统一使用 0X87800000 这个链接地址，不容易记混。 确定了链接地址以后就可以使用 arm-linux-gnueabihf-ld 来将前面编译出来的 led.o 文件链接到 0X87800000 这个地址，使用如下命令： 1arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf 上述命令中-Ttext 就是指定链接地址，“-o”选项指定链接生成的 elf 文件名，这里我们命名为 led.elf。上述命令执行完以后就会在工程目录下多一个 led.elf 文件， arm-linux-gnueabihf-objcopy 格式转换 arm-linux-gnueabihf-objcopy 更像一个格式转换工具，我们需要用它将 led.elf 文件转换为led.bin 文件 1arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin 上述命令中，“-O”选项指定以什么格式输出，后面的“binary”表示以二进制格式输出，选项“-S”表示不要复制源文件中的重定位信息和符号信息，“-g”表示不复制源文件中的调试信息。 arm-linux-gnueabihf-objdump 反汇编 大多数情况下我们都是用 C 语言写试验例程的，有时候需要查看其汇编代码来调试代码，因此就需要进行反汇编，一般可以将 elf 文件反汇编，比如如下命令： 1arm-linux-gnueabihf-objdump -D led.elf &gt; led.dis 上述代码中的“-D”选项表示反汇编所有的段。 烧写bin文件6ULL支持SD卡、EMMC、NAND、nor、SPI flash等等启动。裸机例程选择烧写到SD卡里面。 ​ 在ubuntu下向SD卡烧写裸机bin文件。烧写不是将bin文件拷贝到SD卡中，而是将bin文件烧写到SD卡绝对地址上。而且对于I.MX而言，不能直接烧写bin文件，比如先在bin文件前面添加头部。完成这个工作，需要使用正点原子提供的imxdownload软件。Imxdownload使用方法，确定要烧写的SD卡文件。 12给予imxdownload可执行权限：Chmod 777 imxdownload 12烧写：.&#x2F;imxdownload led.bin &#x2F;dev&#x2F;sdf ​ Imxdownlaod会向led.bin添加一个头部，生成新的load.imx文件，这个load.imx文件就是最终烧写到SD卡里面去的。 链接脚本在上面的 Makefile 中我们链接代码的时候使用如下语句： 1arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf $^ 上面语句中我们是通过“-Ttext”来指定链接地址是 0X87800000 的，这样的话所有的文件都会链接到0X87800000 为起始地址的区域。要完成指定一个文件或者函数应该存放到哪个段里面去这个功能我们就需要使用到链接脚本，链接脚本主要用于链接的，用于描述文件应该如何被链接在一起形成最终的可执行文件。其主要目的是描述输入文件中的段如何被映射到输出文件中，并且控制输出文件中的内存排布。我们一般编译出来的代码都包含在 text、data、bss 和 rodata 这四个段内。 12345671 SECTIONS&#123; 2 . &#x3D; 0X10000000; 3 .text : &#123;*(.text)&#125;4 . &#x3D; 0X30000000; 5 .data ALIGN(4) : &#123; *(.data) &#125; 6 .bss ALIGN(4) : &#123; *(.bss) &#125; 7 &#125; 第 1 行我们先写了一个关键字“SECTIONS”，后面跟了一个大括号，这个大括号和第 7 行的大括号是一对，这是必须的。看起来就跟 C 语言里面的函数一样。第 2 行对一个特殊符号“.”进行赋值，“.”在链接脚本里面叫做定位计数器，默认的定位计数器为0。我们要求代码链接到以 0X10000000 为起始地址的地方，因此这一行给“.”赋值0X10000000，表示以 0X10000000 开始，后面的文件或者段都会以 0X10000000 为起始地址开始链接。 第 3 行的“.text”是段名，后面的冒号是语法要求，冒号后面的大括号里面可以填上要链接到“.text”这个段里面的所有文件，“*(.text)”中的“*”是通配符，表示所有输入文件的.text段都放到“.text”中。 第 4 行，我们的要求是数据放到 0X30000000 开始的地方，所以我们需要重新设置定位计数器“.”，将其改为 0X30000000。 第 5 行定义了一个名为“.data”的段，然后所有文件的“.data”段都放到这里面。但是这一行多了一个“ALIGN(4)”用来对“.data”这个段的起 始地址做字节对齐的，ALIGN(4)表示 4 字节对齐。也就是说段“.data”的起始地址要能被 4 整 除，一般常见的都是 ALIGN(4)或者 ALIGN(8)，也就是 4 字节或者 8 字节对齐。 第 6 行定义了一个“.bss”段，所有文件中的“.bss”数据都会被放到这个里面，“.bss”数据就是那些定义了但是没有被初始化的变量。","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"编译","slug":"编译","permalink":"https://guoqiang-gump.github.io/tags/%E7%BC%96%E8%AF%91/"},{"name":"烧写","slug":"烧写","permalink":"https://guoqiang-gump.github.io/tags/%E7%83%A7%E5%86%99/"}]},{"title":"IMX6U汇编LED","date":"2021-03-02T12:02:00.000Z","path":"2021/03/02/IMX6U汇编LED/","text":"一、汇编LED原理分析​ 为什么要学习Cortex-A汇编： ​ ①、需要用汇编初始化一些SOC外设。 ​ ②、使用汇编初始化DDR，I.MX6U不需要。 ​ ③、设置sp指针，一般指向DDR，设置好C语言运行环境。 1、ALPHA开发板LED灯硬件原理分析：I.MX6ULL IO初始化：​ LED0 接到了 GPIO_3 上，GPIO_3 就是 GPIO1_IO03，当 GPIO1_IO03输出低电平(0)的时候发光二极管 LED0 就会导通点亮，当 GPIO1_IO03 输出高电平(1)的时候发 光二极管 LED0 不会导通，因此 LED0 也就不会点亮。所以 LED0 的亮灭取决于 GPIO1_IO03的输出电平，输出 0 就亮，输出 1 就灭。 ①、使能 GPIO1 时钟，GPIO1 的时钟由 CCM_CCGR1 的 bit27 和 bit26 这两个位控制，将这两个位都设置位 11 即可。将 I.MX6U 的所有外设时钟都已经打开了，因此这一步可以不用做。 ​ ②、设置 GPIO1_IO03 的复用功能，将寄存器IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03的bit3~0设置为0101=5，这样GPIO1_IO03就复用为GPIO。 ​ ③、寄存器IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03是设置GPIO1_IO03的电气属性。包括压摆率、速度、驱动能力、开漏、上下拉等。 ​ ④、配置GPIO功能，设置输入输出。设置GPIO1_DR寄存器bit3为1，也就是设置为输出模式。设置GPIO1_DR寄存器的bit3，为1表示输出高电平，为0表示输出低电平。 LED0 接到了 GPIO_3 上，GPIO_3 就是 GPIO1_IO03，当 GPIO1_IO03输出低电平(0)的时候发光二极管 LED0 就会导通点亮，当 GPIO1_IO03 输出高电平(1)的时候发 光二极管 LED0 不会导通，因此 LED0 也就不会点亮。所以 LED0 的亮灭取决于 GPIO1_IO03的输出电平，输出 0 就亮，输出 1 就灭。 实验程序编写1、使能 GPIO1 时钟GPIO1 的时钟由 CCM_CCGR1 的 bit27 和 bit26 这两个位控制，将这两个位都设置位 11 即可。本教程所有例程已经将 I.MX6U 的所有外设时钟都已经打开了，因此这一步可以不用做。 2、设置 GPIO1_IO03 的复用功能找到 GPIO1_IO03 的复用寄存器“IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03”的地址为0X020E0068，然后设置此寄存器，将 GPIO1_IO03 这个 IO 复用为 GPIO 功能，也就是 ALT5。 3、配置 GPIO1_IO03找到 GPIO1_IO03 的配置寄存器“IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03”的地址为0X020E02F4，根据实际使用情况，配置此寄存器. 4、设置 GPIO 本实验中 GPIO1_IO03 是作为输出功能的，因此 GPIO1_GDIR 的 bit3 要设置为 1，表示输出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 &#x2F;&#x2F;led.s 文件源码.global _start &#x2F;* 全局标号 *&#x2F;&#x2F;* 描述： _start函数，程序从此函数开始执行此函数完成时钟使能、GPIO初始化、最终控制GPIO输出低电平来点亮LED灯。 *&#x2F;_start: &#x2F;* 例程代码 *&#x2F; &#x2F;* 1、使能所有时钟 *&#x2F; ldr r0, &#x3D;0X020C4068 &#x2F;* CCGR0 *&#x2F; ldr r1, &#x3D;0XFFFFFFFF str r1, [r0] ldr r0, &#x3D;0X020C406C &#x2F;* CCGR1 *&#x2F; str r1, [r0] ldr r0, &#x3D;0X020C4070 &#x2F;* CCGR2 *&#x2F; str r1, [r0] ldr r0, &#x3D;0X020C4074 &#x2F;* CCGR3 *&#x2F; str r1, [r0] ldr r0, &#x3D;0X020C4078 &#x2F;* CCGR4 *&#x2F; str r1, [r0] ldr r0, &#x3D;0X020C407C &#x2F;* CCGR5 *&#x2F; str r1, [r0] ldr r0, &#x3D;0X020C4080 &#x2F;* CCGR6 *&#x2F; str r1, [r0] &#x2F;* 2、设置GPIO1_IO03复用为GPIO1_IO03 *&#x2F; ldr r0, &#x3D;0X020E0068 &#x2F;* 将寄存器SW_MUX_GPIO1_IO03_BASE加载到r0中 *&#x2F; ldr r1, &#x3D;0X5 &#x2F;* 设置寄存器SW_MUX_GPIO1_IO03_BASE的MUX_MODE为5 *&#x2F; str r1,[r0] &#x2F;* 3、配置GPIO1_IO03的IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 00 默认下拉 *bit [13]: 0 kepper功能 *bit [12]: 1 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 110 R0&#x2F;6驱动能力 *bit [0]: 0 低转换率 *&#x2F; ldr r0, &#x3D;0X020E02F4 &#x2F;*寄存器SW_PAD_GPIO1_IO03_BASE *&#x2F; ldr r1, &#x3D;0X10B0 str r1,[r0] &#x2F;* 4、设置GPIO1_IO03为输出 *&#x2F; ldr r0, &#x3D;0X0209C004 &#x2F;*寄存器GPIO1_GDIR *&#x2F; ldr r1, &#x3D;0X0000008 str r1,[r0] &#x2F;* 5、打开LED0 \\* 设置GPIO1_IO03输出低电平 *&#x2F; ldr r0, &#x3D;0X0209C000 &#x2F;*寄存器GPIO1_DR *&#x2F; ldr r1, &#x3D;0 str r1,[r0]&#x2F;* \\* 描述： loop死循环 *&#x2F;loop: b loop 第 2 行定义了一个全局标号_start，代码就是从_start 这个标号开始顺序往下执行的。第 11 行使用 ldr 指令向寄存器 r0 写入 0X020C4068，也就是 r0=0X020C4068，这个是CCM_CCGR0 寄存器的地址。 第 12 行使用 ldr 指令向寄存器 r1 写入 0XFFFFFFFF，也就是 r1=0XFFFFFFFF。因为我们要开启所有的外设时钟，因此 CCM_CCGR0~CCM_CCGR6 所有寄存器的 32 位都要置 1，也就是写入 0XFFFFFFFF。 第 13 行使用 str 将 r1 中的值写入到 r0 所保存的地址中去，也就是给 0X020C4068 这个地址写入 0XFFFFFFFF，相当于 CCM_CCGR0=0XFFFFFFFF，就是打开 CCM_CCGR0 寄存器所 控制的所有外设时钟。 第 1531 行都是向 CCM_CCGRX(X=16)寄存器写入 0XFFFFFFFF。这样我就通过汇编代码使能了 I.MX6U 的所有外设时钟。 第35~37行是设置GPIO1_IO03的复用功能，GPIO1_IO03的复用寄存器地址为0X020E0068, 寄 存 器 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 的 MUX_MODE 设置为 5 就 是 将 GPIO1_IO03 设置为 GPIO。 第 49~51 行 是 设 置 GPIO1_IO03 的 配 置 寄 存 器 ， 也 就 是 寄 存 器 IOMUX_SW_PAD_CTL_PAD_GPIO1_IO03 的值，此寄存器地址为 0X020E02F4，代码里面已经 给出了这个寄存器详细的位设置。 第 5463 行是设置 GPIO 功能，经过上面几步操作，GPIO1_IO03 这个 IO 已经被配置为了 GPIO 功能，所以还需要设置跟 GPIO 有关的寄存器。第 5456 行是设置 GPIO1-&gt;GDIR 寄存器， 将 GPIO1_IO03 设置为输出模式，也就是寄存器的 GPIO1_GDIR 的 bit3 置 1。 第 61~63 行设置 GPIO1-&gt;DR 寄存器，也就是设置 GPIO1_IO03 的输出，我们要点亮开发板上的 LED0，那么 GPIO1_IO03 就必须输出低电平，所以这里设置 GPIO1_DR 寄存器为 0。 第 68~69 行是死循环，通过 b 指令，CPU 重复不断的跳到 loop 函数执行，进入一个死循 环。","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"汇编","slug":"汇编","permalink":"https://guoqiang-gump.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"Linux入门-linuxc","date":"2021-03-02T09:18:20.000Z","path":"2021/03/02/Linux入门-linuxc/","text":"GCC 编译器gcc 命令格式如下： 12gcc [选项] [文件名字]gcc main.c calcu.c input.c -o main -c：只编译不链接为可执行文件，编译器将输入的.c 文件编译为.o 的目标文件。 -o：&lt;输出文件名&gt;用来指定编译结束以后的输出文件名，如果使用这个选项的话 GCC 默认编译出来的可执行文件名字为 a.out。 -g：添加调试信息，如果要使用调试工具(如 GDB)的话就必须加入此选项，此选项指示编译的时候生成调试所需的符号信息。 -O：对程序进行优化编译，如果使用此选项的话整个源代码在编译、链接的的时候都会进行优化，这样产生的可执行文件执行效率就高。 -O2：比-O 更幅度更大的优化，生成的可执行效率更高，但是整个编译过程会很慢。 Makefile 语法Makefile 规则格式Makefile 里面是由一系列的规则组成的，这些规则格式如下： 1234目标…... : 依赖文件集合…… 命令 1 命令 2…… 比如下面这条规则： 12main : main.o input.o calcu.o gcc -o main main.o input.o calcu.o 这条规则的目标是 main，main.o、input.o 和 calcu.o 是生成 main 的依赖文件，如果要更新 目标 main，就必须先更新它的所有依赖文件，如果依赖文件中的任何一个有更新，那么目标也 必须更新，“更新”就是执行一遍规则中的命令列表。 命令列表中的每条命令必须以 TAB 键开始，不能使用空格！ Makefile 变量12345678910objects &#x3D; main.o input.o calcu.o main: $(objects) gcc -o main $(objects) %.o : %.c #命令 clean: rm *.o rm main","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"gcc","slug":"gcc","permalink":"https://guoqiang-gump.github.io/tags/gcc/"},{"name":"Makefile","slug":"Makefile","permalink":"https://guoqiang-gump.github.io/tags/Makefile/"}]},{"title":"Linux入门-终端命令","date":"2021-03-02T09:07:04.000Z","path":"2021/03/02/Linux入门-终端命令/","text":"Shell操作Shell 命令的格式如下：1command -options [argument] command: Shell 命令名称。 options：选项，同一种命令可能有不同的选项，不同的选项其实现的功能不同。 argument：Shell 命令是可以带参数的，也可以不带参数运行。 常用Shell 命令1、目录信息查看命令lsls 命令主要用于显示指定目录下的内容，列出指定目录下包含的所有的文件以及子目录， 它的主要参数有： -a 显示所有的文件以及子目录，包括以“.”开头的隐藏文件。 -l 显示文件的详细信息，比如文件的形态、权限、所有者、大小等信息。 -t 将文件按照创建时间排序列出。 -A 和-a 一样，但是不列出“.”(当前目录)和“..”(父目录)。 -R 递归列出所有文件，包括子目录中的文件。 2、目录切换命令cd","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://guoqiang-gump.github.io/tags/ubuntu/"},{"name":"shell","slug":"shell","permalink":"https://guoqiang-gump.github.io/tags/shell/"}]}]