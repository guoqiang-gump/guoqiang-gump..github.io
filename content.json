[{"title":"IMAX6U按键","date":"2021-03-03T09:30:19.000Z","path":"2021/03/03/IMAX6U按键/","text":"","link":"","tags":[]},{"title":"IMX6U蜂鸣器","date":"2021-03-02T16:11:05.000Z","path":"2021/03/03/IMX6U蜂鸣器/","text":"硬件原理图分析​ BEEP控制IO为SNVS_TAMPER1，当输出高电平的时候蜂鸣器关闭，输出低电平的时候蜂鸣器打开。 实验程序编写​ 1、初始化SNVS_TAMPER1这个IO复用为GPIO5_IO01 ​ 2、设置SNVS_TAMPER1这个IO的电气属性。 ​ 3、初始化GPIO ​ 4、控制GPIO输出高低电平。","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"蜂鸣器","slug":"蜂鸣器","permalink":"https://guoqiang-gump.github.io/tags/%E8%9C%82%E9%B8%A3%E5%99%A8/"}]},{"title":"IMX6U_C语言LED","date":"2021-03-02T16:00:05.000Z","path":"2021/03/03/IMX6U-C语言LED/","text":"C语言运行环境构建设置处理器模式​ 设置6ULL处于SVC模式 下。设置CPSR寄存器的bit4-0，也就是M[4:0]为10011=0X13。读写状态寄存器需要用到MRS和MSR指令。MRS将CPSR寄存器数据读出到通用寄存器里面，MSR指令将通用寄存器的值写入到CPSR寄存器里面去。 设置sp指针​ Sp可以指向内部RAM，也可以指向DDR，我们将其指向DDR。Sp设置到哪里？512MB的范围0x80000000~0x9FFFFFFF。栈大小，0x200000=2MB。处理器栈增长方式，对于A7而言是向下增长的。设置sp指向0x80200000。 跳转到C语言​ 使用b指令，跳转到C语言函数，比如main函数。 汇编文件只是用来完成 C 语言环境搭建。 12345678910111213141516171819202122232425262728293031&#x2F;***************************************************************start.s：I.MX6UL&#x2F;I.MX6ULL开发板启动文件，完成C环境初始化， C环境初始化完成以后跳转到C代码。**************************************************************&#x2F;.global _start &#x2F;* 全局标号 *&#x2F;&#x2F;* \\* 描述： _start函数，程序从此函数开始执行，此函数主要功能是设置C \\* 运行环境。 *&#x2F;_start: &#x2F;* 进入SVC模式 *&#x2F; mrs r0, cpsr bic r0, r0, #0x1f &#x2F;* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 *&#x2F; orr r0, r0, #0x13 &#x2F;* r0或上0x13,表示使用SVC模式 *&#x2F; msr cpsr, r0 &#x2F;* 将r0 的数据写入到cpsr_c中 *&#x2F; ldr sp, &#x3D;0X80200000 &#x2F;* 设置栈指针 *&#x2F; b main &#x2F;* 跳转到main函数 *&#x2F;","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"C语言","slug":"C语言","permalink":"https://guoqiang-gump.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"IMX6U编译与烧写","date":"2021-03-02T15:32:19.000Z","path":"2021/03/02/IMX6U编译与烧写/","text":"编译程序​ 1、编译程序 ①、使用**arm-linux-gnueabihf-gcc******，****将.c .s文件变为.o ②、将所有的.o文件连接为elf格式的可执行文件。 ③、将elf文件转为bin文件。 ④、将elf文件转为汇编，反汇编。 链接： ​ 链接就是将所有.o文件链接在一起，并且链接到指定的地方。本实验链接的时候要指定链接起始地址。链接起始地址就是代码运行的起始地址。 ​ 对于6ULL来说，链接起始地址应该指向RAM地址。RAM分为内部RAM和外部RAM，也就是 DDR。6ULL内部RAM地址范围0X9000000X91FFFF。也可以放到外部DDR中，对于I.MX6U-ALPHA开发板，512MB字节DDR版本的核心板，DDR范围就是0X800000000X9FFFFFFF。对于256MB的DDR来说，那就是0X80000000~0X8FFFFFFF。 ​ 本系列视频，裸机代码的链接起始地址为0X87800000。要使用DDR，那么必须要初始化DDR，对于I.MX来说bin文件不能直接运行，需要添加一个头部，这个头部信息包含了DDR的初始化参数，I.MX系列SOC内部boot rom会从SD卡，EMMC等外置存储中读取头部信息，然后初始化DDR，并且将bin文件拷贝到指定的地方。 ​ Bin的运行地址一定要和链接起始地址一致。位置无关代码除外。 编译代码1arm-linux-gnueabihf-gcc -g -c led.s -o led.o &#x2F;&#x2F;编译文件 ​ 上述命令就是将 led.s 编译为 led.o，其中“-g”选项是产生调试信息，GDB 能够使用这些调试信息进行代码调试。“-c”选项是编译源文件，但是不链接。“-o”选项是指定编译产生的文 件名字，这里我们指定 led.s 编译完成以后的文件名字为 led.o。执行上述命令以后就会编译生 成一个 led.o 文件。 12arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf &#x2F;&#x2F;链接文件 ​ arm-linux-gnueabihf-ld 用来将众多的.o 文件链接到一个指定的链接位置。我们在学习 SMT32 的时候基本就没有听过“链接”这个词，我们一般用 MDK 编写好代码，然后点击“编译”，MDK 或者 IAR 就会自动帮我们编译好整个工程，最后再点击“下载”就可以将代码下载 到开发板中。这是因为链接这个操作 MDK 或者 IAR 已经帮你做好了，后面我就以 MDK 为例给大家讲解。大家可以打开一个 STM32 的工程，然后编译一下，肯定能找到很多.o 文件 1arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin ​ 上述命令中，“-O”选项指定以什么格式输出，后面的“binary”表示以二进制格式输出， 选项“-S”表示不要复制源文件中的重定位信息和符号信息，“-g”表示不复制源文件中的调试 信息。 1arm-linux-gnueabihf-objdump -D led.elf &gt; led.dis ​ 上述代码中的“-D”选项表示反汇编所有的段，反汇编完成以后就会在当前目录下出现一个名为 led.dis 文件 烧写bin文件6ULL支持SD卡、EMMC、NAND、nor、SPI flash等等启动。裸机例程选择烧写到SD卡里面。 ​ 在ubuntu下向SD卡烧写裸机bin文件。烧写不是将bin文件拷贝到SD卡中，而是将bin文件烧写到SD卡绝对地址上。而且对于I.MX而言，不能直接烧写bin文件，比如先在bin文件前面添加头部。完成这个工作，需要使用正点原子提供的imxdownload软件。 ​ Imxdownload使用方法，确定要烧写的SD卡文件，我的是/dev/sdf。 123给予imxdownload可执行权限：Chmod 777 imxdownload 12烧写：.&#x2F;imxdownload led.bin &#x2F;dev&#x2F;sdf ​ Imxdownlaod会向led.bin添加一个头部，生成新的load.imx文件，这个load.imx文件就是最终烧写到SD卡里面去的。","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"编译","slug":"编译","permalink":"https://guoqiang-gump.github.io/tags/%E7%BC%96%E8%AF%91/"},{"name":"烧写","slug":"烧写","permalink":"https://guoqiang-gump.github.io/tags/%E7%83%A7%E5%86%99/"}]},{"title":"IMX6U汇编LED","date":"2021-03-02T12:02:00.000Z","path":"2021/03/02/IMX6U汇编LED/","text":"一、汇编LED原理分析​ 为什么要学习Cortex-A汇编： ​ ①、需要用汇编初始化一些SOC外设。 ​ ②、使用汇编初始化DDR，I.MX6U不需要。 ​ ③、设置sp指针，一般指向DDR，设置好C语言运行环境。 1、ALPHA开发板LED灯硬件原理分析：I.MX6ULL IO初始化：​ ①、使能时钟，CCGR0CCGR6这7个寄存器控制着6ULL所有外设时钟的使能。为了简单，设置CCGR0CCGR6这7个寄存器全部为0XFFFFFFFF，相当于使能所有外设时钟。 ​ ②、IO复用，将寄存器IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03的bit3~0设置为0101=5，这样GPIO1_IO03就复用为GPIO。 ​ ③、寄存器IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03是设置GPIO1_IO03的电气属性。包括压摆率、速度、驱动能力、开漏、上下拉等。 ​ ④、配置GPIO功能，设置输入输出。设置GPIO1_DR寄存器bit3为1，也就是设置为输出模式。设置GPIO1_DR寄存器的bit3，为1表示输出高电平，为0表示输出低电平。 LED0 接到了 GPIO_3 上，GPIO_3 就是 GPIO1_IO03，当 GPIO1_IO03输出低电平(0)的时候发光二极管 LED0 就会导通点亮，当 GPIO1_IO03 输出高电平(1)的时候发 光二极管 LED0 不会导通，因此 LED0 也就不会点亮。所以 LED0 的亮灭取决于 GPIO1_IO03的输出电平，输出 0 就亮，输出 1 就灭。 实验程序编写1、使能 GPIO1 时钟GPIO1 的时钟由 CCM_CCGR1 的 bit27 和 bit26 这两个位控制，将这两个位都设置位 11 即可。本教程所有例程已经将 I.MX6U 的所有外设时钟都已经打开了，因此这一步可以不用做。 2、设置 GPIO1_IO03 的复用功能找到 GPIO1_IO03 的复用寄存器“IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03”的地址为0X020E0068，然后设置此寄存器，将 GPIO1_IO03 这个 IO 复用为 GPIO 功能，也就是 ALT5。 3、配置 GPIO1_IO03找到 GPIO1_IO03 的配置寄存器“IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03”的地址为0X020E02F4，根据实际使用情况，配置此寄存器. 4、设置 GPIO 本实验中 GPIO1_IO03 是作为输出功能的，因此 GPIO1_GDIR 的 bit3 要设置为 1，表示输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117 &#x2F;&#x2F;led.s 文件源码.global _start &#x2F;* 全局标号 *&#x2F;&#x2F;* \\* 描述： _start函数，程序从此函数开始执行此函数完成时钟使能、 \\* GPIO初始化、最终控制GPIO输出低电平来点亮LED灯。 *&#x2F;_start: &#x2F;* 例程代码 *&#x2F; &#x2F;* 1、使能所有时钟 *&#x2F; ldr r0, &#x3D;0X020C4068 &#x2F;* CCGR0 *&#x2F; ldr r1, &#x3D;0XFFFFFFFF str r1, [r0] ldr r0, &#x3D;0X020C406C &#x2F;* CCGR1 *&#x2F; str r1, [r0] ldr r0, &#x3D;0X020C4070 &#x2F;* CCGR2 *&#x2F; str r1, [r0] ldr r0, &#x3D;0X020C4074 &#x2F;* CCGR3 *&#x2F; str r1, [r0] ldr r0, &#x3D;0X020C4078 &#x2F;* CCGR4 *&#x2F; str r1, [r0] ldr r0, &#x3D;0X020C407C &#x2F;* CCGR5 *&#x2F; str r1, [r0] ldr r0, &#x3D;0X020C4080 &#x2F;* CCGR6 *&#x2F; str r1, [r0] &#x2F;* 2、设置GPIO1_IO03复用为GPIO1_IO03 *&#x2F; ldr r0, &#x3D;0X020E0068 &#x2F;* 将寄存器SW_MUX_GPIO1_IO03_BASE加载到r0中 *&#x2F; ldr r1, &#x3D;0X5 &#x2F;* 设置寄存器SW_MUX_GPIO1_IO03_BASE的MUX_MODE为5 *&#x2F; str r1,[r0] &#x2F;* 3、配置GPIO1_IO03的IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 00 默认下拉 *bit [13]: 0 kepper功能 *bit [12]: 1 pull&#x2F;keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 110 R0&#x2F;6驱动能力 *bit [0]: 0 低转换率 *&#x2F; ldr r0, &#x3D;0X020E02F4 &#x2F;*寄存器SW_PAD_GPIO1_IO03_BASE *&#x2F; ldr r1, &#x3D;0X10B0 str r1,[r0] &#x2F;* 4、设置GPIO1_IO03为输出 *&#x2F; ldr r0, &#x3D;0X0209C004 &#x2F;*寄存器GPIO1_GDIR *&#x2F; ldr r1, &#x3D;0X0000008 str r1,[r0] &#x2F;* 5、打开LED0 \\* 设置GPIO1_IO03输出低电平 *&#x2F; ldr r0, &#x3D;0X0209C000 &#x2F;*寄存器GPIO1_DR *&#x2F; ldr r1, &#x3D;0 str r1,[r0]&#x2F;* \\* 描述： loop死循环 *&#x2F;loop: b loop 汇编指令汇编由一条一条指令构成，指令就涉及到汇编指令。 123456789Int a，b;a&#x3D;b;假设a地址为0X20，b地址为0x30LDR R0, &#x3D;0X30LDR R1, [R0]LDR R0, &#x3D;0X20STR R1, [R0]","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"IMX6U","slug":"IMX6U","permalink":"https://guoqiang-gump.github.io/tags/IMX6U/"},{"name":"汇编","slug":"汇编","permalink":"https://guoqiang-gump.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"LinuxC编程入门","date":"2021-03-02T09:18:20.000Z","path":"2021/03/02/LinuxC编程入门/","text":"GCC 编译器gcc 命令格式如下： 123gcc [选项] [文件名字]gcc main.c calcu.c input.c -o main -c：只编译不链接为可执行文件，编译器将输入的.c 文件编译为.o 的目标文件。 -o：&lt;输出文件名&gt;用来指定编译结束以后的输出文件名，如果使用这个选项的话 GCC 默认编译出来的可执行文件名字为 a.out。 -g：添加调试信息，如果要使用调试工具(如 GDB)的话就必须加入此选项，此选项指示编译的时候生成调试所需的符号信息。 -O：对程序进行优化编译，如果使用此选项的话整个源代码在编译、链接的的时候都会进行优化，这样产生的可执行文件执行效率就高。 -O2：比-O 更幅度更大的优化，生成的可执行效率更高，但是整个编译过程会很慢。 Makefile 语法Makefile 规则格式Makefile 里面是由一系列的规则组成的，这些规则格式如下： 1234目标…... : 依赖文件集合…… 命令 1 命令 2…… 比如下面这条规则： 12main : main.o input.o calcu.o gcc -o main main.o input.o calcu.o 这条规则的目标是 main，main.o、input.o 和 calcu.o 是生成 main 的依赖文件，如果要更新 目标 main，就必须先更新它的所有依赖文件，如果依赖文件中的任何一个有更新，那么目标也 必须更新，“更新”就是执行一遍规则中的命令列表。 命令列表中的每条命令必须以 TAB 键开始，不能使用空格！ Makefile 变量12345678910objects &#x3D; main.o input.o calcu.o main: $(objects) gcc -o main $(objects) %.o : %.c #命令 clean: rm *.o rm main","link":"","tags":[{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"gcc","slug":"gcc","permalink":"https://guoqiang-gump.github.io/tags/gcc/"},{"name":"Makefile","slug":"Makefile","permalink":"https://guoqiang-gump.github.io/tags/Makefile/"}]},{"title":"Linux终端命令","date":"2021-03-02T09:07:04.000Z","path":"2021/03/02/Linux终端命令/","text":"Shell操作Shell 命令的格式如下：1command -options [argument] command: Shell 命令名称。 options：选项，同一种命令可能有不同的选项，不同的选项其实现的功能不同。 argument：Shell 命令是可以带参数的，也可以不带参数运行。 常用Shell 命令1、目录信息查看命令lsls 命令主要用于显示指定目录下的内容，列出指定目录下包含的所有的文件以及子目录， 它的主要参数有： -a 显示所有的文件以及子目录，包括以“.”开头的隐藏文件。 -l 显示文件的详细信息，比如文件的形态、权限、所有者、大小等信息。 -t 将文件按照创建时间排序列出。 -A 和-a 一样，但是不列出“.”(当前目录)和“..”(父目录)。 -R 递归列出所有文件，包括子目录中的文件。 2、目录切换命令cd","link":"","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://guoqiang-gump.github.io/tags/ubuntu/"},{"name":"linux","slug":"linux","permalink":"https://guoqiang-gump.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://guoqiang-gump.github.io/tags/shell/"}]},{"title":"Hello World","date":"2021-02-05T14:27:39.710Z","path":"2021/02/05/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"","tags":[]}]