<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>国强-阿甘</title>
  <icon>https://www.gravatar.com/avatar/fa14b63fc1e68cede1bc60586c0cf7a7</icon>
  <subtitle>胆小认生，不易相处</subtitle>
  <link href="https://guoqiang-gump.github.io/atom.xml" rel="self"/>
  
  <link href="https://guoqiang-gump.github.io/"/>
  <updated>2021-09-24T05:33:35.928Z</updated>
  <id>https://guoqiang-gump.github.io/</id>
  
  <author>
    <name>GUMP</name>
    <email>1822006273@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在线监控项目复盘-Qt知识点</title>
    <link href="https://guoqiang-gump.github.io/2021/09/19/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-Qt%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://guoqiang-gump.github.io/2021/09/19/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-Qt%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-09-19T12:41:54.000Z</published>
    <updated>2021-09-24T05:33:35.928Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Qt对象的依附性和事务循环"><a href="#1-Qt对象的依附性和事务循环" class="headerlink" title="1. Qt对象的依附性和事务循环"></a>1. Qt对象的依附性和事务循环</h3><p> <a href="https://blog.csdn.net/qq_29344757/article/details/78136829">(16条消息) Qt多线程中的信号与槽_echo_bright_的博客-CSDN博客_qt多线程信号与槽</a> </p><p> (1)使用 继承自QThread类的子类，在run()函数里面代码属于子线程，比如程序运行时发送信号操作在子线程完成，对应的槽函数却是在main线程执行，究其原因，得从Qt对象的依附性说起。</p> <a id="more"></a> <p>  在Qt编程中，默认情况下，对象依附于创建自身的线程，例如上面代码中TestThread对象t它是在main()函数中创建的，那么t依附于主线程，而槽函数在其所依附的线程中被调用执行，因此，槽函数TestThread_Slot()是在main线程中执行。</p><p> 要想让TestThread_Slot()函数运行在main()创建的子线程中，可以使用moveToThread()函数更改TestThread对象所依附的线程： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool QObject::connect (const QObject * sender, </span><br><span class="line">                        const char * signal, </span><br><span class="line">                        const QObject * receiver,</span><br><span class="line">                        const char * method,</span><br><span class="line">                        Qt::ConnectionType type &#x3D; Qt::AutoConnection)</span><br></pre></td></tr></table></figure><p> 其中第5个参数决定信号与槽的连接方式，用于决定槽函数被调用时的相关行为。 </p><p>Qt::AutoConnection              默认连接<br>Qt::DirectConnection            槽函数立即调用<br>Qt::BlockingQueuedConnection    同步调用<br>Qt::QueuedConnection            异步调用<br>Qt::UniqueConnection            单一连接</p><p>(1) Qt::DirectConnection(立即调用)<br>  直接在发送信号的线程中调用槽函数(发送信号和槽函数位于同一线程)，等价于槽函数的实时调用。</p><p>  (2) Qt::QueuedConnection(异步调用)<br>  信号发送至目标线程的事件队列(发送信号和槽函数位于不同线程)，交由目标线程处理，当前线程继续向下执行。</p><p>  (3) Qt::BlockingQueuedConnection(同步调用)<br>  信号发送至目标线程的事件队列，由牧宝想线程处理。当前线程阻塞等待槽函数的返回，之后向下执行。</p><p>  (4) Qt::AutoConnection(默认连接)<br>  当发送信号线程=槽函数线程时，效果等价于Qt::DirectConnection；<br>  当发送信号线程!=槽函数线程时，效果等价于Qt::QueuedConnection。<br>  Qt::AutoConnection是connect()函数第5个参数的默认值，也是实际开发中字常用的连接方式。</p><p>  (5) Qt::UniqueConnection(单一连接)<br>  功能和AutoConnection相同，同样能自动确定连接类型，但是加了限制：同一个信号和同一个槽函数之间只能有一个连接。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-Qt对象的依附性和事务循环&quot;&gt;&lt;a href=&quot;#1-Qt对象的依附性和事务循环&quot; class=&quot;headerlink&quot; title=&quot;1. Qt对象的依附性和事务循环&quot;&gt;&lt;/a&gt;1. Qt对象的依附性和事务循环&lt;/h3&gt;&lt;p&gt; &lt;a href=&quot;https://blog.csdn.net/qq_29344757/article/details/78136829&quot;&gt;(16条消息) Qt多线程中的信号与槽_echo_bright_的博客-CSDN博客_qt多线程信号与槽&lt;/a&gt; &lt;/p&gt;
&lt;p&gt; (1)使用 继承自QThread类的子类，在run()函数里面代码属于子线程，比如程序运行时发送信号操作在子线程完成，对应的槽函数却是在main线程执行，究其原因，得从Qt对象的依附性说起。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在线监控项目复盘-项目难点和项目提高</title>
    <link href="https://guoqiang-gump.github.io/2021/09/19/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9%E5%92%8C%E9%A1%B9%E7%9B%AE%E6%8F%90%E9%AB%98/"/>
    <id>https://guoqiang-gump.github.io/2021/09/19/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9%E5%92%8C%E9%A1%B9%E7%9B%AE%E6%8F%90%E9%AB%98/</id>
    <published>2021-09-19T12:16:55.000Z</published>
    <updated>2021-09-27T06:32:37.385Z</updated>
    
    <content type="html"><![CDATA[<p><strong>项目存在问题和难点</strong>：</p><p>1、环境配置。一开始在开发板上出厂系统没有nginx，自己编译的bulidroot文件系统不知道为什么不能识别出摄像头。只能硬着头皮编译移植nginx，搞了差不多两天才编译成功。所以感觉到bulidroot文件系统移植库真的太方便了。</p> <a id="more"></a> <p>发现imx6ull芯片的视频编码性能太弱了，而且开发板的文件系统移植库很麻烦，我就在win10下开发项目了。在win10配置环境也很麻烦，要用到cmake，我用cmake编译ffmpeg库和opencv库都没有成功，编译的时候还会自动下载一些文件的，而且是要上外网上下载的，我都没有梯子，下载不了，后面找别人要了资源，买了vpn终于下载完了，最后终于得到了opencv的工程包，还需要再次编译得到动态库，最后编译动态库的时候一堆错误，真的哭了。最后在网上下载别人编译好的库。</p><p>2、多线程通信。在拉流端，ffmpeg线程拉流获取音视频数据，opencv线程需要接受ffmpeg的数据。这里面就是线程同步问题。一开始两根线程都是继承qthread类，重写他们的run函数，然后绑定两个线程的信号和槽，但是发现解决不了这个问题，最后发现槽函数是运行在主线程的，并没有运行在子线程。后面看帖子，发现还有另外一种qt多线程，将opencv类继承自qobject，在将opencv类对象移动到qthread里面。绑定ffmpeg的信号和opencv的槽，这样就解决线程的同步问题了。Ffmpeg线程拉流到数据后，发送信号，opencv线程的槽函数就开始执行</p><p>3、当加上识别人脸这个功能的时候，在qlable上显示的画面会花屏。还没处理掉这个问题，可能再开辟多一个线程识别人脸就不会出现这种问题了。</p><p><strong><em>\</em>项目提高：**</strong></p><p>1、可以优化对音频的采集和播放，开辟多一个线程处理音频，当然这里面又涉及到对线程的同步问题。看到网上不少项目使用sdl处理音频的，可以考虑用sdl库处理音频</p><p>2、优化拉流端的拉流。有时候拉流端拉流很久才成功，有时候很快，所以应该对拉流设置个时间，超时就重试。</p><p>3、优化人脸识别。一方面，人脸识别后的画面显示花瓶，需要修改。人脸识别模型库比较小，训练资源少，识别率一般。</p><p>4、可以加多几个功能，比如截图</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;项目存在问题和难点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1、环境配置。一开始在开发板上出厂系统没有nginx，自己编译的bulidroot文件系统不知道为什么不能识别出摄像头。只能硬着头皮编译移植nginx，搞了差不多两天才编译成功。所以感觉到bulidroot文件系统移植库真的太方便了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在线监控项目复盘-拉流端</title>
    <link href="https://guoqiang-gump.github.io/2021/09/19/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E6%8B%89%E6%B5%81%E7%AB%AF/"/>
    <id>https://guoqiang-gump.github.io/2021/09/19/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E6%8B%89%E6%B5%81%E7%AB%AF/</id>
    <published>2021-09-19T12:11:45.000Z</published>
    <updated>2021-09-27T06:56:12.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在线监控项目-拉流端"><a href="#在线监控项目-拉流端" class="headerlink" title="在线监控项目-拉流端"></a>在线监控项目-拉流端</h1><p>拉流端工作流程：</p> <a id="more"></a> <p>视频获取前的相关操作：注册文件格式和解码器，注册设备，初始化网络流格式，设置视频和音频播放参数。</p><p>通过rtmp链接打开输入流</p><p>获取视频流编码格式 –》打开相应的解码器h264</p><p>获取音频流编码格式 –》打开相应的解码器AAC</p><p>设置解码参数</p><p>申请内存</p><p>从输入流中获取包数据</p><p>获取视频包–》解码视频–》将yuv420p转为RGB24格式–》通过信号发送到qlable显示和opencv线程人脸检测</p><p>获取音频包–》解码音频pcm–》播放音频 </p><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>主线程工作比较简单，用两个QLable分别显示ffmpeg拉流的视频数据和opencv人脸识别的数据。在主线程里面要显示两个视频QLable，相当于开两个视频，有点吃力。</p><h2 id="ffmpeg线程"><a href="#ffmpeg线程" class="headerlink" title="ffmpeg线程"></a>ffmpeg线程</h2><p>ffmpeg线程开辟方式是先继承QThread然后重新run()函数，在 run()函数写线程需要执行的代码。</p><p>拉流端工作流程：</p><p>视频获取前的相关操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext* format_ctx = avformat_alloc_context();</span><br><span class="line">avformat_open_input(&amp;format_ctx, url, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注册文件格式和解码器，注册设备，初始化网络流格式，设置视频播放参数。</p><p>通过rtmp链接打开输入流</p><p>获取视频流编码格式 –》打开相应的解码器h264</p><p>设置解码参数</p><p>申请AVpacket包内存存放获取到的数据包。</p><p>申请内存存放解码都的数据</p><p>从输入流中获取包数据</p><p>获取视频包–》解码视频–》将yuv420p转为RGB24格式–》通过信号发送到qlable显示和opencv线程人脸检测</p><h2 id="opencv线程"><a href="#opencv线程" class="headerlink" title="opencv线程"></a>opencv线程</h2><p>opecv线程开辟的方式， 是把一个继承于QObject的类转移到一个Thread里 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_Opencv-&gt;moveToThread(&amp;thread);</span><br></pre></td></tr></table></figure><p>加载人脸检查模型+加载人脸识别训练模型-》通过ffmpeg获取原图-》转换成灰度图-》直方图均匀化-》检测人脸-》识别人脸-》用矩形框出人脸并显示名字–》发送信号到qlable显示</p><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E6%8B%89%E6%B5%81%E7%AB%AF.assets/1631956593474.png" alt="1631956593474"></p><h2 id="多线程通信与同步"><a href="#多线程通信与同步" class="headerlink" title="多线程通信与同步"></a>多线程通信与同步</h2><p>ffmpeg线程开辟方式是先继承QThread然后重新run()函数，在 run()函数写线程需要执行的代码。</p><p>opecv线程开辟的方式， 是把一个继承于QObject的类转移到一个Thread里。</p><p>ffmpeg线程与opecv线程直接需要通信，即ffmpeg线程处理得到的视频数据需要给opecv线程，这里使用Qt的信号槽机制，只要ffmpeg线程发送了信号，opecv线程就会执行，很巧妙的实现了多线程的通信和同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect(thread_laliu, SIGNAL(ffmpeg2opencv(unsigned char *, int, int)),</span><br><span class="line">            thread_Opencv, SLOT(ffmpegDateExchange(unsigned char *, int, int)));</span><br></pre></td></tr></table></figure><p>在推流端中，主线程获取视频数据，而ffmpeg线程也需要这些视频数据，这里也是有线程通信的。在推流端我是使用共享资源的形式实现两个线程的通信，但是两个线程同时对同一个资源会产生竞争，所以使用了QMutex，这是Qt提供的互斥锁，实现多线程的互斥。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;在线监控项目-拉流端&quot;&gt;&lt;a href=&quot;#在线监控项目-拉流端&quot; class=&quot;headerlink&quot; title=&quot;在线监控项目-拉流端&quot;&gt;&lt;/a&gt;在线监控项目-拉流端&lt;/h1&gt;&lt;p&gt;拉流端工作流程：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在线监控项目复盘-RTMP</title>
    <link href="https://guoqiang-gump.github.io/2021/09/19/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-RTMP/"/>
    <id>https://guoqiang-gump.github.io/2021/09/19/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-RTMP/</id>
    <published>2021-09-19T11:48:25.000Z</published>
    <updated>2021-09-27T04:20:47.176Z</updated>
    
    <content type="html"><![CDATA[<p>现有的网络视音频服务主要包括两种方式：点播和直播。点播意即根据用户的需要播放相应的视频节目，这是互联网视音频服务最主要的方式。绝大部分视频网站都提供了点播服务。直播意即互联网视音频平台直接将视频内容实时发送给用户， </p> <a id="more"></a> <p><strong>直播服务普遍采用了RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式。</strong>封装格式，视频编码，音频编码方面，无一例外的使用了FLV + H.264 + AAC的组合。FLV是RTMP使用的封装格式，H.264是当今实际应用中编码效率最高的视频编码标准，AAC则是当今实际应用中编码效率最高的音频编码标准。</p><p>点播服务普遍采用了HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式。采用HTTP作为点播协议有以下两点优势：一方面，HTTP是基于TCP协议的应用层协议，媒体传输过程中不会出现丢包等现象，从而保证了视频的质量；另一方面，HTTP被绝大部分的Web服务器支持，因而流媒体服务机构不必投资购买额外的流媒体服务器，从而节约了开支。点播服务采用的封装格式有多种：MP4，FLV，F4V等，它们之间的区别不是很大。视频编码标准和音频编码标准是H.264和AAC。</p><ul><li>RTMP（Real Time Messaging Protocol）是基于TCP的，由Adobe公司为Flash播放器和服务器之间音频、视频传输开发的开放协议。</li><li>HLS（HTTP Live Streaming）是基于HTTP的，是Apple公司开放的音视频传输协议。</li><li>HTTP FLV则是将RTMP封装在HTTP协议之上的，可以更好的穿透防火墙等</li></ul><p>RTMP协议是Real Time Message Protocol(<strong>实时信息传输协议</strong>)的缩写，它是由Adobe公司提出的一种应用层的协议，<strong>用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题</strong></p><p><strong>RTMP协议是一个互联网TCP/IP五层体系结构中应用层的协议</strong>。RTMP协议中基本的数据单元称为消息（Message）。当RTMP协议在互联网中传输数据的时候，消息会被拆分成更小的单元，称为消息块（Chunk）。</p><p><strong>RTMP传输媒体数据的过程中，发送端首先把媒体数据封装成消息，然后把消息分割成消息块，最后将分割后的消息块通过TCP协议发送出去。接收端在通过TCP协议收到数据后，首先把消息块重新组合成消息，然后通过对消息进行解封装处理就可以恢复出媒体数据。</strong></p><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-RTMP.assets/95396b953315764e43e2caa4020dc8e.jpg" alt="95396b953315764e43e2caa4020dc8e"></p><p>RTMP协议规定，播放一个流媒体有两个前提步骤：第一步，建立一个<strong>网络连接</strong>（NetConnection）；第二步，<strong>建立一个网络流</strong>（NetStream）。其中，<strong>网络连接代表服务器端应用程序和客户端之间基础的连通关系</strong>。网络流代表了发送多媒体数据的通道。<strong>服务器和客户端之间只能建立一个网络连接，但是基于该连接可以创建很多网络流。</strong></p><p>缺点：不支持html5播放</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现有的网络视音频服务主要包括两种方式：点播和直播。点播意即根据用户的需要播放相应的视频节目，这是互联网视音频服务最主要的方式。绝大部分视频网站都提供了点播服务。直播意即互联网视音频平台直接将视频内容实时发送给用户， &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在线监控项目复盘-推流端</title>
    <link href="https://guoqiang-gump.github.io/2021/09/19/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E6%8E%A8%E6%B5%81%E7%AB%AF/"/>
    <id>https://guoqiang-gump.github.io/2021/09/19/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E6%8E%A8%E6%B5%81%E7%AB%AF/</id>
    <published>2021-09-19T04:13:47.000Z</published>
    <updated>2021-09-27T05:32:07.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目框架"><a href="#项目框架" class="headerlink" title="项目框架"></a>项目框架</h1><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E6%8E%A8%E6%B5%81%E7%AB%AF.assets/1632060615855.png" alt="1632060615855"></p> <a id="more"></a> <h1 id="在线监控项目-推流端"><a href="#在线监控项目-推流端" class="headerlink" title="在线监控项目-推流端"></a>在线监控项目-推流端</h1><h2 id="主线程使用Qt获取摄像头数据-显示"><a href="#主线程使用Qt获取摄像头数据-显示" class="headerlink" title="主线程使用Qt获取摄像头数据+显示"></a>主线程使用Qt获取摄像头数据+显示</h2><p>Qt提供了方便的类QCamera来控制摄像头获取数据。ffmpeg也提供了libavdevice相关的API函数来获取摄像头等设备的音视频的数据。opencv对ffmpeg的函数进行封装，提供了很方便的获取摄像头和设备数据的类。总结，难度从高到低分别是：ffmpeg &gt; QCamera &gt;opencv。</p><p>这里使用Qt提供的类来获取摄像头的视频数据。</p><p>在主线程使用QCamera类获取摄像头数据。摄像头获取到视频数据后，QVideoProbe类发送videoFrameProbed信号，可以创建一个槽函数处理信号函数发送过来的视频数据。</p><p>获取的原始视频像素格式为Format_YUV420P，转换成RGB格式后就可以在QLable上显示。</p><p>这视频数据是共享资源，由主线程和ffmpeg线程共享，所以对视频数据必须加互斥锁QMutex实现多线程的互斥。每次多视频数据的读写操作都要加锁，防止多线程的读写冲突。</p><h2 id="子线程使用ffmpeg库的API实现推流"><a href="#子线程使用ffmpeg库的API实现推流" class="headerlink" title="子线程使用ffmpeg库的API实现推流"></a>子线程使用ffmpeg库的API实现推流</h2><p>ffmpeg线程通过继承自QThread类重写run()函数来开辟。</p><p>ffmpeg推流线程的工作流程大概为：</p><p>获取YUV420P格式视频像素数据–&gt;编码成h.264格式–&gt;封装成FLV格式–&gt;以rtmp协议推流到nginx服务器上。</p><p>在编码之前需要完成很多初始化工作，编码和封装也比较繁琐，推流就很简单一个函数搞定。</p><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E6%8E%A8%E6%B5%81%E7%AB%AF.assets/1632040391597.png" alt="1632040391597"></p><p>av_register_all()：注册FFmpeg所有编解码器。</p><p>avformat_alloc_output_context2()：初始化输出码流的AVFormatContext(封装到本地文件还是网络)</p><p>avio_open()：打开输出文件。</p><p>avformat_new_stream()：创建输出码流的AVStream。</p><p>avcodec_alloc_context3()：初始化AVCodecContext，设置编码器编码参数</p><p>avcodec_find_encoder()：查找编码器。</p><p>avcodec_open2()：打开编码器。</p><p>av_frame_alloc() + av_frame_get_buffer()：初始化AVFrame，为音频或视频AVFrame分配缓冲区。</p><p>avio_open()：打开输出URL</p><p>avformat_write_header()：编写文件头（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。</p><p>avcodec_encode_video2()：编码一帧视频。即将AVFrame（存储YUV420P像素数据）编码为AVPacket（存储H.264等格式的码流数据）。</p><p>av_interleaved_write_frame()：将编码得到的AVPacket封装成FLV格式，然后向文件或网络输出一帧FLV数据</p><p>av_write_trailer()：写文件尾（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;项目框架&quot;&gt;&lt;a href=&quot;#项目框架&quot; class=&quot;headerlink&quot; title=&quot;项目框架&quot;&gt;&lt;/a&gt;项目框架&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E6%8E%A8%E6%B5%81%E7%AB%AF.assets/1632060615855.png&quot; alt=&quot;1632060615855&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在线监控项目复盘-YUV与RGB</title>
    <link href="https://guoqiang-gump.github.io/2021/09/19/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-YUV%E4%B8%8ERGB/"/>
    <id>https://guoqiang-gump.github.io/2021/09/19/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-YUV%E4%B8%8ERGB/</id>
    <published>2021-09-19T03:22:38.000Z</published>
    <updated>2021-09-27T05:50:33.108Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="https://img-blog.csdnimg.cn/20190530102442208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpbmJpbjIwMTU=,size_16,color_FFFFFF,t_70" alt="img"> </p> <a id="more"></a> <h1 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h1><p>从采集的角度来说，一般的视频采集芯片输出的码流一般都是YUV数据流的形式，而从视频处理（例如H.264、MPEG视频编解码）的角度来说，也是在原始YUV码流进行编码和解析，所以，了解如何分析YUV数据流对于做视频领域的人而言，至关重要。YUV是指亮度参量和色度参量分开表示的像素格式，而这样分开的好处就是不但可以避免相互干扰，还可以降低色度的采样率而不会对图像质量影响太大。</p><p>   人眼对色度的敏感程度要低于对亮度的敏感程度。</p><p>   YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。与我们熟知的RGB类似，YUV也是一种颜色编码方法，主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。</p><p>   YUV码流有多种不同的格式，要分析YUV码流，就必须搞清楚你面对的到底是哪一种格式，并且必须搞清楚这种格式的YUV采样和分布情况。</p><p>　　YUV格式有两大类：planar <strong>平面格式</strong> 和packed<strong>数据包格式</strong>。<br>对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。<br>对于packed的YUV格式，每个像素点的Y,U,V是连续交叉存储的。</p><p> yuv420p：yyyyyyyy uuuuuuuu vvvvv<br>yuv420： yuv yuv yuv </p><p><strong>1. 采样方式</strong>  </p><p>  YUV码流的存储格式其实与其采样的方式密切相关，主流的采样方式有三种，YUV4:4:4，YUV4:2:2，YUV4:2:0，如何根据其采样格式来从码流中还原每个像素点的YUV值，因为只有正确地还原了每个像素点的YUV值，才能通过YUV与RGB的转换公式提取出每个像素点的RGB值，然后显示出来。</p><p> <strong>YUV 4:4:4采样，每一个Y对应一组UV分量。</strong><br><strong>YUV 4:2:2采样，每两个Y共用一组UV分量。</strong><br><strong>YUV 4:2:0采样，每四个Y共用一组UV分量。</strong> </p><p>RGB24使用24位来表示一个像素，RGB分量都用8位表示，取值范围为0-255。在一个2*2的像素区域，RRG暂用的字节数为2 * 2* 3=12字节。那么用yuv表示，占用的字节数为4(Y)+1(u)+1(v)=6字节,其中Y占用4个字节，U和V各占用1字节，比例为4:1:1</p><p> 一般来说，直接采集到的视频数据是RGB24的格式，RGB24一帧的大小size＝width×heigth×3 B，RGB32的size＝width×heigth×4 B，如果是I420（即YUV标准格式4：2：0）的数据量是 size＝width×heigth×1.5 B。 </p><p> <strong>YUV特点</strong>：也是一种颜色编码方法，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样 可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了<strong>彩色电视机与黑白电视的兼容问题</strong>。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用<strong>YUV方式传送占用极少的频宽</strong>。  在传输时占⽤的带宽也会随之减少。 </p><h3 id="RGB-—-YUV-颜⾊编码转换"><a href="#RGB-—-YUV-颜⾊编码转换" class="headerlink" title="RGB — YUV 颜⾊编码转换"></a>RGB — YUV 颜⾊编码转换</h3><p>对于图像显示器来说，它是通过<code>RGB模型</code>来显示图像的，⽽在传输图像数据时⼜是使⽤<code>YUV模型</code>，这是因为<code>YUV模型</code>可以节省带宽。因此就需要采集图像时将<code>RGB模型</code>转换到<code>YUV模型</code>，显示时再将<code>YUV模型</code>转换为<code>RGB模型</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt; &lt;img src=&quot;https://img-blog.csdnimg.cn/20190530102442208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpbmJpbjIwMTU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;img&quot;&gt; &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在线监控项目复盘-OPENCV</title>
    <link href="https://guoqiang-gump.github.io/2021/09/18/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-OPENCV/"/>
    <id>https://guoqiang-gump.github.io/2021/09/18/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-OPENCV/</id>
    <published>2021-09-18T07:43:29.000Z</published>
    <updated>2021-09-24T05:33:21.080Z</updated>
    
    <content type="html"><![CDATA[<p>FaceRecognizer这个类目前包含三种人脸识别方法：<strong>基于PCA变换的人脸识别(EigenFaceRecognizer)、</strong>基于Fisher变换的人脸识别(FisherFaceRecognizer)、基于局部二值模式的人脸识别(LBPHFaceRecognizer)。 </p><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-OPENCV.assets/1631953663644.png" alt="1631953663644"></p> <a id="more"></a> <p>检测人脸流程：</p><ol><li>建立级联分类器  CascadeClassifier  </li><li>加载已经训练好的人脸检测模型 CascadeClassifier :: load( “.xml” ) ;</li><li>原图转换成灰度图 cvtColor( );  //BGR 转化为灰度图 </li><li>灰度图的直方图均衡化  equalizeHist();</li><li>检测图片中的人脸 CascadeClassifier :: detectMultiScale( ) </li><li>创建特征脸模型  EigenFaceRecognizer::create() </li><li>预测人脸 model-&gt;predict();</li><li>用矩形框框出人脸 rectangle( )</li></ol><p>Opencv人脸检测流程：</p><p>加载人脸检查模型+加载人脸识别训练模型-》通过ffmpeg获取原图-》转换成灰度图-》直方图均匀化-》检测人脸-》识别人脸-》用矩形框出人脸并显示名字–》发送信号到qlable显示</p><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-OPENCV.assets/1631956593474.png" alt="1631956593474"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*********************************** 训练人脸识别模型  ******************************&#x2F;</span><br><span class="line">&#x2F;&#x2F;1、创建训练样本：选用ORL人脸库，里面有40个的人脸图像，每人10张，然后再将自己的10张人脸照也放进去</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、创建特征脸模型：通过样本和类别标签进行训练，最终得到训练好的主成分脸模型。</span><br><span class="line">Ptr&lt;FaceRecognizer&gt; model&#x3D;createEigenFaceRecognizer();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、训练人脸识别模型：通过样本和类别标签进行训练，最终得到训练好的主成分脸模型。</span><br><span class="line">model-&gt;train(images,labels); &#x2F;&#x2F;通过images和labels来训练人脸模型  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、保存人脸识别模型</span><br><span class="line">model-&gt;save(&quot;MyFacePcaModel.xml&quot;); &#x2F;&#x2F;将训练模型保存到MyFacePcaModel.xml  </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*********************************** 1.原图获取与处理  ******************************&#x2F;</span><br><span class="line">&#x2F;&#x2F;1、打开摄像头，读取视频并初始化</span><br><span class="line">VideoCapture capture(0);</span><br><span class="line">&#x2F;&#x2F;2、原图转灰度图</span><br><span class="line">cvtColor(frame, frame_gray, CV_RGB2GRAY);</span><br><span class="line">&#x2F;&#x2F;3、灰度图的直方图均衡化</span><br><span class="line">equalizeHist(frame_gray, frame_gray);</span><br><span class="line"></span><br><span class="line">&#x2F;*********************************** 2.加载人脸检测模型  ******************************&#x2F;</span><br><span class="line">&#x2F;&#x2F;1、建立级联分类器</span><br><span class="line">CascadeClassifier cascade;</span><br><span class="line">cascade.load(&quot;.&#x2F;xml&#x2F;haarcascade_frontalface_alt.xml&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、检测图像中的人脸：将检测到的人脸放到faces中</span><br><span class="line">cascade.detectMultiScale(frame_gray, faces, 1.1, 2, 0|CASCADE_SCALE_IMAGE, Size(60, 60));</span><br><span class="line"></span><br><span class="line">&#x2F;*********************************** 3.预测人脸  ******************************&#x2F;</span><br><span class="line">&#x2F;&#x2F;1、加载人脸识别模型：创建特征脸模型</span><br><span class="line">model &#x3D; EigenFaceRecognizer::create();</span><br><span class="line">model-&gt;read(&quot;MyFaceRecognizer.xml&quot;);&#x2F;&#x2F;加载级联分类器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、预测检测到的人脸</span><br><span class="line">model-&gt;predict(face_test);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void detectMultiScale(   </span><br><span class="line">    const Mat&amp; image,   </span><br><span class="line">    CV_OUT vector&lt;Rect&gt;&amp; objects,   </span><br><span class="line">    double scaleFactor &#x3D; 1.1,   </span><br><span class="line">    int minNeighbors &#x3D; 3,    </span><br><span class="line">    int flags &#x3D; 0,   </span><br><span class="line">    Size minSize &#x3D; Size(),   </span><br><span class="line">    Size maxSize &#x3D; Size()   </span><br><span class="line">); </span><br><span class="line">函数介绍：</span><br><span class="line">功能：图像搜索</span><br><span class="line">参数1：image–待检测图片，一般为灰度图像加快检测速度；</span><br><span class="line">参数2：objects–被检测物体的矩形框向量组，即被成功定位后返回的目标边界矩阵变量；</span><br><span class="line">参数3：scaleFactor–检测尺度之间的跳变(默认1.1)。该值越大，检测速度越快，但会错过更多可能被检测到的目标；</span><br><span class="line">参数4：minNeighbors–对阻止错误检测的控制。例如该值为3，则在人脸检测时表示只有至少存在3个重叠的检测标记时，才认定有人脸的存在；</span><br><span class="line">参数5：flags–要么使用默认值，要么使用CV_HAAR_DO_CANNY_PRUNING，函数将会使用Canny边缘检测来排除边缘过多或过少的区域， 因为这些区域通常不会是人脸所在区域；</span><br><span class="line">参数6、7：minSize和maxSize用来限制得到的目标区域的范围。如果视频中误检到很多无用的小方框，那么就把minSize的尺寸改大一些，默认的为30*30。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;FaceRecognizer这个类目前包含三种人脸识别方法：&lt;strong&gt;基于PCA变换的人脸识别(EigenFaceRecognizer)、&lt;/strong&gt;基于Fisher变换的人脸识别(FisherFaceRecognizer)、基于局部二值模式的人脸识别(LBPHFaceRecognizer)。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-OPENCV.assets/1631953663644.png&quot; alt=&quot;1631953663644&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在线监控项目复盘-音视频压缩编码原理</title>
    <link href="https://guoqiang-gump.github.io/2021/09/16/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/"/>
    <id>https://guoqiang-gump.github.io/2021/09/16/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/</id>
    <published>2021-09-16T06:50:20.000Z</published>
    <updated>2021-09-27T05:32:47.253Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://blog.csdn.net/leixiaohua1020/article/details/28114081">(16条消息) 视频压缩编码和音频压缩编码的基本原理_雷霄骅(leixiaohua1020)的专栏-CSDN博客</a> </p><h1 id="1-视频编码基本原理"><a href="#1-视频编码基本原理" class="headerlink" title="1.视频编码基本原理"></a>1.视频编码基本原理</h1><h2 id="（1）-视频信号的冗余信息"><a href="#（1）-视频信号的冗余信息" class="headerlink" title="（1）  视频信号的冗余信息"></a>（1）  视频信号的冗余信息</h2><p>以记录数字视频的YUV分量格式为例，YUV分别代表亮度与两个色差信号。例如对于现有的PAL制电视系统，其亮度信号采样频率为13.5MHz；色度信号的频带通常为亮度信号的一半或更少，为6.75MHz或3.375MHz。以4：2：2的采样频率为例，Y信号采用13.5MHz，色度信号U和V采用6.75MHz采样，采样信号以8bit量化，则可以计算出数字视频的码率为：</p> <a id="more"></a> <p>13.5*8 + 6.75 * 8 + 6.75*8= 216Mbit/s</p><p>如此大的数据量如果直接进行存储或传输将会遇到很大困难，因此必须采用压缩技术以减少码率。数字化后的视频信号能进行压缩主要依据两个基本条件：</p><p>l  <strong>数据冗余</strong>。例如如空间冗余、时间冗余、结构冗余、信息熵冗余等，即图像的各像素之间存在着很强的相关性。消除这些冗余并不会导致信息损失，属于无损压缩。</p><p>l  <strong>视觉冗余</strong>。人眼的一些特性比如亮度辨别阈值，视觉阈值，对亮度和色度的敏感度不同，使得在编码的时候引入适量的误差，也不会被察觉出来。可以利用人眼的视觉特性，以一定的客观失真换取数据压缩。这种压缩属于有损压缩。</p><p>数字视频信号的压缩正是基于上述两种条件，使得视频数据量得以极大的压缩，有利于传输和存储。一般的数字视频压缩编码方法都是混合编码，即将变换编码，运动估计和运动补偿，以及熵编码三种方式相结合来进行压缩编码。通常使用<strong>变换编码来消去除图像的帧内冗余</strong>，<strong>用运动估计和运动补偿来去除图像的帧间冗余</strong>，用熵编码来进一步提高压缩的效率。下文简单介绍这三种压缩编码方法。</p><h2 id="（2）-压缩编码的方法"><a href="#（2）-压缩编码的方法" class="headerlink" title="（2）  压缩编码的方法"></a>（2）  压缩编码的方法</h2><h3 id="（a）-变换编码"><a href="#（a）-变换编码" class="headerlink" title="（a）  变换编码"></a>（a）  变换编码</h3><p>变换编码的作用是将<strong>空间域描述的图像信号变换到频率域</strong>，然后对变换后的系数进行编码处理。一般来说，<strong>图像在空间上具有较强的相关性，变换到频率域可以实现去相关和能量集中</strong>。常用的正交变换有离散傅里叶变换，离散余弦变换等等。数字视频压缩过程中应用广泛的是<strong>离散余弦变换</strong>。</p><p><strong>离散余弦变换简称为DCT变换</strong>。它可以将L* L的图像块从空间域变换为频率域。所以，在基于DCT的图像压缩编码过程中，首先需要将图像分成互不重叠的图像块。假设一帧图像的大小为1280 * 720，首先将其以网格状的形式分成160*90个尺寸为8 * 8的彼此没有重叠的图像块，接下来才能对每个图像块进行DCT变换。</p><p>经过分块以后，每个8 * 8点的图像块被送入DCT编码器，将8 * 8的图像块从空间域变换为频率域。下左图给出一个实际8*8的图像块例子，图中的数字代表了每个像素的亮度值。从图上可以看出，在这个图像块中各个像素亮度值比较均匀，特别是相邻像素亮度值变化不是很大，说明图像信号具有很强的相关性。<br> <img src="https://img-blog.csdn.net/20140602173641875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"> ——》 <img src="https://img-blog.csdn.net/20140602173658734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"> </p><p> 上右图是上图中图像块经过DCT变换后的结果。从图中可以看出经过DCT变换后，左上角的低频系数集中了大量能量，而右下角的高频系数上的能量很小。 </p><p>信号经过DCT变换后需要进行量化。由于人的眼睛对图像的低频特性比如物体的总体亮度之类的信息很敏感，而对图像中的高频细节信息不敏感，因此在传送过程中可以少传或不传送高频信息，只传送低频部分。量化过程通过对低频区的系数进行细量化，高频区的系数进行粗量化，去除了人眼不敏感的高频信息，从而降低信息传送量。因此，量化是一个有损压缩的过程，而且是视频压缩编码中质量损伤的主要原因。</p><p> DCT系数经过量化之后大部分经变为0，而只有很少一部分系数为非零值，此时只需将这些非0值进行压缩编码即可。 </p><h3 id="（c）-运动估计和运动补偿"><a href="#（c）-运动估计和运动补偿" class="headerlink" title="（c）  运动估计和运动补偿"></a>（c）  运动估计和运动补偿</h3><p><strong>运动估计（Motion Estimation）和运动补偿（Motion Compensation）是消除图像序列时间方向相关性的有效手段。</strong>上文介绍的DCT变换、量化、熵编码的方法是在一帧图像的基础上进行，通过这些方法可以消除图像内部各像素间在空间上的相关性。实际上图像信号除了空间上的相关性之外，还有时间上的相关性。例如对于像新闻联播这种背景静止，画面主体运动较小的数字视频，每一幅画面之间的区别很小，画面之间的相关性很大。对于这种情况我们没有必要对每一帧图像单独进行编码，而是可以只对相邻视频帧中变化的部分进行编码，从而进一步减小数据量，这方面的工作是由运动估计和运动补偿来实现的。</p><p>运动估计技术一般将当前的输入图像分割成若干彼此不相重叠的小图像子块，例如一帧图像的大小为1280*720，首先将其以网格状的形式分成40 * 45个尺寸为16*16的彼此没有重叠的图像块，然后<strong>在前一图像或者后一个图像某个搜索窗口的范围内为每一个图像块寻找一个与之最为相似的图像块。这个搜寻的过程叫做运动估计。通过计算最相似的图像块与该图像块之间的位置信息，可以得到一个运动矢量。这样在编码过程中就可以将当前图像中的块与参考图像运动矢量所指向的最相似的图像块相减，得到一个残差图像块，由于残差图像块中的每个像素值很小，所以在压缩编码中可以获得更高的压缩比。这个相减过程叫运动补偿。</strong></p><p>由于编码过程中需要使用参考图像来进行运动估计和运动补偿，因此参考图像的选择显得很重要。一般情况下编码器的将输入的每一帧图像根据其参考图像的不同分成3种不同的类型：I（Intra）帧、B（Bidirection prediction）帧、P（Prediction）帧。如图所示。<br> <img src="https://img-blog.csdn.net/20140602173430265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p><p>如图所示，<strong>I帧只使用本帧内的数据进行编码，在编码过程中它不需要进行运动估计和运动补偿</strong>。显然，由于I帧没有消除时间方向的相关性，所以压缩比相对不高。P帧在编码过程中使用一个前面的I帧或P帧作为参考图像进行运动补偿，实际上是对当前图像与参考图像的差值进行编码。B帧的编码方式与P帧相似，惟一不同的地方是在编码过程中它要使用一个前面的I帧或P帧和一个后面的I帧或P帧进行预测。由此可见，每一个P帧的编码需要利用一帧图像作为参考图像，而B帧则需要两帧图像作为参考。相比之下，B帧比P帧拥有更高的压缩比。</p><h1 id="2-音频编码基本原理"><a href="#2-音频编码基本原理" class="headerlink" title="2.音频编码基本原理"></a>2.音频编码基本原理</h1><h2 id="（1）-音频信号的冗余信息"><a href="#（1）-音频信号的冗余信息" class="headerlink" title="（1）  音频信号的冗余信息"></a>（1）  音频信号的冗余信息</h2><p>数字音频信号如果不加压缩地直接进行传送，将会占用极大的带宽。数字音频压缩编码在保证信号在听觉方面不产生失真的前提下，对音频数据信号进行尽可能大的压缩。数字音频压缩编码采取去除声音信号中冗余成分的方法来实现。所谓冗余成分指的是音频中不能被人耳感知到的信号，它们对确定声音的音色，音调等信息没有任何的帮助。</p><p>冗余信号包含人耳听觉范围外的音频信号以及被掩蔽掉的音频信号等。例如，人耳所能察觉的声音信号的频率范围为20Hz～20KHz，除此之外的其它频率人耳无法察觉，都可视为冗余信号。此外，根据人耳听觉的生理和心理声学现象，当一个强音信号与一个弱音信号同时存在时，弱音信号将被强音信号所掩蔽而听不见，这样弱音信号就可以视为冗余信号而不用传送。这就是人耳听觉的掩蔽效应，主要表现在频谱掩蔽效应和时域掩蔽效应，现分别介绍如下：</p><h2 id="（a）-频谱掩蔽效应"><a href="#（a）-频谱掩蔽效应" class="headerlink" title="（a）  频谱掩蔽效应"></a>（a）  频谱掩蔽效应</h2><p>一个频率的声音能量小于某个阈值之后，人耳就会听不到，这个阈值称为最小可闻阈。当有另外能量较大的声音出现的时候，该声音频率附近的阈值会提高很多，即所谓的掩蔽效应。如图所示：</p><p> <img src="https://img-blog.csdn.net/20140602173751953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p><p>由图中我们可以看出人耳对2KHz～5KHz的声音最敏感，而对频率太低或太高的声音信号都很迟钝，当有一个频率为0.2KHz、强度为60dB的声音出现时，其附近的阈值提高了很多。由图中我们可以看出在0.1KHz以下、1KHz以上的部分,由于离0.2KHz强信号较远，不受0.2KHz强信号影响,阈值不受影响；而在0.1KHz～1KHz范围，由于0.2KHz强音的出现,阈值有较大的提升，人耳在此范围所能感觉到的最小声音强度大幅提升。如果0.1KHz～1KHz范围内的声音信号的强度在被提升的阈值曲线之下，由于它被0.2KHz强音信号所掩蔽，那么此时我们人耳只能听到0.2KHz的强音信号而根本听不见其它弱信号，这些与0.2KHz强音信号同时存在的弱音信号就可视为冗余信号而不必传送。</p><h2 id="（b）-时域掩蔽效应"><a href="#（b）-时域掩蔽效应" class="headerlink" title="（b）  时域掩蔽效应"></a>（b）  时域掩蔽效应</h2><p>当强音信号和弱音信号同时出现时，还存在时域掩蔽效应。即两者发生时间很接近的时候，也会发生掩蔽效应。时域掩蔽过程曲线如图所示，分为前掩蔽、同时掩蔽和后掩蔽三部分。</p><p> <img src="https://img-blog.csdn.net/20140602173759515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p><p>由图我们可以看出，时域掩蔽效应可以分成三种：前掩蔽，同时掩蔽，后掩蔽。前掩蔽是指人耳在听到强信号之前的短暂时间内，已经存在的弱信号会被掩蔽而听不到。同时掩蔽是指当强信号与弱信号同时存在时，弱信号会被强信号所掩蔽而听不到。后掩蔽是指当强信号消失后，需经过较长的一段时间才能重新听见弱信号，称为后掩蔽。这些被掩蔽的弱信号即可视为冗余信号。</p><h2 id="（2）-压缩编码方法"><a href="#（2）-压缩编码方法" class="headerlink" title="（2）  压缩编码方法"></a>（2）  压缩编码方法</h2><p>对每一个音频声道中的音频采样信号,首先都要将它们映射到频域中,这种时域到频域的映射可通过子带滤波器实现。每个声道中的音频采样块首先要根据心理声学模型来计算掩蔽门限值, 然后由计算出的掩蔽门限值决定从公共比特池中分配给该声道的不同频率域中多少比特数，接着进行量化以及编码工作，最后将控制参数及辅助数据加入数据之中，产生编码后的数据流。</p><h1 id="H-264编码"><a href="#H-264编码" class="headerlink" title="H.264编码"></a>H.264编码</h1><p> H.264仅仅是一个编码标准，而不是一个具体的编码器，H.264只是给编码器的实现提供参照用的。 </p><p>H264定义三种帧，完整的编码帧称为Ｉ帧,参考之前Ｉ帧生成的只包含差异部分的编码的帧叫P帧，还有一种参照前后帧编码的帧叫B帧。</p><p>H<strong>264采用的核心算法是帧内压缩和帧间压缩，帧内压缩是生成Ｉ帧的算法，帧间压缩是生成B帧和P帧的算法。</strong></p><p>Ｉ帧：帧内编码帧，Ｉ帧表示关键帧，理解为这一阵的画面完整保留；解码时只需要本帧数据就可以完成（因为本帧包含完整画面）</p><p>P帧：前向预测编码帧。P帧表示的是这一帧跟之前的关键帧（或P帧）的差别，解码是需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别真，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p><p>Ｂ帧：双向预测内插编码帧。B帧就是双向差别帧，也就是B帧记录的是本帧与前后帧的差别。总而言之，要解码B帧，不仅要去的之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩效率高，但是解码时CPU会比较累。</p><p>帧内（Intraframe）压缩也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩是编码一个完整的图像，所以可以独立的解码、显示。</p><p>帧间（Interframe）压缩的原理是：相邻几帧的数据有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息,根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; &lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/28114081&quot;&gt;(16条消息) 视频压缩编码和音频压缩编码的基本原理_雷霄骅(leixiaohua1020)的专栏-CSDN博客&lt;/a&gt; &lt;/p&gt;
&lt;h1 id=&quot;1-视频编码基本原理&quot;&gt;&lt;a href=&quot;#1-视频编码基本原理&quot; class=&quot;headerlink&quot; title=&quot;1.视频编码基本原理&quot;&gt;&lt;/a&gt;1.视频编码基本原理&lt;/h1&gt;&lt;h2 id=&quot;（1）-视频信号的冗余信息&quot;&gt;&lt;a href=&quot;#（1）-视频信号的冗余信息&quot; class=&quot;headerlink&quot; title=&quot;（1）  视频信号的冗余信息&quot;&gt;&lt;/a&gt;（1）  视频信号的冗余信息&lt;/h2&gt;&lt;p&gt;以记录数字视频的YUV分量格式为例，YUV分别代表亮度与两个色差信号。例如对于现有的PAL制电视系统，其亮度信号采样频率为13.5MHz；色度信号的频带通常为亮度信号的一半或更少，为6.75MHz或3.375MHz。以4：2：2的采样频率为例，Y信号采用13.5MHz，色度信号U和V采用6.75MHz采样，采样信号以8bit量化，则可以计算出数字视频的码率为：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在线监控项目复盘-nginx</title>
    <link href="https://guoqiang-gump.github.io/2021/09/16/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-nginx/"/>
    <id>https://guoqiang-gump.github.io/2021/09/16/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-nginx/</id>
    <published>2021-09-16T04:24:31.000Z</published>
    <updated>2021-09-27T02:55:57.809Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx是一套开源软件，纯C语言编写，效率高。是一个HTTP和反向代理web服务器，同时也是一个 IMAP、POP3、SMTP 代理服务器。具有稳定、高效，支持高并发的优点。<br>在这项目中Nginx可以作为流体服务器，支持RTMP、HTTPFLV、HLS等协议。</p> <a id="more"></a> <p>在跟着韦东山做项目的时候，我使用的是正点原子的阿尔法开发板，而且也是正点原子出品的ov5460摄像头。当时脑抽了才买了这个摄像头，太垃圾了，还贼贵。应该买一个usb摄像头的，舍友买了一个海康的usb摄像头，价格低，拍照清晰，可以在开发板和电脑上都可以使用。肠子悔青了。</p><p>我的ov5460摄像头只能在阿尔法开发板的出厂系统可以读出来，如果是我自己的配置的buildroot根文件系统下就是没办法读出来。明明我都装了驱动了，还是识别不出来，白花一天时间搞这个buildroot根文件系统了。</p><h1 id="nigix移植"><a href="#nigix移植" class="headerlink" title="nigix移植"></a>nigix移植</h1><p>阿尔法开发板的出厂系统没有移植nginx，如果是buildroot系统，移植nginx很简单。但是，阿尔法开发板的出厂系统是基于yocto的，很难移植nginx库。</p><p>只能硬着头皮自己编译、移植nginx库。说实话，编译和移植nginx库对我这种新手来说，绝对是地狱级别的难度的。搞了整整两天才编译成功。自闭。</p><p> <a href="https://blog.csdn.net/u011641885/article/details/49863723">(16条消息) 移植 nginx_Gino的专栏-CSDN博客_nginx移植</a> </p><p> <a href="https://www.cnblogs.com/schips/p/12308651.html">arm linux 移植 Nginx - 黄树超 - 博客园 (cnblogs.com)</a> </p><p>这两篇文章可以解决很多问题。还是踩了很多坑。</p><p>编译nginx需要用到zlib、pcre、openssl依赖库。这些依赖库不要去官网下载最新的。应该根据帖子里面的版本下载。新版本不一定能兼容旧版本，会编译出错。血泪，巨坑。</p><p>openssl依赖库的编译也是大坑。这个库编译不过去。自己摸索出一种方法。在nginx/objs/Makefile 中查找出openssl编译出来的地址，把这句编译的语句注释掉。然后自己手动编译openssl在那个地址里面。这样就可以编译通过。不然就是陷入一个死循环。心累啊，这里摸索了好久，真坑，真的劝退。</p><h1 id="nigix配置和部署"><a href="#nigix配置和部署" class="headerlink" title="nigix配置和部署"></a>nigix配置和部署</h1><p>nginx version: nginx/1.16.1<br>vi /etc/nginx/ngixn.conf </p><p>使用rtmp协议，端口为1935，ip为127.0.0.1</p><p>http协议则使用80端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"> #user  nobody;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtmp&#123;</span><br><span class="line"></span><br><span class="line">  server&#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        chunk_size 4096;</span><br><span class="line">  application live&#123;</span><br><span class="line">        allow publish 127.0.0.1;</span><br><span class="line">        allow play all;</span><br><span class="line">        live on ;</span><br><span class="line">        record off;</span><br><span class="line">        meta copy;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">       location  &#x2F;test&#123;</span><br><span class="line">           flv_live on;</span><br><span class="line">           chunked_transfer_encoding on; </span><br><span class="line">            add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; </span><br><span class="line">            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">     #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">        # concurs with nginx&#39;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ &#x2F;\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">  #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">  #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nginx是一套开源软件，纯C语言编写，效率高。是一个HTTP和反向代理web服务器，同时也是一个 IMAP、POP3、SMTP 代理服务器。具有稳定、高效，支持高并发的优点。&lt;br&gt;在这项目中Nginx可以作为流体服务器，支持RTMP、HTTPFLV、HLS等协议。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在线监控项目复盘-ffmpeg命令</title>
    <link href="https://guoqiang-gump.github.io/2021/09/16/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-ffmpeg%E5%85%A5%E9%97%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/09/16/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-ffmpeg%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-16T04:03:26.000Z</published>
    <updated>2021-09-24T05:32:42.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ffmpeg主要组成部分"><a href="#ffmpeg主要组成部分" class="headerlink" title="ffmpeg主要组成部分"></a>ffmpeg主要组成部分</h2><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-ffmpeg.assets/1631765176676.png" alt="1631765176676"><br> <strong>在这组成部分中，需要熟悉基础概念有</strong><br><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-ffmpeg.assets/1631765137780.png" alt="1631765137780"></p> <a id="more"></a> <h2 id="ffmpeg的解码到编码流程"><a href="#ffmpeg的解码到编码流程" class="headerlink" title="ffmpeg的解码到编码流程"></a>ffmpeg的解码到编码流程</h2><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-ffmpeg.assets/1631765508139.png" alt="1631765508139"></p><p>1、FFmpeg程序把-i参数指定的若干文件内容读入到内存，按照输入的参数或者程序默认的参数来处理并且把结果写入到若干的文件中。输入和输出文件可以是计算机文件、管道、网络流、捕获设备等。<br> 2、FFmpeg用libavformat包调用解复用器（demuxers）来读取输入文件中被编码的数据包(packets)，如果有多个输入文件，FFmpeg以有效输入流的最小时间戳来同步，<br> 3、然后解码器（decoder）从已编码的数据包中产生未被压缩的帧（frame），在那之后调用可选的过滤器。<br> 4、这些帧被传递到编码器，编码器会产生新的编码包<br> 5、把新的编码包传递给复用器(muxer)处理并且把结果写入到输出文件中。</p><h2 id="码率、帧率和文件大小"><a href="#码率、帧率和文件大小" class="headerlink" title="码率、帧率和文件大小"></a>码率、帧率和文件大小</h2><p>码率和帧率是视频文件的最重要的基本特征，对于他们的特有设置会决定视频质量。如果我们知道码率和时长那么可以很容易计算出输出文件的大小。</p><p>帧率：帧率也叫帧频率，帧率是视频文件中每一秒的帧数，肉眼想看到连续移动图像至少需要15帧。<br>码率：比特率(也叫码率，数据率)是一个确定整体视频/音频质量的参数，秒为单位处理的字节数，码率和视频质量成正比，在视频文件中中比特率用bps来表达。</p><h1 id="ffmpeg常用命令参数"><a href="#ffmpeg常用命令参数" class="headerlink" title="ffmpeg常用命令参数"></a>ffmpeg常用命令参数</h1><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-ffmpeg.assets/1631766201281.png" alt="1631766201281"></p><p>AVStream，AVCodecContext：视音频流对应的结构体，用于视音频编解码。</p><p>a)        解协议（http,rtsp,rtmp,mms）</p><p>AVIOContext，URLProtocol，URLContext主要存储视音频使用的协议的类型以及状态。URLProtocol存储输入视音频使用的封装格式。每种协议都对应一个URLProtocol结构。（注意：FFMPEG中文件也被当做一种协议“file”）</p><p>b)        解封装（flv,avi,rmvb,mp4）</p><p>AVFormatContext：统领全局的基本结构体，主要存储视音频封装格式中包含的信息，用于处理封装格式（FLV/MKV/RMVB等）。</p><p>AVInputFormat/AVOutputFormat：输入输出对应的结构体，用于输入输出（读写文件，RTMP协议等），存储输入视音频使用的封装格式。每种视音频封装格式都对应一个AVInputFormat /AVOutputFormat结构。</p><p>c)        解码（h264,mpeg2,aac,mp3）</p><p>每个AVStream：视音频流对应的结构体，存储一个视频/音频流的相关数据；</p><p>每个AVStream对应一个AVCodecContext，AVCodecContext存储该视频/音频流使用解码方式的相关数据，用于视音频编解码；</p><p>每个AVCodecContext中对应一个AVCodec，AVCodec包含该视频/音频对应的解码器。每种解码器都对应一个AVCodec结构。</p><p>d) 存数据</p><p>解码前数据：AVPacket：存储压缩数据（视频对应H.264等码流数据，音频对应AAC/MP3等码流数据）</p><p>解码后数据：AVFrame ：存储非压缩的数据（视频对应RGB/YUV像素数据，音频对应PCM采样数据）<br><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-ffmpeg%E5%85%A5%E9%97%A8.assets/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="无标题"></p><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-ffmpeg%E5%85%A5%E9%97%A8.assets/1632034789138.png" alt="1632034789138"></p><p>av_register_all()：注册FFmpeg所有编解码器。</p><p>avformat_alloc_output_context2()：初始化输出码流的AVFormatContext。</p><p>avio_open()：打开输出文件。</p><p>av_new_stream()：创建输出码流的AVStream。</p><p>avcodec_find_encoder()：查找编码器。</p><p>avcodec_open2()：打开编码器。</p><p>avformat_write_header()：写文件头（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。</p><p>avcodec_encode_video2()：编码一帧视频。即将AVFrame（存储YUV像素数据）编码为AVPacket（存储H.264等格式的码流数据）。</p><p>av_write_frame()：将编码后的视频码流写入文件。</p><p>flush_encoder()：输入的像素数据读取完成后调用此函数。用于输出编码器中剩余的AVPacket。</p><p>av_write_trailer()：写文件尾（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ffmpeg主要组成部分&quot;&gt;&lt;a href=&quot;#ffmpeg主要组成部分&quot; class=&quot;headerlink&quot; title=&quot;ffmpeg主要组成部分&quot;&gt;&lt;/a&gt;ffmpeg主要组成部分&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-ffmpeg.assets/1631765176676.png&quot; alt=&quot;1631765176676&quot;&gt;&lt;br&gt; &lt;strong&gt;在这组成部分中，需要熟悉基础概念有&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-ffmpeg.assets/1631765137780.png&quot; alt=&quot;1631765137780&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在线监控项目复盘-项目背景</title>
    <link href="https://guoqiang-gump.github.io/2021/09/16/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF/"/>
    <id>https://guoqiang-gump.github.io/2021/09/16/%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF/</id>
    <published>2021-09-16T03:22:29.000Z</published>
    <updated>2021-10-07T14:10:06.453Z</updated>
    
    <content type="html"><![CDATA[<p>这个在线监控项目是七月初开始做的，做了差不多一个月，做的过程中没有记录什么笔记，而且做完了就急着刷题，没有做总结和复盘。现在在面试的时候，每当问道这个项目，我都很多答不上来，很打击我信心。舍友告诉我，让我把这个项目当作一个课程设计，做完了就要写一份报告，把写报告当作复盘，面试前多看看这个报告就可以了。我觉得很有道理，所以抽空几天，作深度的复盘。</p><p>项目已经做完半个多月了，现在复盘只能根据回忆来写，当然会深挖项目的技术点和原理。当初就不应该偷懒，做项目的过程中，应该随手做笔记，哎，还是得养成作笔记的习惯。</p> <a id="more"></a> <h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>见过一个师兄做过在线监控项目，觉得很不错。后来在B站看到韦东山的在线监控小项目的视频，立马被震惊了。跟着韦东山作了那个小项目，受益匪浅。算是最低级最初级的音视频入门了。韦东山的项目是通过ffmpeg工具来实现音视频的推拉流的，所以很简单。我之前学了Qt，所以想结合Qt和ffmpeg开源库来实现推拉流的功能。</p><h1 id="韦东山-基于ffmpeg和nginx的在线监控"><a href="#韦东山-基于ffmpeg和nginx的在线监控" class="headerlink" title="韦东山-基于ffmpeg和nginx的在线监控"></a>韦东山-基于ffmpeg和nginx的在线监控</h1><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF.assets/1631763595085.png" alt="1631763595085"></p><p>ffmpeg是一套强大的开源软件：可以记录、转换音视频，可以从摄像头中记录视频，从声卡中记录音频，可以转换为各种格式，保存起来；还可以把各种格式的音视频，转换为流，供在线观看。其他功能：视频截图、加水印、裁剪等等。</p><p>Nginx是一套开源软件，纯C语言编写，效率高。是一个HTTP和反向代理web服务器，同时也是一个 IMAP、POP3、SMTP 代理服务器。具有稳定、高效，支持高并发的优点。<br>在这项目中Nginx可以作为流体服务器支持RTMP、HTTPFLV、HLS等协议。</p><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF.assets/1631769226260.png" alt="1631769226260"></p><p>avi，rmvb，mp4，flv，mkv等等（当然也使用不同的图标）。在这里需要注意的是，这些格式代表的是封装格式。何为封装格式？就是把视频数据和音频数据打包成一个文件的规范。仅仅靠看文件的后缀，很难能看出具体使用了什么视音频编码标准。总的来说，不同的封装格式之间差距不大，各有优劣。</p><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF.assets/1631764236635.png" alt="1631764236635"></p><p>从摄像头、声卡得到的原始数据太大，不易传输，需要压缩。音视频编码就相当于对音视频数据进行压缩。<br>压缩的方法有很多种：格式不同，编码器不同，对应不同的音频、视频编码器。</p><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF.assets/1631764716766.png" alt="1631764716766"></p><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF.assets/1631764693764.png" alt="1631764693764"></p><p> H.264仅仅是一个编码标准，而不是一个具体的编码器，H.264只是给编码器的实现提供参照用的。 </p><p>把这些压缩后，即编码后的视频数据、音频数据合并在一起：复用、MUX，就得到了MP4、FLV等文件</p><p> <a href="https://blog.csdn.net/leixiaohua1020">雷霄骅</a> 的博主有很好的音视频入门博客：<a href="https://blog.csdn.net/leixiaohua1020/article/details/18893769%EF%BC%9B%E5%8F%AF%E6%83%9C%E8%BF%99%E4%BD%8D%E5%A4%A7%E4%BD%AC%E8%8B%B1%E5%B9%B4%E6%97%A9%E9%80%9D%EF%BC%8C%E5%9C%A8%E8%BF%99%E9%87%8C%E6%84%9F%E8%B0%A2%E4%BB%96%E7%9A%84%E6%97%A0%E7%A7%81%E5%92%8C%E5%BC%80%E6%BA%90%E7%B2%BE%E7%A5%9E%EF%BC%8C%E5%AF%B9%E6%88%91%E4%BB%AC%E8%BF%99%E7%A7%8D%E5%B0%8F%E7%99%BD%E7%9C%9F%E7%9A%84%E5%A4%AA%E5%8F%8B%E5%A5%BD%E4%BA%86%E3%80%82">https://blog.csdn.net/leixiaohua1020/article/details/18893769；可惜这位大佬英年早逝，在这里感谢他的无私和开源精神，对我们这种小白真的太友好了。</a></p><h2 id="推拉流"><a href="#推拉流" class="headerlink" title="推拉流"></a>推拉流</h2><p>ffmpeg -f v4l2 -framerate 10 -i /dev/video1 -q 10  -f flv rtmp://127.0.0.1/live/wei</p><p>ffmpeg -re -i test.mp4 -vcodec copy -acodec copy -f flv rtmp://127.0.0.1/live/wei</p><p>使用RTMP协议拉流：VLC播放器中点击“媒体”-&gt;“打开网络串流”，输入：rtmp://192.168.1.6/live/wei  ，就可以播放了<br>使用HTTPFLV协议拉流：VLC播放器中点击“媒体”-&gt;“打开网络串流”，输入： <a href="http://192.168.1.6/test?app=live&amp;stream=wei">http://192.168.1.6/test?app=live&amp;stream=wei</a> ，就可以播放了</p><p><img src="%E5%9C%A8%E7%BA%BF%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98-%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF.assets/1631770151774.png" alt="1631770151774"></p><ul><li>RTMP（Real Time Messaging Protocol）是基于TCP的，由Adobe公司为Flash播放器和服务器之间音频、视频传输开发的开放协议。</li><li>HLS（HTTP Live Streaming）是基于HTTP的，是Apple公司开放的音视频传输协议。</li><li>HTTP FLV则是将RTMP封装在HTTP协议之上的，可以更好的穿透防火墙等</li></ul><p><strong>Http_flv &amp; RTMP</strong></p><p>这两个协议实际上传输数据是一样的，<strong>数据都是flv文件的tag</strong>。http_flv是一个无限大的http流的文件，相比rtmp就只能直播，而rtmp还可以推流和更多的操作。但是http有个好处，就是是以80http通信的，穿透性强，而且rtmp是非开放协议。</p><p>这两个协议是如今直播平台主选的直播方式，主要原因就是延时极低。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个在线监控项目是七月初开始做的，做了差不多一个月，做的过程中没有记录什么笔记，而且做完了就急着刷题，没有做总结和复盘。现在在面试的时候，每当问道这个项目，我都很多答不上来，很打击我信心。舍友告诉我，让我把这个项目当作一个课程设计，做完了就要写一份报告，把写报告当作复盘，面试前多看看这个报告就可以了。我觉得很有道理，所以抽空几天，作深度的复盘。&lt;/p&gt;
&lt;p&gt;项目已经做完半个多月了，现在复盘只能根据回忆来写，当然会深挖项目的技术点和原理。当初就不应该偷懒，做项目的过程中，应该随手做笔记，哎，还是得养成作笔记的习惯。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++_11</title>
    <link href="https://guoqiang-gump.github.io/2021/08/21/C-11/"/>
    <id>https://guoqiang-gump.github.io/2021/08/21/C-11/</id>
    <published>2021-08-21T10:38:54.000Z</published>
    <updated>2021-09-24T05:44:23.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二十四-C-异常机制-exception"><a href="#二十四-C-异常机制-exception" class="headerlink" title="二十四 C++异常机制(exception)"></a>二十四 C++异常机制(exception)</h1><h2 id="1-软件开发中的常见错误"><a href="#1-软件开发中的常见错误" class="headerlink" title="1 软件开发中的常见错误"></a>1 软件开发中的常见错误</h2> <a id="more"></a> <p>1）语法错误<br>2）逻辑错误<br>3）功能错误<br>4）设计缺陷<br>5）需求不符<br>6）环境异常<br>7）操作不当</p><h2 id="2-传统C语言中的错误处理"><a href="#2-传统C语言中的错误处理" class="headerlink" title="2 传统C语言中的错误处理"></a>2 传统C语言中的错误处理</h2><p>1）通过返回值表示错误<br>优点：函数调用路径中的所有栈对象可以得到正确析构，内存管理安全。<br>缺点：错误处理流程比较麻烦，需要逐层进行返回判断，代码臃肿。</p><p>2）通过远程跳转处理错误<br>优点：错误处理流程比较简单，不需要逐层的返回值判断，一步到位的错误处理，代码精炼<br>缺点：函数调用路径中的栈对象失去了被析构的机制，有内存泄漏的风险</p><h2 id="3-C-异常语法"><a href="#3-C-异常语法" class="headerlink" title="3 C++异常语法"></a>3 C++异常语法</h2><p>1）异常抛出<br>   throw 异常对象;<br>   注：异常对象可以是基本类型的数据，也可以是类类型对象.</p><p>2）异常检测和捕获<br>   try{<br>           可能引发异常的语句;<br>   }<br>   catch(异常类型1){<br>           针对异常类型1数据的处理.<br>   }<br>   catch(异常类型2){<br>           针对异常类型2数据的处理.<br>   }<br>   …</p><p>   注：catch子句根据异常对象的类型自上而下顺序匹配，而不是最优匹配，因此对子类异常捕获语句要写在前面，否则会被基类异常捕获语句提前截获。</p><h2 id="4-函数异常说明"><a href="#4-函数异常说明" class="headerlink" title="4 函数异常说明"></a>4 函数异常说明</h2><p>1）语法<br>    返回类型 函数名(参数表) throw(异常类型表) {}<br>    注：“throw(异常类型表)”即为异常说明表，用于说明该函数可能抛出的异常类型<br>2）函数异常说明只是一种承诺，不是强制语法要求，如果函数抛出了异常说明以外的其它类型，则无法被函数的调用者正常检测和捕获，而会被系统捕获，导致进程终止。</p><p>3）函数异常说明的两种极端形式<br>–》不写函数异常说明表，表示可以抛出任何异常。<br>–》空异常说明，“throw()”，表示不可以抛出任何异常。</p><p>4）如果函数的声明和函数定义分开，要保证异常说明表中的类型一致，但是顺序无所谓。</p><h2 id="5-标准异常类exception"><a href="#5-标准异常类exception" class="headerlink" title="5 标准异常类exception"></a>5 标准异常类exception</h2><p>​    vi /usr/include/c++/编译器版本号/exception<br>​    class exception{<br>      public:<br>​        exception() throw() { }<br>​        virtual ~exception() throw();//虚函数覆盖时，子类中版本不能说明比基类版本抛出更多的异常。 </p><pre><code>    /* Returns a C-style character string describing the general cause            of the current error.  */    virtual const char* what() const throw();  &#125;; 注：“_GLIBCXX_USE_NOEXCEPT”即为空异常说明“throw()”</code></pre><p>eg：<br>    try{<br>        func();<br>        …<br>    }<br>    catch(exception&amp; ex){//可以捕获exception所有子类类型异常对象<br>        ex.what();<br>    }</p><h2 id="6-构造函数和析构函数中的异常-了解"><a href="#6-构造函数和析构函数中的异常-了解" class="headerlink" title="6 构造函数和析构函数中的异常 //了解"></a>6 构造函数和析构函数中的异常 //了解</h2><p>1）构造函数可以抛出异常，但是对象将被不完整构造，这样的对象其析构不能再被自动调用执行，因此在构造函数抛出异常之前，需要手动清理之前所分配的动态资源.<br>2）析构函数最好不要抛出异常，在析构函数中抛出异常很难被检测到。</p><h1 id="二十五-I-O流-了解"><a href="#二十五-I-O流-了解" class="headerlink" title="二十五 I/O流 //了解"></a>二十五 I/O流 //了解</h1><p>1 主要的I/O流类<br>                            ios<br>                    /                <br>                istream                ostream<br>        /         |        \        /        |        \<br>istrstream    ifstream     iostream    ofstream    ostrstream</p><p>详细参考官方手册：<a href="http://www.cplusplus.com/reference/iolibrary/">http://www.cplusplus.com/reference/iolibrary/</a></p><p>2 格式化I/O<br>1）格式化函数(本质是成员函数)<br>    cout &lt;&lt; 100/3.0 &lt;&lt; endl;//33.3333</p><hr><p>​    cout.precision(10);//格式化函数<br>​    cout &lt;&lt; 100/3.0 &lt;&lt; endl;//33.33333333</p><p>2）流控制符(本质是全局函数)<br>    cout &lt;&lt; 100/3.0 &lt;&lt; endl;//33.3333<br>    ——————<br>    #include <iomanip><br>    //流控制符<br>    cout &lt;&lt; setprecision(10) &lt;&lt; 100/3.0 &lt;&lt; endl;//33.33333333</p><p>3 字符串流<br>#include <strstream> //过时，不推荐使用<br>istrstream、ostrstream</p><p>#include <sstream> //推荐<br>istringstream //类似sscanf()<br>ostringstream //类似sprintf()</p><p>4 文件流<br>#include <fstream><br>ifstream //类似fscanf<br>ofstream //类似fprintf</p><p>5 二进制I/O<br>//类似fread<br>istream&amp; istream::read(char* buffer,streamsize num);<br>//类似fwrite<br>ostream&amp; ostaream::write(const char* buffer,size_t num);</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;二十四-C-异常机制-exception&quot;&gt;&lt;a href=&quot;#二十四-C-异常机制-exception&quot; class=&quot;headerlink&quot; title=&quot;二十四 C++异常机制(exception)&quot;&gt;&lt;/a&gt;二十四 C++异常机制(exception)&lt;/h1&gt;&lt;h2 id=&quot;1-软件开发中的常见错误&quot;&gt;&lt;a href=&quot;#1-软件开发中的常见错误&quot; class=&quot;headerlink&quot; title=&quot;1 软件开发中的常见错误&quot;&gt;&lt;/a&gt;1 软件开发中的常见错误&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++_10</title>
    <link href="https://guoqiang-gump.github.io/2021/08/21/C-10/"/>
    <id>https://guoqiang-gump.github.io/2021/08/21/C-10/</id>
    <published>2021-08-21T10:36:52.000Z</published>
    <updated>2021-09-24T05:44:12.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二十二-多态-polymorphic"><a href="#二十二-多态-polymorphic" class="headerlink" title="二十二 多态(polymorphic)"></a>二十二 多态(polymorphic)</h1><h2 id="1-虚函数覆盖-函数重写-、多态概念"><a href="#1-虚函数覆盖-函数重写-、多态概念" class="headerlink" title="1 虚函数覆盖(函数重写)、多态概念"></a>1 虚函数覆盖(函数重写)、多态概念</h2> <a id="more"></a> <p>1）如果基类中某个成员函数被声明为虚函数，那么子类中和该函数具有相同的成员函数就也是虚函数，并且对基类中版本形成覆盖，即函数重写。<br>2）满足虚函数覆盖关系后，这时通过指向子类对象的基类指针或者通过引用子类对象的基类引用，去调用虚函数，实际被执行的将是子类中的覆盖版本，而不是基类中的原始版本，这种语法现象被称为多态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void func(void)&#123;&#125;&#x2F;&#x2F;虚函数</span><br><span class="line">&#125;;</span><br><span class="line">class Derived:pubilc Base&#123;</span><br><span class="line">void func(void)&#123;&#125;&#x2F;&#x2F;也是虚函数</span><br><span class="line">&#125;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb &#x3D; &amp;d;&#x2F;&#x2F;pb指向子类对象的基类指针</span><br><span class="line">Base&amp; rb &#x3D; d;&#x2F;&#x2F;rb引用子类对象的基类引用</span><br><span class="line">pb-&gt;func();&#x2F;&#x2F;实际被执行的将是子类中的覆盖版本</span><br><span class="line">rb.func();&#x2F;&#x2F;实际被执行的将是子类中的覆盖版本</span><br></pre></td></tr></table></figure><h2 id="2-虚函数覆盖-函数重写-条件"><a href="#2-虚函数覆盖-函数重写-条件" class="headerlink" title="2 虚函数覆盖(函数重写)条件"></a>2 虚函数覆盖(函数重写)条件</h2><p>1）只有类中成员函数才能被声明为虚函数，而全局函数、静态成员函数、构造函数都不能声明为虚函数。<br>    注：析构函数可以为虚函数(特殊，后面讲)<br>2）只有在基类中以virtual关键字修饰的成员函数才能作为虚函数被子类中版本覆盖，而与子类中虚函数是否加virtual关键字无关。<br>3）虚函数在基类中的原始版本和子类中的覆盖版本必须具有相同的函数签名，即函数名、参数表和常属性一致。<br>4）如果基类中的虚函数返回基本类型的数据，那么该函数在子类中覆盖版本必须返回相同类型的数据；而如果基类中的虚函数返回类类型的指针(A*)或引用(A&amp;)，那么允许子类中的覆盖版本返回其子类类型的指针(B*)或引用(B&amp;)。</p><h2 id="3-多态的条件"><a href="#3-多态的条件" class="headerlink" title="3 多态的条件"></a>3 多态的条件</h2><p>1）多态的语法现象除了满足虚函数覆盖，还必须通过指针或引用调用虚函数才能表现出来。<br>2）调用虚函数的指针也可以是this指针，如果通过子类对象调用基类中的成员函数，在该成员函数中的this指针将是一个指向子类对象的基类指针，再使用this去调用虚函数，也可以表现多态的语法现象。//重点掌握<br>eg:Qt中的多线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class QThread&#123;&#x2F;&#x2F;线程类，官方写好的类</span><br><span class="line">public:</span><br><span class="line">void start(void)&#123;&#x2F;&#x2F;开启线程</span><br><span class="line">this-&gt;run();</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">virtual void run(void)&#123;&#x2F;&#x2F;线程入口函数</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class MyThread:public QThread&#123;</span><br><span class="line">protected:</span><br><span class="line">void run(void)&#123;&#x2F;&#x2F;重写线程入口函数</span><br><span class="line">&#x2F;&#x2F;需要放在线程执行的代码</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">MyThread thread;</span><br><span class="line">thread.start();&#x2F;&#x2F;开启子线程，重写的run函数将在子线程中被执行</span><br></pre></td></tr></table></figure><h2 id="4-纯虚函数、抽象类和纯抽象类"><a href="#4-纯虚函数、抽象类和纯抽象类" class="headerlink" title="4 纯虚函数、抽象类和纯抽象类"></a>4 纯虚函数、抽象类和纯抽象类</h2><p>1）纯虚函数<br>    virtual 返回类型 函数名(形参表)[const] = 0;<br>2）抽象类<br>    如果类中包含了纯虚函数，那么该类就是抽象类。<br>    注：抽象类不能创建对象.<br>3）纯抽象类(接口、接口类)<br>    如果类中所有的成员函数都是纯虚函数，那么该类就是纯抽象类。</p><h2 id="5-多态原理-了解"><a href="#5-多态原理-了解" class="headerlink" title="5 多态原理//了解"></a>5 多态原理//了解</h2><p>  通过虚函数表和动态绑定实现了多态的语法//参考polymorphic.png<img src="C-10.assets/polymorphic.png" alt="polymorphic"><br>  1）虚函数表会增加内存的开销<br>  2）动态绑定有时间的开销<br>  3）虚函数不能被内联优化<br>  总结：实际开发中如果没有多态的语法要求，最好不要使用虚函数。</p><h2 id="6-虚析构函数"><a href="#6-虚析构函数" class="headerlink" title="6 虚析构函数"></a>6 虚析构函数</h2><p>问题：基类析构函数不会调用子类的析构函数，如果对一个指向子类对象的基类指针使用delete运算，实际被执行的将是基类的析构函数，子类的析构函数不会被执行，有内存泄漏风险<br>解决：如果将基类中的析构函数声明为虚函数，那么子类中的析构函数也就是一个虚析构函数，并且可以对基类中版本形成覆盖，可以表现多态的语法；这时如果对一个指向子类对象的基类指针使用delete运算符，实际被执行的将是子类的析构函数，子类的析构函数在执行结束后又会自动调用基类的析构函数，从而避免内存泄漏。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;二十二-多态-polymorphic&quot;&gt;&lt;a href=&quot;#二十二-多态-polymorphic&quot; class=&quot;headerlink&quot; title=&quot;二十二 多态(polymorphic)&quot;&gt;&lt;/a&gt;二十二 多态(polymorphic)&lt;/h1&gt;&lt;h2 id=&quot;1-虚函数覆盖-函数重写-、多态概念&quot;&gt;&lt;a href=&quot;#1-虚函数覆盖-函数重写-、多态概念&quot; class=&quot;headerlink&quot; title=&quot;1 虚函数覆盖(函数重写)、多态概念&quot;&gt;&lt;/a&gt;1 虚函数覆盖(函数重写)、多态概念&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++_8</title>
    <link href="https://guoqiang-gump.github.io/2021/08/21/C-8/"/>
    <id>https://guoqiang-gump.github.io/2021/08/21/C-8/</id>
    <published>2021-08-21T10:31:43.000Z</published>
    <updated>2021-09-24T05:44:04.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二十一-继承-Inheritance"><a href="#二十一-继承-Inheritance" class="headerlink" title="二十一 继承(Inheritance)"></a>二十一 继承(Inheritance)</h1><h2 id="1-继承的概念-了解"><a href="#1-继承的概念-了解" class="headerlink" title="1 继承的概念 //了解"></a>1 继承的概念 //了解</h2><p>​     <a id="more"></a> </p><p>通过一种机制描述类型之间共性和特性的方式，利用已有的数据类型定义新的数据类型，这种机制就是继承.</p><p>   基类–派生–&gt;子类<br>   子类–继承–&gt;基类</p><h2 id="2-继承的语法"><a href="#2-继承的语法" class="headerlink" title="2 继承的语法"></a>2 继承的语法</h2><p>​    class 子类:继承方式 基类1,继承方式 基类2,…{<br>​        ……<br>​    };<br>​    继承方式:<br>​    –&gt; 公有继承(public)<br>​    –&gt; 保护继承protected(protected修饰类的成员时，保护成员在类的内部和子类的内部可以使用，类的外部不可使用)<br>​    –&gt; 私有继承(private)</p><h2 id="3-公有继承-public-的语法特性"><a href="#3-公有继承-public-的语法特性" class="headerlink" title="3 公有继承(public)的语法特性"></a>3 公有继承(public)的语法特性</h2><p>1）子类对象会继承基类的属性和行为，通过子类对象可以访问基类中的成员，如同是基类对象在访问它们一样。<br>  注：子类对象中包含的基类部分被称为“基类子对象”<br><strong>2）向上造型(upcast)//重点掌握</strong><br>   将子类类型的指针或引用转换为基类类型的指针或引用；这种操作性(可操作权限)缩小的类型转换，在编译器看来是安全的，可以直接隐式转换.<br>    基 类<br>      ↑<br>    子 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> class A&#123;&#125;;</span><br><span class="line">class B:public A&#123;&#125;;</span><br><span class="line">class C:public A&#123;&#125;;</span><br><span class="line">class D:public A&#123;&#125;;</span><br><span class="line">...</span><br><span class="line">void func1(A* pa)&#123;&#125;</span><br><span class="line">void func2(A&amp; ra)&#123;&#125;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">func1(&amp;B&#x2F;&amp;C&#x2F;&amp;D...);&#x2F;&#x2F;向上造型</span><br><span class="line">func2(B&#x2F;C&#x2F;D...);&#x2F;&#x2F;向上造型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）向下造型(downcast)</strong><br>    将基类类型的指针或引用转换为子类类型的指针或引用；这种操作性(可操作权限)放大的类型转换，在编译器看来是危险的，不能隐式转换，但可以显式转换(推荐static_cast&lt;类型&gt;)。<br>    基 类<br>      ↓<br>    子 类</p><p>4）子类继承基类的成员<br>–》在子类中，可以直接访问基类中的公有和保护成员，就如同是子类自己的成员一样。<br>–》基类中的私有成员，子类也可以继承，但是受到访问控制属性的影响，无法直接访问；如果希望访问基类中的私有成员，可以让基类提供公有或保护的成员函数，来间接访问。</p><p>5）子类隐藏基类的成员<br>–》如果子类和基类定义了同名的成员函数，因为所属作用域不同，不能构成有效的重载关系，而是一种隐藏关系；通过子类对象将会优先访问子类自己的成员，基类的成员无法被使用。<br>–》如果希望访问基类中被隐藏的同名成员，可以通过”类名::”显式指明 //推荐，d.Base::func();<br>–》如果同名的成员函数参数不同，也可以通过using声明，将基类中的成员函数引入子类的作用域中，让它们形成重载，通过函数重载的参数匹配来解决。//不推荐，在子类里面using Base::func;</p><h2 id="4-访问控制属性和继承方式"><a href="#4-访问控制属性和继承方式" class="headerlink" title="4 访问控制属性和继承方式"></a>4 访问控制属性和继承方式</h2><p>1）访问控制属性：影响类中成员的访问位置。<br>   访问控制限定符    访问控制属性    内部访问     子类访问    外部访问    友元访问<br>   public        公有成员        ok    ok    ok    ok<br>   protected    保护成员        ok    ok    no    ok<br>   private        私有成员        ok    no    no    ok</p><p>2）继承方式：影响通过子类访问基类中成员的可访问性<br>    基类中的成员    公有继承的子类        保护继承的子类        私有继承的子类<br>    公有成员        公有成员            保护成员            私有成员<br>    保护成员        保护成员            保护成员            私有成员<br>    私有成员        私有成员            私有成员            私有成员</p><p>eg:<br>    //阻断继承，防止扩散<br>    class _Base{<br>    public:<br>        void func(void){…}<br>    };<br>    class Base:private _Base{//ok<br>    };<br>    class A:public Base{};//no<br>    class B:public A{};//no<br>    class C:public B{};//no<br>    …<br>    ——————————–<br>eg:<br>    class Base{<br>    public:<br>        void func(void){…}<br>    };<br>    //class Derived:public Base{};<br>    class Derived:private Base{};//保护继承<br>    int main(void){<br>        Derived d;<br>        Base* pb = &d;//向上造型，error<br>        pb-&gt;func();<br>    }<br>    注：向上造型语法特性在保护继承和私有继承不再适用。</p><h2 id="5-子类的构造函数-重点掌握"><a href="#5-子类的构造函数-重点掌握" class="headerlink" title="5 子类的构造函数//重点掌握"></a>5 子类的构造函数//重点掌握</h2><p>1）如果子类构造函数没有显式指明基类子对象的初始化方式，那么编译器将会自动调用基类的无参构造函数来初始化基类子对象。<br>2）如果希望基类子对象以有参的方式被初始化，则需要在子类构造函数的初始化列表中指明基类子对象的初始化方式。<br>Derived(int i):Base(i)，m_member(j){};//在子类构造函数的初始化列表中指明基类子对象的初始化方式和成员子对象(m_member是一个类)的初始化方式<br>3）子类对象创建过程<br>–》分配内存<br>–》构造基类子对象（按继承表顺序）<br>–》构造成员子对象（按声明顺序）<br>–》子类构造函数代码</p><h2 id="6-子类的析构函数-重点掌握"><a href="#6-子类的析构函数-重点掌握" class="headerlink" title="6 子类的析构函数//重点掌握"></a>6 子类的析构函数//重点掌握</h2><p>1）子类的析构函数，无论是自定义的还是编译器缺省提供的，都会自动调用基类的析构函数，完成积累子对象的销毁。<br>2）子类对象销毁过程：<br>–》子类析构函数代码<br>–》析构成员子对象（按声明逆序）<br>–》析构基类子对象（按继承表逆序）<br>–》释放内存<br>3）基类析构函数不会调用子类的析构函数，如果对一个指向子类对象的基类指针使用delete运算，实际被执行的将是基类的析构函数，子类的析构函数不会被执行，有内存泄漏风险。<br>    注：解决方法：虚析构函数（后面讲）<br>eg:<br>    class A{};<br>    class B:public A{};<br>    A* pa = new B;//pa:指向子类对象的基类指针<br>    delete pa;//实际被执行的是基类的析构函数，有内存泄漏风险</p><h2 id="7-子类的拷贝构造和拷贝赋值"><a href="#7-子类的拷贝构造和拷贝赋值" class="headerlink" title="7 子类的拷贝构造和拷贝赋值"></a>7 子类的拷贝构造和拷贝赋值</h2><p>1）子类的拷贝构造<br>–》如果子类自己没有定义拷贝构造函数，那么编译器会为其提供缺省的拷贝构造函数，该函数会自动调用基类的拷贝构造函数，完成基类子对象的拷贝初始化。<br>–》如果子类自己定义了拷贝构造函数，那么需要使用初始化列表，显式指明基类子对象也要以拷贝的方式进行初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;&#125;;</span><br><span class="line">class Derived:public Base&#123;</span><br><span class="line">&#x2F;&#x2F;Base(that):显式指明基类子对象也要以拷贝的方式进行初始化</span><br><span class="line">Derived(const Derived&amp; that):Base(that),…&#123;&#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>2）子类的拷贝赋值<br>–》如果子类自己没有定义拷贝赋值函数，那么编译器会为其提供缺省的拷贝赋值函数，该函数会自动调用基类的拷贝赋值函数，完成基类子对象的赋值操作。<br>–》如果子类自己定义了拷贝赋值函数，那么需要在其中显式调用基类的拷贝赋值函数，完成对基类子对象赋值操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;&#125;;</span><br><span class="line">class Derived:public Base&#123;</span><br><span class="line">&#x2F;&#x2F;Base(that):显式指明基类子对象也要以拷贝的方式进行初始化</span><br><span class="line">Derived&amp; operator&#x3D;(const Derived&amp; that)&#123;</span><br><span class="line">if(*that !&#x3D; this)&#123;</span><br><span class="line">…………</span><br><span class="line">Base::operator&#x3D;(that);</span><br><span class="line">&#125;</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-子类的操作符重载-了解"><a href="#8-子类的操作符重载-了解" class="headerlink" title="8 子类的操作符重载//了解"></a>8 子类的操作符重载//了解</h2><h2 id="9-多重继承"><a href="#9-多重继承" class="headerlink" title="9 多重继承"></a>9 多重继承</h2><p>1）概念：一个子类可以同时继承多个基类，这样的继承方式就为多重继承。<br>2）向上造型时，编译器会根据各个基类子对象的内存布局，自动进行偏移计算，以保证指针的类型和所指向的基类子对象类型一致。<br>3）名字冲突问题<br>–》一个子类的多个基类中如果存在相同 的名字，当通过子类访问这些名字时，编译器会报歧义错误，即名字冲突。<br>–》解决名字冲突的通用做法，就是显式使用“类名：：”，指明要访问名字属于哪个基类//推荐<br>–》如果形成冲突的名字是成员函数，并且参数不同，也可以通过using声明，让他们在子类中形成重载关系，通过函数的重载解析来解决</p><h2 id="10-钻石继承和虚继承"><a href="#10-钻石继承和虚继承" class="headerlink" title="10 钻石继承和虚继承"></a>10 钻石继承和虚继承</h2><p>1）钻收继承<br>–》概念：一个子类的多个基类源自共同的基类祖先，这样继承机构被称为钻石继承。（公共基类、中间类、末端子类）。<br>–》问题：在创建末端子类对象时，会包含多个公共基类子对象，通过末端子类去访问公共基类的成员时，会因为继承路劲不同，而导致结果不同。<br>–》解决：通过虚继承，可以让公共基类子对象在末端子类对象中实例唯一，并可以为所有中间类共享，这样即使沿着不同继承路径所访问的成员一定时一致的。<br>2）虚继承(虚继承原理可以去了解下)<br>–》中间类在继承表位置使用virtual修饰<br>–》由末端子类负责构造公共基类子对象<br>    A(int m_data)<br>   / <br>  B   C //class B/C:virtual public A{…};<br>   \ /<br>    D  //class D:pulic B, pulic C{…};负责构造公共基类子对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class D:pulic B, pulic C&#123;</span><br><span class="line">D(int data):B(data),C(data),A(data)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用虚继承语法后，创建末端子类(D)对象时，继承机构类似如下：<br>B    C    A<br>\    |    /<br>    B</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;二十一-继承-Inheritance&quot;&gt;&lt;a href=&quot;#二十一-继承-Inheritance&quot; class=&quot;headerlink&quot; title=&quot;二十一 继承(Inheritance)&quot;&gt;&lt;/a&gt;二十一 继承(Inheritance)&lt;/h1&gt;&lt;h2 id=&quot;1-继承的概念-了解&quot;&gt;&lt;a href=&quot;#1-继承的概念-了解&quot; class=&quot;headerlink&quot; title=&quot;1 继承的概念 //了解&quot;&gt;&lt;/a&gt;1 继承的概念 //了解&lt;/h2&gt;&lt;p&gt;​</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++_7</title>
    <link href="https://guoqiang-gump.github.io/2021/08/21/C-7/"/>
    <id>https://guoqiang-gump.github.io/2021/08/21/C-7/</id>
    <published>2021-08-21T10:24:18.000Z</published>
    <updated>2021-09-24T05:37:41.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二十-操作符重载-operator"><a href="#二十-操作符重载-operator" class="headerlink" title="二十 操作符重载(operator)"></a>二十 操作符重载(operator)</h1><h2 id="1-双目操作符重载-L-R"><a href="#1-双目操作符重载-L-R" class="headerlink" title="1 双目操作符重载 L#R"></a>1 双目操作符重载 L#R</h2><h3 id="1-1-计算类双目操作符：-…"><a href="#1-1-计算类双目操作符：-…" class="headerlink" title="1.1 计算类双目操作符： + - …"></a>1.1 计算类双目操作符： + - …</h3> <a id="more"></a> <p>1）表达式结果是右值，不能对表达式结果再赋值<br>2）左右操作数既可以是左值也可以是右值<br>3）两种具体实现方式<br>–》成员函数形式(左调右参)<br>    L#R的表达式可以被编译器处理为”L.operator#(R)”成员函数调用形式，该函数的返回就是表达式结果。<br>c1+2c &lt;==&gt; c1.operator+(c2);<br>第一个const：修饰返回值，禁止对表达式结果再赋值<br>第二个const：常引用参数，修饰传入的参数c2，支持常量型右操作数，<br>第三个const：常成员函数，修饰调用的对象c1，支持常量型左操作数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Complex operator+(const Complex&amp; c)const&#123;&#125;;</span><br></pre></td></tr></table></figure><p>–》全局函数形式(左右都参)<br>    L#R的表达式可以被编译器处理为”operator#(L,R)”全局函数调用形式，该函数的返回就是表达式结果。<br>    注：通过friend关键字可以把一个全局函数声明为某个类的友元，对于友元函数可以访问类中的任何成员，可以定义在类的内部，但本质还是全局函数。<br>c2-c1 ==&gt; operator-(c2, c1);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend const Complex operator-(const Complex&amp; l, const Complex&amp; r)&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-赋值类双目操作符：-…"><a href="#1-2-赋值类双目操作符：-…" class="headerlink" title="1.2 赋值类双目操作符： += -= …"></a>1.2 赋值类双目操作符： += -= …</h3><p>1）表达式结果是左值，就是左操作数的自身<br>2）左操作数一定是左值，右操作数可以是左值也可以是右值<br>3）两种具体实现方式<br>–》成员函数形式(左调右参),L#R ==&gt; L.operator#(R)<br>c1+=c2 ==&gt; c1.operator+=(c2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex&amp; operator+&#x3D;(const Complex&amp; c)&#123; ………… return *this;&#125;&#x2F;&#x2F;引用函数，返回自身</span><br></pre></td></tr></table></figure><p>–》全局函数形式(左右都参),L#R ==&gt; operator#(L,R)<br>c1-=c2 ==&gt; operator-=(c1, c2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend Complex&amp; operator-&#x3D;(Complex&amp; l, const Complex&amp; r)&#123;…………return l;&#125;&#x2F;&#x2F;引用函数，返回第一个参数</span><br></pre></td></tr></table></figure><h2 id="2-单目操作符重载-O"><a href="#2-单目操作符重载-O" class="headerlink" title="2 单目操作符重载 #O"></a>2 单目操作符重载 #O</h2><h3 id="1-1-计算类单目操作符：-负-位反-…"><a href="#1-1-计算类单目操作符：-负-位反-…" class="headerlink" title="1.1 计算类单目操作符：-(负) ~(位反) …"></a>1.1 计算类单目操作符：-(负) ~(位反) …</h3><p>1）表达式结果是右值，不能对表达式结果再赋值<br>2）操作数既可以是左值也可以是右值<br>3）两种具体实现方式<br>–》成员函数形式：#O ==&gt; O.operator#()<br>-i ==&gt; i.operator-()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Integer operator-(void) const&#123;&#125;;</span><br></pre></td></tr></table></figure><p>–》全局函数形式：#O ==&gt; operator#(O)<br><del>i ==&gt; operator</del>(i)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend const Integer operator~(const Integer&amp; i)&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-自增减单目操作符：-–-…"><a href="#1-2-自增减单目操作符：-–-…" class="headerlink" title="1.2 自增减单目操作符：++ – …"></a>1.2 自增减单目操作符：++ – …</h3><p>1）前++、–<br>–》表达式结果是左值，就是操作数自身<br>–》操作数一定是左值<br>–》两种具体实现方式<br>    成员函数形式：#O ==&gt; O.operator#()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer&amp; operator++(void)&#123;………… return *this;&#125;</span><br></pre></td></tr></table></figure><p>​    全局函数形式：#O ==&gt; operator#(O)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend Integer&amp; operator++(Integer&amp; i)&#123;…………return i;&#125;</span><br></pre></td></tr></table></figure><p>2）后++、–<br>–》表达式结果是右值，是操作数自增减前副本，不能对表达结果再赋值<br>–》操作数一定是左值<br>–》两种具体实现方式<br>    成员函数形式：O# ==&gt; O.operator#(int/<em>哑元</em>/)//构成重载，编译器自动选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Integer operator++(int)&#123;………………return old;&#125;</span><br></pre></td></tr></table></figure><p>​    全局函数形式：O# ==&gt; operator#(O,int /* 哑元 */)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend const Integer operator++(Integer&amp; i, int)&#123;………………return old;&#125;</span><br></pre></td></tr></table></figure><p>​    </p><h2 id="3-输出-插入-和输入-提取-操作符重载-lt-lt-gt-gt"><a href="#3-输出-插入-和输入-提取-操作符重载-lt-lt-gt-gt" class="headerlink" title="3 输出(插入)和输入(提取)操作符重载: &lt;&lt;  &gt;&gt;"></a>3 输出(插入)和输入(提取)操作符重载: &lt;&lt;  &gt;&gt;</h2><p>功能：实现自定义类型对象的直接输出或输入<br>注：只能使用全局函数形式，不能使用成员函数形式    </p><pre><code>#include &lt;iostream&gt;ostream //标准输出流类，cout就是该类实例化的对象istream //标准输入流类，cin就是该类实例化的对象//全局函数形式：operator&lt;&lt;(cout,a)//cout是左值，被改变，a是右值cout &lt;&lt; a;//全局函数形式：operator&gt;&gt;(cin,a)//cin、a都是左值，都要被改变cin &lt;&lt; b;------------------------------------------------friend ostream&amp; operator&lt;&lt;(ostream&amp; os,const Right&amp; right)&#123;    ...    return os;&#125;friend istream&amp; operator&gt;&gt;(istream&amp; is,Right&amp; right)&#123;    ...    return is;&#125;</code></pre><h2 id="4-下标操作符重载"><a href="#4-下标操作符重载" class="headerlink" title="4 下标操作符重载 []"></a>4 下标操作符重载 []</h2><p>功能：实现自定义类型对象能够像数组一样去使用<br>注：非常对象返回左值，常对象返回右值<br>    string s = “minwei”;<br>    s[0] = ‘M’;//s.operator<a href="0"></a> = ‘M’<br>    s[3] = ‘W’;//s.operator<a href="3"></a> = ‘W’<br>    cout &lt;&lt; s &lt;&lt; endl;//“MinWei”</p><p>​    const string s2 = “youchengwei”;<br>​    cout &lt;&lt; s2[0] &lt;&lt; endl;//y<br>​    s2[0] = ‘Y’;//error<br>int&amp; operator[](size_t i){ return m_arr[i]; }//非常函数，适用非常对象，返回左值<br>const int&amp; operator[](size_t i)const{ return m_arr[i]; }//常函数，适用常对象，返回右值<br>​    </p><h2 id="5-函数操作符重载"><a href="#5-函数操作符重载" class="headerlink" title="5 函数操作符重载 ()"></a>5 函数操作符重载 ()</h2><p>功能：实现让自定义类型对象像函数一样使用//仿函数<br>注：对于参数个数、参数类型和返回类型没有任何限制，只能声明为成员函数形式<br>    A a(..);<br>    a(100,1.23);//a.operator()(100,1.23)<br>int operator()(int a, int b){}<br>int operator()(int a){}</p><h2 id="6-new-delete操作符重载-了解内存创建和销毁过程"><a href="#6-new-delete操作符重载-了解内存创建和销毁过程" class="headerlink" title="6 new/delete操作符重载 //了解内存创建和销毁过程"></a>6 new/delete操作符重载 //了解内存创建和销毁过程</h2><p>static void* operator new(size_t size){…}<br>//1、A* pa = (A* )A::operator new(sizeof(A));//分配内存<br>//2、构造成员子对象（按声明顺序）<br>//3、pa调用自身构造函数<br>A* pa = newA;</p><p>static void operator delete(void* p){…}<br>//1、pa调用自身析构函数<br>//2、析构成员子对象（按对象逆序）<br>//3、(A*)A::operator delete(pa);//释放内存<br>A * pa = newA;</p><h2 id="7-操作符重载限制"><a href="#7-操作符重载限制" class="headerlink" title="7 操作符重载限制"></a>7 操作符重载限制</h2><p>1）不是所有操作符都能重载，下面几个操作符不能重载<br>–》作用域限定操作符 “::”<br>–》直接成员访问操作符 “.”<br>–》直接成员指针解引用操作符 “.*”<br>–》条件操作符 “?:”<br>–》字节长度操作符 “sizeof”<br>–》类型信息操作符 “typeid”//后面讲<br>2）如果一个操作符所有的操作数都是基本类型，则无法重载<br>3）操作符重载不会改变预定的优先级<br>4）操作符重载不会改变操作数个数<br>5）不能通过操作符重载发明新的操作符<br>6）只能使用成员函数形式重载的操作符<br>    = [] () -&gt;</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;二十-操作符重载-operator&quot;&gt;&lt;a href=&quot;#二十-操作符重载-operator&quot; class=&quot;headerlink&quot; title=&quot;二十 操作符重载(operator)&quot;&gt;&lt;/a&gt;二十 操作符重载(operator)&lt;/h1&gt;&lt;h2 id=&quot;1-双目操作符重载-L-R&quot;&gt;&lt;a href=&quot;#1-双目操作符重载-L-R&quot; class=&quot;headerlink&quot; title=&quot;1 双目操作符重载 L#R&quot;&gt;&lt;/a&gt;1 双目操作符重载 L#R&lt;/h2&gt;&lt;h3 id=&quot;1-1-计算类双目操作符：-…&quot;&gt;&lt;a href=&quot;#1-1-计算类双目操作符：-…&quot; class=&quot;headerlink&quot; title=&quot;1.1 计算类双目操作符： + - …&quot;&gt;&lt;/a&gt;1.1 计算类双目操作符： + - …&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++_6</title>
    <link href="https://guoqiang-gump.github.io/2021/08/21/C-6/"/>
    <id>https://guoqiang-gump.github.io/2021/08/21/C-6/</id>
    <published>2021-08-21T04:00:17.000Z</published>
    <updated>2021-09-24T05:37:36.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十八-静态成员-static"><a href="#十八-静态成员-static" class="headerlink" title="十八 静态成员(static)"></a>十八 静态成员(static)</h1><h2 id="1-静态成员变量"><a href="#1-静态成员变量" class="headerlink" title="1 静态成员变量"></a>1 静态成员变量</h2> <a id="more"></a> <p>1）语法<br>    class 类名{<br>        static 数据类型 变量名;//声明<br>    };<br>    数据类型 类名::变量名 = 初值;//定义和初始化<br>2）普通成员变量属于对象，而静态成员变量不属于对象，静态变量内存在全局区，可以把静态变量理解为被限制在类中使用的全局变量，属于公共资源.<br>3）普通成员变量在对象构造时定义和初始化，而静态成员变量在类的外部单独定义和初始化，对象大小（类的类型的大小）不包括静态成员变量<br>5）使用方法<br>    类名::静态成员变量;//推荐<br>    对象.静态成员变量;//和上面等价 </p><h2 id="2-静态成员函数"><a href="#2-静态成员函数" class="headerlink" title="2 静态成员函数"></a>2 静态成员函数</h2><p>1）语法<br>    class 类名{<br>        static 返回类型 函数名(参数表){…}<br>    };<br>2）静态成员函数中没有this指针，也没有const属性，可以把静态成员函数理解为被限制在类作用域使用的全局函数.<br>3）使用方法<br>    类名::静态成员函数(实参表);//推荐<br>    对象.静态成员函数(实参表);//和上面等价<br>注：在静态成员函数中只能访问静态成员，不能访问非静态成员；在非静态成员函数既可以访问静态成员，也可以访问非静态成员.</p><h2 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3 单例模式"></a>3 单例模式</h2><p>1）概念<br>    一个类只允许存在唯一的对象，并提供它的方法.<br>2）实现思路<br>–》禁止在类的外部创建对象：私有化构造函数即可<br>–》类的内部维护唯一的对象：静态成员变量<br>–》提供单例对象的访问方法：静态成员函数<br>3）具体创建方式<br>–》饿汉式：单例对象无论用或不用，程序启动即创建<br>–》懒汉式：单例对象用时再创建，不用即销毁<br>（多敲多背单例模式代码）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Singleton&#123;&#x2F;&#x2F;单例模式--饿汉式</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;3)通过静态成员函数获取单例对象</span><br><span class="line">    static Singleton&amp; getInstance(void)&#123;</span><br><span class="line">        return s_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    void print(void)&#123;</span><br><span class="line">        cout &lt;&lt; m_data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;&#x2F;1)私有化构造函数(包括拷贝构造)</span><br><span class="line">    Singleton(int data&#x3D;0):m_data(data)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;单例对象被创建了&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Singleton(const Singleton&amp;);</span><br><span class="line">    &#x2F;&#x2F;2)使用静态成员变量表示唯一的对象</span><br><span class="line">    static Singleton s_instance;</span><br><span class="line">private:</span><br><span class="line">    int m_data;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::s_instance(123);</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;main函数开始执行&quot; &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F;Singleton s(100);&#x2F;&#x2F;error</span><br><span class="line">    &#x2F;&#x2F;Singleton* ps&#x3D;new Singleton(100);&#x2F;&#x2F;error</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    Singleton&amp; s1&#x3D;Singleton::getInstance();</span><br><span class="line">    Singleton&amp; s2&#x3D;Singleton::getInstance();</span><br><span class="line">    Singleton&amp; s3&#x3D;Singleton::getInstance();</span><br><span class="line"></span><br><span class="line">    s1.print();&#x2F;&#x2F;123</span><br><span class="line">    s2.print();&#x2F;&#x2F;123</span><br><span class="line">    s3.print();&#x2F;&#x2F;123</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;&amp;s1:&quot; &lt;&lt; &amp;s1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;s2:&quot; &lt;&lt; &amp;s2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;s3:&quot; &lt;&lt; &amp;s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Singleton s4 &#x3D; s1;&#x2F;&#x2F;应该error</span><br><span class="line">    &#x2F;&#x2F;cout &lt;&lt; &quot;&amp;s4:&quot; &lt;&lt; &amp;s4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Singleton&#123;&#x2F;&#x2F;单例模式--懒汉式</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;3)通过静态成员函数获取单例对象</span><br><span class="line">    static Singleton&amp; getInstance(void)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        if(s_instance &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">            s_instance &#x3D; new Singleton(123);</span><br><span class="line">        &#125;</span><br><span class="line">        ++s_count;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        return *s_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;单例对象不用即销毁,销毁时机?</span><br><span class="line">    &#x2F;&#x2F;最后一个使用者不在使用才能真的销毁!</span><br><span class="line">    void release(void)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        if(--s_count &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            delete s_instance;</span><br><span class="line">            s_instance &#x3D; NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    void print(void)&#123;</span><br><span class="line">        cout &lt;&lt; m_data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;&#x2F;1)私有化构造函数(包括拷贝构造)</span><br><span class="line">    Singleton(int data&#x3D;0):m_data(data)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;单例对象被创建了&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Singleton(const Singleton&amp;);</span><br><span class="line">    ~Singleton(void)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;单例对象被销毁了&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;2)使用静态成员变量维护唯一的对象</span><br><span class="line">    static Singleton* s_instance;</span><br><span class="line">    &#x2F;&#x2F;计数:记录单例对象使用者个数</span><br><span class="line">    static int s_count;</span><br><span class="line">    &#x2F;&#x2F;互斥所</span><br><span class="line">    static pthread_mutex_t mutex;</span><br><span class="line">private:</span><br><span class="line">    int m_data;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::s_instance&#x3D;NULL;</span><br><span class="line">int Singleton::s_count &#x3D; 0;</span><br><span class="line">pthread_mutex_t Singleton::mutex </span><br><span class="line">    &#x3D; PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;main函数开始执行&quot; &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F;Singleton s(100);&#x2F;&#x2F;error</span><br><span class="line">    &#x2F;&#x2F;Singleton* ps&#x3D;new Singleton(100);&#x2F;&#x2F;error</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    Singleton&amp; s1&#x3D;Singleton::getInstance();</span><br><span class="line">    Singleton&amp; s2&#x3D;Singleton::getInstance();</span><br><span class="line">    Singleton&amp; s3&#x3D;Singleton::getInstance();</span><br><span class="line"></span><br><span class="line">    s1.print();&#x2F;&#x2F;123</span><br><span class="line">    s1.release();&#x2F;&#x2F;--s_count:2</span><br><span class="line"></span><br><span class="line">    s2.print();&#x2F;&#x2F;123</span><br><span class="line">    s3.print();&#x2F;&#x2F;123</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;&amp;s1:&quot; &lt;&lt; &amp;s1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;s2:&quot; &lt;&lt; &amp;s2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;s3:&quot; &lt;&lt; &amp;s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s2.release();&#x2F;&#x2F;--s_count:1</span><br><span class="line">    s3.release();&#x2F;&#x2F;--s_count:0,delete</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>十九 成员指针//了解<br>1 成员变量指针<br>1）定义<br>    类型 类名::<em>成员指针变量名 = &amp;类名::成员变量;<br>2）使用<br>    对象.*成员指针变量名;<br>    对象指针-&gt;*成员指针变量名;<br>    注：“.*”和“-&gt;*”是一个符号，不能写分家了<br>int A::*pdata = &amp;A::m_data;//定义,pdata指向A::m_data,记录m_data在A里面的相对位置<br>A a(100);//a.*pdata=100;<br>A</em> pa = new A(100);//pa-&gt;*pdata=200;</p><p>2 成员函数指针//了解<br>1）定义<br>    返回类型 (类名::<em>成员函数指针)(参数表)<br>        = &amp;类名::成员函数名;<br>2）使用<br>    (对象.*成员函数指针)(实参表);<br>    (对象指针-&gt;*成员指针变量名)(实参表);<br>void (A::*pfunc)(void) = &amp;A::print;<br>A a(100);<br>(a.*pfunc)();<br>A</em> pa = new A(100);<br>(pa-&gt;*pfunc)();</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;十八-静态成员-static&quot;&gt;&lt;a href=&quot;#十八-静态成员-static&quot; class=&quot;headerlink&quot; title=&quot;十八 静态成员(static)&quot;&gt;&lt;/a&gt;十八 静态成员(static)&lt;/h1&gt;&lt;h2 id=&quot;1-静态成员变量&quot;&gt;&lt;a href=&quot;#1-静态成员变量&quot; class=&quot;headerlink&quot; title=&quot;1 静态成员变量&quot;&gt;&lt;/a&gt;1 静态成员变量&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++_5</title>
    <link href="https://guoqiang-gump.github.io/2021/08/21/C-5/"/>
    <id>https://guoqiang-gump.github.io/2021/08/21/C-5/</id>
    <published>2021-08-21T03:56:19.000Z</published>
    <updated>2021-09-24T05:37:30.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十五-this指针和常成员函数"><a href="#十五-this指针和常成员函数" class="headerlink" title="十五 this指针和常成员函数"></a>十五 this指针和常成员函数</h1><h2 id="1-this指针"><a href="#1-this指针" class="headerlink" title="1 this指针"></a>1 this指针</h2> <a id="more"></a> <p>1）类中的成员函数(包括构造函数、析构函数)都有一个隐藏的当前类 类型的指针参数，名为this。在成员函数中访问类中其它成员，其本质都是通过this来实现的。<br>2）对于普通的成员函数,this指针就是指向该成员函数的调用对象；对于构造函数,this指针就指向正在创建的对象。<br>3）大多数情况，可以忽略this直接访问类中的成员，但是在以下几个特殊场景必须要显式使用this指针:<br>–》区分作用域，(区分哪个是成员变量)<br>–》从成员函数返回调用对象自身(返回自引用)//重点掌握<br>–》从类的内部销毁对象自身(对象自销毁) //了解<br>–》作为成员函数实参，实现对象之间交互 //了解</p><h2 id="2-常成员函数-常函数"><a href="#2-常成员函数-常函数" class="headerlink" title="2 常成员函数(常函数)"></a>2 常成员函数(常函数)</h2><p>1）在一个成员函数参数表后面加上const，这个成员函数就是常成员函数。<br>    返回类型 函数名(参数表) const {函数体}<br>2）常成员函数中的this指针是一个常量指针，不能在常成员函数中修改成员变量的值。<br>eg：<br>void print(void) const {} &lt;=&gt; void print(const A* this)<br>3）被mutable关键字修饰的成员变量，可以在常成员函数中被修改。<br>4）非常对象既可以调用常函数也可以调用非常函数；而常对象只能调用常函数，不能调用非常函数.<br>    注：常对象也包括常指针和常引用<br>5）同一个类中，函数名形参表相同的成员函数，其常版本和非常版本可以构成有效的重载关系，常对象匹配常版本，非常对象匹配非常版本.</p><h1 id="十六-析构函数-Destructor"><a href="#十六-析构函数-Destructor" class="headerlink" title="十六 析构函数(Destructor)"></a>十六 析构函数(Destructor)</h1><h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h2><p>​    class 类名{<br>​        <del>类名(void){<br>​            //主要负责清理对象生命周期中的动态资源<br>​        }<br>​    };<br>​    1）函数名必须是”</del>类名”<br>​    2）没有返回类型，也没有参数<br>​    3）不能被重载，一个类只能有一个析构函数、</p><h2 id="2-当对象被销毁时，相应类的析构函数将被自动执行"><a href="#2-当对象被销毁时，相应类的析构函数将被自动执行" class="headerlink" title="2 当对象被销毁时，相应类的析构函数将被自动执行"></a>2 当对象被销毁时，相应类的析构函数将被自动执行</h2><p>1）栈对象当其离开所在作用域时，其析构函数被作用域终止“右化括号”调用<br>2）堆对象的析构函数被delete操作符调用</p><h2 id="3-如果一个类自己没有定义析构函数，那么编译器会为该类提供一个缺省的析构函数："><a href="#3-如果一个类自己没有定义析构函数，那么编译器会为该类提供一个缺省的析构函数：" class="headerlink" title="3 如果一个类自己没有定义析构函数，那么编译器会为该类提供一个缺省的析构函数："></a>3 如果一个类自己没有定义析构函数，那么编译器会为该类提供一个缺省的析构函数：</h2><p>1）对基本类型的成员变量，什么也不做<br>2）对类 类型的成员(成员子对象)，将会自动调用相应类的析构函数.</p><h2 id="4-对象创建和销毁的过程"><a href="#4-对象创建和销毁的过程" class="headerlink" title="4 对象创建和销毁的过程"></a>4 对象创建和销毁的过程</h2><p>1）创建<br>–》分配内存<br>–》构造成员子对象(按声明顺序)<br>–》执行构造函数代码<br>2）销毁<br>–》执行析构函数代码<br>–》析构成员子对象(按声明逆序)<br>–》释放内存</p><h1 id="十七-拷贝构造和拷贝赋值"><a href="#十七-拷贝构造和拷贝赋值" class="headerlink" title="十七 拷贝构造和拷贝赋值"></a>十七 拷贝构造和拷贝赋值</h1><h1 id="1-浅拷贝和深拷贝-参考copy-png"><a href="#1-浅拷贝和深拷贝-参考copy-png" class="headerlink" title="1 浅拷贝和深拷贝 //参考copy.png"></a>1 浅拷贝和深拷贝 //参考copy.png</h1><p><img src="C-5.assets/1629518322069.png" alt="1629518322069"></p><p>1）如果一个类中包含了指针形式的成员变量，缺省的拷贝构造函数只是赋值了指针变量自身，而没有复制指针所指向的内容，这种拷贝方式被称为浅拷贝.（只拷贝指针变量本身）<br>2）浅拷贝将会导致不同对象之间的数据共享，如果数据在堆区，析构时还可能会出现”double free”的异常，为此就必须自己定义一个支持复制指针所指向内容的拷贝构造函数（拷贝指针所指向的数据），即深拷贝（先new，再*=*）。</p><h2 id="2-拷贝赋值-参考copy2-png"><a href="#2-拷贝赋值-参考copy2-png" class="headerlink" title="2 拷贝赋值 //参考copy2.png"></a>2 拷贝赋值 //参考copy2.png</h2><p><img src="C-5.assets/1629518362287.png" alt="1629518362287"></p><p>1）当两个对象进行赋值运算时，比如”i3=i2”,编译器会将其处理为“i3.operator=(i2)”成员函数调用形式，其中“operator=”被称为拷贝赋值函数，由该函数完成两个对象的赋值运算，该函数的返回结果就是赋值表达式结果.<br>2）如果自己没有定义拷贝赋值函数，那么编译器会提供一个缺省的拷贝赋值函数，但是缺省的拷贝赋值和缺省拷贝构造类似，也是浅拷贝，只是赋值指针变量本身，而没有复制指针所指向的内容，有数据共享、double free、内存泄漏的问题。<br>3）为了避免浅拷贝的问题，必须自己定义深拷贝赋值函数:<br>    类名&amp; operator=(const 类名&amp; that){<br>        if(&amp;that != this){//防止自赋值<br>            释放旧内存;<br>            分配新内存;<br>            拷贝新数据;<br>        }<br>        return *this;//返回自引用<br>    }</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;十五-this指针和常成员函数&quot;&gt;&lt;a href=&quot;#十五-this指针和常成员函数&quot; class=&quot;headerlink&quot; title=&quot;十五 this指针和常成员函数&quot;&gt;&lt;/a&gt;十五 this指针和常成员函数&lt;/h1&gt;&lt;h2 id=&quot;1-this指针&quot;&gt;&lt;a href=&quot;#1-this指针&quot; class=&quot;headerlink&quot; title=&quot;1 this指针&quot;&gt;&lt;/a&gt;1 this指针&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++_4</title>
    <link href="https://guoqiang-gump.github.io/2021/08/21/C-4/"/>
    <id>https://guoqiang-gump.github.io/2021/08/21/C-4/</id>
    <published>2021-08-21T03:44:01.000Z</published>
    <updated>2021-09-24T05:36:50.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十二-类和对象-了解"><a href="#十二-类和对象-了解" class="headerlink" title="十二 类和对象//了解"></a>十二 类和对象//了解</h1><p>1 什么是对象<br>    万物皆对象，任何一种事物都可以看做是对象.</p> <a id="more"></a> <p>2 如何描述对象<br>    通过对象的属性和行为来描述对象.</p><p>3 面向对象程序设计<br>    对自然世界中对象观察和描述引入到编程中一种理念和方法，这种方法称为”数据抽象”，即在描述对象时把细节东西剥离出去，只考虑一般性的、有规律性的、统一性的东西.</p><p>4 什么是类<br>    类就是将多个对象共性提取出来定义的一种新的数据类型，是对 对象 属性和行为的抽象描述.</p><p>现实世界                  类                     虚拟世界<br>具体对象–抽象–&gt;属性/行为–实例化–&gt;具体对象</p><h1 id="十三-类的定义和实例化"><a href="#十三-类的定义和实例化" class="headerlink" title="十三 类的定义和实例化"></a>十三 类的定义和实例化</h1><h2 id="1-类定义的一般语法形式"><a href="#1-类定义的一般语法形式" class="headerlink" title="1 类定义的一般语法形式"></a>1 类定义的一般语法形式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct&#x2F;class 类名:继承方式 基类,...&#123;</span><br><span class="line">访问控制限定符:</span><br><span class="line">类名(形参表):初始化列表&#123;&#125;&#x2F;&#x2F;构造函数</span><br><span class="line">~类名(void)&#123;&#125;&#x2F;&#x2F;析构函数</span><br><span class="line">返回类型 函数名(形参表)&#123;&#125;&#x2F;&#x2F;成员函数</span><br><span class="line">数据类型 变量名;&#x2F;&#x2F;成员变量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-访问控制限定符"><a href="#2-访问控制限定符" class="headerlink" title="2 访问控制限定符"></a>2 访问控制限定符</h2><p>1）public：公有成员，任何位置都可以访问。<br>2）private：私有成员，只有类自己的成员函数才能访问<br>3）protected：保护成员(后面讲)</p><h2 id="C-中struct和class区别："><a href="#C-中struct和class区别：" class="headerlink" title="C++中struct和class区别："></a>C++中struct和class区别：</h2><p>​    struct定义类默认的访问控制属性是public；而class定义类默认的访问控制属性是private。<br>​    struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p><p>封装：使用函数指针把属性与方法封装到结构体中。类中的私有成员不能在外部直接访问，但是可以提供公有成员来间接访问，在函数中可以合理对非法数据加以限定控制业务逻辑的合理性，这种编程思想叫“封装。”</p><h2 id="3-构造函数-constructor"><a href="#3-构造函数-constructor" class="headerlink" title="3 构造函数(constructor)"></a>3 构造函数(constructor)</h2><p>1）语法<br>    class 类名{<br>        类名(参数表){<br>            主要负责初始化对象，即初始化成员变量。<br>        }<br>    };<br>2）函数名和类名一致，没有返回类型。<br>3）构造函数在创建对象时自动被调用，不能像普通的成员函数一样显式的调用，在创建对象时可以向构造函数传递参数.<br>4）在每个对象的生命周期，构造函数一定会被调用，且仅会被调用一次。</p><h2 id="4-对象的创建和销毁"><a href="#4-对象的创建和销毁" class="headerlink" title="4 对象的创建和销毁"></a>4 对象的创建和销毁</h2><p>1）在栈区创建单个对象 //重点掌握<br>eg:    string s;<br>    类名 对象(构造实参表);//直接初始化<br>    string s(“hello”);<br>    类名 对象=类名(构造实参表);//拷贝初始化(实际等价)<br>    string s = string(“hello”); &lt;=&gt; string s = “hello”;(只有第一个参数情况下)</p><p>2）在栈区创建多个对象(对象数组)<br>    类名 对象数组[元素个数] = {<br>        类名(构造实参表),类名(构造实参表),…};</p><p>3）在堆区创建/销毁单个对象 //重点掌握<br>创建：<br>    类名* 对象指针 = new 类名(构造实参表);<br>    注：new操作符会先分配内存再自动调用构造函数，完成对象的创建和初始化；而如果是malloc函数只能分配内存，不会调用构造函数，不具备创建对象能力.</p><p>销毁：<br>    delete 对象指针;<br>    注：delete操作符会自动调用析构函数销毁对象再释放内存；而如果是free函数只能释放内存，不会调用析构函数，不具备销毁对象能力.</p><p>4）在堆区创建/销毁多个对象<br>创建：<br>    类名* 对象指针 = new 类名[元素个数] {<br>        类名(构造实参表),类名(构造实参表),…};<br>eg：<br>    Student* parr = new Student[3] {<br>        Student(“xiaoqiao”, 22, 10016);<br>        Student(“daqiao”, 25, 10017); };<br>销毁：<br>    delete[] 对象指针; </p><p>5 多文件编程：类的声明和定义可以分别放在不同的文件中<br>1）类的声明一般放在头文件中(xx.h)<br>2）类的实现一般放在源文件中(xx.cpp) </p><h1 id="十四-构造函数和初始化列表"><a href="#十四-构造函数和初始化列表" class="headerlink" title="十四 构造函数和初始化列表"></a>十四 构造函数和初始化列表</h1><h2 id="1-构造函数可以重载，也可以带有缺省参数。"><a href="#1-构造函数可以重载，也可以带有缺省参数。" class="headerlink" title="1 构造函数可以重载，也可以带有缺省参数。"></a>1 构造函数可以重载，也可以带有缺省参数。</h2><h2 id="2-缺省构造函数-无参构造函数"><a href="#2-缺省构造函数-无参构造函数" class="headerlink" title="2 缺省构造函数(无参构造函数)"></a>2 缺省构造函数(无参构造函数)</h2><p>1）如果类中没有定义任何构造函数,编译器会为该类提供一个缺省(无参)构造函数：<br>–》对于基本类型成员变量不做初始化<br>–》对于类 类型的成员变量(成员子对象)，将会自动调用相应类的无参构造函数来初始化</p><p>2）如果自己定义了构造函数，无论是否有参数，那么编译器都不会再提供缺省的无参构造函数了.</p><h2 id="3-类型转换构造函数-单参构造函数"><a href="#3-类型转换构造函数-单参构造函数" class="headerlink" title="3 类型转换构造函数(单参构造函数)"></a>3 类型转换构造函数(单参构造函数)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">​&#x2F;&#x2F;可以将源类型变量转换为当前类类型对象.</span><br><span class="line">​类名(源类型)&#123;...&#125;&#x2F;&#x2F;(单参构造函数)</span><br><span class="line">​&#125;;</span><br><span class="line"></span><br><span class="line">​class 类名&#123;</span><br><span class="line">​&#x2F;&#x2F;加“explicit”关键字修饰，可以强制要求这种类型转换必须显式的完成.</span><br><span class="line">​explicit 类名(源类型)&#123;...&#125;</span><br><span class="line">​&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-拷贝构造函数-复制构造函数"><a href="#4-拷贝构造函数-复制构造函数" class="headerlink" title="4 拷贝构造函数(复制构造函数)"></a>4 拷贝构造函数(复制构造函数)</h2><p>1）用一个已存在的对象作为同类对象的构造实参，创建新的副本对象时，会调用该类拷贝构造函数。<br>    class 类名{<br>        类名(const 类名&amp;){//拷贝构造,一定要用引用&amp;，而且要用const（可以传左值和右值）<br>            …<br>        }<br>    };</p><p>​    class A{…}；<br>​    A a1(…);<br>​    //匹配A的拷贝构造函数<br>​    A a2(a1);<br>​    A a2 = A(a1);<br>​    A a2 = a1;<br>​<br>2）如果一个类没有自己定义拷贝构造函数，那么编译器会为该类提供一个缺省的拷贝构造函数：<br>​    –》对于基本类型的成员变量，按字节复制<br>​    –》对于类类型的成员变量(成员子对象)，将自动调用相应类的拷贝构造函数来初始化<br>​    注：一般不需要自己定义拷贝构造函数函数，因为编译器缺省提供的已经很好用了.</p><pre><code>class A1&#123;&#125;;//缺省无参，缺省拷贝class A2&#123;//缺省拷贝    A(void)&#123;&#125;&#125;;class A3&#123;//缺省拷贝    A(int)&#123;&#125;&#125;；class A4&#123;//没有缺省构造，因为已经有拷贝构造了    A(const A&amp;)&#123;&#125;&#125;;</code></pre><p>3）拷贝构造函数调用时机<br>–》用一个已存在对象作为同类对象的构造实参<br>–》以对象形式向函数传递参数（传参时可使用引用&amp;避免拷贝）<br>–》从函数中返回对象(返回的对象先被拷贝到临时对象中，临时对象再被拷贝到目标对象中，所以发生两次拷贝，但是有可能被编译器优化掉(目标对象直接引用临时对象)而导致只发生一次拷贝)</p><h2 id="5-初始化列表"><a href="#5-初始化列表" class="headerlink" title="5 初始化列表"></a>5 初始化列表</h2><p>1）语法<br>    class 类名{<br>        //定义成员变量同时初始化，可以显式初始化成员子对象<br>        类名(参数表):成员变量1(初值),成员变量2(初值){<br>            …<br>        }<br>    };<br>eg：<br>    class Student{<br>    public:<br>        //使用构造函数体赋初值：先定义成员变量，再赋初值<br>        Student(const string&amp; name,int age,int no){<br>            m_name = name;<br>            m_age = age;<br>            m_no = no;<br>        }<br>        //使用初始化列表赋初值：定义成员变量同时初始化<br>        Student(const string&amp; name,int age,int no)<br>            :m_name(name),m_age(age),m_no(no){<br>        }<br>    private:<br>        string m_name;<br>        int m_age;<br>        int m_no;<br>    };<br>2）大多数情况使用初始化列表和在构造函数体赋初值没有太大区别，两种形式可以任选；但是有以下特殊场景必须要使用初始化列表:<br>–》如果有类 类型的成员变量(成员子对象)，并希望以有参方式对其进行初始化，则必须使用初始化列表显式指明成员子对象需要的构造实参。<br>–》如果类中包含”const”或”引用”成员变量，则必须在初始化列表显式的初始化。<br>注：成员变量的初始化顺序由声明顺序决定，而与初始化列表的顺序无关，所以不要使用一个成员变量去初始化另一个成员变量.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;十二-类和对象-了解&quot;&gt;&lt;a href=&quot;#十二-类和对象-了解&quot; class=&quot;headerlink&quot; title=&quot;十二 类和对象//了解&quot;&gt;&lt;/a&gt;十二 类和对象//了解&lt;/h1&gt;&lt;p&gt;1 什么是对象&lt;br&gt;    万物皆对象，任何一种事物都可以看做是对象.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++_3</title>
    <link href="https://guoqiang-gump.github.io/2021/08/21/C-3/"/>
    <id>https://guoqiang-gump.github.io/2021/08/21/C-3/</id>
    <published>2021-08-21T03:37:55.000Z</published>
    <updated>2021-09-24T05:35:17.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十一-类型转换"><a href="#十一-类型转换" class="headerlink" title="十一 类型转换"></a>十一 类型转换</h1> <a id="more"></a> <h2 id="1-隐式类型转换"><a href="#1-隐式类型转换" class="headerlink" title="1 隐式类型转换"></a>1 隐式类型转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">char c &#x3D; &#39;A&#39;;</span><br><span class="line">int i &#x3D; c;&#x2F;&#x2F;隐式</span><br><span class="line"></span><br><span class="line">void func(int i)&#123;&#125;</span><br><span class="line">func(c);&#x2F;&#x2F;隐式</span><br><span class="line"></span><br><span class="line">int func(void)&#123;</span><br><span class="line">char c&#x3D;&#39;A&#39;;</span><br><span class="line">return c;&#x2F;&#x2F;隐式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-显示类型转换"><a href="#2-显示类型转换" class="headerlink" title="2 显示类型转换"></a>2 显示类型转换</h2><h3 id="2-1-C-兼容C中强制类型转换"><a href="#2-1-C-兼容C中强制类型转换" class="headerlink" title="2.1 C++兼容C中强制类型转换"></a>2.1 C++兼容C中强制类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char c &#x3D; &#39;A&#39;;</span><br><span class="line"> int i &#x3D; (int)c;&#x2F;&#x2F;C风格</span><br><span class="line"> int i &#x3D; int(c);&#x2F;&#x2F;C++风格</span><br></pre></td></tr></table></figure><h3 id="2-2-C-扩展了四种操作符形式显式转换"><a href="#2-2-C-扩展了四种操作符形式显式转换" class="headerlink" title="2.2 C++扩展了四种操作符形式显式转换"></a>2.2 C++扩展了四种操作符形式显式转换</h3><h4 id="1）静态类型转换-static-cast"><a href="#1）静态类型转换-static-cast" class="headerlink" title="1）静态类型转换:static_cast"></a>1）静态类型转换:static_cast</h4><p>语法：<br>    目标变量 = static_cast&lt;目标类型&gt;(源类型变量);<br>适用场景：<br>    主要用于将void* 转化为其它类型的指针，也可以用于向下造型(downcast)的显式转换</p><h4 id="2）动态类型转换-dynamic-cast"><a href="#2）动态类型转换-dynamic-cast" class="headerlink" title="2）动态类型转换:dynamic_cast"></a>2）动态类型转换:dynamic_cast</h4><p>语法：<br>    目标变量 = dynamic_cast&lt;目标类型&gt;(源类型变量);<br>适用场景：<br>    主要用于具有多态特性父子类指针或引用之间的显式类型转换.<br>    动态类型转换过程中，会检查原类型变量和期望转换的类型是否一致，如果一致则转换成功，否则失败</p><h4 id="3）去常类型转换-const-cast"><a href="#3）去常类型转换-const-cast" class="headerlink" title="3）去常类型转换:const_cast"></a>3）去常类型转换:const_cast</h4><p>语法：<br>    目标变量 = const_cast&lt;目标类型&gt;(源类型变量);<br>适用场景：<br>    主要用于去掉指针或引用const属性.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int i &#x3D; 100；</span><br><span class="line">int* pi &#x3D; const_cast&lt; int* &gt;(&amp;i);&#x2F;&#x2F;ok,但是p&#x3D;&amp;i,*pi !&#x3D; i, 这是编译器优化导致的错误</span><br><span class="line"></span><br><span class="line">volatile const int i &#x3D; 100；</span><br><span class="line">int* pi &#x3D; const_cast&lt;int*&gt;(&amp;i);&#x2F;&#x2F;ok,p &#x3D;&#x3D; &amp;i,且*pi &#x3D;&#x3D; i, </span><br></pre></td></tr></table></figure><p>volatile是标准C语言的关键字，被volatile修饰的变量表示易变的，告诉编译器每次使用该变量时，都要小心从内存中读取，而不是取寄存器的副本，防止编译器优化引起的错误变化</p><h4 id="4）重解释类型转换-reinterpret-cast"><a href="#4）重解释类型转换-reinterpret-cast" class="headerlink" title="4）重解释类型转换:reinterpret_cast"></a>4）重解释类型转换:reinterpret_cast</h4><p>语法：<br>    目标变量=reinterpret_cast&lt;目标类型&gt;(源类型变量);<br>适用场景：<br>    在指针和整型数进行显式转换.<br>    任意类型指针或引用之间显式转换.</p><pre><code>eg:已知物理内存地址0x12345678，向该地址存放一个整型数100？int* paddr = reinterpret_cast&lt;int*&gt;(0x12345678);*paddr = 100;</code></pre><h1 id="二十三-运行时的类型信息-了解"><a href="#二十三-运行时的类型信息-了解" class="headerlink" title="二十三 运行时的类型信息//了解"></a>二十三 运行时的类型信息//了解</h1><p>1 typeid操作符<br>  #include <typeinfo><br>  typeid(类型/对象);//返回typeinfo对象，用于描述类型信息<br>  typeinfo支持”==,!=”操作符重载，可以直接进行类型之间比较，如果类型直接具有多态的继承关系，typeid还可以利用多态的语法确定实际的目标对象类型</p><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;十一-类型转换&quot;&gt;&lt;a href=&quot;#十一-类型转换&quot; class=&quot;headerlink&quot; title=&quot;十一 类型转换&quot;&gt;&lt;/a&gt;十一 类型转换&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++_2</title>
    <link href="https://guoqiang-gump.github.io/2021/08/21/C-2/"/>
    <id>https://guoqiang-gump.github.io/2021/08/21/C-2/</id>
    <published>2021-08-21T03:32:40.000Z</published>
    <updated>2021-09-24T05:34:37.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六-C-的布尔类型-bool"><a href="#六-C-的布尔类型-bool" class="headerlink" title="六 C++的布尔类型(bool)"></a>六 C++的布尔类型(bool)</h1><p>1 bool类型是C++中的基本数据类型，专门表示逻辑值，逻辑真用true表示，逻辑假false表示<br>2 bool类型在内存占一个字节：1表示true，0表示false<br>3 bool类型变量可以接收任意类型表达式结果，其值非0则为true，为0则为假。</p> <a id="more"></a> <h1 id="八-C-的函数"><a href="#八-C-的函数" class="headerlink" title="八 C++的函数"></a>八 C++的函数</h1><h2 id="1-函数重载-overload"><a href="#1-函数重载-overload" class="headerlink" title="1 函数重载(overload)"></a>1 函数重载(overload)</h2><p>1）定义<br>    在相同作用域，可以定义同名的函数，但是参数必须有所区分，这样函数构成重载关系.<br>    注：函数重载与返回类型无关。</p><p>2）函数重载匹配<br>    调用重载关系的函数时，编译器将根据实参和形参的匹配程度，自动选择最优的重载版本，当前g++编译器匹配一般规则：<br>    完全匹配&gt;=常量转换&gt;升级转换&gt;降级转换&gt;省略号</p><p>3）函数重载原理<br>    C++的编译器在编译函数时，会进行换名，将参数表的类型信息整合到新的函数名中，因为重载关系的函数参数表有所区分，换出的新的函数名也一定有所区分，解决了函数重载和名字冲突的矛盾。</p><h2 id="C-中extern-“C”作用"><a href="#C-中extern-“C”作用" class="headerlink" title="C++中extern “C”作用"></a>C++中extern “C”作用</h2><p>​    被 extern 限定的函数或变量是 extern 类型的<br>​    被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的<br>​    在C++函数声明时加extern “C”，要求C++编译器不对该函数进行换名，当作C语言代码处理，便于C程序直接调用该函数，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。<br>​    注：extern “C”的函数无法重载。<br>​    </p><h2 id="2-函数的缺省参数-默认实参"><a href="#2-函数的缺省参数-默认实参" class="headerlink" title="2 函数的缺省参数(默认实参)"></a>2 函数的缺省参数(默认实参)</h2><p>1）可以为函数参数指定缺省值，调用该函数时，如果不给实参，就取缺省值作为默认实参。<br>    void func(int i,int j=0/<em>缺省参数</em>/){}<br>2）靠右原则：如果函数的某个参数带有缺省值，那么该参数右侧的所有参数都必须带有缺省值。<br>3）如果函数的声明和定义分开写，缺省参数应该写在函数的声明部分，而定义部分不写。</p><h2 id="3-函数的哑元参数"><a href="#3-函数的哑元参数" class="headerlink" title="3 函数的哑元参数"></a>3 函数的哑元参数</h2><p>1）定义(不是声明)函数时，只有类型而没有变量名的形参被称为哑元<br>    void func(int){…}<br>2）需要使用哑元场景<br>–》在操作符重载函数中，区分前后++、– //后面讲<br>–》兼容旧的代码<br>    算法库：void math_func(int a,int b){…}<br>    升级算法库:void math_func(int a,int/<em>哑元</em>/){…}</p><h2 id="4-内联函数-inline"><a href="#4-内联函数-inline" class="headerlink" title="4 内联函数(inline)"></a>4 内联函数(inline)</h2><p>1）使用inilne关键字修饰的函数，即为内联函数，编译器将会尝试进行内联优化，可以避免函数调用开销，提高代码执行效率.<br>    inline void func(void){…}<br>2）使用说明<br>–》多次调用小而简单的函数适合内联优化<br>–》调用次数极少或大而复杂的函数不适合内联<br>–》递归函数不能内联优化<br>–》虚函数不能内联优化//后面讲</p><p>注：内联只是一种建议而不是强制的语法要求，一个函数能否内联优化主要取决于编译器，有些函数不加inline修饰也会默认处理为内联优化，有些函数即便加了inline修饰也会被编译器忽略。</p><h1 id="九-C-动态内存管理"><a href="#九-C-动态内存管理" class="headerlink" title="九 C++动态内存管理"></a>九 C++动态内存管理</h1><p>1 C语言动态内存管理<br>1）分配：malloc()<br>2）释放：free()</p><p>2 C++动态内存管理</p><p>1）分配：new/new[]<br>2）释放：delete/delete[]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int* p1 &#x3D; new int;&#x2F;&#x2F;定义</span><br><span class="line">delete p1;</span><br><span class="line">int* p2 &#x3D; new int(100);&#x2F;&#x2F;定义且初始化</span><br><span class="line">delete p2;</span><br><span class="line">int* p3 &#x3D; new int[10];&#x2F;&#x2F;数组，有十个int</span><br><span class="line">delete[] p3;</span><br></pre></td></tr></table></figure><p>delete一个野指针（只声明未定义的指针），危险；delete空指针（NULL），安全，无意义；不能多次delete同一个指针</p><h1 id="十-C-引用-Reference"><a href="#十-C-引用-Reference" class="headerlink" title="十 C++引用(Reference)"></a>十 C++引用(Reference)</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>1）引用即别名，引用就是某个变量别名，对引用操作和对变量本身完全相同.<br>2）语法<br>    类型 &amp; 引用名 = 变量名;<br>    注：引用必须在定义同时初始化（引用没有被分配内存），而且在初始化以后所绑定的目标变量不能再做修改.<br>    注：引用类型和绑定目标变量类型要一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">int &amp; b &#x3D; a;&#x2F;&#x2F;b就是a的别名</span><br><span class="line">b++;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;&#x2F;&#x2F;11</span><br><span class="line">a++;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;&#x2F;&#x2F;12</span><br><span class="line"></span><br><span class="line">int c &#x3D; 123;</span><br><span class="line">b &#x3D; c;&#x2F;&#x2F;仅是赋值</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;&#x2F;&#x2F;123</span><br></pre></td></tr></table></figure><h2 id="2-常引用"><a href="#2-常引用" class="headerlink" title="2 常引用"></a>2 常引用</h2><p>1）定义引用时可以加const修饰，即为常引用，不能通过常引用修改目标变量.<br>    const 类型 &amp; 引用名 = 变量名;<br>    类型 const &amp; 引用名 = 变量名;//和上面等价</p><pre><code>int a = 10;const int&amp; b = a;//b就是a常引用cout &lt;&lt; b &lt;&lt; endl;//10b++;//error</code></pre><p>2）普通引用也可以称为左值引用，只能引用左值；而常引用也可以称为万能引用，既可以引用左值也可以引用右值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const int&amp; r1 &#x3D; 100;&#x2F;&#x2F;ok</span><br><span class="line">int&amp; r2 &#x3D; 200;&#x2F;&#x2F;error，200为右值</span><br><span class="line"> int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">int&amp; r3 &#x3D; a+b;&#x2F;&#x2F;error</span><br><span class="line">&#x2F;&#x2F;r4引用的是a+b表达式结果的临时变量（右值）</span><br><span class="line">const int&amp; r4 &#x3D; a+b;&#x2F;&#x2F;ok</span><br></pre></td></tr></table></figure><p>3）关于左值和右值<br>    左值(lvalue):可以放在赋值表达式左侧或者右侧，可以被修改<br>    右值(rvalue):只能放在赋值表达式右侧，不能被修改</p><p>练习：测试下面表达式结果，是左值还是右值？<br>        int a,b;<br>        a+b;//右值<br>        a+=b;//左值<br>        ++a;//左值<br>        a++;//右值</p><h2 id="3-引用型函数参数"><a href="#3-引用型函数参数" class="headerlink" title="3 引用型函数参数"></a>3 引用型函数参数</h2><p>1）可以将引用用于函数的参数，这时形参就是实参别名，可以通过形参直接修改实参的值；同时还能避免函数调用时传参的开销，提高代码执行效率。<br>int func(int&amp; a, int&amp; b);<br>2）引用型参数有可能意外修改实参的值，如果不希望修改实参，可以将形参声明为常引用，提高效率的同时还可以接收常量型的实参。<br>int func(const int&amp; a);</p><h2 id="4-引用型函数返回值"><a href="#4-引用型函数返回值" class="headerlink" title="4 引用型函数返回值"></a>4 引用型函数返回值</h2><p>1）可以将函数的返回类型声明为引用，这时函数的返回结果就是return后面数据的别名，可以避免返回值带来的开销，提高代码执行效率.<br>2）如果函数返回类型是左值引用，那么函数调用表达式结果就也将是一个左值。<br>    注：不要从函数中返回局部变量的引用，因为所引用的内存会在函数返回以后被释放，使用非常危险！可以在函数中返回成员变量、静态变量、全局变量的引用。<br>    int&amp; func(void){<br>        …<br>        return num;<br>    }<br>    func() = 100;//ok,左值引用</p><p>5 引用和指针<br>1）如果从C语言角度看待引用的本质，可以认为引用就是通过指针实现的，但是在C++开发中，推荐使用引用，而不推荐使用指针.<br>    int i = 100;<br>    int* const pi = &i;<br>    int&amp; ri = i;<br>    * pi &lt;=等价=&gt; ri<br>2）指针可以不做初始化，其目标可以在初始化以后随意改变(指针常量除外)，而引用必须做初始化，而且一旦初始化所引用的目标不能再改变.</p><p>//下面内容了解<br>3）可以定义指针的指针(二级指针)，但是不能定义引用的指针.<br>    int a = 10;<br>    int* p = &a;<br>    int** pp = &p;//二级指针</p><hr><p>​    int&amp; r = a;<br>​    int&amp;* pr = &r;//error,引用的指针<br>​    int* pr = &r;//ok,仅是普通指针<br>​<br>4）可以指针的引用(指针变量别名)，但是不能定义引用的引用。<br>​    int a = 100;<br>​    int* p = &a;<br>    int* &amp; rp = p;//ok,指针的引用</p><hr><p>​    int&amp; r = a;<br>​    int&amp; &amp; rr = r;//error,引用用的引用<br>​    int&amp; rr = r;//ok,但是仅是一个普通引用<br>​<br>5）可以指针数组，但是不能定义引用数组<br>​    int i=10,j=20,k=30;<br>​    int* parr[3] = {&amp;i,&amp;j,&amp;k};//ok,指针数组<br>​    int&amp; rarr[3] = {i,j,k};//error<br>​<br>6）可以定义数组引用（数组别名）<br>​    int i=10,j=20,k=30;<br>​    int arr[3] = {i,j,k};<br>​    int (&amp;rarr)[3] = arr;//ok,    数组引用    </p><p>7）和函数指针类似，也可以定义函数引用(函数别名)<br>    void func(int i){}<br>    int main(void){<br>        void (*pf)(int) = func;//函数指针<br>        void (&amp;rf)(int) = func;//函数引用<br>        pf(100);<br>        rf(100);<br>    }        </p><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;六-C-的布尔类型-bool&quot;&gt;&lt;a href=&quot;#六-C-的布尔类型-bool&quot; class=&quot;headerlink&quot; title=&quot;六 C++的布尔类型(bool)&quot;&gt;&lt;/a&gt;六 C++的布尔类型(bool)&lt;/h1&gt;&lt;p&gt;1 bool类型是C++中的基本数据类型，专门表示逻辑值，逻辑真用true表示，逻辑假false表示&lt;br&gt;2 bool类型在内存占一个字节：1表示true，0表示false&lt;br&gt;3 bool类型变量可以接收任意类型表达式结果，其值非0则为true，为0则为假。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
