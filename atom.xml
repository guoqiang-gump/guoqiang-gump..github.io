<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>国强-阿甘</title>
  <icon>https://www.gravatar.com/avatar/fa14b63fc1e68cede1bc60586c0cf7a7</icon>
  <subtitle>胆小认生，不易相处</subtitle>
  <link href="https://guoqiang-gump.github.io/atom.xml" rel="self"/>
  
  <link href="https://guoqiang-gump.github.io/"/>
  <updated>2021-05-05T03:53:29.341Z</updated>
  <id>https://guoqiang-gump.github.io/</id>
  
  <author>
    <name>GUMP</name>
    <email>1822006273@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UnixC-网络编程</title>
    <link href="https://guoqiang-gump.github.io/2021/05/04/UnixC-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://guoqiang-gump.github.io/2021/05/04/UnixC-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2021-05-04T15:41:02.000Z</published>
    <updated>2021-05-05T03:53:29.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十三、网络通信"><a href="#十三、网络通信" class="headerlink" title="十三、网络通信"></a>十三、网络通信</h1><h2 id="1-网络和网络协议"><a href="#1-网络和网络协议" class="headerlink" title="1.网络和网络协议"></a>1.网络和网络协议</h2><p><strong>1)什么是计算机网络？</strong></p><a id="more"></a><p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过有形或无形的通信线路连接起来，在网络操作系统、网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p><p><strong>2)什么是网络协议？</strong><br>网络协议是一种特殊的软件，是计算机网络实现其功能的最基本的机制。网路协议的本质就是规则，即各种硬件和软件必须遵循的共同守则。网络协议并不是一套单独的软件，它融合于所有涉及网络通信的软件甚至硬件之中，因此可以说协议于网络中无处不在。</p><p><strong>3)什么是协议栈？</strong><br>为了减少网络设计的复杂性，绝大多数网络采用分层设计的方法。所谓分层设计，就是按照信息流动的过程将网络的整体功能分解为一个个的功能层，不同机器上的同等功能层之间采用相同的协议，同一机器上相邻功能层之间通过接口进行信息传递。各层的协议和接口统称为协议栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ISO(国际标准化组织)&#x2F;OSI(Open System Interconnection, 开放系统互联)网络协议模型：</span><br><span class="line">应用层：业务逻辑               \</span><br><span class="line">表示层：数据的表现形式           | -&gt; 应用层</span><br><span class="line">会话层：建立、管理和终止通信过程 &#x2F;</span><br><span class="line">传输层：源到目的地的点对点传输</span><br><span class="line">网络层：路径选择、路由、寻址等网络结构拓扑</span><br><span class="line">数据链路层：物理寻址、数据通道、错误检测等通信路径</span><br><span class="line">物理层：在数据和电平信号之间进行转换</span><br><span class="line"></span><br><span class="line">比喻：</span><br><span class="line">买点心（应用层：业务需求）</span><br><span class="line">选择包装（表示层：数据形式）</span><br><span class="line">选择快递公司（会话层：通信过程）</span><br><span class="line">填写收寄单（传输层：点对点）</span><br><span class="line">选择路径（网络层：通路）</span><br><span class="line">中途周转（数据链路层：多点连线）</span><br><span class="line">送货过程（物理层：实际通信）</span><br></pre></td></tr></table></figure><p><strong>4)TCP/IP协议栈</strong><br>传输层：TCP、UDP<br>网络层：IP、ICMP、IGMP<br>链路层：ARP、RARP</p><p><strong>5)消息包和数据流</strong><br>应用层：HTTP请求=用户数据包<br>传输层：TCP头+用户数据包=TCP包<br>网络层：IP头+TCP包=IP包<br>链路层：以太网头+IP包+以太网尾=以太网帧<br>物理层：以太网帧-&gt;电平信号<br>                                    |   ^<br>                                   v    |<br>                                传输线路<br>发送数据流：消息自协议栈顶层向底层流动，逐层打包。<br>接收数据流：消息自协议栈底层向顶层流程，逐层解析。</p><p><strong>6)IP地址</strong><br>IP地址(Internet Protocol Address，互联网协议地址)是一种地址格式，为互联网上的每个网络和主机分配一个逻辑地址，其目的是消除物理地址的差异性。<br>IP地址的计算机内部用一个网络字节序的32位(4个字节)无符号整数表示。通常习惯将其表示为点分十进制整数字符串的形式。例如：<br>点分十进制整数字符串：1.2.3.4<br>32位(4个字节)无符号整数：0x01020304<br>内存布局：| 0x01 | 0x02 | 0x03 | 0x04 |<br>                   低地址—————&gt;高地址<br>网络字节序就是大端字节序，高位在低地址，低位在高地址。<br>一台计算机的IP地址=网络地址+主机地址<br>A级地址：以0为首8位网络地址+24位主机地址<br>B级地址：以10为首16位网络地址+16位主机地址<br>C级地址：以110为首24位网络地址+8位主机地址<br>D级地址：以1110为首的32为多(组)播地址<br>例如：某台计算机的IP地址为192.168.182.48，其网络地址和主机地址分别为何？<br>           192            168            182              48<br>11000000 10101000 10110110 00110000<br>以110为首，C级地址，网络地址是192.168.182.0，主机地址是48。<br>主机IP地址 &amp; 子网掩码 = 网络地址<br>主机IP地址 &amp; ~子网掩码 = 主机地址<br>例如：主机IP地址192.168.182.48，子网掩码255.255.255.0，其网络地址和主机地址分别为何？<br>192.168.182.48 &amp; 255.255.255.0 = 192.168.182.0<br>192.168.182.48 &amp; 0.0.0.255 = 0.0.0.48</p><h2 id="2-套接字"><a href="#2-套接字" class="headerlink" title="2.套接字"></a>2.套接字</h2><p><strong>1)什么是套接字？</strong><br>Socket，电源插座-&gt;套接字<br>一个由系统内核负责维护，通过文件描述符访问的对象， 可用于在同一台机器或不同机器中的进程之间实现通信。<br>进程表项<br>    文件描述符表<br>    0: 文件描述符标志 | * -&gt; 标准输入文件表项 -&gt; 键盘<br>    1: 文件描述符标志 | * -&gt; 标准输出文件表项 -&gt; 显示器<br>    2: 文件描述符标志 | * -&gt; 标准错误文件表项 -&gt; 显示器<br>    3: 文件描述符标志 | * -&gt; 套接字对象 -&gt; 网卡<br>           应用程序                       应用程序<br>                 v                                   v<br>磁盘文件的文件描述符 表示网络的文件描述符<br>                 v                                   v<br>           文件对象                      套接字对象<br>                 v                                   v<br>           文件系统                      网络协议栈<br>                 v                                   v<br>           磁盘设备                       网络设备<br>套接字也可以被视为是围绕表示网络的文件描述符的一套函数库。调用其中的函数就可以访问网络上的数据，实现不同主机间的通信功能。<br><strong>2)绑定和连接</strong><br>   套接字就是系统内核内存中的一块数据——逻辑对象<br>                                                                            | 绑定(bind)<br>包含了IP地址和端口号等参数的网络设备——物理对象<br>互联网<br>     | &lt;-网络地址：192.168.182.0<br>子网络<br>     | &lt;-主机地址：0.0.0.48<br>计算机<br>     | &lt;-端口号：80<br>  应用<br>通过IP地址(网络地址+主机地址)和端口号就可以唯一定位互联网上的一个通信引用。</p><p>主机A<br>应用程序<br>      |<br>逻辑对象(套接字)<br>      | 绑定(bind)                  连接(connection)<br>物理对象(IP地址和端口号)———物理对象(IP地址和端口号)<br>                                                             | 绑定(bind)<br>                                                       逻辑对象(套接字)<br>                                                             |<br>                                                       应用程序<br>                                                       主机B<br><strong>3)常用函数</strong><br><strong>创建套接字：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">成功返回套接字描述符，失败返回-1。</span><br><span class="line">domain - 通信域，即协议族，可取以下值：</span><br><span class="line">    PF_LOCAL&#x2F;PF_UNIX: 本地通信，进程间通信</span><br><span class="line">    PF_INET: 互联网通信</span><br><span class="line">    PF_PACKET: 底层包通信（嗅探器、端口扫描）</span><br><span class="line">type - 套接字类型，可取以下值：</span><br><span class="line">    SOCK_STREAM: 流式套接字，使用TCP协议</span><br><span class="line">    SOCK_DGRAM: 数据报式套接字，使用UDP协议</span><br><span class="line">    SOCK_RAW: 原始套接字，使用自定义协议</span><br><span class="line">protocol - 特殊协议对于流式套接字和数据报式套接字，取0</span><br></pre></td></tr></table></figure><p>套接字描述符与文件描述符在逻辑层面是一致的，所有关于文件描述符的规则对于套接字描述符也同样成立。同样也通过close函数关闭套接字，即释放内核中的有关资源。</p><p><strong>基本地址结构：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr &#123;</span><br><span class="line">    sa_family_t sa_family; &#x2F;&#x2F; 地址族</span><br><span class="line">    char sa_data[14]; &#x2F;&#x2F; 地址值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基本地址结构仅用于给函数传参时做强制类型转换。</p><p><strong>本地地址结构：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_un &#123;</span><br><span class="line">    sa_family_t sun_family; &#x2F;&#x2F; 地址族(AF_LOCAL&#x2F;AF_UNIX)</span><br><span class="line">    char sun_path[]; &#x2F;&#x2F; 套接字文件路径</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>网络地址结构：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t sin_family; &#x2F;&#x2F; 地址族(AF_INET)</span><br><span class="line">    in_port_t sin_port; &#x2F;&#x2F; 端口号(网络字节序)</span><br><span class="line">    struct in_addr sin_addr; &#x2F;&#x2F; IP地址</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    in_addr_t s_addr; &#x2F;&#x2F; 网络字节序32位无符号整数形式的IP地址</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef uint32_t in_addr_t;</span><br><span class="line">typedef uint16_t in_port_t;</span><br></pre></td></tr></table></figure><p>发送：主机字节序-&gt;网络(大端)字节序<br>接收：网络(大端)字节序-&gt;主机字节序<br>小端字节序的主机A             大端字节序的主机B<br>0x1234<br>主：0x34 | 0x12<br>           L        H<br>网：0x12 | 0x34      -&gt;      网：0x12 | 0x34<br>                                                       L         H<br>                                            主：0x12 | 0x34</p><p>​                                            0x1234</p><p>​                                            小端字节序的主机C<br>​                                  -&gt;      网：0x12 | 0x34<br>​                                                       L         H<br>​                                            主：0x34 | 0x12<br>​                                            0x1234</p><p><strong>将套接字对象和自己的地址结构绑定在一起：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">sockfd - 套接字描述符</span><br><span class="line">addr - 自己的地址结构</span><br><span class="line">addrlen - 地址结构字节数</span><br><span class="line">addr-&gt;sa_family: AF_LOCAL&#x2F;AF_UNIX</span><br><span class="line">     ((struct sockaddr_un*)addr)-&gt;sun_path: 套接字文件</span><br><span class="line">addr-&gt;sa_family: AF_INET</span><br><span class="line">     ((struct sockaddr_in*)addr)-&gt;sin_port&#x2F;sin_addr: IP地址和端口号</span><br></pre></td></tr></table></figure><p><strong>将套接字对象所代表的物理对象和对方的地址结构连接在一起：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">sockfd - 套接字描述符</span><br><span class="line">addr - 对方的地址结构</span><br><span class="line">addrlen - 地址结构字节数</span><br></pre></td></tr></table></figure><p>通过套接字描述符接收和发送数据的过程完全与通过文件描述符读取和写入数据的过程完全一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read(int sockfd, void* buf, size_t count);</span><br><span class="line">ssize_t write(int sockfd, const void* buf, size_t count);</span><br></pre></td></tr></table></figure><p><strong>字节序转换</strong><br>通过网络传输多字节整数，需要在发送前转换为网络字节序，在接收后转换为主机字节序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">uint32_t htonl(uint32_t hostlong);</span><br><span class="line">uint16_t htons(uint16_t hostshort);</span><br><span class="line">uint32_t ntohl(uint32_t netlong);</span><br><span class="line">uint16_t ntohs(uint16_t netshort);</span><br><span class="line">h - host，主机(字节序)</span><br><span class="line">to - 到，把...转换到...</span><br><span class="line">n - network，网络(字节序)</span><br><span class="line">l - long版本，32位无符号整数</span><br><span class="line">s - short版本，16位无符号整数</span><br></pre></td></tr></table></figure><p><strong>IP地址转换</strong><br>(网络字节序32位无符号)整数&lt;=&gt;(点分十进制)字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in_addr_t inet_addr(const char* cp); &#x2F;&#x2F; 串-&gt;数</span><br><span class="line">int inet_aton(const char* cp, struct in_addr* inp);&#x2F;&#x2F; 串-&gt;数</span><br><span class="line">转换成功返回0，失败返回-1。</span><br><span class="line"></span><br><span class="line">char* inet_ntoa(struct in_addr in); &#x2F;&#x2F; 数-&gt;串</span><br><span class="line">转换成功返回字符串指针，失败返回NULL。</span><br></pre></td></tr></table></figure><h2 id="3-基于本地套接字的进程间通信："><a href="#3-基于本地套接字的进程间通信：" class="headerlink" title="3.基于本地套接字的进程间通信："></a>3.基于本地套接字的进程间通信：</h2><p>服务器：提供业务服务的计算机程序。<br>客户机：请求业务服务的计算机程序。<br>服务器                                     客户机<br>创建套接字(socket)                创建套接字(socket)<br>准备地址结构(sockaddr_un)  准备地址结构(sockaddr_un)<br>绑定地址(bind)                       建立连接(connect)<br>接收请求(read)                       发送请求(write)<br>业务处理(…)                            等待处理(…)<br>发送响应(write)                      接收响应(read)<br>关闭套接字(close)                   关闭套接字(close)</p><h2 id="4-基于网络套接字的进程间通信："><a href="#4-基于网络套接字的进程间通信：" class="headerlink" title="4.基于网络套接字的进程间通信："></a>4.基于网络套接字的进程间通信：</h2><p>服务器                                     客户机<br>创建套接字(socket)                创建套接字(socket)<br>准备地址结构(sockaddr_in)   准备地址结构(sockaddr_in)<br>绑定地址(bind)                       建立连接(connect)<br>接收请求(read)                       发送请求(write)<br>业务处理(…)                            等待处理(…)<br>发送响应(write)                      接收响应(read)<br>关闭套接字(close)                   关闭套接字(close)</p><h2 id="5-基于并发的TCP客户机-服务器模型"><a href="#5-基于并发的TCP客户机-服务器模型" class="headerlink" title="5.基于并发的TCP客户机/服务器模型"></a>5.基于并发的TCP客户机/服务器模型</h2><h3 id="1-TCP协议的基本特征"><a href="#1-TCP协议的基本特征" class="headerlink" title="1)TCP协议的基本特征"></a>1)TCP协议的基本特征</h3><p>A.面向连接：参与通信的双方在正式通信之前需要先建立连接，已形成一条虚拟电路，所有的后续通信都在这条虚电路上完成。类似于电话通信业务。正式通话之前要先拨号，拨通了才能讲话。拨号的过程就是一个建立连接的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">三路握手：</span><br><span class="line">    客户机                          服务器</span><br><span class="line">发起连接请求 --------SYN(n)--------&gt; 被动侦听</span><br><span class="line">   等待应答     &lt;-ACK(n+1)+SYN(m)-- 可以接受</span><br><span class="line">   反向确认     ------ACK(m+1)------&gt; 连接成功</span><br></pre></td></tr></table></figure><p>一旦三路握手完成，客户机和服务器的网络协议栈中就会保存有关连接的信息，此后的通信内容全部基于此连接实现数据传输。通信过程中任何原因导致的连接中断，都无法再继续通信，除非重新建立连接。</p><p>B.可靠传输：超时重传。每次发送一个数据包，对方都需要在一个给定的时间窗口内予以应答，如果超过时间没有收到对方的应答，发送方就会重发该数据包，只有重试过足够多的次数依然失败才会最终放弃。</p><p>C.保证顺序：发送端为每一个数据包编制序列号，接收端会根据序列号对所接收到的数据包进行重排，避免重复和乱序。</p><p>D.流量控制：协议栈底层在从另一端接收数据时，会不断告知对方它能够接收多少字节的数据，即所谓通告窗口。任何时候，这个窗口都反映了接收缓冲区可用空间的大小，从而确保不会因为发送方发送数据过快或过慢导致接收缓冲区出现上溢出或下溢出。</p><p>E.流式传输：以字节流形式传输数据，数据包在传输过程中没有记录边界。应用程序需要根据自己的规则来划分出数据包的记录边界。</p><ul><li>定长记录</li><li>不定长记录加分隔符</li><li>定长长度加不定长记录</li></ul><p>F.全双工：在给定的连接上，应用程序在任何时候都既可以发送数据也可以接收数据。因此TCP必须跟踪每个方向上数据流的状态信息，如序列号和通告窗口大小等。</p><h3 id="2-TCP连接的生命周期"><a href="#2-TCP连接的生命周期" class="headerlink" title="2)TCP连接的生命周期"></a>2)TCP连接的生命周期</h3><p>被动打开：通过侦听套接字感知其它主机发起的连接请求。<br>三路握手：TCP连接的建立过程。<br>| TCP包头 | TCP包体 |<br>&lt;20字节&gt;<br>含有6个标志位：SYN/ACK/FIN/RST/…<br>发送序列号和应答序列号<br>…<br>数据传输：超时重传、流量控制、面向字节流、全双工<br>终止连接：<br>  客户机                                         服务器<br>主动关闭 ———FIN(n)——-&gt; 被动关闭<br>等待应答 &lt;—–ACK(n+1)——   关闭应答<br>确定关闭 &lt;——–FIN(m)——-  已经关闭<br>关闭应答 ——ACK(m+1)—–&gt;  等待应答</p><h3 id="3-常用函数"><a href="#3-常用函数" class="headerlink" title="3)常用函数"></a>3)常用函数</h3><p><strong>在指定套接字上启动对连接请求的侦听，即将该套接字置为被动模式，因为套接字都缺省为主动模式。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">sockfd - 套接字描述符</span><br><span class="line">backlog - 未决连接请求队列的最大长度</span><br></pre></td></tr></table></figure><p><strong>在指定的侦听套接字上等待并接受连接请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int accept(int sockfd, struct sockaddr* addr, size_t* addrlen);</span><br><span class="line">成功返回连接套接字描述符用于后续通信，失败返回-1。</span><br><span class="line">sockfd - 侦听套接字描述符</span><br><span class="line">addr - 输出连接请求发起者的地址信息</span><br><span class="line">addrlen - 输入输出连接请求发起者地址信息的字节数</span><br></pre></td></tr></table></figure><p>该函数由TCP服务器调用，返回排在已决连接 队列首部的连接套接字对象的描述符，若已决连接队列为空，该函数会阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">非并发的TCP服务器：</span><br><span class="line">创建套接字(socket)</span><br><span class="line">绑定地址(bind)</span><br><span class="line">启动侦听(listen)</span><br><span class="line">等待连接(accept)&lt;--+</span><br><span class="line">接收请求(read)&lt;-+  |</span><br><span class="line">业务处理(...)   |  |</span><br><span class="line">发送响应(write)--+--+</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">并发的TCP服务器</span><br><span class="line">创建套接字(socket)</span><br><span class="line">绑定地址(bind)</span><br><span class="line">启动侦听(listen)</span><br><span class="line">等待连接(accept)&lt;---+</span><br><span class="line">                   |</span><br><span class="line">产生客户子进程(fork)-+</span><br><span class="line">    接收请求(read)&lt;-+</span><br><span class="line">    业务处理(...)   |</span><br><span class="line">    发送响应(write)--+</span><br></pre></td></tr></table></figure><p><strong>接收数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recv(int sockfd, void* buf, size_t len, int flags);</span><br><span class="line">flags - 接收标志，取0等价于read</span><br><span class="line">    MSG_DONTWAIT: 非阻塞接收。对于阻塞模式，当接收缓冲区为空时，该函数会阻塞，直到接收缓冲区不空为止。如果使用了此标志位，当接收缓冲区为空时，该函数会返回-1，并置errno为EAGAIN或EWOULDBLOCK。</span><br><span class="line">    MSG_OOB: 接收带外数据。</span><br><span class="line">    MSG_PEEK: 瞄一眼数据，只将接收缓冲区中的数据复制到buf缓冲区中，但并不将其从接收缓冲区中删除。</span><br><span class="line">    MSG_WAITALL: 接收到所有期望接收的数据才返回，如果接收缓冲区中的数据不到len个字节，该函数会阻塞，直到可接收到len个字节为止。</span><br></pre></td></tr></table></figure><p><strong>发送数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssize_t send(int sockfd, const void* buf, size_t len, int flags);</span><br><span class="line">flags - 接收标志，取0等价于write</span><br><span class="line">     MSG_DONTWAIT: 非阻塞发送。对于阻塞模式，当发送缓冲区的空余空间不足以容纳期望发送的字节数时，该函数会阻塞，直到发送缓冲区的空余空间足以容纳期望发送的字节数为止。如果使用了此标志位，能发送多少字节就发送多少字节，不会阻塞，甚至可能返回0表示发送缓冲区满，无法发送数据。</span><br><span class="line">     MSG_OOB: 发送带外数据。</span><br><span class="line">     MSG_DONTROUT: 不查路由表，直接在本地网中寻找目的主机。</span><br></pre></td></tr></table></figure><p>代码：tcpsvr.c、tcpcli.c</p><h2 id="6-基于迭代的UDP客户机-服务器模型"><a href="#6-基于迭代的UDP客户机-服务器模型" class="headerlink" title="6.基于迭代的UDP客户机/服务器模型"></a>6.基于迭代的UDP客户机/服务器模型</h2><h3 id="1-UDP协议的基本特征"><a href="#1-UDP协议的基本特征" class="headerlink" title="1)UDP协议的基本特征"></a>1)UDP协议的基本特征</h3><p>A.面向无连接：参与通信的主机之间不需要专门建立和维护逻辑的连接通道。一个UDP套接字可以和任意其它UDP套接字通信，而不必受连接的限制。</p><p>B.不可靠传输：没有超时重传机制。可能导致数据丢失。</p><p>C.不保证顺序：没有序列号，也不进行序列重组。可能产生数据包重复和乱序。</p><p>D.无流量控制：没有通告窗口，通信参与者完全不知道对方的接受能力。可能造成数据溢出。</p><p>E.记录式传输：以消息报文的形式传输数据，数据包在传输过程中有记录边界。应用程序无需划分数据包边界。</p><p>F.全双工</p><p>通过在可靠性方面的部分牺牲换取高速度。</p><h3 id="2-常用函数"><a href="#2-常用函数" class="headerlink" title="2)常用函数"></a>2)常用函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">发送函数：</span><br><span class="line">ssize_t sendto(int sockfd, const void* buf, size_t len, int flags,</span><br><span class="line">const struct sockaddr* dest_addr, socklen_t addrlen);</span><br><span class="line">dest_addr - 数据包接收者地址结构</span><br><span class="line">addrlen - 数据包接收者地址结构字节数</span><br><span class="line"></span><br><span class="line">接受函数：</span><br><span class="line">ssize_t recvfrom(int sockfd, void* buf, size_t len, int flags, struct sockaddr* src_addr,</span><br><span class="line">    socklen_t* addrlen);</span><br><span class="line">src_addr - 输出数据包发送者地址结构</span><br><span class="line">addrlen - 输出数据包发送者地址结构字节数</span><br></pre></td></tr></table></figure><p>针对UDP套接字的connect函数并不象TCP套接字的connect函数一样通过三路握手过程建立所谓的虚电路连接，而仅仅是将传递给该函数的对方地址结构缓存在套接字对象中。此后通过该套接字发送数据时，可以不使用 sendto函数，而直接调用send函数，有关接收方的地址信息从套接字对象的地址缓存中提取即可。<br>代码：concli.c</p><h2 id="7-域名解析（Domain-Name-Service-DNS）"><a href="#7-域名解析（Domain-Name-Service-DNS）" class="headerlink" title="7.域名解析（Domain Name Service, DNS）"></a>7.域名解析（Domain Name Service, DNS）</h2><p>字符串形式的域名<br>(<a href="http://www.tmooc.cn/">www.tmooc.cn</a>)<br>              |<br>              v<br>      DNS服务器<br>              |<br>              v<br>整数形式的IP地址<br>(202.141.55.23)–&gt;套接字编程</p><p><strong>根据主机域名获取信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct hostent* gethostbyname(const char* name);</span><br><span class="line">成功返回主机信息条目指针，失败返回NULL。</span><br><span class="line">name - 主机域名(字符串)</span><br><span class="line">hostent</span><br><span class="line">    h_name -&gt; xxx\0 - 主机官方名</span><br><span class="line">    h_aliases -&gt; * * * ... NULL - 别名表</span><br><span class="line">    h_addrtype -&gt; AF_INET - 地址类型</span><br><span class="line">    h_length -&gt; 4 - 地址字节数</span><br><span class="line">    h_addr_list -&gt; * * * ... NULL - 地址表</span><br><span class="line">                          |</span><br><span class="line">                          v</span><br><span class="line">                   struct in_addr</span><br><span class="line">                       s_addr - 网络字节序32位无符号整数</span><br></pre></td></tr></table></figure><h2 id="8-获取HTTP服务器上的页面内容"><a href="#8-获取HTTP服务器上的页面内容" class="headerlink" title="8.获取HTTP服务器上的页面内容"></a>8.获取HTTP服务器上的页面内容</h2><p>HTTP, Hyper Text Transform Protocol，超文本传输协议<br>www服务器通过http协议提供页面服务。<br>HTTP - 应用层协议：| HTTP包头 | HTTP包体 |<br>    |<br> TCP - 传输层协议：| TCP包头 | HTTP包头 | HTTP包体 |<br>    |<br>   IP - 网络层协议：…<br>    |<br>   …<br>HTTP请求包头：<br>方法                资源路径                 协议及<br>   |        (URI，统一资源定位符)      其版本<br>   |                         |                             |<br>GET /user/project/main.html     HTTP/1.1<br>   键         值<br>    |            |<br>Host: <a href="http://www.tmooc.cn/r/n">www.tmooc.cn\r\n</a><br>Accept: text/html\r\n<br>Connection: Keep-Alive\r\n<br>User-Agent: Mozilla/5.0\r\n<br>Referer: <a href="http://www.tmooc.cn/r/n">www.tmooc.cn\r\n</a><br>…<br>最后一行\r\n\r\n<br>代码：http.c</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;十三、网络通信&quot;&gt;&lt;a href=&quot;#十三、网络通信&quot; class=&quot;headerlink&quot; title=&quot;十三、网络通信&quot;&gt;&lt;/a&gt;十三、网络通信&lt;/h1&gt;&lt;h2 id=&quot;1-网络和网络协议&quot;&gt;&lt;a href=&quot;#1-网络和网络协议&quot; class=&quot;headerlink&quot; title=&quot;1.网络和网络协议&quot;&gt;&lt;/a&gt;1.网络和网络协议&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1)什么是计算机网络？&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>UnixC-线程</title>
    <link href="https://guoqiang-gump.github.io/2021/05/04/UnixC-%E7%BA%BF%E7%A8%8B/"/>
    <id>https://guoqiang-gump.github.io/2021/05/04/UnixC-%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-05-04T14:32:47.000Z</published>
    <updated>2021-05-05T03:10:53.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十四、多线程"><a href="#十四、多线程" class="headerlink" title="十四、多线程"></a>十四、多线程</h1><h2 id="1-什么是线程？"><a href="#1-什么是线程？" class="headerlink" title="1.什么是线程？"></a>1.什么是线程？</h2><p>源代码 -编译和链接-&gt; 程序 -加载到内存中-&gt; 进程</p><a id="more"></a><p>​                                       |                                  |<br>​                                    文件                             内存<br>​                                                                        /   <br>​                                                                 代码 &lt;- 执行<br>​                                                                 数据 &lt;- 处理<br>​                                                                    |            | &lt;- CPU<br>​                                                                 静态      动态<br>​                                                                    |            |<br>​                                                                 资源      线程<br>线程就是进程的执行过程，即进程内部的控制序列，或者说是进程中的一个任务。<br>一个进程可以同时拥有多个线程，即同时被系统调度的多个执行路径，但至少要有一个主线程——main函数及被其调用的其它函数。<br>一个进程的所有线程都共享进程的代码区、数据区、BSS区、堆区、环境变量和命令行参数区、文件描述符表、信号处理函数、当前工作目录、用户和组的各种ID等。但是栈区不是共享的，一个进程的每个线程都拥有自己独立的栈区。</p><p><strong>线程调度：</strong><br>1)系统内核中专门负责线程调度的处理单元被称为调度器；<br>2)调度器将所有处于就绪状态(没有阻塞在任何系统调用上)的线程排成一个队列，即所谓就绪队列；<br>3)调度器从就绪队列中获取队首线程，为其分配一个时间片，并令处理器执行该线程，过了一段时间：</p><ul><li>该线程的时间片耗尽，调度器立即终止该线程，并将其排到就绪队列的尾端，接着从队首获取下一个线程；</li><li>该线程的时间片未耗尽，但需阻塞于某系统调用，比如等待I/O或者睡眠。调度器会中止该线程，并将其从就绪队列中移至等待队列，直到其等待的条件满足后，再被移回就绪队列；</li></ul><p>4)在低优先级线程执行期间，有高优先级线程就绪，后者会抢占前者的时间片；<br>5)若就绪队列为空，则系统内核进入空闲状态，直至其非空；<br>6)象Linux这样的多任务分时系统，基本的调度单位是线程；<br>7)为线程分配的时间片不宜过长，因为时间片太长会导致没有获得处理机的线程等候时间过久，降低系统运行的并行性，用户会感觉到明显的响应延迟；时间片也不宜过短，因为过短的时间片会增加在线程之间切换上下文的频率，降低系统的运行性能。</p><h2 id="2-线程的基本特点"><a href="#2-线程的基本特点" class="headerlink" title="2.线程的基本特点"></a>2.线程的基本特点</h2><p>1)线程是进程中的独立实体，可以拥有自己的资源，可以被独立标识——线程ID，同时也被作为基本调用单元，参与时间片的分配。<br>2)线程有不同的状态，如创建、运行、终止、暂停、恢复、取消等。<br>3)线程可以使用的大部分资源还是隶属于进程的，因此线程作为进程的一部分不能脱离进程独立存在。<br>4)一个进程可以同时执行多个线程，这些线程可以执行相同的代码，完成相同的任务，也可以执行不同的代码，完成不同的任务。<br>5)创建一个线程所花费的开销远小于创建进程的开销。线程也称为轻量级进程。因此在解决诸如并发问题等问题时，优先考虑多线程，其次才是多进程。<br>6)多线程的问题在于因为太多的资源被共享，极易导致冲突，为了解决冲突可能需要增加额外的开销，因此多进程仍然有它的优势。</p><ul><li>进程，特点：内存壁垒，重点关注：通信。</li><li>线程，特点：内存共享，重点关注：同步。</li></ul><h2 id="3-POSIX线程"><a href="#3-POSIX线程" class="headerlink" title="3.POSIX线程"></a>3.POSIX线程</h2><p>#include &lt;pthread.h&gt;<br>-lpthread -&gt; libpthread.so//需要链接动态库</p><h2 id="4-创建线程"><a href="#4-创建线程" class="headerlink" title="4.创建线程"></a>4.创建线程</h2><p>线程过程函数：在一个线程中被内核调用的函数，对该函数的调用过程就是线程的执行过程，从该函数中返回就意味着线程的结束。因此，main函数其实就是一个进程的主线程的线程过程函数。所有自创建的线程都必须有一个对应线程过程函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void* 线程过程函数(void* 线程参数指针) &#123;</span><br><span class="line">    线程的执行过程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int pthread_create(pthread_t* tid, const pthread_attr_t* attr,</span><br><span class="line">    void* (*start_routine)(void*), void* arg);</span><br><span class="line">成功返回0，失败返回错误码。</span><br><span class="line">tid - 输出线程标识(TID)。</span><br><span class="line">attr - 线程属性，NULL表示缺省属性。</span><br><span class="line">start_routine - 线程过程函数指针</span><br><span class="line">arg - 线程参数指针</span><br></pre></td></tr></table></figure><p>pthread_create<br>    -&gt;创建一个新线程<br>        -&gt;调用线程过程函数(start_routine) 并传入线程参数指针(arg)<br>被创建的子线程和创建该子线程的父线程是并行的关系，其调度顺序无法预知，因此当pthread_create函数返回时子线程执行的位置无从确定，其线程过程函数可能尚未被调用，也可能正在执行，甚至可能已经返回。传递给线程的参数对象，一定要在线程过程函数不再使用它的情况下才能被释放。</p><p>主线程和通过pthread_create函数创建的多个子线程，在时间上“同时”运行，如果不附加任何同步条件，则它们每一个执行步骤的先后顺序完全无法预知，这就叫做自由并发。</p><p>为了让线程过程函数的实现更加灵活，可以通过线程参数传递特定的信息，帮助线程过程函数执行不同的任务。</p><h2 id="5-汇合线程"><a href="#5-汇合线程" class="headerlink" title="5.汇合线程"></a>5.汇合线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       创建点     汇合点</span><br><span class="line">--------+---------+-------&gt; 主线程</span><br><span class="line">        \________&#x2F; 子线程</span><br><span class="line">int phread_join(pthread_t tid, void** retval);</span><br><span class="line">成功返回0，失败返回错误码。</span><br><span class="line">tid - 线程标识</span><br><span class="line">retval - 线程退出码</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当调用pthread_join函数时：<br>tid线程已经终止，立刻返回，返回线程退出码。<br>tid线程尚未终止，阻塞等待，直到被汇合线程终止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void* 线程过程函数(void* 线程参数指针) &#123;</span><br><span class="line">    线程的执行过程</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程过程函数返回一个指针P，内核将p传给线程退出码retval-&gt;q[ ]，汇合线程函数phread_join(…, &amp;q);就可以得到线程过程函数返回的内容。</p><p>phread_join主要做的工作：</p><ul><li>等待子线程终止</li><li>清理线程的资源</li><li>获得线程过程函数的返回值</li></ul><h2 id="6-分离线程"><a href="#6-分离线程" class="headerlink" title="6.分离线程"></a>6.分离线程</h2><p>在有些时候作为子线程的创建者，父线程可能并不关心子线程何时终止，同时父线程也不需要获得子线程的返回值。这种情况下，就可将子线程设置为分离线程，这样的线程一旦终止，它们的资源会被系统自动回收，而无需在其父线程中调用pthread_join函数。</p><p>方法一：pthread_detach函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pthread_detach(pthread_t tid);</span><br><span class="line">成功返回0，失败返回错误码。</span><br><span class="line">tid - 线程标识</span><br></pre></td></tr></table></figure><p>方法二：通过设置线程属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_attr_t attr;&#x2F;&#x2F;线程属性</span><br><span class="line">pthread_attr_init(&amp;attr); &#x2F;&#x2F; 用缺省值初始化线程属性</span><br><span class="line">pthread_attr_setdetachstat(&amp;attr, PTHREAD_CREATE_DETACHED);&#x2F;&#x2F;设置分离线程属性</span><br><span class="line">pthread_create(..., &amp;attr, ...);&#x2F;&#x2F;在创建的时候就可以使线程为分离线程</span><br><span class="line">pthread_attr_destroy(&amp;attr);</span><br></pre></td></tr></table></figure><h2 id="7-线程ID"><a href="#7-线程ID" class="headerlink" title="7.线程ID"></a>7.线程ID</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pthread_t tid;</span><br><span class="line">pthread_create(&amp;tid, ...); </span><br><span class="line">tid：输出子线程的TID</span><br><span class="line"></span><br><span class="line">pthread_self();&#x2F;&#x2F; 返回调用线程的TID</span><br><span class="line"></span><br><span class="line">int pthread_equal(pthread_t tid1, pthread_t tid2);&#x2F;&#x2F;比较两个线程tid</span><br><span class="line">两个TID相等返回非零，否则返回0。</span><br></pre></td></tr></table></figure><p>通过pthread_self函数返回的线程ID和pthread_create函数输出的线程ID一样都是由PTHREAD库内部维护的虚拟(伪)线程ID，可用于其它需要提供线程ID的PTHREAD函数。系统内核维护的真实线程ID，可通syscall(SYS_gettid)获得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt; &#x2F;&#x2F; 声明syscall函数</span><br><span class="line">#include &lt;syscall.h&gt; &#x2F;&#x2F; 定义SYS_gettid宏</span><br><span class="line">syscall(SYS_gettid);&#x2F;&#x2F;获取系统内核维护的真实线程ID</span><br></pre></td></tr></table></figure><p>在Linux系统中，一个进程的PID实际上就是其主线程的TID。</p><h2 id="8-终止线程-自己"><a href="#8-终止线程-自己" class="headerlink" title="8.终止线程(自己)"></a>8.终止线程(自己)</h2><p>1)从线程过程函数中返回，执行该过程函数的线程即终止。其返回值可通过pthread_join函数的第二参数输出给调用者。<br>2)在线程过程函数及被其调用的任何函数中都可以调用pthread_exit函数终止当前线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void pthread_exit(void* retval);</span><br></pre></td></tr></table></figure><p>retval就相当于线程过程函数的返回值，同样可被pthread_join的第二个参数输出给调用。</p><p>注意：在子线程中调用pthread_exit，只会终止调用线程自己，对其其它兄弟线程和主线程没有影响。但如果在主线程中调用pthread_exit，被终止的将是整个进程及其所包含的全部线程。</p><h2 id="9-取消-其它-线程"><a href="#9-取消-其它-线程" class="headerlink" title="9.取消(其它)线程"></a>9.取消(其它)线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cancel(pthread_t tid);</span><br><span class="line">成功返回0，失败返回错误码。</span><br><span class="line">tid - 被取消线程的TID。</span><br></pre></td></tr></table></figure><p>该函数只是向特定线程发出取消请求，并不等待其终止运行。缺省情况下，线程在收到取消请求以后，并不会立即终止，而是仍继续运行，直到达到某个取消点。在取消点处，线程检查其自身是否已被取消，若是则立即终止。取消点通常出现在一些特定的系统调用中。</p><p><strong>设置调用线程的取消状态为接受或忽略取消请求：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int pthread_setcancelstate(int state, int* oldstate);</span><br><span class="line">state - 取消状态，可取以下值：</span><br><span class="line">    PTHREAD_CANCEL_ENABLE - 接受取消请求(缺省)</span><br><span class="line">    PTHREAD_CANCEL_DISABLE - 忽略取消请求</span><br><span class="line">old_state - 输出原取消状态，可取NULL。</span><br></pre></td></tr></table></figure><p><strong>设置调用线程的取消类型为延迟取消或立即取消：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int pthread_setcanceltype(int type, int* oldtype);</span><br><span class="line">type - 取消类型，可取以下值：</span><br><span class="line">    PTHREAD_CANCEL_DEFERRED - 延迟取消(缺省)，接到取消请求，如果不是忽略的话，继续运行一段时间，直到执行取消点时再终止。</span><br><span class="line">    PTHREAD_CANEL_ASYNCHRONOUS - 立即取消，接到取消请求，如果不是忽略的话，立刻终止运行。</span><br><span class="line">old_type - 输出原取消类型，可取NULL。</span><br></pre></td></tr></table></figure><h2 id="10-线程冲突"><a href="#10-线程冲突" class="headerlink" title="10.线程冲突"></a>10.线程冲突</h2><p>g = 0<br>线程1                                   线程2<br>把内存(g=0)中的值读入寄存器(eax=0)<br>把寄存器(eax=0-&gt;1)中的值加1<br>把寄存器(eax=1)中的值存入内存(g=1)<br>                                  把内存(g=1)中的值读入寄存器(eax=1)<br>                                  把寄存器(eax=1-&gt;2)中的值加1<br>                                  把寄存器(eax=2)中的值存入内存(g=2)<br>线程1                                   线程2<br>把内存(g=0)中的值读入寄存器(eax=0)<br>                                  把内存(g=0)中的值读入寄存器(eax=0)<br>把寄存器(eax=0-&gt;1)中的值加1<br>                                  把寄存器(eax=0-&gt;1)中的值加1<br>把寄存器(eax=1)中的值存入内存(g=1)<br>                                  把寄存器(eax=1)中的值存入内存(g=1)</p><p>当两个或两个的线程同时以非原子化的方式访问同一个对象时，极有可能导致对象的最终状态不稳定，这就是所谓的线程冲突。解决冲突的基本原则就是敏感操作的原子化，即保证一个线程完成这组敏感操作以后，再允许另个线程执行类似的操作，位于与共享资源有关的操作代码，在任何时候都只允许一个线程执行。</p><h2 id="11-互斥锁"><a href="#11-互斥锁" class="headerlink" title="11.互斥锁"></a>11.互斥锁</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">静态初始化</span><br><span class="line">pthread_mutex_t mutex &#x3D; PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">动态初始化</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"></span><br><span class="line">pthread_mutex_init(&amp;mutex, NULL); &#x2F;&#x2F; 分配内核资源</span><br><span class="line">pthread_mutex_destroy(&amp;mutex); &#x2F;&#x2F; 释放内核资源</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex); &#x2F;&#x2F; 锁定互斥锁</span><br><span class="line">pthread_mutex_unlock(&amp;mutex); &#x2F;&#x2F; 解锁互斥锁</span><br></pre></td></tr></table></figure><p>任何时刻只会有一个线程对特定的互斥锁锁定成功，其它试图对其锁定的线程会在此函数中阻塞等待，直到该互斥锁的持有者线程将其解锁为止。</p><p>对特定互斥锁对象锁定成功的线程通过pthread_mutex_unlock函数将其解锁，那些阻塞于对该互斥锁对象试图锁定的线程中的一个会被唤醒，得到该互斥锁，并从pthread_mutex_lock函数中返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">void* thread1(void* arg) &#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    执行操作，访问共享对象</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">void* thread2(void* arg) &#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    执行操作，访问共享对象</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥锁在保证数据一致性和防止并发冲突的同时，也牺牲了多线程应用的并发性，因此在设计上，应尽量少地使用互斥锁，或者说只有在需要被互斥锁保护的操作过程中，使用它，而对于保护需求不明显的场合尽量不用。</p><h2 id="12-信号量"><a href="#12-信号量" class="headerlink" title="12.信号量"></a>12.信号量</h2><p>功能和用法与XSI/IPC对象中的信号量集非常类似，但是XSI/IPC对象中的信号量集只能用于进程，而这里的信号量既可以用于进程，也可以用于线程。<br><strong>初始化信号量：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int sem_init(sem_t* sem, int pshared, unsigned int value);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">sem - 信号量。</span><br><span class="line">pshared - 用0和非0分别表示该信号量用于线程或是进程。</span><br><span class="line">value - 信号量的初值，即初始空闲资源数。</span><br></pre></td></tr></table></figure><p>当pshared参数取0，信号量仅用于一个进程中的多个线程，其本质就是一个普通的全局变量，但如果改参数取值为非0，则信号量可用于不同的进程，其存储位置在可为这些进程所访问的共享内存中。</p><p><strong>销毁信号量：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sem_destroy(sem_t* sem);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">sem - 信号量。</span><br></pre></td></tr></table></figure><p><strong>等待信号量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sem_wait(sem_t* sem);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">sem - 信号量。</span><br></pre></td></tr></table></figure><p>如果信号量的当前值大于0，则将其减1并立即返回0，表示获得资源。如果该信号量的当前值等于0，这就意味着已经没有空闲资源可供分配，调用该该函数的线程或进程将被阻塞，直到因资源被释放信号量的值够减1为止。</p><p><strong>释放信号量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sem_post(sem_t* sem);</span><br><span class="line">成功返回0，失败返回-1。</span><br></pre></td></tr></table></figure><p>将信号量的值加1。那些正阻塞于针对该信号量的sem_wait函数调用中的一个线程或进程将被唤醒，并在对信号量减1之后从sem_wait函数中返回。</p><p><strong>获取信号量的当前值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sem_getvalue(sem_t* sem, int* sval);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">sem - 信号量</span><br><span class="line">sval - 输出信号量的当前值，即当前可分配资源数</span><br></pre></td></tr></table></figure><h3 id="信号量与信号量集"><a href="#信号量与信号量集" class="headerlink" title="信号量与信号量集"></a>信号量与信号量集</h3><p>信号量 —— semaphore<br>信号量集 —— semaphore arrays</p><ul><li>信号量可以用于进程与进程之间、线程与线程之间的通信</li><li>信号量集只可以用于进程与进程之间的通信</li></ul><p><strong>信号量</strong></p><p>信号量其实就是一个计数器，用于控制同时访问共享资源的进程/线程的总数（IPC中的信号量集只控制进程）</p><p>信号量的使用方式：</p><ol><li>先赋初值，就是允许并行的进程最大数量。</li><li>如果有进程访问， 计数-1，到0就阻塞访问进程。</li><li>如果有进程结束访问，计数 + 1。</li></ol><p><strong>信号量集</strong></p><p>信号量集就是将多个信号量放入数组，统一管理，IPC使用的是信号量的数组(信号量集)，而不是单一的信号量。<br>信号量集其实就是一个计数器数组，只能控制进程数量而不能互发数据。</p><p>信号量集的使用步骤：</p><ol><li>生成一个key，使用ftok()</li><li>创建/获取 信号量集的ID semget()</li><li>给信号量集中的每个信号量赋初始值 semctl()</li><li>semop()负责进程访问或者结束访问时。计数的 +1和 -1</li><li>如果不再使用信号量集，可以使用scmctl() 删除</li></ol><p>转载自链接：<a href="https://blog.csdn.net/Robot__Man/article/details/52235965">https://blog.csdn.net/Robot__Man/article/details/52235965</a></p><h2 id="13-条件变量"><a href="#13-条件变量" class="headerlink" title="13.条件变量"></a>13.条件变量</h2><p>线程1<br>    …<br>    if (后续操作所依赖的条件不满足)<br>        睡眠于条件变量;<br>    后续操作<br>    …<br>线程2<br>    …<br>    创建出后续操作所依赖的条件<br>    唤醒在条件变量中睡眠的线程<br>    …</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">静态初始化</span><br><span class="line">pthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line">动态初始化</span><br><span class="line">pthread_cond_init(&amp;cond, NULL);&#x2F;&#x2F;动态创建</span><br><span class="line">...</span><br><span class="line">pthread_cond_destroy(&amp;cond);&#x2F;&#x2F;销毁</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">等待条件变量，即在条件变量中睡眠：</span><br><span class="line">int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex);</span><br><span class="line">当调用线程在cond条件变量中睡眠期间mutex互斥会被解锁，直到该线程从条件变量中苏醒，即从该函数中返回再重新拥有该互斥锁。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_signal(pthread_cond_t* cond);</span><br><span class="line">唤醒在条件变量cond中睡眠的第一个线程，即条件等待队列的队首线程，待其重新获得互斥锁以后从pthread_cond_wait函数中返回。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_broadcast(pthread_cond_t* cond);</span><br><span class="line">唤醒在条件变量cond中睡眠的所有线程，只有重新获得互斥锁的线程会从pthread_cond_wait函数中返回。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">生产者——消费者模型：</span><br><span class="line">硬件&#x2F;网络-&gt;生产者线程-数据-&gt;消费者线程</span><br><span class="line">          \__________________&#x2F;</span><br><span class="line">                 刚性耦合</span><br><span class="line">硬件&#x2F;网络-&gt;生产者线程-数据-&gt;缓冲区-数据-&gt;消费者线程</span><br><span class="line">          \________________________________&#x2F;</span><br><span class="line">                 柔性耦合</span><br></pre></td></tr></table></figure><p>理想缓冲区：永远不满且不空<br>实际缓冲区：满不能放入——撑死，空不能提取——饿死。<br>生产者线程：<br>    if (缓冲区满)<br>        睡入非满条件变量，释放缓冲区锁<br>        被唤醒，离开条件等候队列，重新获得缓冲区锁<br>    生产-&gt;非空<br>    唤醒在非空条件变量中睡眠的消费者线程<br>消费者线程：<br>    if (缓冲区空)<br>        睡入非空条件变量，释放缓冲区锁<br>        被唤醒，离开条件等候队列，重新获得缓冲区锁<br>    消费-&gt;非满<br>    唤醒在非满条件变量中睡眠的生产者线程</p><h2 id="14-死锁"><a href="#14-死锁" class="headerlink" title="14.死锁"></a>14.死锁</h2><p>死锁的四个必要条件：</p><ol><li>独占排它：线程以独占的方式使用其所获得的资源，即在一个段时间内不允许其它线程使用该资源。这段时间内，任何试图请求该资源的线程只能在阻塞中等待，直到资源被其拥有者主动释放。</li><li>请求保持：线程已经拥有了至少一份资源，但又试图获取已被其它线程拥有的资源，因此只能在阻塞中等待，同时对自己已经获取的资源又坚守不放。</li><li>不可剥夺：线程已经获得的资源，在其未被使用完之前，不可被强制剥夺，而只能由其拥有者自己释放。</li><li>循环等待：线程集合{T0,T1,Tn}中，T0等待T1占有的资源，T1等待T2占有的资源，…，Tn等待T0占有的资源，形成环路。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;十四、多线程&quot;&gt;&lt;a href=&quot;#十四、多线程&quot; class=&quot;headerlink&quot; title=&quot;十四、多线程&quot;&gt;&lt;/a&gt;十四、多线程&lt;/h1&gt;&lt;h2 id=&quot;1-什么是线程？&quot;&gt;&lt;a href=&quot;#1-什么是线程？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是线程？&quot;&gt;&lt;/a&gt;1.什么是线程？&lt;/h2&gt;&lt;p&gt;源代码 -编译和链接-&amp;gt; 程序 -加载到内存中-&amp;gt; 进程&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>UnixC-进程</title>
    <link href="https://guoqiang-gump.github.io/2021/05/04/UnixC-%E8%BF%9B%E7%A8%8B/"/>
    <id>https://guoqiang-gump.github.io/2021/05/04/UnixC-%E8%BF%9B%E7%A8%8B/</id>
    <published>2021-05-04T11:45:28.000Z</published>
    <updated>2021-05-05T03:25:08.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十、进程"><a href="#十、进程" class="headerlink" title="十、进程"></a>十、进程</h1><h2 id="1-进程的基本概念"><a href="#1-进程的基本概念" class="headerlink" title="1.进程的基本概念"></a><strong>1.进程的基本概念</strong></h2><p>程序：磁盘上的可执行文件。</p><a id="more"></a><p>​                    | 加载<br>​                    v<br>进程：内存中的指令和数据。<br>​                    执行 |        ^<br>​                            v        | 访问<br>​                         CPU—+</p><h2 id="2-进程的分类"><a href="#2-进程的分类" class="headerlink" title="2.进程的分类"></a><strong>2.进程的分类</strong></h2><ul><li>交互式进程：由Shell启动，借助标准I/O与用户交互。</li><li>批处理进程：在无需人工干预的条件下，自动运行一组批量任务。</li><li>守护(精灵)进程：后台服务，多数时候处于待命状态，一旦有需要可被激活完成特定的任务。</li></ul><h2 id="3-进程快照-进程查看命令"><a href="#3-进程快照-进程查看命令" class="headerlink" title="3.进程快照(进程查看命令)"></a><strong>3.进程快照</strong>(进程查看命令)</h2><p>ps - 显示当前用户拥有控制终端的进程信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps axuw - BSD风格选项</span><br><span class="line">a: 所有用户</span><br><span class="line">x: 既包括有控制终端也包括无控制终端的进程</span><br><span class="line">u: 详细信息</span><br><span class="line">w: 更大列宽</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -efFl - SVR4风格选项</span><br><span class="line">e: 所有用户的所有进程</span><br><span class="line">f: 完整格式</span><br><span class="line">F: 更完整格式</span><br><span class="line">l: 长格式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">USER&#x2F;UID: 进程的实际用户ID</span><br><span class="line">PID: 进程标识</span><br><span class="line">%CPU&#x2F;C: CPU使用率</span><br><span class="line">%MEM: 内存使用率</span><br><span class="line">VSZ: 占用虚拟内存大小(KB)</span><br><span class="line">RSS: 占用半导体物理内存大小(KB)</span><br><span class="line">TTY: 终端次设备号</span><br><span class="line">         ttyn - 物理终端(硬件设备)</span><br><span class="line">         pts&#x2F;n - 虚拟终端(软件窗口)</span><br><span class="line">         ? - 无控制终端，如后台进程</span><br><span class="line">STAT&#x2F;S: 进程状态</span><br><span class="line">        O - 就绪，等待被调度</span><br><span class="line">        R - 运行，Linux下没有O状态，就绪状态也用R表示</span><br><span class="line">        S - 可唤醒睡眠，系统中断，获得资源，收到信号， 都可被唤醒，转入运行状态</span><br><span class="line">        D - 不可唤醒的睡眠，只能被wake_up系统调用唤醒</span><br><span class="line">        T - 暂停，收到SIGSTOP(19)信号转入暂停状态，收到SIGCONT(18)信号转入运行状态</span><br><span class="line">        W - 等待内存分页(2.6内核后被废弃)</span><br><span class="line">        X - 终止且被回收，不可见</span><br><span class="line">        Z - 僵尸，已退出但未被回收</span><br><span class="line">        &lt; - 高优先级</span><br><span class="line">        N - 低优先级</span><br><span class="line">        L - 有被锁定在半导体内存中的分页</span><br><span class="line">        s - 会话首进程</span><br><span class="line">        l - 多线程化</span><br><span class="line"></span><br><span class="line">在前台进程组中，往往带有终端设备的进程</span><br><span class="line">START: 进程启动时间</span><br><span class="line">TIME: 进程运行时间</span><br><span class="line">COMMAND&#x2F;CMD: 进程启动命令</span><br><span class="line">F: 进程标志</span><br><span class="line">        1 - 通过fork产生的子进程，但是并没有通过exec创建新进程</span><br><span class="line">        4 - 拥有超级用户(root)特权</span><br><span class="line">PPID: 父进程的PID</span><br><span class="line">NI: 进程nice值，-20~19，进程优先级浮动量</span><br><span class="line">PRI: 进程优先级&#x3D;80+nice，60~99，值越小优先级越高</span><br><span class="line">       I&#x2F;O消耗型进程(占用CPU少)，奖励，提高优先级，降低nice值</span><br><span class="line">       处理机消耗型进程(占用CPU多)，惩罚，降低优先级，提高nice值</span><br><span class="line">ADDR: 内核进程的内存地址，普通进程显示&quot;-&quot;</span><br><span class="line">SZ: 占用虚拟内存页数</span><br><span class="line">WCHAN: 进程正在等待的内核函数或事件</span><br><span class="line">PSR: 进程当前正在被哪个处理器执行</span><br></pre></td></tr></table></figure><p><strong>4.父子孤尸</strong><br>父进程创建子进程，子进程继承父进程。<br>一个父进程可以创建多个子进程，每个子进程有且仅有一个父进程，除非是根进程(PID=0，调度器实例)没有父进程。<br>进程树：<br>调度进程(PID=0)<br>    init(PID=1)<br>        xinetd<br>            in.telnetd    &lt;-    远程登录<br>                 login           &lt;-   用户名和口令<br>                     bash             &lt;-   Shell命令：ls<br>                          ls                    -&gt;   显示目录条目清单</p><p>父进程在创建完子进程以后依然存在，甚至可以和子进程进行某种形式的交互，如：传参、回收、通信等。<br>旧进程在创建完新进程以后被其取代，新进程沿用旧进程的PID，继续独立地存在。</p><p>父进程创建子进程以后，子进程在操作系统的调度下与其父进程同时运行。如果父进程先用子进程的终止而终止，子进程即成为孤儿进程，同时被init进程收养，即成为init进程的子进程，因此init进程又被成为孤儿院进程。一个进程成为孤儿进程是正常的，系统中大多数守护进程都是孤儿进程。</p><p>如果子进程先于父进程的终止而终止，但父进程由于某种原因，没有回收子进程的尸体(终止状态)，子进程即成为僵尸进程。僵尸进程虽然已经不再活动，但其终止状态和PID仍然被保留，也会占用系统资源，直到其被父进程或init进程回收为止。如果父进程直到其终止都没有回收其处于僵尸状态的子进程，init进程会立即回收这些僵尸。因此一个进程不可能同时既是僵尸进程又是孤儿进程。</p><h2 id="5-进程的各种ID"><a href="#5-进程的各种ID" class="headerlink" title="5.进程的各种ID"></a><strong>5.进程的各种ID</strong></h2><p>系统内核会为每个进程维护一个进程表项，其中包括如下ID：</p><ul><li>进程ID：系统为每个进程分配的唯一标识。内核在分配进程ID时，会持续增加，直到不发在增加了，再从头寻找被释放的ID，即延迟重用。 </li><li>父进程ID：父进程的PID，在创建子进程的过程中被初始化到子进程的进程表项中。</li><li>实际用户ID：启动该进程的用户ID。</li><li>实际组ID：启动该进程的用户组ID。</li><li>有效用户ID：通常情况下，取自进程的实际用户ID。如果该进程的可执行文件带有设置用户ID位，那么该进程的有效用户ID就取自其可执行文件的拥有者用户ID。</li><li>有效组ID：通常情况下，取自进程的实际组ID。如果该进程的可执行文件带有设置组ID位，那么该进程的有效组ID就取自其可执行文件的拥有者组ID。</li></ul><p>一个进程的能力和权限，由其有效用户ID和有效组ID决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t getpid(void);   &#x2F;&#x2F; 返回调用进程的PID</span><br><span class="line">pid_t getppid(void); &#x2F;&#x2F; 返回调用进程的PPID，即其父进程的PID</span><br><span class="line">uid_t getuid(void);   &#x2F;&#x2F; 返回调用进程的实际用户ID</span><br><span class="line">uid_t getgid(void);   &#x2F;&#x2F; 返回调用进程的实际组ID</span><br><span class="line">uid_t geteuid(void); &#x2F;&#x2F; 返回调用进程的有效用户ID</span><br><span class="line">uid_t getegid(void); &#x2F;&#x2F; 返回调用进程的有效组ID</span><br></pre></td></tr></table></figure><h2 id="6-创建子进程"><a href="#6-创建子进程" class="headerlink" title="6.创建子进程"></a><strong>6.创建子进程</strong></h2><p>产生进程分支(fork)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void);</span><br><span class="line">成功分别父子进程中返回子进程的PID和0，失败返回-1。</span><br><span class="line">即调用一次返回两次：在父进程中返回所创建子进程的PID，而在子进程中返回0</span><br></pre></td></tr></table></figure><p>函数的调用者往往可以根据该函数返回值的不同，分别为父子进程编写不同的处理分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pid_t pid &#x3D; fork();</span><br><span class="line">if (pid &#x3D;&#x3D; -1) &#123;</span><br><span class="line">    perror(&quot;fork&quot;);</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    子进程的处理分支</span><br><span class="line">    exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">父进程的处理分支</span><br><span class="line">exit(EXIT_SUCCESS);</span><br></pre></td></tr></table></figure><p>子进程是父进程不完全副本，子进程的数据区、BSS区、堆栈区(包括I/O缓冲区)，甚至命令行参数和全局变量区都从父进程拷贝，唯有代码区与父进程共享。即代码共享，数据复制。<br>fork函数成功返回以后，父子进程各自独立地运行，其被调度的先后顺序并不确定，某些实现可以保证子进程先被调度。<br>fork函数成功返回以后，系统内核为父进程维护的文件描述符表也被复制到子进程的进程表项中，文件表项并不复制。<br>系统总线程数达到上限(/proc/sys/kernel/threads-max)或用户总进程数达到上限(ulimit -u)，fork函数将返回失败。<br>一个进程如果希望创建自己的副本并执行同一份代码，或希望与另一个进程并发地运行，都可以使用fork函数。</p><h2 id="7-创建轻量级子进程"><a href="#7-创建轻量级子进程" class="headerlink" title="7.创建轻量级子进程"></a><strong>7.创建轻量级子进程</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pid_t vfork(void);</span><br><span class="line">成功分别父子进程中返回子进程的PID和0，失败返回-1。</span><br></pre></td></tr></table></figure><p>vfork函数与fork函数的功能基本相同，只有一下两点区别：<br>1)vfork函数创建的子进程不复制父进程的物理内存，也不拥有自己独立的内存映射，而是与父进程共享全部地址空间。</p><p>2)vfork函数在创建子进程的同时会挂起父进程，直到子进程终止，或通过exec函数创建新进程，再恢复父进程的运行。(防止和父进程冲突) 即数据和代码都是独立的。</p><p>使用了写时拷贝(copy-on-write)优化技术的fork结合exec的使用，其性能并不弱于典型vfork+exec的用法。<br>终止vfork函数创建的子进程，不能在main函数中使用return语句，也不要在任何函数中调用exit函数，而要调用_exit函数，以避免对父进程造成不利影响。</p><h2 id="8-进程的终止"><a href="#8-进程的终止" class="headerlink" title="8.进程的终止"></a><strong>8.进程的终止</strong></h2><h3 id="1-正常终止"><a href="#1-正常终止" class="headerlink" title="1)正常终止"></a><strong>1)正常终止</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、从main函数中rerurn返回</span><br><span class="line">2、在任何地方调用exit&#x2F;_exit&#x2F;_Exit函数</span><br><span class="line">3、在主线程中调用pthread_exit函数</span><br></pre></td></tr></table></figure><p>进程一旦终止，被终止进程在用户空间所持有的资源会被自动释放，如代码区、数据区、堆栈区等，但内核空间中与该进程相关的资源，如进程表项、文件描述符等未必会得到释放。<br>在main函数中执行return语句就相当于调用了exit函数。<br>main函数的返回值和exit/_exit/_Exit函数的参数一样，构成了进程的退出码，可以被终止进程的父进程通过wait或waitpid函数获得，其中只有最低8位可被获取。</p><p><strong>注册退出处理函数：</strong><br>当return或调用exit函数时，以下两个函数开始执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int atexit(void (*function)(void));</span><br><span class="line">int on_exit(void (*function)(int, void*), void* arg);</span><br><span class="line">int: main函数的返回值&#x2F;exit函数的参数</span><br><span class="line">void* arg会传给void*</span><br><span class="line">宏：</span><br><span class="line">EXIT_SUCCESS - 0</span><br><span class="line">EXIT_FAILURE - -1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">exit函数的执行过程：</span><br><span class="line">    调用实现通过atexit&#x2F;on_exit函数注册的退出处理函数</span><br><span class="line">    冲刷并关闭所有仍处于打开状态的标准I&#x2F;O流</span><br><span class="line">    删除所有通过tmpfile函数创建临时文件</span><br><span class="line">    调用_exit函数</span><br><span class="line">_exit函数的执行过程：</span><br><span class="line">        关闭所有仍处于打开状态的文件描述符</span><br><span class="line">        将调用进程的子进程(无论活死)托付给孤儿院进程收养</span><br><span class="line">        向调用进程的父进程发送SIGCHLD(17)信号，通知父进程回收子进程</span><br><span class="line">        令调用进程终止</span><br><span class="line">_Exit与_exit的功能完全一致，唯一的区别是前者有标准库提供，被声明于stdlib.h，而后者有系统调用提供，被声明于unistd.h。</span><br></pre></td></tr></table></figure><h3 id="2-异常终止"><a href="#2-异常终止" class="headerlink" title="2)异常终止"></a><strong>2)异常终止</strong></h3><ul><li>在主线程外部通过pthread_cancel将主线程取消</li><li>通过信号杀死进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+C -&gt; SIGINT(2), 终端中断符信号, 进程收到该信号执行默认动作——（异常）终止。</span><br><span class="line">Ctrl+\ -&gt; SIGQUIT(3), 终端退出符信号</span><br><span class="line">SIGKILL(9)</span><br><span class="line">SIGTERM(15)</span><br><span class="line">SIGSEGV(11), 内存段出错</span><br><span class="line">SIGBUS(7), 硬件错误</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="9-回收子进程"><a href="#9-回收子进程" class="headerlink" title="9.回收子进程"></a>9.回收子进程</h2><ol><li><p>通过等待子进程结束实现某种进程间的同步。</p></li><li><p>获知子进程的退出码，根据子进程不同的退出原因采取不同的对策。</p></li><li><p>避免过多的子进程僵尸拖垮系统。</p><p><strong>回收子进程函数wait：</strong></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid_t wait(int* status);</span><br><span class="line">成功返回所回收子进程的PID，失败返回-1。</span><br><span class="line">status - 输出子进程的终止状态，可置NULL。</span><br></pre></td></tr></table></figure><p>父进程在创建若干子进程以后调用wait函数：<br>1)若所有子进程都在运行，则阻塞，直到有子进程终止才返回<br>2)若至少有一个子进程已经终止，则立即返回该子进程的PID并通过status参数(若非NULL)输出器终止状态<br>3)若没有需要等待的活动子进程，也没有需要回收的死亡子进程，则返回-1，同时置errno为ECHILD</p><p><strong>分析进程的终止状态函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WIFEXITED(status) - 返回非零则表示进程正常终止</span><br><span class="line">    WEXITSTATUS(status) - 返回进程main函数的返回值或者传递给exit&#x2F;_exit&#x2F;_Exit函数参数的低8位</span><br><span class="line">WIFSIGNALED(status) - 返回非零则表示进程被信号杀死</span><br><span class="line">    WTERMSIG(status) - 返回杀死进程的信号编号</span><br></pre></td></tr></table></figure><p><strong>回收子进程函数waitpid：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid, int* status, int options);</span><br><span class="line">成功返回所回收子进程的PID，失败返回-1。</span><br><span class="line">pid - 进程标识，可取以下值：</span><br><span class="line">&lt;-1: 等待并回收由-pid所标识的进程组中任意子进程</span><br><span class="line">-1: 等待并回收任意子进程，相当于wait函数</span><br><span class="line">0: 等待并回收与调用进程同组的任意子进程</span><br><span class="line">0: 等待并回收由pid所标识的特定子进程</span><br><span class="line">status - 输出子进程的终止状态，可置NULL。</span><br><span class="line">options - 选项，可取以下值：</span><br><span class="line">0: 阻塞模式，等不来就死等，类似于wait函数</span><br><span class="line">WNOHANG: 非阻塞模式，如果所等子进程仍在运行，则返回0</span><br></pre></td></tr></table></figure><h2 id="10-创建新进程"><a href="#10-创建新进程" class="headerlink" title="10.创建新进程"></a>10.创建新进程</h2><p>子进程：父子同在——并行。<br>新进程：以新换旧——取代。<br>创建新进程的exec函数族包括6个函数，根据参数的形式和是否使用PATH环境变量进行区分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">为一个函数传递不定数量的字符串参数：</span><br><span class="line">1、void foo(const char* arg, ...); &#x2F;&#x2F; 变长参数表，...表示参数数目不固定</span><br><span class="line">foo(&quot;abc&quot;, &quot;def&quot;, ..., NULL);</span><br><span class="line"></span><br><span class="line">2、void bar(const char* arg[]); &#x2F;&#x2F; 字符指针数组</span><br><span class="line">const char* a[] &#x3D; &#123;&quot;abc&quot;, &quot;def&quot;, ..., NULL&#125;;</span><br><span class="line">bar(a);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int execl(const char* path, const char* arg, ...);</span><br><span class="line">path: 可执行文件的路径</span><br><span class="line">arg: 命令行参数</span><br><span class="line"></span><br><span class="line">$ gcc hello.c -o hello</span><br><span class="line">gcc-&gt;argv[0]</span><br><span class="line">hello.c-&gt;argv[1]</span><br><span class="line">-o-&gt;argv[2]</span><br><span class="line">hello-&gt;argv[3]</span><br><span class="line">execl(&quot;&#x2F;usr&#x2F;bin&#x2F;gcc&quot;, &quot;gcc&quot;, &quot;hello.c&quot;, &quot;-o&quot;, &quot;hello&quot;, NULL);                         |                  |            |            |</span><br><span class="line">                        argv[0]  argv[1] argv[2] argv[3]</span><br><span class="line">用arg, ...作为命令行参数，运行path所表示的可执行文件，创建新进程，并用新进程取代调用进程。</span><br><span class="line">成功不返回，失败返回-1。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int execlp(const char* file, const char* arg, ...);</span><br><span class="line">通过file参数传入可执行文件的名字即可，无需带路径，该函数会遍历PATH环境变量中的所有路径，寻找可执行文件。</span><br><span class="line">execlp(&quot;gcc&quot;, &quot;gcc&quot;, &quot;hello.c&quot;, &quot;-o&quot;, &quot;hello&quot;, NULL);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int execle(const char* path, const char* arg, ..., char* const envp[]);</span><br><span class="line">envp：环境变量，以NULL结尾的字符指针数组</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int execv(const char* path, char* const argv[]);</span><br><span class="line"></span><br><span class="line">char* const a[] &#x3D; &#123;&quot;gcc&quot;, &quot;hello.c&quot;, &quot;-o&quot;, &quot;hello&quot;, NULL&#125;</span><br><span class="line">execv(&quot;&#x2F;usr&#x2F;bin&#x2F;gcc&quot;, a);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int execvp(const char* file, char* const argv[]);</span><br><span class="line">int execve(const char* path, char* const argv[], char* const envp[]);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec(执行)+</span><br><span class="line">l - list，以变长参数表的形式传入命令行参数</span><br><span class="line">p - path，使用PATH环境变量寻找可执行文件</span><br><span class="line">e - environ，以字符指针数组的形式传入环境变量</span><br><span class="line">v - vector，以字符指针数组的形式传入命令行参数</span><br></pre></td></tr></table></figure><p>与fork或vfork函数不同，exec函数不是创建调用进程的子进程，而是创建一个新的进程取代调用进程自身。新进程会用自己的全部地址空间，覆盖调用进程的地址空间，但进程的PID保持不变。调用exec函数不仅改变调用进程的地址空间和进程映像，调用进程的一些属性也发生了变化：<br>1)任何处于阻塞状态的信号都会丢失；<br>2)被设置为捕获的信号会还原为默认操作；<br>3)有关线程属性的设置会还原为缺省值；<br>4)有关进程的统计信息会复位；<br>5)与进程内存有关的任何数据都会丢失，包括内存映射文件；<br>6)标注库在用户空间维护的一切数据结构，如通过malloc函数族动态分配的堆内存，通过atexit/on_exit函数注册的退出处理函数等，都会丢失。<br>但有些属性会被新进程继承下来，比如PID、PPID、实际用户ID和实际组ID、优先级，以及文件描述符(除非该文件描述符带有FD_CLOEXEC标志位)等。</p><p><strong>vfork+exec模式：</strong><br>调用exec函数固然可以创建出新的进程，但是新进程会取代原来的进程。如果既想创建新的进程，同时有希望原来的进程继续存在，则可以考虑使用vfork+exec模式，即在由vfork产生的子进程中调用exec函数，新进程取代了子进程，但父进程依然存在。</p><p>如果一个进程可以根据用户的输入创建不同的进程，并在所建进程结束以后继续重复这个过程，那么这个进程就是Shell：<br>     Shell进程(bash)<br>+-&gt;显示提示符并<br>|      等待用户输入<br>|                | &lt;- 输入：ls -l<br>|               v<br>|       调用vfork函<br>|       数创建子进程 —————&gt; 子进程(ls)</p><p>|                v                                           v<br>|   调用waitpid函数               根据用户的输入调用exec<br>|   等待并回收子进程 &lt;——  函数创建新进程(/bin/ls)<br>|                |<br>+———+</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int system(const char* command);&#x2F;&#x2F;system&#x3D;vfork+exec+waitpid</span><br><span class="line">成功返回command命令行进程的终止状态，失败返回-1。</span><br><span class="line">command - 命令行字符串</span><br><span class="line">如果调用vfork或waitpid函数出错，返回-1。</span><br><span class="line">如果调用exec函数出错，返回127。</span><br><span class="line">如果都成功，返回command进程的终止状态，由waitpid函数的status参数输出。</span><br><span class="line">如果command参数取NULL指针，该函数返回-1表示失败，返回其它非0(真)值表示当前Shell可用，返回0(假)表示不可用。</span><br></pre></td></tr></table></figure><h1 id="十一、信号"><a href="#十一、信号" class="headerlink" title="十一、信号"></a>十一、信号</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p><strong>1)什么是信号？</strong><br>信号是提供异步事件处理机制的软件中断。这些异步事件可能来自硬件设备，也可能来自系统内核，甚至可能来自用户程序。进程之间可以相互发送信号，这使信号成为一种进程间通信(Inter-Process Communication, IPC)的基本手段。信号的异步特性不仅表现为它的产生是异步的，对它的处理同样也是异步的。程序设计者不可能也不需要精确地预见什么时候触发什么信号，也同样无法预见该信号究竟在什么时候会被处理。一切尽在内核操控下异步地发生。</p><p><strong>2)什么是信号处理？</strong><br>每一个信号都有其生命周期：<br>产生：信号被生成，并被发送至系统内核<br>未决：信号被内核缓存，而后被递送至目标进程<br>递送：内核已将信号发送至目标进程<br>           忽略 - 什么也不做。<br>           捕获 - 暂定当前的执行过程，转而调用一个事先写好<br>                     的信号处理函数，待该函数完成并返回后，再<br>                     继续之前被中断的过程。<br>           默认 - 既不忽略该信号，也不用自己定义处理方式，<br>                     而是按照系统默认的方式予以响应。<br>激励(信号)-&gt;响应(信号处理)</p><p><strong>3)信号的名称和编号</strong><br>信号名称：形如SIGXXX的字符串或宏定义，提高可读性。<br>信号编号：整数<br>通过kill -l命令查看当前系统所支持的全部信号名称及其编号。<br>1<del>31，31个不可靠信号，也叫非实时信号。<br>34</del>64， 31个可靠信号，也叫实时信号。<br>共62个信号，注意没有32和33信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SIGHUP(1)，控制终端关闭，终止</span><br><span class="line">SIGINT(2)，用户产生中断符(Ctrl+C)，终止</span><br><span class="line">SIGQUIT(3)，用户产生退出符(Ctrl+\)，终止+转储</span><br><span class="line">SIGBUS(7)，硬件或内存对齐错误，终止+转储</span><br><span class="line">SIGKILL(9)，不能被捕获和忽略，终止</span><br><span class="line">SIGSEGV(11)，无效内存访问，终止+转储</span><br><span class="line">SIGPIPE(13)，向读端已关闭的管道写入，终止</span><br><span class="line">SIGALRM(14)，alarm函数设置的闹钟到期，终止</span><br><span class="line">SIGTERM(15)，可被捕获和忽略，终止</span><br><span class="line">SIGCHLD(17)，子进程终止，忽略</span><br><span class="line">SIGIO(29)，异步I&#x2F;O事件，终止</span><br></pre></td></tr></table></figure><h2 id="2-捕获信号"><a href="#2-捕获信号" class="headerlink" title="2.捕获信号"></a>2.捕获信号</h2><p>#include &lt;signal.h&gt;<br>typedef void (*sighandler_t) (int);//信号处理函数指针<br>                                    |<br>                             函数指针<br>   指向一个接受整型参数且无返回值的函数</p><p>设置针对特定信号的处理方式，即捕获特定的信号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">成功返回原信号处理方式，失败返回SIG_ERR(sighandler_t类型的-1)。</span><br><span class="line">signum - 信号编号</span><br><span class="line">handler - 信号处理函数指针，也可以取以下值：</span><br><span class="line">                 SIG_IGN - 忽略信号</span><br><span class="line">                 SIG_DFL - 默认操作</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义信号处理函数</span><br><span class="line">void sigint (int signum) &#123;</span><br><span class="line">    SIGINT(2)信号的处理代码</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 捕获SIGINT(2)信号</span><br><span class="line">if (signal(SIGINT, sigint) &#x3D;&#x3D; SIG_ERR) &#123;</span><br><span class="line">    perror(&quot;signal&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">signal(SIGINT, SIG_DFL); &#x2F;&#x2F; 按默认方式处理</span><br><span class="line">signal(SIGINT, SIG_IGN); &#x2F;&#x2F; 忽略信号</span><br></pre></td></tr></table></figure><p>​                                        SIGINT(2)<br>​                                               v<br>SIGINT(2)/PID/sigint-&gt;系统内核<br>​                                               v<br>​                             目标进程中的sigint函数</p><p>当一个信号正在被处理的过程中，相同的信号再次产生，该信号会被阻塞，直到前一个信号处理完成，即从信号处理函数中返回，后一个被阻塞的信号才被递送，进而再次执行信号处理函数。当一个不可靠信号正在被处理的过程中，多个相同的信号再次产生，只有第一个信号会被阻塞，其它信号直接丢弃，如果是可靠信号，都会被阻塞，并按照产生的顺序依次被递送。<br>信号处理函数及被其调用的函数都有可能发生重入，由此可能引发无可预知的风险。<br>所有标准I/O函数都是不可重入函数。在信号处理的过程中要慎用。<br>A信号-&gt;A信号处理函数 \ 打印AAAAAA<br>                                        &gt; printf(调试信息);<br>B信号-&gt;B信号处理函数 / 打印BBBBBB<br>AAABBBBBBAAA</p><p>3.信号捕获流程<br>                                     中断<br>主控制流程———         v        ———–&gt;<br>                            /                     <br>信号处理函数    /       ——&gt;      \        用户空间<br>                        /          \      /         \       ———<br>                      /              \  /             \      内核空间<br>内核处理流程———–&gt; ———-&gt;<br>                       do_signal  system_call<br>                handle_signal  sys_sigreturn<br>                  setup_frame  restore_sigcontext<br>信号的本质是一个中断的处理过程，而非多线程的并发过程。<br>线程安全的函数未必是可重入函数。</p><h2 id="4-信号捕获的一次性问题"><a href="#4-信号捕获的一次性问题" class="headerlink" title="4.信号捕获的一次性问题"></a>4.信号捕获的一次性问题</h2><p>在某些非Linux操作系统上，存在信号捕获的一次性问题：<br>即使设置了对某个信号的捕获，只有设置后的第一个该信号被递送时，信号处理函数会被执行，以后再来相同的信号，均按默认方式处理。如果希望对信号的捕获具有持久性，可以在信号处理函数返回前再次设置对该信号的捕获。</p><h2 id="5-太平间信号SIGCHLD-17"><a href="#5-太平间信号SIGCHLD-17" class="headerlink" title="5.太平间信号SIGCHLD(17)"></a>5.太平间信号SIGCHLD(17)</h2><p>子进程死掉后就会向父进程发送SIGCHLD(17)信号。可通过SIGCHLD(17)信号高效地回收子进程僵尸。<br>高效：及时性，适时性。</p><h2 id="6-信号处理的继承与恢复"><a href="#6-信号处理的继承与恢复" class="headerlink" title="6.信号处理的继承与恢复"></a>6.信号处理的继承与恢复</h2><p>1)fork/vfork函数创建的子进程会继承父进程的信号处理方式，直到子进程调用exec函数创建新进程替代其自身为止。<br>2)exec函数创建的新进程会将原进程中被设置为捕获的信号还原为默认处理。在原进程中被忽略的信号于新进程中继续被忽略。</p><h2 id="7-发送信号"><a href="#7-发送信号" class="headerlink" title="7.发送信号"></a>7.发送信号</h2><p>1)通过键盘向当前拥有控制终端的前台进程发送信号</p><ul><li>Ctrl+C -&gt; SIGINT(2)，默认终止进程</li><li>Ctrl+\ -&gt; SIGQUIT(3)，默认终止进程且转储</li><li>Ctrl+Z -&gt; SIGTSTP(20)，默认停止(挂起)进程</li></ul><p>2)来自硬件或者内核的错误和异常引发的信号</p><ul><li>SIGILL(4)，进程试图执行非法指令</li><li>SIGBUS(7)，硬件或总线对齐错误</li><li>SIGFPE(8)，浮点异常</li><li>SIGSEGV(11)，无效内存访问</li><li>SIGPIPE(13)，向无读端的管道写入</li><li>SIGSTKFLT(16)，浮点数协处理器栈错误</li><li>SIGXFSZ(25)，文件资源超限</li><li>SIGPWR(30)，断电</li><li>SIGSYS(31)，无效系统调用</li></ul><p>3)通过kill命令发送信号<br>kill [-信号] PIDs<br>           |<br>缺省发送SIGTERM(15)信号<br>超级用户可以给任何进程发信号，普通用户只能给自己的进程发信号。</p><p>4)调用函数发送信号<br>向特定的进程(组)发送信号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int kill(pid_t pid, int signum);</span><br><span class="line">成功(至少发出去一个信号)返回0，失败返回-1。</span><br><span class="line">pid - 进程(组)标识，可取以下值：</span><br><span class="line">    &lt;-1：向-pid进程组中的所有进程发送信号</span><br><span class="line">    -1: 向系统中的所有进程发送信号</span><br><span class="line">    0: 向调用进程同组的所有进程发送信号</span><br><span class="line">    0: 向进程标识为pid的特定进程发送信号</span><br><span class="line">signum - 信号编号，取0用于检查pid进程是否存在，如果不存在则返回-1，且置errno为ESRCH。</span><br></pre></td></tr></table></figure><p>向调用进程自己发送信号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int raise(int signum);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">signum - 信号编号</span><br><span class="line">raise(SIGINT) &#x3D;&#x3D; kill(getpid(), SIGINT) </span><br></pre></td></tr></table></figure><p>通过raise或kill向调用进程自己发送信号，如果该信号被捕获，则要等到信号处理函数返回后，这两个函数才会返回。（信号不会丢失，不管发送多少次都可以收到）</p><h2 id="8-暂停、睡眠和闹钟"><a href="#8-暂停、睡眠和闹钟" class="headerlink" title="8.暂停、睡眠和闹钟"></a>8.暂停、睡眠和闹钟</h2><p><strong>暂停，即不受时间限制的睡眠：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pause(void);</span><br><span class="line">成功阻塞，失败返回-1。</span><br></pre></td></tr></table></figure><p>该函数使调用进程进入无时限的睡眠状态，即不参与内核调度，直到有信号终止了调用进程或被捕获。如果有信号被调用进程捕获，当信号处理函数返回以后，pause函数才会返回，且返回值为-1，同时置errno为EINTR，表示阻塞的系统调用被信号中断。pause函数要么不返回，要么返回-1，不会返回0。</p><p><strong>受时间限制的睡眠：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unsigned int sleep(unsigned int seconds);</span><br><span class="line">返回0或剩余秒数。</span><br><span class="line">seconds - 以秒为单位的睡眠时限</span><br><span class="line"></span><br><span class="line">int usleep(useconds_t usec);</span><br><span class="line">睡够了返回0，睡不够返回-1，同时置errno为EINTR。</span><br><span class="line">usec - 为微秒为单位的睡眠时限</span><br></pre></td></tr></table></figure><p>该函数使调用进程睡眠seconds秒，除非有信号终止了调用进程或被其捕获。如果有信号被调用进程捕获，在信号函数返回以后，sleep函数才会返回，且返回值为剩余秒数，否则该函数返回0，表示睡眠充足。</p><p><strong>设置闹钟</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line">返回0或先前闹钟的剩余时间。</span><br><span class="line">seconds - 以秒为单位的闹钟时间</span><br></pre></td></tr></table></figure><p>alarm函数使系统内核在该函数被调用以后seconds秒的时候，向调用进程发送SIGALRM(14)信号。若在调用该函数前已设过闹钟且尚未到期，则该函数会重设闹钟，并返回先前所设闹钟的剩余秒数，否则返回0。若seconds参数取0，则取消之前设置过且未到期的闹钟。</p><p>通过alarm函数所设置的定时只是一次性的，即在定时到期时发行一次SIGALRM(14)信号，此后不会再发送该信号。如果希望获得周期性的定时效果，可以在SIGALRM(14)信号的处理函数中继续调用alarm函数，完成下一个定时的设置。</p><h2 id="9-信号集"><a href="#9-信号集" class="headerlink" title="9.信号集"></a>9.信号集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">typedef __sigset_t sigset_t;</span><br><span class="line">#include &lt;sigset.h&gt;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    unsigned long int __val[_SIGSET_NWORDS];</span><br><span class="line">&#125;   __sigset_t;</span><br><span class="line">#define _SIGSET_NWORDS  (1024 &#x2F; (8 * sizeof(unsigned long int)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">填满信号集，即将信号集的全部信号位置1</span><br><span class="line">int sigfillset(sigset_t* sigset);</span><br><span class="line"></span><br><span class="line">清空信号集，即将信号集的全部信号位置0</span><br><span class="line">int sigemptyset(sigset_t* sigset);</span><br><span class="line"></span><br><span class="line">加入信号，即将信号集中的特定信号位置1</span><br><span class="line">int sigaddset(sigset_t* sigset, int signum);</span><br><span class="line"></span><br><span class="line">删除信号，即将信号集中的特定信号位置0</span><br><span class="line">int sigdelset(sigset_t* sigset, int signum);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line"></span><br><span class="line">检查信号，即判断信号集中的特定信号位是否为1</span><br><span class="line">int sigismember(sigset_t* sigset, int signum);</span><br><span class="line">有则返回1，无则返回0，失败返回-1。</span><br></pre></td></tr></table></figure><p><strong>信号与信号集</strong></p><p>信号： 是软件类型的中断，但不是中断，中断是指由外部设备通过硬件请求的方式产生的中断，信号是是由CPU运行程序错误或执行内部程序调用对于异步事件的响应。</p><p> 信号集：信号的一个集合，一个能表示多个信号的数据类型(结构)，能够把 能够把系统支持的62个信号都表示下（都装下）。</p><h2 id="10-信号屏蔽"><a href="#10-信号屏蔽" class="headerlink" title="10.信号屏蔽"></a>10.信号屏蔽</h2><p>1)递送、未决和掩码<br>当信号产生时，系统内核在目标进程的进程表项中，以信号位置1的方式，存储该信号，这个过程就叫做递送。信号从产生到完成递送之间存在一定的时间间隔，处于该间隔状态的信号就是属于未决信号。每个进程都已一个信号掩码，它实际上是一个信号集，位于该信号集中的信号一旦产生，并不会被递送给相应的进程，而是会被阻塞于未决状态。<br>当进程正在执行类似更新数据库、设置硬件状态等敏感任务时，可能不希望被某些信号中断。这是可以通过信号掩码暂时屏蔽而非忽略这些信号，使其一旦产生即被阻塞于未决状态，待特定任务完成以后，在恢复对这些信号的处理。</p><p>2)设置信号掩码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sigprocmask(int how, const sigset_t* sigset, sigset_t* oldset);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">how - 信号掩码的修改方式，可取以下值：</span><br><span class="line">    SIG_BLOCK - 将sigset中的信号加入当前掩码</span><br><span class="line">    SIG_UNBLOCK - 从当前掩码中删除sigset中的信号</span><br><span class="line">    SIG_SETMASK - 将sigset设置为当前掩码</span><br><span class="line">    sigset - 信号集，取NULL则忽略参数</span><br><span class="line">    oldset - 原信号掩码，取NULL则忽略此参数</span><br></pre></td></tr></table></figure><p>3)获取未决信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sigpending(sigset_t* sigset);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">sigset - 输出未决信号集</span><br></pre></td></tr></table></figure><p>4)不可靠信号最多被信号掩码屏蔽一次，在屏蔽期间再有更多的相同信号，一律被丢弃。可靠信号会全部被保留下来，且按照发送的顺序排成队列。</p><h2 id="11-现代版本的信号处理与发送"><a href="#11-现代版本的信号处理与发送" class="headerlink" title="11.现代版本的信号处理与发送"></a>11.现代版本的信号处理与发送</h2><p>经典版本的信号处理与发送：signal/kill(raise)<br>现代版本的信号处理与发送：sigaction/sigqueue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int sigaction(int signum, const struct sigaction* sigact, struct sigaction* oldact);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">signum - 信号编号</span><br><span class="line">sigact - 信号行为</span><br><span class="line">oldact - 输出原来的信号行为，可置NULL</span><br></pre></td></tr></table></figure><p>当signum信号被递送时，按sigact结构所描述的行为响应之。若oldact参数非NULL，则通过该参数输出原来的响应行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction &#123;</span><br><span class="line">    &#x2F;&#x2F; 经典版本的信号处理函数指针</span><br><span class="line">    void (*sa_handler)(int);</span><br><span class="line">    &#x2F;&#x2F; 现代版本的信号处理函数指针</span><br><span class="line">    void (*sa_sigaction)(int, siginfo_t*, void*);</span><br><span class="line">    &#x2F;&#x2F; 信号处理期间的附加掩码集</span><br><span class="line">    sigset_t sa_mask;</span><br><span class="line">    &#x2F;&#x2F; 信号处理标志</span><br><span class="line">    int sa_flags;</span><br><span class="line">    &#x2F;&#x2F; 预留项，目前置NULL</span><br><span class="line">    void (*sa_restorer)(void);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">现代版本的信号处理函数：</span><br><span class="line">void sigint(int signum, siginfo_t* si, void* reserved) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">signum：信号编号</span><br><span class="line">si：信号信息</span><br><span class="line">reserved：保留未用</span><br><span class="line"></span><br><span class="line">typedef struct siginfo &#123;</span><br><span class="line">    &#x2F;&#x2F; 发送信号进程的PID</span><br><span class="line">    pid_t si_pid;            </span><br><span class="line">    &#x2F;&#x2F; 信号附加数据            </span><br><span class="line">    sigval_t si_value;</span><br><span class="line">    ...            </span><br><span class="line">&#125;  siginfo_t;</span><br><span class="line">typedef union sigval &#123;</span><br><span class="line">    int      sival_int; &#x2F;&#x2F; 用整型作为信号附加数据</span><br><span class="line">    void* sival_ptr; &#x2F;&#x2F; 用任意类型的指针作为信号附加数据</span><br><span class="line">&#125;  sigval_t;</span><br></pre></td></tr></table></figure><p>1)增减信号掩码<br>缺省情况下，在信号处理函数的执行过程中，会自动屏蔽这个正在被处理的信号，而对于其他信号则不会被屏蔽。通过sa_mask字段可以人为指定，在信号处理函数执行期间， 除正在被处理的这个信号以外，还想屏蔽哪些信号，并在信号处理函数返回后，自动解除对它们的屏蔽。另一方面，还可以通过为sa_flags字段设置SA_NOMASK/SA_NODEFER标志位，告诉系统内核在信号处理函数执行期间，不要屏蔽这个正在被处理的信号。</p><p>2)选择信号处理函数的风格<br>如果sa_flags字段中没有SA_SIGINFO标志位，则sa_handler字段有效，即使用经典版本的信号处理函数。相反，如果sa_flags字段包含SA_SIGINFO标志位，则sa_sigaction字段有效，即使用现代版本的信号处理函数。</p><p>3)一次性信号处理<br>如果sa_flags字段中包含SA_ONESHOT/SA_RESETHAND标志位，那么对所捕获信号的处理就是一次性的，即在执行完一次信号处理函数后，即恢复为按默认方式处理。</p><p>4)系统调用中断重启<br>诸如pause、sleep、usleep等系统调用的阻塞过程会被信号打断，即在针对某个信号的处理函数返回后，这些系统调用也会从阻塞中返回。如果不希望这类系统调用被所捕获的信号打断，即在针对该信号的处理函数返回后，能够自动重启阻塞过程，而不要返回，可以为sa_flags字段添加SA_RESTART标志位。</p><p><strong>利用信号附加数据实现简单的进程间通信:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int sigqueue(pid_t pid, int signum, const union sigval value);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">pid - 接收信号进程的PID</span><br><span class="line">signum - 信号编号</span><br><span class="line">value - 信号附加数据 -&gt; siginfo::si_value</span><br></pre></td></tr></table></figure><p><strong>12.定时器(alarm闹钟重复性不好)</strong><br>执行时间(真实计时器)=用户时间(虚拟计时器)+内核时间+睡眠时间</p><ul><li><p>执行时间：直观感受墙钟时间</p></li><li><p>用户时间：消耗在用户态的时间</p></li><li><p>内核时间： 消耗在内核态的时间</p></li><li><p>睡眠时间：消耗在等待I/O、睡眠等不被调度的时间</p></li><li><p>执行时间 = 真实计时器定时</p></li><li><p>实用计时器定时 = 虚拟计时器定时+内核时间</p></li></ul><p>利用真实计时器定时，到期信号：SIGALRM(14)<br>利用虚拟计时器定时，到期信号：SIGVTALRM(26)<br>利用实用计时器定时，到期信号：SIGPROF(27)</p><p>基于每钟计时器的定时都有两个参数：</p><ul><li>初始间隔 - 从开始定时到发出第一个到期信号的时间间隔。</li><li>重复间隔 - 每相邻两个到期信号的时间间隔。</li></ul><p>设置、开启和关闭定时器函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int setitimer(int which, const struct itimerval* new_value, struct itimerval* old_value);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">which - 指定设置哪个定时器，可取以下值：</span><br><span class="line">    ITIMER_REAL: 基于真实计时器的定时</span><br><span class="line">    ITIMER_VIRTUAL: 基于虚拟计时器的定时</span><br><span class="line">    ITIMER_PROF: 基于实用计时器的定时</span><br><span class="line">new_value - 新设置值</span><br><span class="line">old_value - 输出原设置值，可置NULL</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct itimerval &#123;</span><br><span class="line">    &#x2F;&#x2F; 重复间隔，取0表示只发一个信号，不重复，没有周期性</span><br><span class="line">    struct timeval it_interval;</span><br><span class="line">    &#x2F;&#x2F; 初始间隔，取0表示停止定时器，不再发信号</span><br><span class="line">    struct timeval it_value;</span><br><span class="line">&#125;;</span><br><span class="line">struct timeval &#123;</span><br><span class="line">    long tv_sec; &#x2F;&#x2F; 秒</span><br><span class="line">    long tv_usec; &#x2F;&#x2F; 微秒</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如：5秒以后开始发SIGALRM(14)信号，以后每隔3毫秒再发一次该信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct itimerval it;</span><br><span class="line">it.it_value.tv_sec &#x3D; 5;</span><br><span class="line">it.it_value.tv_usec &#x3D; 0;</span><br><span class="line">it.it_interval.tv_sec &#x3D; 0;</span><br><span class="line">it.it_interval.tv_usec &#x3D; 3000;</span><br><span class="line">setitimer(ITIMER_REAL, &amp;it, NULL); &#x2F;&#x2F; 开</span><br><span class="line">...</span><br><span class="line">it.it_value.tv_sec &#x3D; 0;</span><br><span class="line">setitimer(ITIMER_REAL, &amp;it, NULL); &#x2F;&#x2F; 关</span><br></pre></td></tr></table></figure><p>如果希望立即启动定时器，初始间隔至少是1微秒。</p><p>获取当前定时器设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int getitimer(int which, struct itimerval* curr_value);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">which - 指定设置哪个定时器，可取以下值：</span><br><span class="line">    ITIMER_REAL: 基于真实计时器的定时</span><br><span class="line">    ITIMER_VIRTUAL: 基于虚拟计时器的定时</span><br><span class="line">    ITIMER_PROF: 基于实用计时器的定时</span><br><span class="line">curr_value - 当前设置值</span><br></pre></td></tr></table></figure><h1 id="十二、进程间通信"><a href="#十二、进程间通信" class="headerlink" title="十二、进程间通信"></a>十二、进程间通信</h1><h2 id="1-什么是进程间通信"><a href="#1-什么是进程间通信" class="headerlink" title="1.什么是进程间通信"></a>1.什么是进程间通信</h2><p>Unix/Linux系统中每个进程都拥有独立的4G字节大小的虚拟内存空间。其中高地址的1G字节被映射到相同的物理内存区域，用于保存内核代码和数据。低地址的3G字节作为保存用户代码和数据的用户空间，被映射到彼此不同物理内存。因此同一个虚拟内存地址，在不同的进程中，会被映射到不同的物理内存区域，在多个进程之间以交换虚拟内存地址的方式交换数据是不可能的。鉴于进程之间天然的内存壁垒，为了能够在不同进程之间高效地交换数据，需要有一种专门的机制，这就是所谓的进程间通信(Inter-Process Communication, IPC)。</p><h2 id="3-简单的进程间通信"><a href="#3-简单的进程间通信" class="headerlink" title="3.简单的进程间通信"></a>3.简单的进程间通信</h2><p>1)命令行参数<br>进程1组织命令行参数-&gt;execl-&gt;进程2处理命令行参数<br>进程1：username，password<br>execl(…, “login”, username, password, NULL)<br>                                     |                   |<br>进程2：                   argv[1]       argv[2]</p><p>2)环境变量<br>进程1组织环境变量-&gt;execle-&gt;进程2处理环境变量<br>进程1：username，password<br>sprintf(envp[0], “USERNAME=%s”, username);<br>sprintf(envp[1], “PASSWORD=%s”, password);<br>execle(…, envp);<br>进程2：envp[0]-&gt;USERNAME=minwei<br>             envp[1]-&gt;PASSWORD=tarena</p><p>3)wait/waitpid<br>进程1-&gt;fork/vfork+exec-&gt;进程2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait&#x2F;waitpid(..., &amp;status);     main-&gt;return ...;</span><br><span class="line">                      ^       exit&#x2F;_exit&#x2F;_Exit(...)</span><br><span class="line">                      |_________________________|</span><br></pre></td></tr></table></figure><p>4)内存映射文件<br>进程1[虚拟内存]–&gt;文件区域&lt;–[虚拟内存]进程2</p><p>5)信号<br>进程1—-信号+附加数据—&gt;进程2</p><h2 id="4-传统的进程间通信"><a href="#4-传统的进程间通信" class="headerlink" title="4.传统的进程间通信"></a>4.传统的进程间通信</h2><p><strong>1)有名管道（借用内存，速度快）</strong></p><p>进程1&lt;-管道文件-&gt;进程2<br>有名管道：是一种文件，内存文件，有i节点没有数据块<br>全双工通信</p><p>创建有名管道文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int mkfifo(const char* pathname, model_t mode);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">pathname - 文件路径</span><br><span class="line">mode - 权限模式</span><br></pre></td></tr></table></figure><p>打开、关闭、读取和写入有名管道文件的方法与读写普通文件无异：open/read/write/close。<br>编程模型<br>进程A                                进程B<br>创建管道     mkfifo<br>打开管道     open              打开管道<br>读写管道     read/write    读写管道<br>关闭管道     close              关闭管道<br>删除管道     unlink</p><p><strong>2)无名管道</strong><br>           / -无名管道-&gt; <br>父进程                         子进程<br>           \ &lt;-无名管道- /<br>半双工通信</p><p>创建无名管道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int pipefd[2]);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">pipefd - 输出两个文件描述符：</span><br><span class="line">               pipefd[0]表示管道的读端</span><br><span class="line">               pipefd[1]表示管道的写端</span><br></pre></td></tr></table></figure><p>1)父进程调用pipe函数在系统内核中创建无名管道对象，同时得到与该对象相关联的两个文件描述符，一个用于读取，另一个用于写入；<br>2)父进程调用fork函数，创建子进程，子进程复制父进程的文件描述符表，因此子进程也同样拥有可用于读写管道对象的两个文件描述符。<br>3)负责写数据进程关闭管道读端，即pipefd[0]，而负责读数据的继承关闭管道的写端，即pipefe[1]；<br>4)父子进程通过各自持有的文件描述符，分别向管道写入和读取数据，待完成通信后再各自关闭所持有的文件描述符，内核中的无关管道对象即被释放。<br>代码：pipe.c</p><p><strong>基于管道通信的特殊情况</strong><br>1)从写端已被关闭的管道中读取<br>只要管道缓冲区中还有数据，依然可被正常读取，一直读到缓冲区空，这时read函数会返回0（既不是返回-1也不是阻塞），如同读到文件尾。</p><p>2)向读端已被关闭的管道中写入<br>会直接触发SIGPIPE(13)信号。该信号的默认操作是终止执行写入动作的进程。但如果执行写入动作的进程已经事先将SIGPIPE(13)信号设置为忽略或捕获，这时虽然进程不会因为写入无读端的管道而被终止，但write函数会返回-1，并置errno为EPIPE。</p><p>3)在/usr/include/linux/limits.h头文件中定义的PIPE_BUF宏(4096)表示管道写缓冲区的大小。如果写管道时发现缓冲区中的空闲空间不足以容纳此次write调用所要写入的字节数，则write函数会阻塞，直到缓冲区中的空闲空间变得足够大为止。如果同时有多个进程向同一个管道写入数据，而每次调用write函数写入的字节数都不大于BUF_SIZE，则这些write操作不会互相穿插(原子化，atomic)，反之单次写入的字节数超过了BUF_SIZE，则它们的write操作可能会相互穿插。读取一个缓冲区为空的管道，只要其写端没有被关闭，读操作就会阻塞，除非该读文件描述符被设置为非阻塞(O_NONBLOCK)，此时会立即返回失败，并置errno为EAGAIN。</p><p><strong>管道符号的原理</strong><br>命令1    |    命令2    |    命令3 …<br>   |                 |                  |<br>输出&gt;管道&gt;输入<br>                    输出&gt;管道&gt;输入<br>                                        输出&gt;…<br>A | B<br>Shell进程：<br>int pipefd[2];<br>pipe(pipefd); // 创建无名管道<br>vfork(); // 产生一个子进程1<br>    子进程1:<br>    close(pipefd[0]); // 关闭无名管道的读端<br>    dup2(pipefd[1], STDOUT_FILENO); // 写端=标准输出<br>    exec(A) // 创建A进程，继承了原进程的文件描述符表<br>                  // 在A进程中，写端=标准输出<br>                  // printf/puts将数据写入无名管道的写端<br>vfork(); // 产生一个子进程2<br>    子进程2:<br>    close(pipefd[1]); // 关闭无名管道的写端<br>    dup2(pipefd[0], STDIN_FILENO); // 读端=标准输入<br>    exec(B) // 创建B进程，继承了原进程的文件描述符表<br>                  // 在B进程集中，读端=标准输入<br>                  // scanf/gets从无名管道的读端读取数据<br>A和B就成为协作进程，A写入数据进管道，B从管道中读取A写入的数据。</p><h2 id="5-套接字进程间通信-BSD"><a href="#5-套接字进程间通信-BSD" class="headerlink" title="5.套接字进程间通信(BSD)"></a>5.套接字进程间通信(BSD)</h2><p>进程1&lt;-本地套接字文件-&gt;进程2<br>                       |<br>本地套接字文件：内存文件，有i节点没有数据块，<br>以一种统一的编程模式和接口库，处理网络和本机通信。</p><h2 id="6-XSI进程间通信-SVR4"><a href="#6-XSI进程间通信-SVR4" class="headerlink" title="6.XSI进程间通信(SVR4)"></a>6.XSI进程间通信(SVR4)</h2><p>1)消息队列：进程1—消息3|消息2|消息1–&gt;进程2<br>2)共享内存：进程1[虚拟内存]-&gt;物理内存&lt;-[虚拟内存]进程2<br>3)信号量集：多个进程竞争有限的资源11.XSI的IPC对象</p><h3 id="1-IPC对象的标识符-ID-和键-KEY"><a href="#1-IPC对象的标识符-ID-和键-KEY" class="headerlink" title="1)IPC对象的标识符(ID)和键(KEY)"></a>1)IPC对象的标识符(ID)和键(KEY)</h3><p>IPC对象在系统内核中的唯一名称用键(KEY)表示。不同的进程可以通过键来引用该IPC对象。一旦进程获得了该IPC对象，即通过其标识(ID)来称谓该对象。<br>     IPC对象(键)        内核空间<br>— / — | — \ —————<br>    /键    |键     \键    用户空间<br>进程1 进程2 进程3<br>  ID1   ID2    ID3<br>#include &lt;sys/ipc.h&gt;<br>key_t ftok(const char* pathname, int proj_id);<br>成功返回IPC对象的键，失败返回-1。<br>pathname - 一个真实存在的路径，使用该路径的i节点号<br>proj_id - 项目ID，仅低8为有效，-128<del>127/0</del>255<br>相同项目使用相同的pathname和proj_id，保证key的一致性<br>不同项目使用不同的pathname或proj_id，避免key发生冲突</p><h3 id="2-IPC对象的编程接口"><a href="#2-IPC对象的编程接口" class="headerlink" title="2)IPC对象的编程接口"></a>2)IPC对象的编程接口</h3><p>A.创建或获取IPC对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 共享内存</span><br><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">&#x2F;&#x2F; 消息队列</span><br><span class="line">int msgget(key_t key, int msgflg);</span><br><span class="line">&#x2F;&#x2F; 信号量集</span><br><span class="line">int semget(key_t key, int nsems, int semflg);</span><br></pre></td></tr></table></figure><p>B.控制或销毁IPC对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 共享内存</span><br><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds* buf);</span><br><span class="line">&#x2F;&#x2F; 消息队列</span><br><span class="line">int msgctl(int msqid, int cmd, struct msqid_ds* buf);</span><br><span class="line">&#x2F;&#x2F; 信号量集</span><br><span class="line">int semctl(int semid, int semnum, int cmd, union semun arg);</span><br><span class="line">cmd - 控制命令，可取以下值：</span><br><span class="line">    IPC_STAT: 获取IPC对象的属性</span><br><span class="line">    IPC_SET: 设置IPC对象的属性</span><br><span class="line">    IPC_RMID: 删除IPC对象</span><br></pre></td></tr></table></figure><p>C.IPC对象的权限结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct ipc_perm &#123;</span><br><span class="line">    key_t                   __key; &#x2F;&#x2F; 键</span><br><span class="line">    uid_t                   uid;     &#x2F;&#x2F; 拥有者用户</span><br><span class="line">    gid_t                   gid;     &#x2F;&#x2F; 拥有者组</span><br><span class="line">    uid_t                   cuid;    &#x2F;&#x2F; 创建者用户</span><br><span class="line">    gid_t                   cgid;    &#x2F;&#x2F; 创建者组</span><br><span class="line">    unsigned short mode; &#x2F;&#x2F;  权限</span><br><span class="line">    unsigned short __seq;  &#x2F;&#x2F; 序号</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中只有uid、gid和model三个字段可以在创建完成以后被修改。</p><h3 id="3-共享内存"><a href="#3-共享内存" class="headerlink" title="3)共享内存"></a>3)共享内存</h3><p>两个或者更多进程，共享一块由系统内核负责维护的物理内存，其地址空间通常被映射到每个进程虚拟内存堆和栈之间的不同区域。<br><strong>共享内存的属性结构：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct shmid_ds &#123;</span><br><span class="line">    struct ipc_perm shm_prem;  &#x2F;&#x2F; 权限结构</span><br><span class="line">    size_t          shm_segsz;  &#x2F;&#x2F; 字节数</span><br><span class="line">    time_t          shm_atime;  &#x2F;&#x2F; 最后加载时间</span><br><span class="line">    time_t          shm_dtime;  &#x2F;&#x2F; 最后卸载时间</span><br><span class="line">    time_t          shm_ctime;  &#x2F;&#x2F; 最后改变时间</span><br><span class="line">    pid_t           shm_cpid;    &#x2F;&#x2F; 创建进程的PID</span><br><span class="line">    pit_t           shm_lpid;     &#x2F;&#x2F; 最后加(卸)载进程的PID</span><br><span class="line">    shmatt_t        shm_nattch; &#x2F;&#x2F; 当前加载计数</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>获取一个共享内存标识符或创建一个共享内存对象:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">成功返回共享内存的标识符，出错返回-1，错误原因存于error中。</span><br><span class="line">size - 共享内存的字节数，按页向上取整。获取已有共享内存对象时可置0。</span><br><span class="line">shmflg - 创建标志:</span><br><span class="line">    0: 获取，不存在即失败。</span><br><span class="line">    IPC_CREATE - 创建兼获取，不存在即创建，已存在直接获取</span><br><span class="line">    IPC_EXCL - 不存在即创建，已存在直接报错。</span><br></pre></td></tr></table></figure><p><strong>加载共享内存到虚拟内存，加载虚拟内存和物理内存间的映射:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void* shmat(int shmid, const void* shmaddr, int shmflags);</span><br><span class="line">成功返回共享内存起始地址，失败返回void*类型的-1。</span><br><span class="line">shmid - 共享内存标识</span><br><span class="line">shmaddr - 共享内存起始地址，置NULL由系统内核选择</span><br><span class="line">shmflags - 加载标志，可取以下值：</span><br><span class="line">    0: 可读可写</span><br><span class="line">    SHM_RDONLY: 只读</span><br><span class="line">    SHM_RND: 若shmaddr非空且不是页边界，则将其调整至页边界。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>卸载共享内存</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int shmdt(const void* shmaddr);</span><br><span class="line">成功返回0，失败返回-1，错误原因存于error中。</span><br></pre></td></tr></table></figure><p><strong>控制或销毁共享内存</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf)</span><br><span class="line">成功返回0，失败返回，-1错误原因存于error中。</span><br></pre></td></tr></table></figure><p>shmat函数负责将给定共享内存映射到调用进程的虚拟内存空间，返回映射区的起始地址，同时将系统内核中共享内存对象的加载计数(shm_nattch)加1。调用进程在获得shmat函数返回的共享内存起始地址以后，就可以象访问普通内存一样访问该共享内存中的数据。</p><p>shmdt函数负责从调用进程的虚拟内存中解除shmaddr所指向的映射区到共享内存的映射，同时将系统内核中共享内存对象的加载计数(shm_nattch)减1。因此加载计数为0的共享内存必定是没有任何进程使用的。</p><p>shmctl(…, IPC_RMID, …)调用可以用于销毁共享内存，但并非真的销毁，而只是做一个销毁标记，禁止任何进程对该共享内存形成新的加载，但已有的加载依然保留。只有当其使用者们纷纷卸载，直至其加载计数降为0时，共享内存才会真的被销毁。</p><p>通过共享内存实现进程间通信，可以直接访问由系统内核维护的公共内存区域，不需要额外构建用户缓冲区，也不需要在用户缓冲区和内核缓冲区之间来回复制数据。因此共享内存是速度最快的进程间通信机制。但是共享内存因为缺乏必要的同步机制，往往需要借助其它进程间通信策略提供某种形式的停等机制。</p><h3 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4)消息队列"></a>4)消息队列</h3><p>消息队列是由单个的类型各异的一系列消息结构组成的链表。<br>    消息       +-&gt;  消息<br>———       |   ———-<br>消息类型    |    消息类型<br>数据长度    |    数据长度<br>消息数据    |    消息数据<br>消息指针–+   消息指针–&gt;<br>    尾                          首</p><p>最大可发送消息字节数：8192(8K)<br>最大全队列消息字节数：16384(16K)<br>最大全系统消息队列数：16<br>最大全系统消息总个数：262144</p><p>获取一个消息队列或者创建一个消息队列:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int msgget(key_t key, int msgflg);</span><br><span class="line">                           |</span><br><span class="line">                      0&#x2F;IPC_CREAT&#x2F;IPC_EXCL</span><br></pre></td></tr></table></figure><p>发送消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int msgsnd(</span><br><span class="line">    int                msqid,   &#x2F;&#x2F; 消息队列标识</span><br><span class="line">    const void* msgp,    &#x2F;&#x2F; 一个指针-&gt;| 消息类型(4字节) | 消息数据 |</span><br><span class="line">    size_t           msgsz,   &#x2F;&#x2F;消息数据的长度   &lt;--长度--&gt;</span><br><span class="line">    int                msgflg  &#x2F;&#x2F; 0阻塞&#x2F;IPC_NOWAIT非阻塞</span><br><span class="line">);</span><br><span class="line">成功返回0，失败返回-1。</span><br></pre></td></tr></table></figure><p>msgsnd函数的msgp参数所指向的内存中包含4个字节大小的消息类型，其值必须大于0，但该函数的msgsz参数所表示的期望发送字节数却不包含消息类型所占的4个字节。<br>如果系统内核中的消息未达上限，则msgsnd函数会将欲发送消息加入消息队列并立即返回0，否则该函数会阻塞，直到系统内核允许加入新消息为止(比如有消息因被接收而离开消息队列)。若msgflg参数中包含IPC_NOWAIT位，则msgsnd函数在系统内核中的消息已达上限的情况下不会阻塞，而是返回-1，并置errno为EAGAIN。</p><p>接收消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int msgrcv(</span><br><span class="line">    int      msqid,    &#x2F;&#x2F; 消息队列标识</span><br><span class="line">    void* msgp,     &#x2F;&#x2F; -&gt;| 消息类型(4字节) | 消息数据缓冲区 |</span><br><span class="line">    size_t msgsz,    &#x2F;&#x2F;                  &lt;-----长度-----&gt;</span><br><span class="line">    long   msgtyp, &#x2F;&#x2F; 消息类型</span><br><span class="line">    int      msgflg   &#x2F;&#x2F; 0阻塞&#x2F;IPC_NOWAIT非阻塞&#x2F;...</span><br><span class="line">);</span><br><span class="line">成功返回实际接收到的消息数据的长度，失败返回-1。</span><br><span class="line">msgtyp可取以下值：</span><br><span class="line">    &gt;0 - 提取消息队列中的第一条消息而无论其类型。</span><br><span class="line">    0 - msgflg不含MSG_EXCEPT位，提取第一条类型为msgtyp的消息，msgflg含MSG_EXCEPT位，提取第一条类型不为msgtyp的消息。</span><br><span class="line">    &lt;0 - 提取队列中类型小于或等于|msgtyp|的消息，类型越小的越先被提取。</span><br></pre></td></tr></table></figure><p>注意msgrcv函数的msgp参数所指向的内存块中包含4字节的消息类型，其值由该函数输出，但该函数的msgsz参数所表示的期望接收字节数以及该函数所返回的实际接收字节数都不包含消息类型4个字节。<br>若存在与msgtyp参数匹配的消息，但是数据长度大于msgsz参数，且msgflg参数包含MSG_NOERROR位，则置截取该消息数据的前msgsz字节返回，剩余部分直接丢弃；但如果msgflg参数不包含MSG_NOERROR位，则不处理该消息，直接返回-1，并置errno为E2BIG。<br>msgrcv函数根据msgtyp参数对消息队列中消息有选择地接收，只有满足条件的消息才会被复制到应用程序缓冲区并从内核中删除。如果满足msgtyp条件的消息不只一条，则按照先进先出的规则提取。<br>若消息队列中有可接收消息，则msgrcv函数会将该消息移出消息队列，并立即返回所接收到的消息数据字节数，表示接收成功，否则此函数会阻塞，直到消息队列中有可接收消息为止。若msgflg参数包含IPC_NOWAIT位，则msgrcv函数在消息队列中没有可接收消息的情况下不会阻塞，而是返回-1，并置errno为ENOMSG。</p><h3 id="5-信号量集"><a href="#5-信号量集" class="headerlink" title="5)信号量集"></a>5)信号量集</h3><p>资源的需求者多于资源本身，如何协调有限资源在多数需求者之间的分配，以使每个资源需求者都有相对均衡的几率获得其所要求的资源。<br>系统内核中为每一种资源维护一个资源计数器，其值为当前空闲资源的数量，每当一个进程试图获取该种资源时，会先尝试减少其计数器的值，如果该计数器的值够减(计数器&gt;=0)，则说明空闲资源足够，该进程即获得资源，如果该计数器的值不够减，则说明空闲资源不够，该进程即进入等待模式，等候其它拥有该种资源的进程释放资源。任何一个拥有该种资源的进程，一旦决定释放该资源，都必须将其计数器的值予以增加，以表示空闲资源量的增加，为其它等候该资源的进程提供条件。<br>用一个信号量表示一种类型资源，其值为该类型资源的空闲数量。用由多个信号量组成的信号量集表示多种类型的资源。</p><p>创建或获取信号量集：<br>#include &lt;sys/sem.h&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int semget(key_t key, int nsems, int semflg);</span><br><span class="line">成功返回信号量集标识符，失败返回-1。</span><br><span class="line">key - 信号量集键</span><br><span class="line">nsems - 信号量个数，即资源的种类数</span><br><span class="line">semflg - 创建标志，可取以下值：</span><br><span class="line">    0 - 获取，不存在即失败</span><br><span class="line">    IPC_CREAT - 创建，不存在即创建，已存在即获取</span><br><span class="line">    IPC_EXCL - 排斥，已存在即失败</span><br></pre></td></tr></table></figure><p>操作信号量集：减操作-&gt;拥有资源…释放资源-&gt;加操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int semop(int semid, struct sembuf* sops, unsigned nsops);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">semid - 信号量集标识</span><br><span class="line">sops - 操作结构数组</span><br><span class="line">nsops - 操作结构数组长度</span><br><span class="line"></span><br><span class="line">struct sembuf &#123;</span><br><span class="line">    unsigned short sem_num; &#x2F;&#x2F; 信号量编号(集合索引)</span><br><span class="line">    short          sem_op;     &#x2F;&#x2F; 操作数(-获取&#x2F;+释放)</span><br><span class="line">    short          sem_flg;     &#x2F;&#x2F; 操作标志(0&#x2F;IPC_NOWAIT)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sops指针指向一个struct sembuf类型的结构体数组，其中每个元素都是一个struct sembuf类型的结构体，该结构体包含三个字段，用于表示针对信号量集中的一个特定信号量的特定操作。</p><p>semid=0                        semid=0<br>———- –semop()-&gt; ———-<br>   0: 15            -1               0: 14<br>   1: 21                               1: 21<br>   2: 33           +1               2: 34<br>   3: 42            -1               3: 41<br>sops</p><p>0: {0, -1, 0}<br>1: {2, 1, 0}<br>2: {3, -1, 0}</p><p>如果sem_op字段的值为负，则从semid信号量集第sem_num个信号量的值中减去|sem_op|，以表示对资源的获取；如果不够减(信号量的值不能为负)，则此函数会阻塞，直到够减为止，以表示对资源的等待，但如果sem_flg包含IPC_NOWAIT位，则即使不够减也不会阻塞，而是返回-1，并置errno为EAGAIN。</p><p>销毁或控制信号量集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int semctl(int semid, int semnum, int cmd, ...);</span><br><span class="line">成功返回0或其它与cmd有关的值，失败返回-1。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">A.销毁信号量集</span><br><span class="line">int semctl(int semid, 0, IPC_RMID); -&gt; 0&#x2F;-1</span><br><span class="line"></span><br><span class="line">B.获取信号量集中每个信号量的值</span><br><span class="line">unsigned short array[4]; &#x2F;&#x2F; 每个信号量的值</span><br><span class="line">int semctl(int semid, 0, GETALL, array); -&gt; 0&#x2F;-1</span><br><span class="line"></span><br><span class="line">C.设置信号量集中每个信号量的值</span><br><span class="line">unsigned short array[4] &#x3D; &#123;5, 5, 5, 5&#125;; &#x2F;&#x2F; 每个信号量的值</span><br><span class="line">int semctl(int semid, 0, SETALL, array); -&gt; 0&#x2F;-1</span><br><span class="line"></span><br><span class="line">D.获取信号量集中特定信号量的值</span><br><span class="line">int semctl(int semid, int semnum, GETVAL);</span><br><span class="line">    -&gt;semid信号量集中第semnum个信号量的值&#x2F;-1</span><br><span class="line">    </span><br><span class="line">E.设置信号量集中特定信号量的值</span><br><span class="line">int semctl(int semid, int semnum, SETVAL, int val);-&gt;0&#x2F;-1</span><br><span class="line">将semid信号量集中第semnum个信号量的值设置为val</span><br></pre></td></tr></table></figure><h3 id="进程间的通信（IPC）的方式总结："><a href="#进程间的通信（IPC）的方式总结：" class="headerlink" title="进程间的通信（IPC）的方式总结："></a>进程间的通信（IPC）的方式总结：</h3><p><strong>命令行参数和环境变量(给main函数传参)</strong><br>    初始化设置</p><p><strong>回收进程退出码(接收main函数的返回值或者exit函数的参数)</strong><br>    获得终止信息</p><p><strong>内存映射文件</strong><br>    通过内存的方式操作共享文件，读写磁盘数据<br>    速度慢但持久性好</p><p><strong>信号</strong><br>    简单，异步，信息量有限，效率不高，可靠性不佳</p><p><strong>有名管道或本地套接字</strong><br>    非近亲进程之间的中等规模数据通信</p><p><strong>无名管道</strong><br>    近亲进程之间的中等规模数据通信</p><p><strong>共享内存</strong><br>    大数据量的快速数据通信<br>    缺乏同步机制，需要依赖其它IPC机制实现同步</p><p><strong>消息队列</strong><br>    天然的同步性，根据类型做细分<br>    适用于中等规模数据通信</p><p><strong>信号量集</strong><br>    多数进程竞争少数资源</p><h3 id="6-IPC命令"><a href="#6-IPC命令" class="headerlink" title="6)IPC命令"></a>6)IPC命令</h3><p>查看IPC对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ipcs -m, m&#x3D;memory, 共享内存对象</span><br><span class="line">ipcs -q, q&#x3D;queue, 消息队列对象</span><br><span class="line">ipcs -s, s&#x3D;semphore, 信号量集对象</span><br><span class="line">ipcs -a, a&#x3D;all, 全部IPC对象</span><br></pre></td></tr></table></figure><p>删除IPC对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -m &lt;共享内存对象标识&gt;</span><br><span class="line">ipcrm -q &lt;消息队列对象标识&gt;</span><br><span class="line">ipcrm -s &lt;信号量集对象标识&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;十、进程&quot;&gt;&lt;a href=&quot;#十、进程&quot; class=&quot;headerlink&quot; title=&quot;十、进程&quot;&gt;&lt;/a&gt;十、进程&lt;/h1&gt;&lt;h2 id=&quot;1-进程的基本概念&quot;&gt;&lt;a href=&quot;#1-进程的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.进程的基本概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.进程的基本概念&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;程序：磁盘上的可执行文件。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>UinxC-IO编程2</title>
    <link href="https://guoqiang-gump.github.io/2021/05/03/UinxC-IO%E7%BC%96%E7%A8%8B2/"/>
    <id>https://guoqiang-gump.github.io/2021/05/03/UinxC-IO%E7%BC%96%E7%A8%8B2/</id>
    <published>2021-05-03T03:34:17.000Z</published>
    <updated>2021-05-05T02:08:29.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="九、文件"><a href="#九、文件" class="headerlink" title="九、文件"></a>九、文件</h1><h2 id="1-文件系统的物理结构"><a href="#1-文件系统的物理结构" class="headerlink" title="1.文件系统的物理结构"></a>1.文件系统的物理结构</h2><p>1)硬盘的物理结构：驱动臂、盘片、主轴、磁头、控制器</p><p>2)磁表面存储器的读写原理</p><a id="more"></a><p>硬盘片的表面覆盖着薄薄的磁性涂层，涂层中含有无数微小的磁性颗粒，谓之磁畴。相邻的若干磁畴组成一个磁性存储元，以其剩磁的极性表示二进制数字0和1。为磁头的写线圈中施加脉冲电流，可把一位二进制数组转换为磁性存储元的剩磁极性。利用磁电变换，通过磁头的读线圈，可将磁性存储元的剩磁极性转换为相应的电信号，表示二进制数。</p><p>3)磁道和扇区<br>磁盘旋转，磁头固定，每个磁头都会在盘片表面画出一个圆形轨迹。改变磁头位置，可以形成若干大小不等的同心圆，这些同心圆就叫做磁道(Track)。每张盘片的每个表面上都有成千上万个磁道。一个磁道，以512字节为单位，分成若干个区域，其中的每个区域就叫做一个扇区(Sector)。扇区是文件存储的基本单位。</p><p>4)柱面、柱面组、分区和磁盘驱动器<br>硬盘中，不同盘片相同半径的磁道所组成的圆柱称为柱面(Cylinder)。整个硬盘的柱面数与每张盘片的磁道数相等。<br>硬盘上的每个字节需要通过以下参数定位：<br>磁头号：确定哪个盘面    <br>柱面号：确定哪个磁道     &gt; 磁盘I/O<br>扇区号：确定哪个区域     /<br>偏移量：确定扇区内的位置<br>若干个连续的柱面构成一个柱面组<br>若干个连续的柱面组构成一个分区<br>每个分区都建有独立的文件系统<br>若干分区构成一个磁盘驱动器</p><h2 id="2-文件系统的逻辑结构"><a href="#2-文件系统的逻辑结构" class="headerlink" title="2.文件系统的逻辑结构"></a>2.文件系统的逻辑结构</h2><p>磁盘驱动器：| 分区 | 分区 | 分区 |<br>分区：| 引导块 | 超级块 | 柱面组 | 柱面组 | 柱面组 |<br>柱面组：| 引导块副本| 柱面组信息 | i节点映射表 | 块位图 | i节点表 | 数据块集 |<br>根据目录文件中记录的i节点编号检索i节点映射表，获得i节点下标，用该下标查i节点表，获得i节点，i节点中包含了数据块索引表，利用数据块索引从数据块集中读取数据块，即获得文件数据。</p><ul><li>直接块：存储文件实际数据内容</li><li>间接块：存储下级文件数据块索引表</li></ul><h2 id="3-文件分类"><a href="#3-文件分类" class="headerlink" title="3.文件分类"></a>3.文件分类</h2><p>普通文件(-)：可执行程序、文本、图片、音频、视频、网页<br>目录文件(d)：该目录中每个硬链接名和i节点号的对应表<br>符号链接文件(l)：存放目标文件的路径<br>管道文件(p)：有名管道，进程间通信<br>套接字文件(s)：进程间通信<br>块设备文件(b)：按块寻址，顺序或随机读写<br>字符设备文件(c)：按字节寻址，只能以字节为单位顺序读写</p><h2 id="4-文件的打开与关闭"><a href="#4-文件的打开与关闭" class="headerlink" title="4.文件的打开与关闭"></a>4.文件的打开与关闭</h2><p>打开：在系统内核中建立一套数据结构，用于访问文件<br>关闭：释放打开文件过程中建立的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp &#x3D; fopen(&quot;reame.txt&quot;, &quot;r&quot;);&#x2F;&#x2F;C语言库函数</span><br><span class="line">fread(fp, ...);</span><br></pre></td></tr></table></figure><p><strong>打开已有的文件或创建新文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int open(const char* pathname, int flags, mode_t mode);&#x2F;&#x2F;系统调用</span><br><span class="line">成功返回文件描述符，失败返回-1。</span><br><span class="line">pathname - 文件路径</span><br><span class="line">flags - 文件状态标志，可取以下值：</span><br><span class="line">    O_RDONLY - 只读  \</span><br><span class="line">    O_WRONLY - 只写  &gt; 只选其一</span><br><span class="line">    O_RDWR - 读写    &#x2F;</span><br><span class="line">    O_APPEND - 追加</span><br><span class="line">    O_CREAT - 创建，不存在即创建，已存在即打开，除非与以下两个标志之一合用，由此标志mode参数才有效。</span><br><span class="line">    O_EXCL - 排它，已存在即失败</span><br><span class="line">    O_TRUNC - 清空，已存在即清空，同时有O_WRONLY或O_RDWR</span><br><span class="line">    O_SYNC - 写同步，在数据被写到磁盘之前写操作不会完成，读操作本来就是同步的，此标志对读操作没有意义</span><br><span class="line">    O_ASYNC - 异步，在文件可读写时产生一个SIGIO信号，在对信号的处理过程中读写I&#x2F;O就绪的文件，只能用于终端设备或网络套接字，而不能用于磁盘文件</span><br><span class="line">    O_NONBLOCK - 非阻塞，读操作不会因为无数据可读而阻塞，写操作也不会因为缓冲区满而阻塞，相反会返回失败，并设置特定的errno</span><br><span class="line">mode - 权限模式，三位八进制：0XXX &#x3D; 0(拥有者用户)(同组用户)(其它用户)</span><br><span class="line">    4: 可读</span><br><span class="line">    2: 可写</span><br><span class="line">    1: 可执行</span><br></pre></td></tr></table></figure><p>所创建文件的实际权限除了跟mode参数有关，还受权限掩码的影响。<br>mode=0666<br>umask=0002<br>权限=mode&amp;~umask=0664</p><p><strong>创建新文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int creat(const char* pathname, mode_t mode);</span><br><span class="line">flags: O_WRONLY | O_CREAT | O_TRUNC</span><br></pre></td></tr></table></figure><p><strong>打开已有文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int open(const char* pathname, int flags);&#x2F;&#x2F;系统调用</span><br></pre></td></tr></table></figure><p><strong>关闭文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int close(int fd);&#x2F;&#x2F;系统调用</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">fd - 文件描述符</span><br></pre></td></tr></table></figure><p>作为文件描述符表项在文件描述符表中的下标，合法的文件描述符一定是大于或等于0的整数。每次产生新的文件描述符表项，系统总是从下标0开始在文件描述符表中寻找最小的未使用项。每关闭一个文件描述符，无论被其索引的文件表项和v节点是否被删除，与之对应的文件描述符表项一定会被标记为未使用，并在后续操作中为新的文件描述符所占用。系统内核缺省为每个进程打开三个文件描述符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define STDIN_FILENO   0 &#x2F;&#x2F; 标准输入，即键盘</span><br><span class="line">#define STDOUT_FILENO 1 &#x2F;&#x2F; 标准输出，终端屏幕，有缓冲</span><br><span class="line">#define STDERR_FILENO  2 &#x2F;&#x2F; 标准错误，终端屏幕，无缓冲</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th align="center">UC</th><th align="center">C</th><th align="center">C++</th><th></th></tr></thead><tbody><tr><td>标准输入</td><td align="center">0</td><td align="center">stdin</td><td align="center">cin</td><td>它是命令的输入，缺省是键盘，也可以是文件或其他命令的输出</td></tr><tr><td>标准输出</td><td align="center">1</td><td align="center">stdout</td><td align="center">cout</td><td>它是命令的输出，缺省是屏幕，也可以是文件</td></tr><tr><td>标准错误</td><td align="center">2</td><td align="center">stderr</td><td align="center">cerr</td><td>这是命令错误的输出，缺省是屏幕，同样也可以是文件。</td></tr><tr><td>数据类型</td><td align="center">int</td><td align="center">FILE*</td><td align="center">iostream</td><td></td></tr></tbody></table><p>文件描述符是用户程序和系统内核关于文件的唯一联系方式。如果没有特别指定文件描述符，命令将使用缺省的文件描述符。<br>在linu系统中，Shell会自动为我们打开和关闭0、1、2这三个文件描述符，我们不需要显式地打开或关闭它们。标准输入是命令的输入，默认指向键盘；标准输出是命令的输出，默认指向屏幕；标准错误是命令错误信息的输出，默认指向屏幕。<br>如果没有显式地进行重定向，命令通过文件描述符0从屏幕读取输入，通过文件描述符1和2将输出和错误信息输出到屏幕。但如果我们想从其他文件（再次强调，I/O设备在Unix/Linux中也是文件）读取输入或产生输出，就需要对0、1、2使用重定向了。其语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">shell终端重定向命令:</span><br><span class="line">command &lt; filename                        把标准输入重定向到filename文件中</span><br><span class="line">command 0&lt; filename                       同上</span><br><span class="line"></span><br><span class="line">command &gt; filename                         把标准输出重定向到filename文件中(覆盖)</span><br><span class="line">command 1&gt; fielname                       同上</span><br><span class="line"></span><br><span class="line">command &gt;&gt; filename                       把标准输出重定向到filename文件中(追加)</span><br><span class="line">command 1&gt;&gt; filename                     同上 </span><br><span class="line">command 2&gt; filename                       把标准错误重定向到filename文件中(覆盖)</span><br><span class="line">command 2&gt;&gt; filename                     同上</span><br><span class="line"></span><br><span class="line">command &gt; filename 2&gt;&amp;1               把标准输出和标准错误一起重定向到filename文件中(覆盖)</span><br><span class="line">command &gt;&gt; filename 2&gt;&amp;1             把标准输出和标准错误一起重定向到filename文件中(追加)</span><br><span class="line"></span><br><span class="line">command &lt; filename &gt;filename2     把文件filename中的内容作为command的输入，把标准输出重定向到filename2文件中</span><br><span class="line">command 0&lt; filename 1&gt; filename2   同上</span><br></pre></td></tr></table></figure><h1 id="5-文件的读取和写入"><a href="#5-文件的读取和写入" class="headerlink" title="5.文件的读取和写入"></a>5.文件的读取和写入</h1><p>向指定文件写入字节流:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write(int fd, const void* buf, size_t count);</span><br><span class="line">成功返回实际写入的字节数(0表示未写入)，失败返回-1。</span><br><span class="line">fd - 文件描述符</span><br><span class="line">buf - 内存缓冲区</span><br><span class="line">count - 期望写入的字节数</span><br></pre></td></tr></table></figure><p>向指定文件读入字节流:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read(int fd, void* buf, size_t count);</span><br><span class="line">成功返回实际读取的字节数(0表示读到文件尾)，失败返回-1。</span><br><span class="line">fd - 文件描述符</span><br><span class="line">buf - 内存缓冲区</span><br><span class="line">count - 期望读取的字节数</span><br></pre></td></tr></table></figure><p>基于系统调用的文件读写本来就是面向二进制字节流的，因此对二进制读写而言，无需做任何额外的工作。如果要求文件中内容必须是可阅读的，那么就必须通过格式化和文本解析处理二进制形式的数据和文本字符串之间的转换。</p><h1 id="6-顺序与随机读写"><a href="#6-顺序与随机读写" class="headerlink" title="6.顺序与随机读写"></a>6.顺序与随机读写</h1><p>每个打开的文件都有一个与其相关的文件读写位置保存在文件表项中，用以记录从文件头开始计算的字节偏移。文件读写位置通常是一个非负的整数，用off_t类型表示，在32位系统上被定义为long int，而在64位系统上则被定义为long long int。打开一个文件时，除非指定了O_APPEND标志，否则文件读写位置一律被设为0，即文件首字节的位置。每一次读写操作都从当前的文件读写位置开始，并根据所读写的字节数，同步增加文件读写位置，为下一次读写做好准备。因为文件读写位置是保存在文件表项而不是v节点中的，因此通过多次打开同一个文件得到多个文件描述符，各自拥有各自的文件读写位置。<br>人为调整文件读写位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">off_t lseek(int fd, off_t offset, int whence);</span><br><span class="line">成功返回调整后的文件读写位置，失败返回-1。</span><br><span class="line">fd - 文件描述符</span><br><span class="line">offset - 文件读写位置相对于whence参数的偏移量</span><br><span class="line">whence：</span><br><span class="line">    SEEK_SET - 从文件开始</span><br><span class="line">    SEEK_CUR - 从当前位置开始</span><br><span class="line">    SEEK_END - 从文件尾开始</span><br></pre></td></tr></table></figure><p>lseek函数仅仅是修改文件表项中的文件读写位置，并不引发实际的I/O操作，速度很快。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lseek(fd, 10, SEEK_SET);</span><br><span class="line">lseek(fd, -10, SEEK_END);</span><br><span class="line">lseek(fd, 0, SEEK_CUR); &#x2F;&#x2F; 返回当前读写位置</span><br><span class="line">lseek(fd, 0, SEEK_END); &#x2F;&#x2F; 返回文件总字节数</span><br><span class="line">lseek(fd, -10, SEEK_SET); &#x2F;&#x2F; 错误</span><br><span class="line">lseek(fd, 10, SEEK_END); &#x2F;&#x2F; 允许，空洞部分补0</span><br></pre></td></tr></table></figure><h1 id="7-标准I-O和系统I-O"><a href="#7-标准I-O和系统I-O" class="headerlink" title="7.标准I/O和系统I/O"></a>7.标准I/O和系统I/O</h1><p>​             应用程序———-+<br>​                    |                     |<br>​                    v                    |<br>​           标准(库)I/O            |<br>   fopen/fwrite/fclose    |<br>​                    |                    |<br>​                   v                    |<br>​         系统(库)I/O             |<br>   open/write/close &lt;–+<br>代码：stdio.c、sysio.c<br>标准库通过缓冲区优化，减少系统调用的次数，降低在用户态和内核态之间来回切换的频率，提高运行速度，缩短运行时间。</p><h2 id="8-复制文件描述符-表项"><a href="#8-复制文件描述符-表项" class="headerlink" title="8.复制文件描述符(表项)"></a>8.复制文件描述符(表项)</h2><p>进程表项<br>​    …<br>​    文件描述符表<br>​        |文件描述符标志 | 文件表项指针 | 0<br>​        |文件描述符标志 | 文件表项指针 | 1<br>​        |文件描述符标志 | 文件表项指针 | 2<br>int fd  = open(…); // fd: 3<br>进程表项<br>​    …<br>​    文件描述符表<br>​        |文件描述符标志 | 文件表项指针 | 0<br>​        |文件描述符标志 | 文件表项指针 | 1<br>​        |文件描述符标志 | 文件表项指针 | 2<br>​        |文件描述符标志 | 文件表项指针 | 3 -&gt; 文件表项<br>文件表项：包含文件状态标志、文件读写位置、v节点指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int dup(int oldfd);</span><br><span class="line">成功返回目标文件描述符，失败返回-1。</span><br><span class="line">oldfd - 源文件描述符</span><br><span class="line">int fd2 &#x3D; dup(fd); &#x2F;&#x2F; fd2: 7</span><br><span class="line">close(fd);</span><br><span class="line">close(fd2);</span><br></pre></td></tr></table></figure><p>dup函数将oldfd参数所对应的文件描述符表项复制到文件描述符表第一个空闲项中，同时返回该表 项所对应的文件描述符。</p><p>进程表项<br>    …<br>    文件描述符表<br>        |文件描述符标志 | 文件表项指针 | 0<br>        |文件描述符标志 | 文件表项指针 | 1<br>        |文件描述符标志 | 文件表项指针 | 2<br>        |文件描述符标志 | 文件表项指针 | 3-&gt;文件表项-&gt;v节点<br>        …                                                                       ^<br>        |文件描述符标志 | 文件表项指针 | 7 ——–+<br>fd2(7)和fd(3)对应同一个文件表项，访问同一个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int dup2(int oldfd, int newfd);</span><br><span class="line">成功返回目标文件描述符，失败返回-1。</span><br><span class="line">oldfd - 源文件描述符</span><br><span class="line">newfd - 目标文件描述符</span><br></pre></td></tr></table></figure><p>dup2函数在复制oldfd参数所标识的源文件描述符表项时，会首先检查由newfd参数所标识的目标文件描述符表项是否空闲，若空闲则直接将前者复制给后者，否则会先将目标文件描述符newfd关闭，再行复制。<br>fd1 = open(“1.txt”, …); –&gt; 文件表项 <br>                                                                &gt; v节点(仅仅是v节点相同)<br>fd2 = open(“1.txt”, …); –&gt; 文件表项 /</p><p>fd1 = open(“2.txt”, …); <br>                                           &gt; 文件表项(文件状态标志、文件读写位置、v节点指针都相同) -&gt; v节点<br>fd2 = dup(fd1);              /<br>代码：dup.c same.c</p><h1 id="9-文件控制"><a href="#9-文件控制" class="headerlink" title="9.文件控制"></a>9.文件控制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fcntl(int fd, int cmd, ...);</span><br></pre></td></tr></table></figure><h2 id="1、复制文件描述符-表项"><a href="#1、复制文件描述符-表项" class="headerlink" title="1、复制文件描述符(表项)"></a>1、复制文件描述符(表项)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fcntl(int oldfd, F_DUPFD, int newfd);</span><br><span class="line">成功返回目标文件描述符，失败返回-1。</span><br><span class="line">oldfd - 源文件描述符</span><br><span class="line">newfd - 目标文件描述符</span><br></pre></td></tr></table></figure><p>该函数类似dup2函数，但略有不同。如果newfd处于打开状态，该函数并不会象dup2函数那样关闭它，而是另外寻找一个比它大的最小的空闲文件描述符作为复制目标。</p><h2 id="2、获取-设置文件描述符标志"><a href="#2、获取-设置文件描述符标志" class="headerlink" title="2、获取/设置文件描述符标志"></a>2、获取/设置文件描述符标志</h2><p>截止目前只有一个文件描述符标志位：FD_CLOEXEC<br>一个进程可以通过exec函数族启动另一个进程取代其自身。<br>原进程中无FD_CLOEXEC标志位的文件描述符在新进程中会依然保持打开状态，这也是文件描述符的默认状态。如果原进程中的某个文件描述符带有此标志位，那么在新进程中该文件描述符会被关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取文件描述符标志</span><br><span class="line">int fcntl(int fd, F_GETFD);</span><br><span class="line">成功返回文件描述符标志，失败返回-1。</span><br><span class="line">&#x2F;&#x2F; 设置文件描述符标志</span><br><span class="line">int fcntl(int fd, F_SETFD, int flags);</span><br><span class="line">成功返回0，失败返回-1。</span><br></pre></td></tr></table></figure><h2 id="3、获取-追加文件状态标志"><a href="#3、获取-追加文件状态标志" class="headerlink" title="3、获取/追加文件状态标志"></a>3、获取/追加文件状态标志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取文件状态标志</span><br><span class="line">int fcntl(int fd, F_GETFL);</span><br><span class="line">成功返回文件状态标志，失败返回-1。</span><br><span class="line">与文件创建有关的三个状态标志： O_CREAT(创建)&#x2F;O_EXCL(排他)&#x2F;O_TRUC(清空)，无法被获取。</span><br></pre></td></tr></table></figure><p>只读标志O_RDONLY的值为0，不能与位与检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int flags &#x3D; fcntl(fd, F_GETFL);</span><br><span class="line">if ((flags &amp; O_ACCMODE) &#x3D;&#x3D; O_RDONLY)&#x2F;&#x2F;只读标志O_RDONLY判断方式</span><br><span class="line">    &#x2F;&#x2F; 只读文件</span><br><span class="line">if (flags &amp; O_WRONLY)</span><br><span class="line">    &#x2F;&#x2F; 只写文件</span><br><span class="line">if (flags &amp; O_RDWR)</span><br><span class="line">    &#x2F;&#x2F; 读写文件</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 追加文件状态标志</span><br><span class="line">int fcntl(int fd, F_SETFL, flags);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">只有O_APPEND(追加)和O_NONBLOCK(非阻塞)两个状态标志可被追加。</span><br></pre></td></tr></table></figure><p>代码：fl.c</p><h2 id="10-文件锁"><a href="#10-文件锁" class="headerlink" title="10.文件锁"></a>10.文件锁</h2><p>为了避免在读写同一个文件的同一个区域时发生冲突，进程之间应该遵循以下规则：<br>1、如果一个进程正在写，那么其它进程既不能写也不能读。<br>2、如果一个进程正在读，那么其它进程不能写但是可以读。<br>3、读共享，写独占。</p><p>为了避免多个进程在读写同一个文件的同一个区域时发生冲突，操作系统引入了文件锁机制，并把文件锁分读锁和写锁两种，它们区别在于：<br>读锁：共享锁，对一个文件的特定区域可以同时加多个读锁<br>写锁：排它锁，对一个文件的特定区域只能加一把写锁<br>锁模式：加锁-&gt;读写-&gt;解锁<br>                              期望的加锁<br>                              读锁    写锁<br>文件的某 无任何锁  OK     OK<br>个区域正 多把读锁  OK     NO<br>在被访问 一把写锁  NO     NO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fcntl(int fd, F_SETLKW&#x2F;F_SETLK, struct flock* lock);</span><br></pre></td></tr></table></figure><p>F_SETLKW: 阻塞模式，程序会一直等待。<br>F_SETLK: 非阻塞模式，如果文件被占用直接返回false，errno=EAGAIN或EACCES</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct flock &#123;</span><br><span class="line">    short int l_type;       &#x2F;&#x2F; 锁类型 F_RDLCK&#x2F;F_WRLCK&#x2F;F_UNLCK(解锁)</span><br><span class="line">    short int l_whence;  &#x2F;&#x2F; 锁区偏移起点 SEEK_SET&#x2F;SEEK_CUR&#x2F; SEEK_END</span><br><span class="line">    off_t     l_start;       &#x2F;&#x2F; 锁区偏移</span><br><span class="line">    off_t     l_len;          &#x2F;&#x2F; 锁区长度(字节数)，0表示锁到尾</span><br><span class="line">    pid_t     l_pid;         &#x2F;&#x2F; 加锁进程PID，-1表示自动设置</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对相对于文件头10字节开始的20字节以阻塞模式加读锁。</span><br><span class="line">struct flock lock;</span><br><span class="line">lock.l_type &#x3D; F_RDLCK;</span><br><span class="line">lock.l_whence &#x3D; SEEK_SET;</span><br><span class="line">lock.l_start &#x3D; 10;</span><br><span class="line">lock.l_len &#x3D; 20;</span><br><span class="line">lock.l_pid &#x3D; -1;</span><br><span class="line">fcntl(fd, F_SETLKW, &amp;lock);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对相对于当前位置10字节开始到文件尾以非阻塞方式加写锁。</span><br><span class="line">struct flock lock;</span><br><span class="line">lock.l_type &#x3D; F_WRLCK;</span><br><span class="line">lock.l_whence &#x3D; SEEK_CUR;</span><br><span class="line">lock.l_start &#x3D; 10;</span><br><span class="line">lock.l_len &#x3D; 0;</span><br><span class="line">lock.l_pid &#x3D; -1;</span><br><span class="line">fcntl(fd, F_SETLK, &amp;lock);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对整个文件解锁。</span><br><span class="line">struct flock lock;</span><br><span class="line">lock.l_type &#x3D; F_UNLCK;</span><br><span class="line">lock.l_whence &#x3D; SEEK_SET;</span><br><span class="line">lock.l_start &#x3D; 0;</span><br><span class="line">lock.l_len &#x3D; 0;</span><br><span class="line">lock.l_pid &#x3D; -1;</span><br><span class="line">fcntl(fd, F_SETLK, &amp;lock);</span><br></pre></td></tr></table></figure><p>测试对文件的某个区域是否可以加某种锁，如果不能加锁，是什么原因导致加锁冲突？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fcntl(int fd, F_GETLK, struct flock* lock);</span><br><span class="line">成功返回0，失败返回-1。</span><br></pre></td></tr></table></figure><p>调用该函数时，lock参数表示欲加之锁的细节。函数成功返回时，通过lock参数输出欲加之锁是否可加，以及存在冲突的锁信息。<br>v节点<br>    i节点内容<br>    锁表指针-&gt;锁节点-&gt;锁节点-&gt;…<br>    …                   锁的类型<br>                          锁区偏移<br>                          锁区大小<br>                          加锁进程的PID</p><p>每次对给定文件的特定区域加锁，都会通过fcntl函数向系统内核传递flock结构，该结构中包含了有关锁的一些细节，诸如锁的类型、锁区的起始位置和大小，甚至加锁进程的PID(填-1由系统自动设置)。系统内核会收集所有进程对该文件所加的各种锁，并把这些flock结构中的信息，以链表的形式组织成一张锁表，其起始地址就保存在该文件的v节点中。任何一个进程通过fcntl函数对该文件加锁，系统内核都要遍历这张锁表，一旦发现有与欲加之锁构成冲突的锁即阻塞或报错，否则即将欲加之锁插入锁表，而解锁的过程实际上就是调整或删除锁表中的相应节点。<br>文件锁属于劝谏锁，亦称协议锁，不是强制锁，自觉遵守才有用。</p><h1 id="11-文件元数据"><a href="#11-文件元数据" class="headerlink" title="11.文件元数据"></a>11.文件元数据</h1><p>i节点<br>    文件元数据<br>    数据块索引表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">文件元数据结构体stat：</span><br><span class="line">struct stat &#123;</span><br><span class="line">    dev_t st_dev; &#x2F;&#x2F; 设备ID</span><br><span class="line">    ino_t st_ino; &#x2F;&#x2F; i节点号</span><br><span class="line">    mode_t st_mode; &#x2F;&#x2F; 文件类型和权限</span><br><span class="line">    nlink_t st_nlink; &#x2F;&#x2F; 硬链接数</span><br><span class="line">    uid_t st_uid; &#x2F;&#x2F; 用户ID</span><br><span class="line">    gid_t st_gid; &#x2F;&#x2F; 组ID</span><br><span class="line">    dev_t st_rdev; &#x2F;&#x2F; 特殊设备ID</span><br><span class="line">    off_t st_size; &#x2F;&#x2F; 总字节数</span><br><span class="line">    blksize_t st_blksize; &#x2F;&#x2F; I&#x2F;O块字节数</span><br><span class="line">    blkcnt_t st_blocks; &#x2F;&#x2F; 块数</span><br><span class="line">    time_t st_atime; &#x2F;&#x2F; 最后访问时间</span><br><span class="line">    time_t st_mtime; &#x2F;&#x2F; 最后修改时间</span><br><span class="line">    time_t st_ctime; &#x2F;&#x2F; 最后状态改变时间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>文件类型和权限的数据类型mode_t其实就是一个整数，其中只有低16位有效。<br>B15~B12 - 文件类型，掩码：S_IFMT<br>1000，S_IFREG，普通文件，-<br>0100，S_IFDIR，目录文件，d<br>1100，S_IFSOCK，本地套接字文件，s<br>0010，S_IFCHR，字符设备文件，c<br>0110，S_IFBLK，块设备文件，b<br>1010，S_IFLNK，符号链接文件，l<br>0001，S_IFFIFO，有名管道文件，p</p><p>B11~B9 - 设置用户ID位、设置组ID位和粘滞位<br>带有设置用户ID位(即B11位为1)的可执行文件(如：/usr/bin/passwd)：<br>系统中的每个进程其实都有两个用户ID，一个叫实际用户ID，取决于运行该进程的登录用户，另一个叫有效用户ID。一般情况下，进程的有效用户ID就取自其实际用户ID。但是如果产生该进程的可执行文件带有设置用户ID位(即B11位为1)，那么该进程的有效用户ID就不再取自实际用户ID，而是取自该可执行文件的拥有者用户ID。进程对系统资源的权限判定是根据其有效用户ID做出的，因此通过这种方法，就可以提升普通用户执行进程的权限，完成本来只有高权限用户才能完成的任务，即有限提权。<br>带有设置组ID位(即B10位为1)的可执行文件：<br>设置组ID位(B10)的情况与上述类似，只是针对进程的有效组ID而已。<br>带有设置用户ID位的不可执行文件：毫无意义。<br>带有设置组ID位的不可执行文件：某些系统用这种无意义的状态作为强制锁标志。<br>带有粘滞位(B9位为1)的目录：除root以外的任何用户在该目录下，都只能删除或更名那些属于自己的文件或子目录，而对于其它用户的文件或子目录，既不能删除也不能改名。如：/tmp<br>拥有者用户     拥有者组        其它用户<br>B8B7B6           B5B4B3         B2B1B0<br>  |    |    |           |    |    |         |    |    |<br>读  写  执行     读  写  执行    读  写  执行</p><p>拥有者用户   拥有者组     其它用户<br>C1  C2  C3 C4  C5  C6  C7  C8  C9<br>-/r -/w -/x -/r -/w -/x -/r -/w -/x<br>设置用户ID位   设置组ID位   粘滞位<br>             S/s            S/s    T/t</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int stat(char const* path, struct stat* buf);&#x2F;&#x2F;获取文件信息，跟踪符号链接</span><br><span class="line">int fstat(int fd, struct stat* buf);&#x2F;&#x2F;跟踪符号链接</span><br><span class="line">int lstat(char const* path, struct stat* buf); &#x2F;&#x2F; 不跟踪符号链接</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">path - 文件路径</span><br><span class="line">buf - 文件元数据结构</span><br><span class="line">fd - 文件描述符</span><br></pre></td></tr></table></figure><h1 id="12-访问测试"><a href="#12-访问测试" class="headerlink" title="12.访问测试"></a>12.访问测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int access(const char* pathname, int mode);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">pathname - 文件路径</span><br><span class="line">mode - 访问权限，可取以下值：</span><br><span class="line">    R_OK: 可读否</span><br><span class="line">    W_OK: 可写否</span><br><span class="line">    X_OK: 可执行否</span><br><span class="line">    F_OK: 存在否</span><br></pre></td></tr></table></figure><p>根据调用该函数的进程的实际用户ID和实际组ID，检测其是否可读、可写或可执行给定的文件，也可检测该文件是否存在。</p><h1 id="13-权限掩码"><a href="#13-权限掩码" class="headerlink" title="13.权限掩码"></a>13.权限掩码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">mode_t umask(mode_t cmask);</span><br><span class="line">永远成功，返回原来的权限掩码。</span><br><span class="line">cmask - 新权限掩码</span><br></pre></td></tr></table></figure><p>权限掩码是进程的属性之一，存储在系统内核中的进程表项里。umask函数所影响的仅仅是调用进程自己，对于其它进程，包括其父进程，如Shell，都没有任何影响。</p><h1 id="14-修改权限"><a href="#14-修改权限" class="headerlink" title="14.修改权限"></a>14.修改权限</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int chmod(const char* pathname, mode_t mode);</span><br><span class="line">int fchmod(int fd, mode_t mode);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">pathname - 文件路径</span><br><span class="line">mode - 文件权限</span><br><span class="line">fd - 文件描述符</span><br></pre></td></tr></table></figure><p>调用进程的有效用户ID必须与文件的拥有者用户ID匹配，或者是root用户，才能修改该文件的权限，且受权限掩码的影响。</p><h1 id="15-修改文件的拥有者和-或-拥有者组"><a href="#15-修改文件的拥有者和-或-拥有者组" class="headerlink" title="15.修改文件的拥有者和(或)拥有者组"></a>15.修改文件的拥有者和(或)拥有者组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int chown(const char* path, uid_t owner, gid_t group);</span><br><span class="line">int fchown(int fd, uid_t owner, gid_t group);</span><br><span class="line">int lchown(const char* path, uid_t owner, gid_t group); &#x2F;&#x2F; 不跟踪符号链接</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">path - 文件路径</span><br><span class="line">owner - 拥有者用户ID，-1表示不修改</span><br><span class="line">group - 拥有者组ID，-1表示不修改</span><br><span class="line">fd - 文件描述符</span><br></pre></td></tr></table></figure><p>如果调用进程的有效用户ID为root用户，则它可以任意修改任何文件的拥有者用户和组。如果调用进程的有效用户ID为普通用户，则它只能把自己名下文件的拥有者组改成自己隶属的其它组。</p><h1 id="16-修改文件大小"><a href="#16-修改文件大小" class="headerlink" title="16.修改文件大小"></a>16.修改文件大小</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int truncate(const char* path, off_t length);</span><br><span class="line">int ftruncate(int fd, off_t length);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">path - 文件路径</span><br><span class="line">fd - 文件描述符</span><br><span class="line">length - 文件大小</span><br><span class="line">    大-&gt;小：截掉靠文件尾的部分。</span><br><span class="line">    小-&gt;大：在文件尾之后增加0。</span><br></pre></td></tr></table></figure><h1 id="17-硬链接"><a href="#17-硬链接" class="headerlink" title="17.硬链接"></a>17.硬链接</h1><p>硬链接就是文件路径，即由各级目录、分隔符(/)和文件名共同组成的字符串，与一个特定的i节点号所形成的对应关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;shell中创建硬链接命令</span><br><span class="line">ln &lt;目标路径(已经存在的路径)&gt; &lt;源路径(新建立的路径)&gt;</span><br></pre></td></tr></table></figure><p><strong>根据一个已有的硬链接创建一个新的硬链接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int link(const char* oldpath, const char* newpath);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">oldpath - 已有的硬链接路径</span><br><span class="line">newpath - 新的硬链接路径</span><br><span class="line">oldpath必须存在，newpath中不能包含不存在目录。</span><br></pre></td></tr></table></figure><p><strong>删除硬链接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int unlink(const char* pathname);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">pathname - 文件路径(不能是目录)</span><br></pre></td></tr></table></figure><p>从pathname所对应的目录文件中删除包含该文件的条目，同时将其对应的i节点中的硬链接数减一，若该硬链接数被减至0，则将该文件所占用的磁盘空间释放出来。</p><p><strong>修改硬链接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int rename(const char* oldpath, const char* newpath);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">oldpath - 原路径</span><br><span class="line">newpath - 新路径</span><br><span class="line">rename(&quot;.&#x2F;a.txt&quot;, &quot;.&#x2F;b.txt&quot;); &#x2F;&#x2F; 改名</span><br><span class="line">rename(&quot;a&#x2F;1.txt&quot;, &quot;b&#x2F;1.txt&quot;); &#x2F;&#x2F; 移动</span><br><span class="line">rename(&quot;a&#x2F;1.txt&quot;, &quot;b&#x2F;2.txt&quot;); &#x2F;&#x2F; 移动且改名</span><br></pre></td></tr></table></figure><p>另一个版本的unlink，还可以删除空目录的硬链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int remove(const char* pathname);</span><br></pre></td></tr></table></figure><h1 id="18-软链接"><a href="#18-软链接" class="headerlink" title="18.软链接"></a>18.软链接</h1><p>软链接文件的本质就是保存着另一个文件或目录的路径的文件。<br><strong>根据一个已有的硬链接创建一个符号链接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int symlink(const char* oldpath,  const char* newpath);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">oldpath - 原有路径，可以是文件，也可以是目录，甚至可以不存在</span><br><span class="line">newpath - 新建路径，不能包含不存在目录</span><br></pre></td></tr></table></figure><p><strong>读取软链接文件本身的内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssize_t readlink(const char* path, char* buf, size_t size);</span><br><span class="line">成功返回拷入buf的符号链接文件内容的字节数，失败返回-1。</span><br><span class="line">path - 软链接文件路径</span><br><span class="line">buf - 缓冲区</span><br><span class="line">size - 缓冲区大小</span><br></pre></td></tr></table></figure><h1 id="19-目录"><a href="#19-目录" class="headerlink" title="19.目录"></a>19.目录</h1><p><strong>创建一个空目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int mkdir(const char* pathname, mode_t model);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">pathname - 目录路径</span><br><span class="line">mode - 访问权限，目录的执行权限(x)表示可以进入</span><br></pre></td></tr></table></figure><p><strong>删除一个空目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int rmdir(const char* pathname);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">pathname - 目录路径</span><br><span class="line"></span><br><span class="line">int remove(const char* pathname);</span><br><span class="line">remove &#x3D; unlink + rmdir</span><br></pre></td></tr></table></figure><p><strong>获取当前工作目录</strong><br>char* getcwd(char* buf, size_t size);<br>成功返回工作目录字符串指针，即buf，失败返回NULL。<br>buf - 缓冲区<br>size - 缓冲区大小<br>自动追加结尾空字符。<br>当前工作目录作为进程的属性之一，也是系统内核进程表项的一部分。</p><p><strong>改变当前工作目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int chdir(const char* path);</span><br><span class="line">成功返回0，失败返回-1。</span><br></pre></td></tr></table></figure><p><strong>打开目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DIR* opendir(const char*name);</span><br><span class="line">成功返回目录流指针，失败返回NULL。</span><br></pre></td></tr></table></figure><p><strong>读取目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct dirent* readdir(DIR* dirp);</span><br><span class="line">成功返回目录条目指针，读完(不设置errno)或失败(设置errno)返回NULL。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct dirent &#123;</span><br><span class="line">    ino_t           d_ino;            &#x2F;&#x2F; 节点号</span><br><span class="line">    off_t           d_off;           &#x2F;&#x2F; 下一条位置(索引)</span><br><span class="line">    unsigned short d_reclen;     &#x2F;&#x2F; 记录长度</span><br><span class="line">    unsigned char   d_type;       &#x2F;&#x2F; 文件类型</span><br><span class="line">    char            d_name[]; &#x2F;&#x2F; 文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>关闭目录流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int closedir(DIR* dirp);</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">dirp - 目录流指针</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;九、文件&quot;&gt;&lt;a href=&quot;#九、文件&quot; class=&quot;headerlink&quot; title=&quot;九、文件&quot;&gt;&lt;/a&gt;九、文件&lt;/h1&gt;&lt;h2 id=&quot;1-文件系统的物理结构&quot;&gt;&lt;a href=&quot;#1-文件系统的物理结构&quot; class=&quot;headerlink&quot; title=&quot;1.文件系统的物理结构&quot;&gt;&lt;/a&gt;1.文件系统的物理结构&lt;/h2&gt;&lt;p&gt;1)硬盘的物理结构：驱动臂、盘片、主轴、磁头、控制器&lt;/p&gt;
&lt;p&gt;2)磁表面存储器的读写原理&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>UinxC-IO编程1</title>
    <link href="https://guoqiang-gump.github.io/2021/05/03/UinxC-IO%E7%BC%96%E7%A8%8B1/"/>
    <id>https://guoqiang-gump.github.io/2021/05/03/UinxC-IO%E7%BC%96%E7%A8%8B1/</id>
    <published>2021-05-03T02:36:43.000Z</published>
    <updated>2021-05-05T04:48:34.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、GNU编译器-gcc"><a href="#一、GNU编译器-gcc" class="headerlink" title="一、GNU编译器(gcc)"></a>一、GNU编译器(gcc)</h1><h2 id="1-GCC的基本特点"><a href="#1-GCC的基本特点" class="headerlink" title="1.GCC的基本特点"></a>1.GCC的基本特点</h2><p>1)支持多种硬件架构</p><a id="more"></a><p>x86-64</p><p>Alpha<br>ARM<br>…<br>2)支持多种操作系统<br>Unix<br>Linux<br>Android<br>iOS<br>Windows<br>3)支持多种编程语言<br>C<br>C++<br>Objective-C<br>Java<br>4)查看GCC的版本<br>gcc -v</p><h2 id="2-构建过程"><a href="#2-构建过程" class="headerlink" title="2.构建过程"></a>2.构建过程</h2><p>源代码(.c)-预编译-&gt;头文件和宏扩展-编译-&gt;汇编码(.s)-汇编-&gt;目标码(.o)-链接-&gt;可执行代码(a.out)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi hello.c - 编写源代码</span><br><span class="line">gcc -E hello.c -o hello.i - 预编译(编译预处理)</span><br><span class="line">gcc -S hello.i - 获得汇编代码(hello.s)</span><br><span class="line">gcc -c hello.s - 获得目标代码(hello.o)</span><br><span class="line">gcc hello.o -o hello - 获得可执行代码(hello)</span><br><span class="line">.&#x2F;hello - 运行可执行代码</span><br></pre></td></tr></table></figure><h2 id="3-文件名后缀"><a href="#3-文件名后缀" class="headerlink" title="3.文件名后缀"></a>3.文件名后缀</h2><p>.h - C语言源代码头文件                  <br>.c - 预处理前的C语言源代码文件      &gt; 可读文本<br>.s - 汇编语言文件                            /<br>.o - 目标文件                                   <br>.a - 静态库文件                                 &gt; 不可读的二进制<br>.so - 共享(动态)库文件                     /<br>.out - 可执行文件                           /</p><h2 id="4-编译选项"><a href="#4-编译选项" class="headerlink" title="4.编译选项"></a>4.编译选项</h2><p>gcc [选项] [参数] 文件1 文件2 …<br>-o: 指定输出文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：gcc hello.c -o hello</span><br></pre></td></tr></table></figure><p>-E: 预编译，缺省输出到屏幕，用-o指定输出文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><p>-S: 编译，将高级语言文件编译成汇编语言文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：gcc -S hello.c</span><br></pre></td></tr></table></figure><p>-c: 汇编，将汇编语言文件汇编成机器语言文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：gcc -c hello.s</span><br></pre></td></tr></table></figure><p>-Wall：产生全部警告</p><p>-Werror：将警告作为错误处理</p><p>-x: 指定源代码的语言</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如：gcc -Wall wall.c</span><br><span class="line">如：gcc -Werror werror.c</span><br><span class="line">xxx.c - C语言</span><br><span class="line">xxx.cpp - C++语言</span><br><span class="line">xxx.for - Fortran语言</span><br><span class="line">xxx.java - Java语言</span><br><span class="line">gcc -x c++ cpp.c -lstdc++ -o cpp</span><br></pre></td></tr></table></figure><p>-O0/O1/O2/O3: 指定优化等级，O0不优化，缺省O1优化</p><h2 id="5-头文件"><a href="#5-头文件" class="headerlink" title="5.头文件"></a>5.头文件</h2><p>1)头文件里写什么？<br>头文件卫士：防止重定义、 重扩展</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __XXX_</span><br><span class="line">#define __XXX_</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>宏定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PI 3.14159</span><br></pre></td></tr></table></figure><p>自定义类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    double x, y, r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类型别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Circle C;</span><br></pre></td></tr></table></figure><p>外部变量声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern double e;</span><br></pre></td></tr></table></figure><p>函数声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double circleArea(C c);</span><br></pre></td></tr></table></figure><p>一个头文件可能会被多个源文件包含，写在头文件里的函数定义也会因此被预处理器扩展到多个包含该头文件的源文件中，并在编译阶段被编译到等多个不同的目标文件中，这将导致链接错误：multiple definition，多重定义。</p><p>2)去哪里找头文件？<br>gcc -I&lt;头文件的附加搜索路径&gt;<br>#include &lt;my.h&gt; ：先找-I指定的目录，再找系统目录。<br>#include “my.h” ：先找-I指定的目录，再找当前目录，最后找系统目录。</p><p>头文件的系统目录：</p><ul><li>/usr/include - 标准C库</li><li>/usr/local/include - 第三方库</li><li>/usr/lib/gcc/i686-linux-gnu/5.4.0/include - 编译器库</li></ul><h2 id="6-预处理指令"><a href="#6-预处理指令" class="headerlink" title="6.预处理指令"></a>6.预处理指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include - 将指定的文件内容插至此指令处</span><br><span class="line">#define - 定义宏</span><br><span class="line">#undef - 删除宏</span><br><span class="line">#if - 如果</span><br><span class="line">#ifdef - 如果宏已定义</span><br><span class="line">#ifndef - 如果宏未定义</span><br><span class="line">#else - 否则，与#if&#x2F;#ifdef&#x2F;#ifndef配合使用</span><br><span class="line">#elif - 否则如果，与#if&#x2F;#ifdef&#x2F;#ifndef配合使用</span><br><span class="line">#endif - 结束判定，与#if&#x2F;#ifdef&#x2F;#ifndef配合使用</span><br><span class="line">#error - 产生错误，结束预处理</span><br><span class="line">#warning - 产生警告，继续预处理</span><br><span class="line">#line - 指定行号</span><br><span class="line">#pragma - 设定编译器的状态或者指示编译器的操作</span><br><span class="line">#pragma GCC dependency +&quot;被依赖文件&quot;——对比被编译文件与被依赖文件的生成时间，如果被依赖文件形成时间晚于被编译文件，则编译过程中提示错误</span><br><span class="line">#pragma GCC poison +语法禁忌</span><br><span class="line">#pragma pack(按几字节对齐：1&#x2F;2&#x2F;4&#x2F;8)</span><br><span class="line">#pragma pack() - 按缺省字节数对齐，取消自定义字节对齐方式，恢复默认字节对齐</span><br></pre></td></tr></table></figure><h2 id="7-预定义宏"><a href="#7-预定义宏" class="headerlink" title="7.预定义宏"></a>7.预定义宏</h2><p>无需自行定义，预处理器会根据事先设定好的规则将这些宏扩展成其对应的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__BASE_FILE__: 正在被处理的源文件名</span><br><span class="line">__FILE__: __FILE__这个宏所在文件名</span><br><span class="line">__LINE__: __LINE__这个宏所在行的行号</span><br><span class="line">__FUNCTION__: __FUNCTION__这个宏所在函数的函数名</span><br><span class="line">__func__: 同__FUNCTION__</span><br><span class="line">__DATE__: 处理日期</span><br><span class="line">__TIME__: 处理时间</span><br><span class="line">__INCLUDE_LEVEL__: __INCLUDE_LEVEL__这个宏所在的被包含层数，从0开始</span><br><span class="line">__cplusplus__: C++有定义，C无定义</span><br></pre></td></tr></table></figure><h2 id="8-环境变量"><a href="#8-环境变量" class="headerlink" title="8.环境变量"></a>8.环境变量</h2><p>在进程向下文中保存的一些数据：键(功能，是什么)=值(内容)。<br>env：查看在进程向下文中保存的一些数据和环境变量。</p><ul><li>C_INCLUDE_PATH、CPATH：C语言头文件的附加搜索路径，相当于-I选项。</li><li>CPLUS_INCLUDE_PATH：C++语言头文件的附加搜索路径，相当于-I选项。</li><li>LIBRARY_PATH：链接库路径</li><li>LD_LIBRARY_PATH： 加载库路径</li></ul><p>#include “/…/…/xxx.h” - 移植性差<br>#include “xxx.h”<br>gcc -I/…/… … - 推荐<br>C_INCLUDE_PATH/CPATH=/…/…:/… - 易冲突</p><h1 id="三、库"><a href="#三、库" class="headerlink" title="三、库"></a>三、库</h1><p>单一模型：将程序中所有功能全部实现于一个单一的源文件内部。编译时间长，不易于维护和升级，不易于协作开发。<br>分离模型：将程序中的不同功能模块划分到不同的源文件中。缩短编译时间，易于维护和升级，易于协作开发。</p><h2 id="1-静态库"><a href="#1-静态库" class="headerlink" title="1.静态库"></a>1.静态库</h2><p>静态库的本质就是将多个目标文件打包成一个文件。<br>链接静态库就是将库中被调用的代码复制到调用模块中。<br>使用静态库的程序通常会占用较大的空间，库中代码一旦修改，所有使用该库的程序必须重新链接。<br>使用静态库的程序在运行无需依赖库，其执行效率高。<br><strong>静态库的形式：libxxx.a</strong><br><strong>构建静态库：</strong><br>.c -&gt; .o -&gt; .a<br>ar -r libxxx.a x.o y.o z.o<br><strong>使用静态库：</strong><br>gcc … -lxxx -L&lt;库路径&gt;  ——推荐使用<br>或者<br>export LIBRARY_PATH=&lt;库路径&gt;<br>gcc … -lxxx</p><h2 id="2-动态-共享-库"><a href="#2-动态-共享-库" class="headerlink" title="2.动态(共享)库"></a>2.动态(共享)库</h2><p>动态库和静态库最大的不同就是，链接动态库并不需要将库中被调用的代码复制到调用模块中，相反被嵌入到调用模块中的仅仅是被调用代码在动态库中的相对地址。<br>如果动态库中的代码同时为多个进程所用，动态库的实例在整个内存空间中仅需一份，因此动态库也叫共享库或共享对象(Shared Object, so)。<br>使用动态库的模块所占空间较小，即使修改了库中的代码，只要接口保持不变，无需重新链接。<br>使用动态库的代码在运行时需要依赖库，执行效率略低。<br><strong>动态库的形式：libxxx.so</strong><br><strong>构建动态库：</strong><br>gcc -c -fpic xxx.c -&gt; 用于生成xxx.o<br>               |<br>   生成位置无关码<br>   库内部的函数调用也用相对地址表示<br>gcc -shared -o libxxx.so x.o y.o z.o -&gt;生成动态库<br><strong>使用动态库：</strong><br>gcc … -lxxx -L&lt;库路径&gt;</p><p>或者</p><p>export LIBRARY_PATH=&lt;库路径&gt;<br>gcc … -lxxx<br>运行时所调用的动态库必须位于LD_LIBRARY_PATH环境变量所表示的路径中。</p><p><strong>gcc缺省链接共享库，可通过-static选项强制链接静态库。</strong></p><h2 id="3-动态加载动态库"><a href="#3-动态加载动态库" class="headerlink" title="3.动态加载动态库"></a>3.动态加载动态库</h2><p>构建动态加载动态库：<br>gcc xxx.c -ldl -o xxx<br>-ldl： 系统提供的针对动态库的动态加载函数集，位于#include &lt;dlfcn.h&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void* dlopen(const char* filename, int flag);</span><br><span class="line">filename - 动态库路径，若只给文件名，则根据LD_LIBRARY_PATH环境变量搜索动态库</span><br><span class="line">flag - 加载方式，可取以下值：</span><br><span class="line">RTLD_LAZY - 延迟加载，使用动态中的符号时才加载</span><br><span class="line">RTLD_NOW - 立即加载</span><br><span class="line">成功返回动态库的句柄，失败返回NULL。</span><br></pre></td></tr></table></figure><p>该函数所返回的动态库句柄唯一地标识了系统内核所维护的动态库对象，将作为后续函数调用的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void* dlsym(void* handle, const char* symbol);</span><br><span class="line">handle - 动态库句柄</span><br><span class="line">symbol - 符号(函数或全局变量)名</span><br><span class="line">成功返回函数地址，失败返回NULL。</span><br></pre></td></tr></table></figure><p>该函数所返回的函数指针是void*类型，需要强制类型转换为实际的函数指针类型才能调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int dlclose(void* handle);</span><br><span class="line">handle - 动态库句柄</span><br><span class="line">成功返回0，失败返回非零。</span><br><span class="line">char* dlerror(void);</span><br><span class="line">之前若有错误发生则返回错误信息字符串，否则返回NULL。</span><br></pre></td></tr></table></figure><h1 id="四、辅助工具"><a href="#四、辅助工具" class="headerlink" title="四、辅助工具"></a>四、辅助工具</h1><p>1.查看符号表：nm——列出目标文件(.o)、可执行文件、静态库文件(.a)或动态库文件(.so)中的符号<br>2.显示二进制模块的反汇编信息：objdump -S<br>3.删除目标文件(.o)、可执行文件、静态库文件(.a)或动态库文件(.so)中的符号表和调试信息：strip<br>4.查看可执行程序文件或动态库文件所依赖的动态库文件：ldd</p><h1 id="五、错误号和错误信息"><a href="#五、错误号和错误信息" class="headerlink" title="五、错误号和错误信息"></a>五、错误号和错误信息</h1><p>1.通过函数的返回值表达错误</p><ul><li>返回整数的函数：通过返回合法值域以外的值表示错误</li><li>返回指针的函数：通过返回NULL指针表示错误</li><li>不需要通过返回值输出信息的函数：返回0表示成功，返回-1表示失败。</li></ul><p>2.通过错误号和错误信息表示产生错误的具体原因</p><ul><li>#include &lt;errno.h&gt;中有全局变量：errno，整数，标识最近一次系统调用的错误</li><li>#include &lt;string.h&gt;中有函数char* strerror(int errnum); // 根据错误号(errno)返回错误信息</li><li>#include &lt;stdio.h&gt;中有函数void perror(const char* s); // 打印最近错误的错误信息</li><li>printf函数的%m标记被替换为最近错误的错误信息</li></ul><p>虽然所有的错误号都不是0，但是因为在函数执行成功的情况下错误号全局变量errno不会被清0，因此不能用errno是否为0作为函数成功失败的判断条件，是否出错还是应该根据函数的返回值来决定。</p><p>3.常见处理错误方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回值 &#x3D; 函数调用(...);</span><br><span class="line">if (返回值表示函数调用失败) &#123;</span><br><span class="line">    根据errno判断发生了什么错误</span><br><span class="line">    针对不同的错误提供不同的处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、环境变量"><a href="#六、环境变量" class="headerlink" title="六、环境变量"></a>六、环境变量</h1><p>每个进程都有一张独立的环境变量表，其中的每个条目都是一个形如“键=值”形式的环境变量。<br>env：查看系统当前环境变量的命令<br>全局变量：environ，需要自己在代码做外部声明。<br>environ-&gt;|    *    |-&gt;AAA=aaa\0<br>                  |    *    |-&gt;BBB=bbb\0<br>                  |    *    |-&gt;CCC=ccc\0<br>                  |NULL|<br>所谓环境变量表就是一个以NULL指针结束的字符指针数组char *arr[]，其中的每个元素都是一个字符指针，指向一个以空字符结尾的字符串，该字符串就是形如”键=值”形式的环境变量。<br>类似mian函数的第二个参数char *argv[]，mian函数的三个参数char *envp[]就是环境变量表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">char  *getenv(char const* name);&#x2F;&#x2F;根据环境变量名获取其值</span><br><span class="line">成功返回变量名匹配的变量值，即等号右边的部分，失败返回NULL。</span><br><span class="line">name - 环境变量名，即等号左边的部分</span><br><span class="line"></span><br><span class="line">int putenv(char* string);&#x2F;&#x2F;添加或修改环境变量</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">string - 形如“键&#x3D;值”形式的环境变量字符串</span><br><span class="line">若其键已存在，则修改其中，若其键不存在，则添加新变量</span><br><span class="line"></span><br><span class="line">int setenv(const char* name, const char* value, int overwrite);&#x2F;&#x2F;添加或修改环境变量</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">name - 环境变量名，即等号左边的部分</span><br><span class="line">value - 环境变量值，即等号右边的部分</span><br><span class="line">overwrite - 当name参数所表示的环境变量名已存在，此参数取0则保持该变量的原值不变，若此参数取非0，则将该变量的值修改为value。</span><br><span class="line"></span><br><span class="line">int unsetenv(const char* name);&#x2F;&#x2F;删除环境变量</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">name - 环境变量名，即等号左边的部分</span><br><span class="line"></span><br><span class="line">int clearenv(void);&#x2F;&#x2F;清空环境变量</span><br><span class="line">成功返回0，失败返回-1。</span><br></pre></td></tr></table></figure><h1 id="七、内存"><a href="#七、内存" class="headerlink" title="七、内存"></a>七、内存</h1><h2 id="1-虚拟内存、物理内存、半导体内存和换页文件"><a href="#1-虚拟内存、物理内存、半导体内存和换页文件" class="headerlink" title="1.虚拟内存、物理内存、半导体内存和换页文件"></a>1.虚拟内存、物理内存、半导体内存和换页文件</h2><p>虚拟内存：地址空间，虚拟的存储区域，应用程序所访问的都是虚拟内存。<br>物理内存：存储空间，实际的存储区域，只有系统内核可以访问物理内存。<br>虚拟内存和物理内存之间存在对应关系，当应用程序访问虚拟内存时，系统内核会依据这种对应关系找到与之相应的物理内存。上述对应关系存储在内核中的内存映射表中。<br>物理内存包括半导体内存和换页文件两部分。<br>当半导体内存不够用时，可以把一些长期闲置的代码和数据从半导体内存中缓存到换页文件中，这叫页面换出(1页=4096字节)，一旦需要使用被换出的代码和数据，再把它们从换页文件恢复到半导体内存中，这叫页面换入。因此，系统中的虚拟内存比半导体内存大得多。</p><h2 id="2-进程映射-Process-Maps"><a href="#2-进程映射-Process-Maps" class="headerlink" title="2.进程映射(Process Maps)"></a>2.进程映射(Process Maps)</h2><p>每个进程都拥有独立的4G字节的虚拟内存，分别被映射到不同的物理内存区域。<br>内存映射和换入换出都是以页为单位，1页=4096字节。<br>4G虚拟内存中高地址的1G被映射到内核的代码和数据区，这1个G在各个进程间共享。用户的应用程序只能直接访问低地址的3个G虚拟内存，因此该区域被称为用户空间，而高地址的1个G虚拟内存则被称为内核空间。用户空间中的代码只能直接访问用户空间的数据，如果要想访问内核空间中的代码和数据必须借助专门的系统调用完成。</p><p>用户空间的3G虚拟内存可以进一步被划分为如下区域：</p><p><img src="UinxC-IO%E7%BC%96%E7%A8%8B.assets/1620011624886.png" alt="1620011624886"></p><p>通过size命令查看一个可执行程序的代码区、数据区和BSS区的大小。<br>每个进程的用户空间都拥有独立的从虚拟内存到物理内存的映射，谓之进程间的内存壁垒。</p><h2 id="3-内存的分配与释放"><a href="#3-内存的分配与释放" class="headerlink" title="3.内存的分配与释放"></a>3.内存的分配与释放</h2><p>malloc/calloc/realloc/free<br>                   |调用<br>                  v<br>            brk/sbrk：以增加方式分配或释放虚拟内存<br>                   |调用<br>                  v<br>     mmap/munmap：建立虚拟内存到物理内存或文件的映射<br>                   |调用<br>                  v<br>        kmalloc/kfree</p><p><strong>brk/sbrk：以增加方式分配或释放虚拟内存</strong></p><p>分配 = 映射+占有</p><ul><li>映射：在地址空间(虚拟内存)和存储空间(物理内存)之间建立映射关系</li><li>占有：指定内存空间的归属性</li></ul><p>释放 = 放弃占有+解除映射</p><ul><li>放弃占有：解除对内存空间的归属约束 </li><li>解除映射：消除地址空间(虚拟内存)和存储空间(物理内存)之间的映射关系</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;<span class="comment">//以增加方式分配或释放虚拟内存，推荐在分配内存时使用</span></span><br><span class="line">成功返回调用该函数之前的堆顶指针，失败返回<span class="number">-1</span>。</span><br><span class="line">increment：</span><br><span class="line">    <span class="number">0</span> - 堆顶指针上移，增大堆空间，分配虚拟内存</span><br><span class="line">    &lt;<span class="number">0</span> - 堆顶指针下移，缩小堆空间，释放虚拟内存</span><br><span class="line">    =<span class="number">0</span> - 不分配也不释放虚拟内存，仅仅返回当前堆顶指针</span><br><span class="line"><span class="comment">//sbrk(0);返回当前堆顶</span></span><br></pre></td></tr></table></figure><p>系统内核维护一个指针，指向堆内存的顶端(有效堆内存中最后一个字节的下一个位置)。<br>sbrk函数根据增量参数increment调整该指针的位置，同时返回该指针原来的位置，期间若发生内存耗尽或空闲，则自动追加或取消相应内存页的映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int brk(void* end_data_segment);&#x2F;&#x2F;以绝对地址的方式分配或释放虚拟内存，推荐在释放内存时使用</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">end_data_segment:</span><br><span class="line">    &gt;当前堆顶，分配虚拟内存</span><br><span class="line">    &lt;当前堆顶，释放虚拟内存</span><br><span class="line">    &#x3D;当前堆顶，空操作</span><br></pre></td></tr></table></figure><p>系统内核维护一个指针，指向当前堆顶，brk函数根据指针参数end_data_segment设置堆顶的新位置，期间若发生内存耗尽或空闲，则自动追加或取消相应内存页的映射。</p><p> <strong>mmap/munmap：建立虚拟内存到物理内存或文件的映射</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">建立虚拟内存到物理内存或文件的映射:</span><br><span class="line">void* mmap(void* start, size_t length, int prot,  int flags, int fd, off_t offset);</span><br><span class="line">成功返回映射区虚拟内存的起始地址，失败返回MAP_FAILED(void*类型的-1)。</span><br><span class="line">start - 映射区虚拟内存的起始地址，NULL表示自动选择</span><br><span class="line">length - 映射区的字节数，自动按页取整</span><br><span class="line">prot - 访问权限，可取以下值：</span><br><span class="line">    PROT_READ - 可读</span><br><span class="line">    PROT_WRITE - 可写</span><br><span class="line">    PROT_EXEC - 可执行</span><br><span class="line">    PROT_NONE - 不可访问</span><br><span class="line">flags - 映射标志，可取以下值：</span><br><span class="line">    MAP_ANONYMOUS - 匿名映射，将虚拟内存映射到物理内存，函数的最后两个参数fd和offset被忽略</span><br><span class="line">    MAP_PRIVATE - 私有映射，将虚拟内存映射到文件的内存缓冲区中而非磁盘文件</span><br><span class="line">    MAP_SHARED - 共享映射，将虚拟内存映射到磁盘文件中</span><br><span class="line">    MAP_DENYWRITE - 拒写映射，文件中被映射区域不能存在其它写入操作</span><br><span class="line">    MAP_FIXED - 固定映射，若在start上无法创建映射，则失败(无此标志系统会自动调整)</span><br><span class="line">    MAP_LOCKED - 锁定映射，禁止被换出到换页文件</span><br><span class="line">fd - 文件描述符</span><br><span class="line">offset - 文件偏移量，自动按页对齐</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解除虚拟内存到物理内存或文件的映射:</span><br><span class="line">int munmap(void* start, size_t length);&#x2F;&#x2F;解除虚拟内存到物理内存或文件的映射</span><br><span class="line">成功返回0，失败返回-1。</span><br><span class="line">start - 映射区的起始地址</span><br><span class="line">length - 映射区的字节数</span><br></pre></td></tr></table></figure><h1 id="八、系统调用"><a href="#八、系统调用" class="headerlink" title="八、系统调用"></a>八、系统调用</h1><p>​              应用程序————–+<br>  vi/emacs/gftp/firefox        |<br>​                    |                         |<br>​       标准库、第三方库          |<br>​        C/C++/Qt/X11               |<br>​                    |                          |<br>​              系统调用&lt;————+<br>brk/sbrk/mmap/munmap</p><p>1.Linux系统内核提供了一套用于实现各种系统功能的子程序，谓之系统调用。程序编写者可以象调用普通C语言函数一样调用这些系统调用函数，以访问系统内核提供的各种服务。<br>2.系统调用函数在形式上与普通C语言函数并无差别。二者的不同之处在于，前者工作在内核态，而后者工作在用户态。<br>3.在Intel的CPU上运行代码分为四个安全级别：Ring0、Ring1、Ring2和Ring3。Linux系统只使用了Ring0和Ring3。用户代码工作在Ring3级，而内核代码工作在Ring0级。一般而言用户代码无法访问Ring0级的资源，除非借助系统调用，使用户代码得以进入Ring0级，使用系统内核提供的功能。<br>4.系统内核内部维护一张全局表sys_call_table，表中的每个条目记录着每个系统调用在内核代码中的实现入口地址。<br>5.当用户代码调用某个系统调用函数时，该函数会先将参数压入堆栈，将系统调用标识存入eax寄存器，然后通过int 80h指令触发80h中断。<br>6.这时程序便从用户态(Ring3)进入内核态(Ring0)。<br>7.工作系统内核中的中断处理函数被调用，80h中断的处理函数名为system_call，该函数先从堆栈中取出参数，再从eax寄存器中取出系统调用标识，然后再从sys_call_table表中找到与该系统调用标识相对应的实现代码入口地址，挈其参数调用该实现，并将处理结果逐层返回到用户代码中。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、GNU编译器-gcc&quot;&gt;&lt;a href=&quot;#一、GNU编译器-gcc&quot; class=&quot;headerlink&quot; title=&quot;一、GNU编译器(gcc)&quot;&gt;&lt;/a&gt;一、GNU编译器(gcc)&lt;/h1&gt;&lt;h2 id=&quot;1-GCC的基本特点&quot;&gt;&lt;a href=&quot;#1-GCC的基本特点&quot; class=&quot;headerlink&quot; title=&quot;1.GCC的基本特点&quot;&gt;&lt;/a&gt;1.GCC的基本特点&lt;/h2&gt;&lt;p&gt;1)支持多种硬件架构&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="https://guoqiang-gump.github.io/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://guoqiang-gump.github.io/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-18T12:37:24.000Z</published>
    <updated>2021-05-05T04:34:11.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据结构理论"><a href="#1-数据结构理论" class="headerlink" title="1. 数据结构理论"></a>1. <strong>数据结构理论</strong></h1><p>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集</p><p>数据项:一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。（耳、鼻、嘴、手、脚）</p><p>数据元素:是组成数据的、有一定意义的基本单位,在计算机中通常作为整体处理。也被称为记录。（人）</p><a id="more"></a><p>数据对象:是性质相同的数据元素的集合,是数据的子集。既然数据对象是数据的子集,在实际应用中,处理的数据元素通常具有相同性质,在不产生混淆的情况下,我们都将数据对象简称为<strong>数据</strong>。</p><p><img src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/1618755737702.png" alt="1618755737702"></p><p><strong>数据结构</strong>是计算机存储、组织数据的方式。是相互之间存在一种或多种特定关系的数据元素集合</p><p><strong>算法</strong>是特定问题求解步骤的描述，在计算机中表现为<strong>指令的有限序列</strong>，算法是独立存在的一种解决问题的方法和思想。对于算法而言，语言并不重要，重要的是思想。</p><p><strong>算法和数据结构区别</strong></p><p>数据结构只是静态的描述了数据元素之间的关系，高效的程序需要在数据结构的基础上设计和选择算法。</p><p>算法是为了解决实际问题而设计的。<br>数据结构是算法需要处理的问题载体。<br>数据结构与算法相辅相成</p><p><strong>算法的特性</strong></p><p>算法具有五个基本的特性：输入、输出、有穷性、确定性和可行性</p><p>输入输出：算法具有零个或多个输入、至少有一个或多个输出。</p><p>有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</p><p>确定性：算法的每一步骤都有确定的含义，不会出现二义性。</p><p>可行性：算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成。</p><h1 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h1><h2 id="1、逻辑结构"><a href="#1、逻辑结构" class="headerlink" title="1、逻辑结构"></a>1、逻辑结构</h2><p>集合结构：集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。各个数据元素是平等的。他们共同属于同一个集合，</p><p>线性结构：线性结构中的数据元素之间是一对一的关系。（动态数组、链表、栈、队列）</p><p>树形结构：树形结构中是数据元素之间存在一种一对多的层次关系，</p><p>图形结构： 图形结构的数据元素是多对多的关系</p><h2 id="2、物理结构"><a href="#2、物理结构" class="headerlink" title="2、物理结构"></a>2、物理结构</h2><p>物理结构是指数据的逻辑结构在计算机中的存储形式，共分为两种：顺序存储和链式存储。</p><p>顺序存储：是把数据元素存放在地址连续的存储单元里，其数据的逻辑关系和物理关系是一致的，</p><p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据的位置。</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是零个或者多个数据元素的有限序列，数据元素之间是有顺序的，数据元素个数有限。通常线性表可以采用顺序存储和链式存储</p><h2 id="1、线性表的顺序存储"><a href="#1、线性表的顺序存储" class="headerlink" title="1、线性表的顺序存储"></a>1、线性表的顺序存储</h2><p>线性表的顺序存储结构,指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来<br>实现这一结构。</p><p>采用顺序存储是表示线性表最简单的方法，具体做法是：将线性表中的元素一个接一个的存储在一块连续的存储区域中，这种顺序表示的线性表也成为顺序表。</p><h2 id="2、线性表的链式存储"><a href="#2、线性表的链式存储" class="headerlink" title="2、线性表的链式存储"></a>2、线性表的链式存储</h2><p>单链表</p><p>静态链表</p><p>首先我们让数组的元素都是由两个数据域组成,data和cur。也就是说,数组的每个下标都对应一个data和一个cur。数据域data,用来存放数据元素,也就是通常我们要处理的数据;而游标cur相当于单链表中的next指针,存放该元素的后继在数组中的下标。我们把这种用数组描述的链表叫做静态链表,这种描述方法还有起名叫做游标实<br>现法。</p><p>循环链表</p><p>将单链表中终端结点的指针端由空指针改为指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表( circular linked list)。</p><p>双向链表</p><p>双向链表double linked list)是在单链表的每个结点中,再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域,一个指向直接后继,另一个指向直接前驱。</p><h1 id="受限线性表"><a href="#受限线性表" class="headerlink" title="受限线性表"></a><strong>受限线性表</strong></h1><h1 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h1><p>栈的基本特性<br>   具有后进先出的特性(Last In First Out=LIFO)<br>   具有先进后出的特性(First In Last Out=FILO)<br>   栈的操作只能操作栈顶！类比弹匣<br>   入栈又称压栈<br>   出栈又称弹栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct stack &#123;</span><br><span class="line">    int *arr; &#x2F;&#x2F;数组的首地址</span><br><span class="line">    int cap; &#x2F;&#x2F;栈的容量大小</span><br><span class="line">    int top; &#x2F;&#x2F;栈顶</span><br><span class="line">&#125;stack_t;</span><br></pre></td></tr></table></figure><h1 id="队列queue"><a href="#队列queue" class="headerlink" title="队列queue"></a>队列queue</h1><p>特性：先进先出(First In First Out=FIFO),取数从队列的开头取,存储从队列尾部存<br>              第一个元素又称首元素,最后一个元素又称尾元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct queue &#123;</span><br><span class="line">    int *arr; &#x2F;&#x2F;首地址</span><br><span class="line">    int cap; &#x2F;&#x2F;容量</span><br><span class="line">    int size; &#x2F;&#x2F;有效数据的个数</span><br><span class="line">    int front; &#x2F;&#x2F;前端(出队)</span><br><span class="line">    int rear; &#x2F;&#x2F;后端(入队)</span><br><span class="line">&#125;queue_t;</span><br></pre></td></tr></table></figure><h1 id="链表list"><a href="#链表list" class="headerlink" title="链表list"></a>链表list</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>特点：体现一对一的前后关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明描述每个节点信息的数据结构</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">    int data; &#x2F;&#x2F;数据</span><br><span class="line">    struct node *next; &#x2F;&#x2F;保存下一个节点的首地址</span><br><span class="line">&#125;node_t;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;声明描述整个单链表的数据结构</span><br><span class="line">typedef struct list &#123;</span><br><span class="line">    struct node *head; &#x2F;&#x2F;指向头节点</span><br><span class="line">    struct node *tail; &#x2F;&#x2F;指向尾节点</span><br><span class="line">&#125;list_t;</span><br></pre></td></tr></table></figure><p>​     注意：每个节点的内存不一定连续,不像数组一样连续</p><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p> 一个有序的结点序列，每个链表元素既有指向下一个元素的指针，又有指向前一个元素的指针，其中每个结点都有两种指针，即<strong>front</strong>和<strong>tail</strong>，<strong>front</strong>指针指向左边结点，<strong>tail</strong>指针指向右边结点 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*声明描述节点信息的结构体*&#x2F;</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">    int data; &#x2F;&#x2F;数据</span><br><span class="line">    struct node *next; &#x2F;&#x2F;指向下一个节点</span><br><span class="line">    struct node *prev; &#x2F;&#x2F;指向上一个节点</span><br><span class="line">&#125;node_t;</span><br><span class="line"></span><br><span class="line">&#x2F;*声明描述整个链表的结构体*&#x2F;</span><br><span class="line">typedef struct list &#123;</span><br><span class="line">    struct node head; &#x2F;&#x2F;头节点</span><br><span class="line">    struct node tail; &#x2F;&#x2F;尾节点</span><br><span class="line">&#125;list_t;</span><br></pre></td></tr></table></figure><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>指的是在单向链表和双向链表的基础上，将两种链表的最后一个结点指向第一个结点从而实现循环</p><h1 id="树tree"><a href="#树tree" class="headerlink" title="树tree"></a>树tree</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是一种特殊的树</p><p>1.每个节点最多有两个子节点(可以没有,可以有一个)<br>      2.单根,每个子节点有且仅有一个父节点,整棵树只有一个根节点<br>         左子树：根节点左边的子树<br>         右子树：根节点右边的子树<br>      3.一般用递归函数来处理</p><h3 id="二叉查找树-有序二叉树"><a href="#二叉查找树-有序二叉树" class="headerlink" title="二叉查找树(有序二叉树)"></a>二叉查找树(有序二叉树)</h3><p>有序二叉树定义：一般来说,当左子树不为空时,左子树的元素值小于根节点 当右子树不为空时,右子树的元素值大于根节点</p><p>三种遍历方式：<br>   先序遍历(又称前序遍历):处理节点自己的数据-&gt;处理左节点-&gt;处理右节点<br>   中序遍历(重点):处理左节点-&gt;处理节点自己的数据-&gt;处理右节点<br>   后序遍历:处理左节点-&gt;处理右节点-&gt;处理节点自己的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明描述节点的数据结构</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">    int data; &#x2F;&#x2F;数据</span><br><span class="line">    struct node *left; &#x2F;&#x2F;左子树地址</span><br><span class="line">    struct node *right; &#x2F;&#x2F;右子树地址</span><br><span class="line">&#125;node_t;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;声明描述整颗树的数据结构、</span><br><span class="line">typedef struct tree &#123;</span><br><span class="line">    node_t *root; &#x2F;&#x2F;根节点地址</span><br><span class="line">    int cnt; &#x2F;&#x2F;节点个数</span><br><span class="line">&#125;tree_t;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-数据结构理论&quot;&gt;&lt;a href=&quot;#1-数据结构理论&quot; class=&quot;headerlink&quot; title=&quot;1. 数据结构理论&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;数据结构理论&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集&lt;/p&gt;
&lt;p&gt;数据项:一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。（耳、鼻、嘴、手、脚）&lt;/p&gt;
&lt;p&gt;数据元素:是组成数据的、有一定意义的基本单位,在计算机中通常作为整体处理。也被称为记录。（人）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-电容触摸屏驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/18/Linux%E9%A9%B1%E5%8A%A8-%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/18/Linux%E9%A9%B1%E5%8A%A8-%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-18T02:57:18.000Z</published>
    <updated>2021-05-05T04:42:49.253Z</updated>
    
    <content type="html"><![CDATA[<p>①、电容触摸屏是 IIC 接口的，需要触摸 IC，所谓的电容触摸驱动就是 IIC 设备驱动。<br>②、触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息。<br>③、电容触摸屏得到的是触摸位置绝对信息以及触摸屏是否有按下。<br>④、电容触摸屏不需要校准，</p><a id="more"></a><p>电容触摸屏驱动其实就是以下几种 linux 驱动框架的组合：<br>①、IIC 设备驱动，因为电容触摸 IC 基本都是 IIC 接口的，因此大框架就是 IIC 设备驱动。<br>②、通过中断引脚(INT)向 linux 内核上报触摸信息，因此需要用到 linux 中断驱动框架。坐标的上报在中断服务函数中完成。<br>③、触摸屏的坐标信息、屏幕按下和抬起信息都属于 linux 的 input 子系统，因此向 linux 内核上报触摸屏坐标信息就得使用 input 子系统。只是，我们得按照 linux 内核规定的规则来上报坐标信息。</p><h1 id="多点触摸-MT-协议详解"><a href="#多点触摸-MT-协议详解" class="headerlink" title="多点触摸(MT)协议详解"></a>多点触摸(MT)协议详解</h1><p>多点电容触摸的(Multi-touch，简称 MT)，MT 协议被分为两种类型，TypeA 和 TypeB，这两种类型的区别如下：<br>TypeA：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少！)。 Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个触摸点的信息，FT5426 就属于此类型，一般的多点电容触摸屏 IC 都有此能力。</p><p>触摸点的信息通过一系列的 ABS_MT 事件(有的资料也叫消息)上报给 linux 内核，只有ABS_MT 事件是用于多点触摸的，ABS_MT 事件定义在文件 linux/input.h 中，</p><p>在 众 多 的 ABS_MT 事 件 中 ， 我 们 最 常 用 的 就 是 ABS_MT_SLOT 、ABS_MT_POSITION_X 、ABS_MT_POSITION_Y 和 ABS_MT_TRACKING_ID 。其中ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y 用 来 上报 触 摸点 的 (X,Y) 坐 标 信息 ，ABS_MT_SLOT 用 来 上 报 触 摸 点 ID ，对于 Type B 类 型 的 设 备 ， 需 要 用 到<br>ABS_MT_TRACKING_ID 事件来区分触摸点。</p><p>对于 Type B 类型的设备，上报触摸点信息的时候需要通过 input_mt_slot()函数区分是哪一个触摸点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void input_mt_slot(struct input_dev *dev, int slot)</span><br></pre></td></tr></table></figure><p>第一个参数是 input_dev 设备，第二个参数 slot 用于指定当前上报的是哪个触摸点信息。input_mt_slot()函数会触发 ABS_MT_SLOT 事件，此事件会告诉接收者当前正在更新的是哪个触摸点(slot)的数据。</p><p>不管是哪个类型的设备，最终都要调用 input_sync()函数来标识多点触摸信息传输完成，告诉接收者处理之前累计的所有消息，并且准备好下一次接收。</p><p>Type B 和 Type A 相比最大的区别就是 Type B 可以区分出触摸点， 因此可以减少发送到用户空间的数据。</p><p>对于 TypeA 设备，内核驱动需要一次性将触摸屏上所有的触摸点信息全部上报，每个触摸点的信息在本次上报事件流中的顺序不重要，因为事件的过滤和手指(触摸点)跟踪是在内核空间处理的。</p><p>Type B 使用 slot 协议区分具体的触摸点，slot 需要用到 ABS_MT_TRACKING_ID 消息，这个 ID 需要硬件提供，<br>或者通过原始数据计算出来。Type B 设备驱动需要给每个识别出来的触摸点分配一个 slot，后面使用这个 slot 来上报触摸点信息。可以通过 slot 的 ABS_MT_TRACKING_ID 来新增、替换或删除触摸点。一个非负数 的 ID 表示一个有效的触摸点，-1 这个 ID 表示未使用 slot。一个以前不存在的 ID 表示这是一个新加的触摸点，一个 ID 如果再也不存在了就表示删除了。</p><h2 id="Type-B-触摸点信息上报时序"><a href="#Type-B-触摸点信息上报时序" class="headerlink" title="Type B 触摸点信息上报时序"></a>Type B 触摸点信息上报时序</h2><p>对于 Type B 类型的设备，发送触摸点信息的时序如下所示，这里以 2 个触摸点为例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_SLOT 0 </span><br><span class="line">ABS_MT_TRACKING_ID 45</span><br><span class="line">ABS_MT_POSITION_X x[0] </span><br><span class="line">ABS_MT_POSITION_Y y[0] </span><br><span class="line"></span><br><span class="line">ABS_MT_SLOT 1 </span><br><span class="line">ABS_MT_TRACKING_ID 46</span><br><span class="line">ABS_MT_POSITION_X x[1] </span><br><span class="line">ABS_MT_POSITION_Y y[1] </span><br><span class="line">SYN_REPORT</span><br><span class="line"></span><br><span class="line">ABS_MT_TRACKING_ID -1 </span><br><span class="line">SYN_REPORT</span><br></pre></td></tr></table></figure><p>第 1 行，上报 ABS_MT_SLOT 事件，也就是触摸点对应的 SLOT。每次上报一个触摸点坐 标之前要先使用input_mt_slot函数上报当前触摸点SLOT，触摸点的SLOT其实就是触摸点ID， 需要由触摸 IC 提供。 </p><p>第 2 行，根据 Type B 的要求，每个 SLOT 必须关联一个 ABS_MT_TRACKING_ID，通过 修改 SLOT 关联的 ABS_MT_TRACKING_ID 来完成对触摸点的添加、替换或删除。具体用到 的函数就是 input_mt_report_slot_state，如果是添加一个新的触摸点，那么此函数的第三个参数 active 要设置为 true，linux 内核会自动分配一个 ABS_MT_TRACKING_ID 值，不需要用户去指 定具体的 ABS_MT_TRACKING_ID 值。 </p><p>第 3 行，上报触摸点 0 的 X 轴坐标，使用函数 input_report_abs 来完成。 </p><p>第 4 行，上报触摸点 0 的 Y 轴坐标，使用函数 input_report_abs 来完成。 </p><p>第 5<del>8 行，和第 1</del>4 行类似，只是换成了上报触摸点 0 的(X,Y)坐标信息 </p><p>第 9 行，当所有的触摸点坐标都上传完毕以后就得发送 SYN_REPORT 事件，使用 input_sync 函数来完成。 </p><p>第 11行，当一个触摸点(SLOT)移除以后，需要通过 ABS_MT_TRACKING_ID 事件发送一 个-1 给内核。方法很简单，同样使用 input_mt_report_slot_state 函数来完成，只需要将此函数的第三个参数 active 设置为 false 即可，不需要用户手动去设置-1。 </p><p>第 12 行，当所有的触摸点坐标都上传完毕以后就得发送 SYN_REPORT 事件</p><h1 id="多点触摸所使用到的-API-函数"><a href="#多点触摸所使用到的-API-函数" class="headerlink" title="多点触摸所使用到的 API 函数"></a>多点触摸所使用到的 API 函数</h1><h2 id="1、input-mt-init-slots-函数"><a href="#1、input-mt-init-slots-函数" class="headerlink" title="1、input_mt_init_slots 函数"></a>1、input_mt_init_slots 函数</h2><p>input_mt_init_slots 函数用于初始化 MT 的输入 slots，编写 MT 驱动的时候必须先调用此函数初始化 slots，此函数定义在文件 drivers/input/input-mt.c 中，函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int input_mt_init_slots( struct input_dev *dev, unsigned int num_slots,</span><br><span class="line">unsigned int flags)</span><br><span class="line">&#x2F;&#x2F;dev： MT 设备对应的 input_dev，因为 MT 设备隶属于 input_dev。</span><br><span class="line">&#x2F;&#x2F;num_slots：设备要使用的 SLOT 数量，也就是触摸点的数量。</span><br><span class="line">&#x2F;&#x2F;flags：其他一些 flags 信息，可以采用‘|’运算来同时设置多个 flags 标识。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br></pre></td></tr></table></figure><p>flags：其他一些 flags 信息，可设置的 flags 如下所示：可以采用‘|’运算来同时设置多个 flags 标识。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define INPUT_MT_POINTER 0x0001 &#x2F;* pointer device, e.g. trackpad *&#x2F;</span><br><span class="line">#define INPUT_MT_DIRECT 0x0002 &#x2F;* direct device, e.g. touchscreen *&#x2F;</span><br><span class="line">#define INPUT_MT_DROP_UNUSED0x0004 &#x2F;* drop contacts not seen in frame *&#x2F;</span><br><span class="line">#define INPUT_MT_TRACK 0x0008 &#x2F;* use in-kernel tracking *&#x2F;</span><br><span class="line">#define INPUT_MT_SEMI_MT 0x0010 &#x2F;* semi-mt device, finger count handled manually *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="2、input-mt-slot-函数"><a href="#2、input-mt-slot-函数" class="headerlink" title="2、input_mt_slot 函数"></a>2、input_mt_slot 函数</h2><p>此函数用于 Type B 类型，此函数用于产生 ABS_MT_SLOT 事件，告诉内核当前上报的是哪个触摸点的坐标数据，此函数定义在文件 include/linux/input/mt.h 中，函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void input_mt_slot(struct input_dev *dev, int slot)</span><br><span class="line">&#x2F;&#x2F;dev： MT 设备对应的 input_dev。</span><br><span class="line">&#x2F;&#x2F;slot：当前发送的是哪个 slot 的坐标信息，也就是哪个触摸点。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h2 id="3、input-mt-report-slot-state-函数"><a href="#3、input-mt-report-slot-state-函数" class="headerlink" title="3、input_mt_report_slot_state 函数"></a>3、input_mt_report_slot_state 函数</h2><p>此函数用于 Type B 类型，用于产生 ABS_MT_TRACKING_ID 和 ABS_MT_TOOL_TYPE事件， ABS_MT_TRACKING_ID 事 件 给 slot 关联一个 ABS_MT_TRACKING_ID ，ABS_MT_TOOL_TYPE 事 件 指 定 触 摸 类 型 （ 是 笔 还 是 手 指 等 ）。 此 函 数 定 义 在 文 件drivers/input/input-mt.c 中，此函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void input_mt_report_slot_state( struct input_dev *dev, unsigned int tool_type, </span><br><span class="line">bool active)</span><br><span class="line">&#x2F;&#x2F;dev： MT 设备对应的 input_dev。</span><br><span class="line">&#x2F;&#x2F;tool_type：触摸类型，可以选择 MT_TOOL_FINGER(手指)、MT_TOOL_PEN(笔)或MT_TOOL_PALM(手掌)，</span><br><span class="line">&#x2F;&#x2F;active：true，连续触摸，input 子系统内核会自动分配一个 ABS_MT_TRACKING_ID 给 slot。false，触摸点抬起，表示某个触摸点无效了，input 子系统内核会分配一个-1 给 slot，表示触摸点溢出。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h2 id="4、input-report-abs-函数"><a href="#4、input-report-abs-函数" class="headerlink" title="4、input_report_abs 函数"></a>4、input_report_abs 函数</h2><p>TypeA 和 Type B 类型都使用此函数上报触摸点坐标信息，通过 ABS_MT_POSITION_X 和ABS_MT_POSITION_Y 事 件 实 现 X 和 Y 轴 坐 标 信 息 上 报 。 此 函 数 定 义 在 文 件<br>include/linux/input.h 中，函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void input_report_abs( struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">&#x2F;&#x2F;dev： MT 设备对应的 input_dev。</span><br><span class="line">&#x2F;&#x2F;code：要上报的是什么数据，可以设置为 ABS_MT_POSITION_X 或 ABS_MT_POSITION_Y，也就是 X 轴或者 Y 轴坐标数据。</span><br><span class="line">&#x2F;&#x2F;value：具体的 X 轴或 Y 轴坐标数据值。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h2 id="5、input-mt-report-pointer-emulation-函数"><a href="#5、input-mt-report-pointer-emulation-函数" class="headerlink" title="5、input_mt_report_pointer_emulation 函数"></a>5、input_mt_report_pointer_emulation 函数</h2><p>如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 BTN_TOOL_TAP 事件来通知用户空间当前追踪到的触摸点总数量，然后调用 input_mt_report_pointer_emulation 函数将use_count 参数设置为 false。否则的话将 use_count 参数设置为 true，表示当前的触摸点数量(此函数会获取到具体的触摸点数量，不需要用户给出)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void input_mt_report_pointer_emulation(struct input_dev *dev, </span><br><span class="line">bool use_count)</span><br><span class="line">&#x2F;&#x2F;dev： MT 设备对应的 input_dev。</span><br><span class="line">&#x2F;&#x2F;use_count：true，有效的触摸点数量；false，追踪到的触摸点数量多于当前上报的数量。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h1 id="多点电容触摸驱动框架"><a href="#多点电容触摸驱动框架" class="headerlink" title="多点电容触摸驱动框架"></a>多点电容触摸驱动框架</h1><p>①、多点电容触摸芯片的接口，一般都为 I2C 接口，因此驱动主框架肯定是 I2C。<br>②、linux 里面一般都是通过中断来上报触摸点坐标信息，因此需要用到中断框架。<br>③、多点电容触摸属于 input 子系统，因此还要用到 input 子系统框架。<br>④、在中断处理程序中按照 linux 的 MT 协议上报坐标信息。</p><h2 id="1、I2C-驱动框架"><a href="#1、I2C-驱动框架" class="headerlink" title="1、I2C 驱动框架"></a><strong>1、I2C</strong> <strong>驱动框架</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;* 设备树匹配表 *&#x2F;</span><br><span class="line">static const struct of_device_id xxx_of_match[] &#x3D; &#123; </span><br><span class="line">    &#123; .compatible &#x3D; &quot;xxx&quot;, &#125;,</span><br><span class="line">    &#123; &#x2F;* sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* i2c 驱动结构体 *&#x2F;</span><br><span class="line">static struct i2c_driver ft5x06_ts_driver &#x3D; &#123;</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .owner &#x3D; THIS_MODULE,</span><br><span class="line">        .name &#x3D; &quot;edt_ft5x06&quot;,</span><br><span class="line">        .of_match_table &#x3D; of_match_ptr(xxx_of_match),</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table &#x3D; xxx_ts_id,</span><br><span class="line">    .probe &#x3D; xxx_ts_probe,</span><br><span class="line">    .remove &#x3D; xxx_ts_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    ret &#x3D; i2c_add_driver(&amp;xxx_ts_driver);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    i2c_del_driver(&amp;ft5x06_ts_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、初始化触摸-IC、中断和-input-子系统"><a href="#2、初始化触摸-IC、中断和-input-子系统" class="headerlink" title="2、初始化触摸 IC、中断和 input 子系统"></a>2、初始化触摸 IC、中断和 input 子系统</h2><p>初始化操作都是在 xxx_ts_probe 函数中完成，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int xxx_ts_probe(struct i2c_client *client, const struct i2c_device_id *id) </span><br><span class="line">&#123; </span><br><span class="line">    struct input_dev *input;</span><br><span class="line">    &#x2F;* 1、初始化 I2C *&#x2F;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;* 2，申请中断， *&#x2F;</span><br><span class="line">    devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, NULL,</span><br><span class="line">    xxx_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,</span><br><span class="line">    client-&gt;name, &amp;xxx);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;* 3，input 设备申请与初始化 *&#x2F;</span><br><span class="line">    input &#x3D; devm_input_allocate_device(&amp;client-&gt;dev);</span><br><span class="line"></span><br><span class="line">    input-&gt;name &#x3D; client-&gt;name;</span><br><span class="line">    input-&gt;id.bustype &#x3D; BUS_I2C;</span><br><span class="line">    input-&gt;dev.parent &#x3D; &amp;client-&gt;dev;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;* 4，初始化 input 和 MT *&#x2F;</span><br><span class="line">    __set_bit(EV_ABS, input-&gt;evbit);</span><br><span class="line">    __set_bit(BTN_TOUCH, input-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    input_set_abs_params(input, ABS_X, 0, width, 0, 0);</span><br><span class="line">    input_set_abs_params(input, ABS_Y, 0, height, 0, 0);</span><br><span class="line">    input_set_abs_params(input, ABS_MT_POSITION_X,0, width, 0, 0);</span><br><span class="line">    input_set_abs_params(input, ABS_MT_POSITION_Y,0, height, 0, 0); </span><br><span class="line">    input_mt_init_slots(input, MAX_SUPPORT_POINTS, 0);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;* 5，注册 input_dev *&#x2F;</span><br><span class="line">    input_register_device(input);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 5~7 行，首先肯定是初始化触摸芯片，包括芯片的相关 IO，比如复位、中断等 IO 引脚， 然后就是芯片本身的初始化，也就是配置触摸芯片的相关寄存器。 </p><p>第 9 行，因为一般触摸芯片都是通过中断来向系统上报触摸点坐标信息的，因此我们需要初始化中断，采用了 devm_request_threaded_irq 这个函数。</p><p>第 15 行，接下来就是申请 input_dev，因为多点电容触摸属于 input 子系统。这里同样使用 devm_input_allocate_device 函数来申请 input_dev，申请到 input_dev 以后还需要对其进行初始化操作。 </p><p>第 23~24 行，设置 input_dev 需要上报的事件为 EV_ABS 和 BTN_TOUCH，因为多点电容 屏的触摸坐标为绝对值，因此需要上报 EV_ABS 事件。触摸屏有按下和抬起之分，因此需要上报 BTN_TOUCH 按键。</p><p>第 26~29 行，调用 input_set_abs_params 函数设置 EV_ABS 事件需要上报 ABS_X、ABS_Y、 ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。单点触摸需要上报 ABS_X 和 ABS_Y，对于多点触摸需要上报 ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。 </p><p>第 30 行，调用 input_mt_init_slots 函数初始化多点电容触摸的 slots。 </p><p>第 34 行，调用 input_register_device 函数系统注册前面申请到的 input_dev。</p><p><strong>devm_request_threaded_irq 函数特点如下：</strong> </p><p>①、用于申请中断，作用和 request_irq 函数类似。 </p><p>②、此函数的作用是中断线程化。硬件中断具有最高优先级，不论什么时候只要硬件中断发生，那么内核都会终止当前正在执行的操作，转而去执行中断处理程序(不考虑关闭中断和中断优先级的情况)，如果中断非常频繁的话那么内核将会频繁的执行中断处理程序，导致任务得不到及时的处理。中断线程化以后中断将作为内核线程运行，而且也可以被赋予不同的优先级，任务的优先级可能比中断线程的优先级高，这样做的目的就是保证高优先级的任务能被优先处理。使用“devm_”前缀的函数申请到的资源可以由系统自动释放，不需要我们手动处理。</p><h2 id="3、上报坐标信息"><a href="#3、上报坐标信息" class="headerlink" title="3、上报坐标信息"></a>3、上报坐标信息</h2><p>最后就是在中断服务程序中上报读取到的坐标信息，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static irqreturn_t xxx_handler(int irq, void *dev_id) </span><br><span class="line">&#123; </span><br><span class="line">    int num; &#x2F;* 触摸点数量 *&#x2F;</span><br><span class="line">    int x[n], y[n]; &#x2F;* 保存坐标值 *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 1、从触摸芯片获取各个触摸点坐标值 *&#x2F;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;* 2、上报每一个触摸点坐标 *&#x2F;</span><br><span class="line">    for (i &#x3D; 0; i &lt; num; i++) &#123;</span><br><span class="line">    input_mt_slot(input, id);</span><br><span class="line">    input_mt_report_slot_state(input, MT_TOOL_FINGER, true);</span><br><span class="line">    input_report_abs(input, ABS_MT_POSITION_X, x[i]);</span><br><span class="line">    input_report_abs(input, ABS_MT_POSITION_Y, y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    input_sync(input);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环上报每一个触摸点坐标，一定要按照 Type B 类型的时序进行，每一轮触摸点坐标上报完毕以后就调用一次 input_sync 函数发送一个SYN_REPORT 事件。 </p><h1 id="试验程序编写"><a href="#试验程序编写" class="headerlink" title="试验程序编写"></a>试验程序编写</h1><h2 id="1、修改设备树"><a href="#1、修改设备树" class="headerlink" title="1、修改设备树"></a><strong>1、修改设备树</strong></h2><p>1、添加 FT5426 所使用的 IO<br>FT5426 触摸芯片用到了 4 个 IO，一个复位 IO、一个中断 IO、I2C2 的 SCL 和 SDA，所以我们需要先在设备树中添加 IO 相关的信息。复位 IO 和中断 IO 是普通的 GPIO，因此这两个 IO可以放到同一个节点下去描述，I2C2 的 SCL 和 SDA 属于 I2C2，因此这两个要放到同一个节点下去描述。</p><p>2、添加 FT5426 节点</p><p>FT5426 这个触摸 IC 挂载 I2C2 下，因此需要向 I2C2 节点下添加一个子节点，此子节点用 </p><p>于描述FT5426，添加完成以后的 I2C2 节点内容如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ft5426: ft5426@38 &#123;</span><br><span class="line">13 compatible &#x3D; &quot;edt,edt-ft5426&quot;;</span><br><span class="line">14 reg &#x3D; &lt;0x38&gt;;</span><br><span class="line">15 pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">16 pinctrl-0 &#x3D; &lt;&amp;pinctrl_tsc</span><br><span class="line">17 &amp;pinctrl_tsc_reset &gt;;</span><br><span class="line">18 interrupt-parent &#x3D; &lt;&amp;gpio1&gt;;</span><br><span class="line">19 interrupts &#x3D; &lt;9 0&gt;;</span><br><span class="line">20 reset-gpios &#x3D; &lt;&amp;gpio5 9 GPIO_ACTIVE_LOW&gt;; </span><br><span class="line">21 interrupt-gpios &#x3D; &lt;&amp;gpio1 9 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">22 &#125;;</span><br><span class="line">23 &#125;;</span><br></pre></td></tr></table></figure><p>第 12 行，触摸屏所使用的 FT5426 芯片节点，挂载 I2C2 节点下，FT5426 的器件地址为 0X38。</p><p>第 14 行，reg 属性描述 FT5426 的器件地址为 0x38。 </p><p>第 16 和 17 行，pinctrl-0 属性描述 FT5426 的复位 IO 和中断 IO 所使用的节点为 pinctrl_tsc 和 pinctrl_tsc_reset。 </p><p>第 18 行，interrupt-parent 属性描述中断 IO 对应的 GPIO 组为 GPIO1。 </p><p>第 19 行，interrupts 属性描述中断 IO 对应的是 GPIO1 组的 IOI09。 </p><p>第 20 行，reset-gpios 属性描述复位 IO 对应的 GPIO 为 GPIO5_IO09。 </p><p>第 21 行，interrupt-gpios 属性描述中断 IO 对应的 GPIO 为 GPIO1_IO09</p><h2 id="2、编写多点电容触摸驱动"><a href="#2、编写多点电容触摸驱动" class="headerlink" title="2、编写多点电容触摸驱动"></a>2、编写多点电容触摸驱动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: ft5x06.c</span><br><span class="line">描述   : FT5X06，包括FT5206、FT5426等触摸屏驱动程序</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">#define MAX_SUPPORT_POINTS5&#x2F;* 5点触摸 *&#x2F;</span><br><span class="line">#define TOUCH_EVENT_DOWN0x00&#x2F;* 按下 *&#x2F;</span><br><span class="line">#define TOUCH_EVENT_UP0x01&#x2F;* 抬起 *&#x2F;</span><br><span class="line">#define TOUCH_EVENT_ON0x02&#x2F;* 接触 *&#x2F;</span><br><span class="line">#define TOUCH_EVENT_RESERVED0x03&#x2F;* 保留 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* FT5X06寄存器相关宏定义 *&#x2F;</span><br><span class="line">#define FT5X06_TD_STATUS_REG0X02&#x2F;*状态寄存器地址 *&#x2F;</span><br><span class="line">#define FT5x06_DEVICE_MODE_REG0X00 &#x2F;* 模式寄存器 *&#x2F;</span><br><span class="line">#define FT5426_IDG_MODE_REG0XA4&#x2F;* 中断模式*&#x2F;</span><br><span class="line">#define FT5X06_READLEN29&#x2F;* 要读取的寄存器个数 *&#x2F;</span><br><span class="line"></span><br><span class="line">struct ft5x06_dev &#123;</span><br><span class="line">struct device_node*nd; &#x2F;* 设备节点 *&#x2F;</span><br><span class="line">int irq_pin,reset_pin;&#x2F;* 中断和复位IO*&#x2F;</span><br><span class="line">int irqnum;&#x2F;* 中断号    *&#x2F;</span><br><span class="line">void *private_data;&#x2F;* 私有数据 *&#x2F;</span><br><span class="line">struct input_dev *input;&#x2F;* input结构体 *&#x2F;</span><br><span class="line">struct i2c_client *client;&#x2F;* I2C客户端 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">static struct ft5x06_dev ft5x06;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : 复位FT5X06</span><br><span class="line"> * @param - client : 要操作的i2c</span><br><span class="line"> * @param - multidev: 自定义的multitouch设备</span><br><span class="line"> * @return          : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ft5x06_ts_reset(struct i2c_client *client, struct ft5x06_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">if (gpio_is_valid(dev-&gt;reset_pin)) &#123;  &#x2F;* 检查IO是否有效 *&#x2F;</span><br><span class="line">&#x2F;* 申请复位IO，并且默认输出低电平 *&#x2F;</span><br><span class="line">ret &#x3D; devm_gpio_request_one(&amp;client-&gt;dev,</span><br><span class="line">dev-&gt;reset_pin, GPIOF_OUT_INIT_LOW,</span><br><span class="line">&quot;edt-ft5x06 reset&quot;);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msleep(5);</span><br><span class="line">gpio_set_value(dev-&gt;reset_pin, 1);&#x2F;* 输出高电平，停止复位 *&#x2F;</span><br><span class="line">msleep(300);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 从FT5X06读取多个寄存器数据</span><br><span class="line"> * @param - dev:  ft5x06设备</span><br><span class="line"> * @param - reg:  要读取的寄存器首地址</span><br><span class="line"> * @param - val:  读取到的数据</span><br><span class="line"> * @param - len:  要读取的数据长度</span><br><span class="line"> * @return : 操作结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ft5x06_read_regs(struct ft5x06_dev *dev, u8 reg, void *val, int len)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">struct i2c_msg msg[2];</span><br><span class="line">struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;client;</span><br><span class="line"></span><br><span class="line">&#x2F;* msg[0]为发送要读取的首地址 *&#x2F;</span><br><span class="line">msg[0].addr &#x3D; client-&gt;addr;&#x2F;* ft5x06地址 *&#x2F;</span><br><span class="line">msg[0].flags &#x3D; 0;&#x2F;* 标记为发送数据 *&#x2F;</span><br><span class="line">msg[0].buf &#x3D; &amp;reg;&#x2F;* 读取的首地址 *&#x2F;</span><br><span class="line">msg[0].len &#x3D; 1;&#x2F;* reg长度*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* msg[1]读取数据 *&#x2F;</span><br><span class="line">msg[1].addr &#x3D; client-&gt;addr;&#x2F;* ft5x06地址 *&#x2F;</span><br><span class="line">msg[1].flags &#x3D; I2C_M_RD;&#x2F;* 标记为读取数据*&#x2F;</span><br><span class="line">msg[1].buf &#x3D; val;&#x2F;* 读取数据缓冲区 *&#x2F;</span><br><span class="line">msg[1].len &#x3D; len;&#x2F;* 要读取的数据长度*&#x2F;</span><br><span class="line"></span><br><span class="line">ret &#x3D; i2c_transfer(client-&gt;adapter, msg, 2);</span><br><span class="line">if(ret &#x3D;&#x3D; 2) &#123;</span><br><span class="line">ret &#x3D; 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ret &#x3D; -EREMOTEIO;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 向ft5x06多个寄存器写入数据</span><br><span class="line"> * @param - dev:  ft5x06设备</span><br><span class="line"> * @param - reg:  要写入的寄存器首地址</span><br><span class="line"> * @param - val:  要写入的数据缓冲区</span><br><span class="line"> * @param - len:  要写入的数据长度</span><br><span class="line"> * @return   :   操作结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static s32 ft5x06_write_regs(struct ft5x06_dev *dev, u8 reg, u8 *buf, u8 len)</span><br><span class="line">&#123;</span><br><span class="line">u8 b[256];</span><br><span class="line">struct i2c_msg msg;</span><br><span class="line">struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;client;</span><br><span class="line"></span><br><span class="line">b[0] &#x3D; reg;&#x2F;* 寄存器首地址 *&#x2F;</span><br><span class="line">memcpy(&amp;b[1],buf,len);&#x2F;* 将要写入的数据拷贝到数组b里面 *&#x2F;</span><br><span class="line"></span><br><span class="line">msg.addr &#x3D; client-&gt;addr;&#x2F;* ft5x06地址 *&#x2F;</span><br><span class="line">msg.flags &#x3D; 0;&#x2F;* 标记为写数据 *&#x2F;</span><br><span class="line"></span><br><span class="line">msg.buf &#x3D; b;&#x2F;* 要写入的数据缓冲区 *&#x2F;</span><br><span class="line">msg.len &#x3D; len + 1;&#x2F;* 要写入的数据长度 *&#x2F;</span><br><span class="line"></span><br><span class="line">return i2c_transfer(client-&gt;adapter, &amp;msg, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 向ft5x06指定寄存器写入指定的值，写一个寄存器</span><br><span class="line"> * @param - dev:  ft5x06设备</span><br><span class="line"> * @param - reg:  要写的寄存器</span><br><span class="line"> * @param - data: 要写入的值</span><br><span class="line"> * @return   :    无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void ft5x06_write_reg(struct ft5x06_dev *dev, u8 reg, u8 data)</span><br><span class="line">&#123;</span><br><span class="line">u8 buf &#x3D; 0;</span><br><span class="line">buf &#x3D; data;</span><br><span class="line">ft5x06_write_regs(dev, reg, &amp;buf, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : FT5X06中断服务函数</span><br><span class="line"> * @param - irq : 中断号 </span><br><span class="line"> * @param - dev_id: 设备结构。</span><br><span class="line"> * @return : 中断执行结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static irqreturn_t ft5x06_handler(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">struct ft5x06_dev *multidata &#x3D; dev_id;</span><br><span class="line"></span><br><span class="line">u8 rdbuf[29];</span><br><span class="line">int i, type, x, y, id;</span><br><span class="line">int offset, tplen;</span><br><span class="line">int ret;</span><br><span class="line">bool down;</span><br><span class="line"></span><br><span class="line">offset &#x3D; 1; &#x2F;* 偏移1，也就是0X02+1&#x3D;0x03,从0X03开始是触摸值 *&#x2F;</span><br><span class="line">tplen &#x3D; 6;&#x2F;* 一个触摸点有6个寄存器来保存触摸值 *&#x2F;</span><br><span class="line"></span><br><span class="line">memset(rdbuf, 0, sizeof(rdbuf));&#x2F;* 清除 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 读取FT5X06触摸点坐标从0X02寄存器开始，连续读取29个寄存器 *&#x2F;</span><br><span class="line">ret &#x3D; ft5x06_read_regs(multidata, FT5X06_TD_STATUS_REG, rdbuf, FT5X06_READLEN);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 上报每一个触摸点坐标 *&#x2F;</span><br><span class="line">for (i &#x3D; 0; i &lt; MAX_SUPPORT_POINTS; i++) &#123;</span><br><span class="line">u8 *buf &#x3D; &amp;rdbuf[i * tplen + offset];</span><br><span class="line"></span><br><span class="line">&#x2F;* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下：</span><br><span class="line"> * bit7:6  Event flag  0:按下 1:释放 2：接触 3：没有事件</span><br><span class="line"> * bit5:4  保留</span><br><span class="line"> * bit3:0  X轴触摸点的11~8位。</span><br><span class="line"> *&#x2F;</span><br><span class="line">type &#x3D; buf[0] &gt;&gt; 6;     &#x2F;* 获取触摸类型 *&#x2F;</span><br><span class="line">if (type &#x3D;&#x3D; TOUCH_EVENT_RESERVED)</span><br><span class="line">continue;</span><br><span class="line"> </span><br><span class="line">&#x2F;* 我们所使用的触摸屏和FT5X06是反过来的 *&#x2F;</span><br><span class="line">x &#x3D; ((buf[2] &lt;&lt; 8) | buf[3]) &amp; 0x0fff;</span><br><span class="line">y &#x3D; ((buf[0] &lt;&lt; 8) | buf[1]) &amp; 0x0fff;</span><br><span class="line"></span><br><span class="line">&#x2F;* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下：</span><br><span class="line"> * bit7:4  Touch ID  触摸ID，表示是哪个触摸点</span><br><span class="line"> * bit3:0  Y轴触摸点的11~8位。</span><br><span class="line"> *&#x2F;</span><br><span class="line">id &#x3D; (buf[2] &gt;&gt; 4) &amp; 0x0f;</span><br><span class="line">down &#x3D; type !&#x3D; TOUCH_EVENT_UP;</span><br><span class="line"></span><br><span class="line">input_mt_slot(multidata-&gt;input, id);</span><br><span class="line">input_mt_report_slot_state(multidata-&gt;input, MT_TOOL_FINGER, down);</span><br><span class="line"></span><br><span class="line">if (!down)</span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">input_report_abs(multidata-&gt;input, ABS_MT_POSITION_X, x);</span><br><span class="line">input_report_abs(multidata-&gt;input, ABS_MT_POSITION_Y, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input_mt_report_pointer_emulation(multidata-&gt;input, true);</span><br><span class="line">input_sync(multidata-&gt;input);</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">return IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : FT5x06中断初始化</span><br><span class="line"> * @param - client : 要操作的i2c</span><br><span class="line"> * @param - multidev: 自定义的multitouch设备</span><br><span class="line"> * @return          : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ft5x06_ts_irq(struct i2c_client *client, struct ft5x06_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;* 1,申请中断GPIO *&#x2F;</span><br><span class="line">if (gpio_is_valid(dev-&gt;irq_pin)) &#123;</span><br><span class="line">ret &#x3D; devm_gpio_request_one(&amp;client-&gt;dev, dev-&gt;irq_pin,</span><br><span class="line">GPIOF_IN, &quot;edt-ft5x06 irq&quot;);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">dev_err(&amp;client-&gt;dev,</span><br><span class="line">&quot;Failed to request GPIO %d, error %d\n&quot;,</span><br><span class="line">dev-&gt;irq_pin, ret);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 2，申请中断,client-&gt;irq就是IO中断， *&#x2F;</span><br><span class="line">ret &#x3D; devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, NULL,</span><br><span class="line">ft5x06_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,</span><br><span class="line">client-&gt;name, &amp;ft5x06);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">dev_err(&amp;client-&gt;dev, &quot;Unable to request touchscreen IRQ.\n&quot;);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : i2c驱动的probe函数，当驱动与</span><br><span class="line">  *                    设备匹配以后此函数就会执行</span><br><span class="line">  * @param - client  : i2c设备</span><br><span class="line">  * @param - id      : i2c设备ID</span><br><span class="line">  * @return          : 0，成功;其他负值,失败</span><br><span class="line">  *&#x2F;</span><br><span class="line">static int ft5x06_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">ft5x06.client &#x3D; client;</span><br><span class="line"></span><br><span class="line">&#x2F;* 1，获取设备树中的中断和复位引脚 *&#x2F;</span><br><span class="line">ft5x06.irq_pin &#x3D; of_get_named_gpio(client-&gt;dev.of_node, &quot;interrupt-gpios&quot;, 0);</span><br><span class="line">ft5x06.reset_pin &#x3D; of_get_named_gpio(client-&gt;dev.of_node, &quot;reset-gpios&quot;, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;* 2，复位FT5x06 *&#x2F;</span><br><span class="line">ret &#x3D; ft5x06_ts_reset(client, &amp;ft5x06);</span><br><span class="line">if(ret &lt; 0) &#123;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 3，初始化中断 *&#x2F;</span><br><span class="line">ret &#x3D; ft5x06_ts_irq(client, &amp;ft5x06);</span><br><span class="line">if(ret &lt; 0) &#123;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 4，初始化FT5X06 *&#x2F;</span><br><span class="line">ft5x06_write_reg(&amp;ft5x06, FT5x06_DEVICE_MODE_REG, 0); &#x2F;* 进入正常模式 *&#x2F;</span><br><span class="line">ft5x06_write_reg(&amp;ft5x06, FT5426_IDG_MODE_REG, 1); &#x2F;* FT5426中断模式*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 5，input设备注册 *&#x2F;</span><br><span class="line">ft5x06.input &#x3D; devm_input_allocate_device(&amp;client-&gt;dev);</span><br><span class="line">if (!ft5x06.input) &#123;</span><br><span class="line">ret &#x3D; -ENOMEM;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line">ft5x06.input-&gt;name &#x3D; client-&gt;name;</span><br><span class="line">ft5x06.input-&gt;id.bustype &#x3D; BUS_I2C;</span><br><span class="line">ft5x06.input-&gt;dev.parent &#x3D; &amp;client-&gt;dev;</span><br><span class="line"></span><br><span class="line">__set_bit(EV_KEY, ft5x06.input-&gt;evbit);</span><br><span class="line">__set_bit(EV_ABS, ft5x06.input-&gt;evbit);</span><br><span class="line">__set_bit(BTN_TOUCH, ft5x06.input-&gt;keybit);</span><br><span class="line"></span><br><span class="line">input_set_abs_params(ft5x06.input, ABS_X, 0, 1024, 0, 0);</span><br><span class="line">input_set_abs_params(ft5x06.input, ABS_Y, 0, 600, 0, 0);</span><br><span class="line">input_set_abs_params(ft5x06.input, ABS_MT_POSITION_X,0, 1024, 0, 0);</span><br><span class="line">input_set_abs_params(ft5x06.input, ABS_MT_POSITION_Y,0, 600, 0, 0);     </span><br><span class="line">ret &#x3D; input_mt_init_slots(ft5x06.input, MAX_SUPPORT_POINTS, 0);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret &#x3D; input_register_device(ft5x06.input);</span><br><span class="line">if (ret)</span><br><span class="line">goto fail;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</span><br><span class="line"> * @param - client : i2c设备</span><br><span class="line"> * @return          : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ft5x06_ts_remove(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 释放input_dev *&#x2F;</span><br><span class="line">input_unregister_device(ft5x06.input);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 设备树匹配表 </span><br><span class="line"> *&#x2F;</span><br><span class="line">static const struct of_device_id ft5x06_of_match[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;edt,edt-ft5206&quot;, &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;edt,edt-ft5426&quot;, &#125;,</span><br><span class="line">&#123; &#x2F;* sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* i2c驱动结构体 *&#x2F;</span><br><span class="line">static struct i2c_driver ft5x06_ts_driver &#x3D; &#123;</span><br><span class="line">.driver &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.name &#x3D; &quot;edt_ft5x06&quot;,</span><br><span class="line">.of_match_table &#x3D; of_match_ptr(ft5x06_of_match),</span><br><span class="line">&#125;,</span><br><span class="line">.id_table &#x3D; ft5x06_ts_id,</span><br><span class="line">.probe    &#x3D; ft5x06_ts_probe,</span><br><span class="line">.remove   &#x3D; ft5x06_ts_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;①、电容触摸屏是 IIC 接口的，需要触摸 IC，所谓的电容触摸驱动就是 IIC 设备驱动。&lt;br&gt;②、触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息。&lt;br&gt;③、电容触摸屏得到的是触摸位置绝对信息以及触摸屏是否有按下。&lt;br&gt;④、电容触摸屏不需要校准，&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-串口驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/18/Linux%E9%A9%B1%E5%8A%A8-%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/18/Linux%E9%A9%B1%E5%8A%A8-%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-18T02:23:45.000Z</published>
    <updated>2021-05-05T04:42:36.752Z</updated>
    
    <content type="html"><![CDATA[<p>根据电平的不同，串口分为 TTL 和 RS232。不管是什么样的接口电平，其驱动程序都是一样的，通过外接 RS485 这样的芯片就可以将串口转换为 RS485 信号，正点原子的 I.MX6U-ALPHA 开发板就是这么做的。对于正点原子的 I.MX6U-ALPHA 开发板而言， RS232、RS485 以及 GPS 模 块接口通通连接到了 I.MX6U 的 UART3 接口上，因此这些外设最终都归结为 UART3 的串口驱动。学习一下如何驱动 I.MX6U-ALPHA 开发板上的 UART3 串口，进而实现 RS232、RS485 以及 GSP 驱动。</p> <a id="more"></a> <h1 id="Linux-下-UART-驱动框架"><a href="#Linux-下-UART-驱动框架" class="headerlink" title="Linux 下 UART 驱动框架"></a><strong>Linux</strong> <strong>下</strong> <strong>UART</strong> <strong>驱动框架</strong></h1><h2 id="1、uart-driver-注册与注销"><a href="#1、uart-driver-注册与注销" class="headerlink" title="1、uart_driver 注册与注销"></a>1、uart_driver 注册与注销</h2><p>同 I2C、SPI 一样，Linux 也提供了串口驱动框架，我们只需要按照相应的串口框架编写驱动程序即可。串口驱动没有什么主机端和设备端之分，就只有一个串口驱动，而且这个驱动已经由 NXP 官方已经编写好了，我们真正要做的就是在设备树中添加所要使用的串口节点信息。当系统启动以后串口驱动和设备匹配成功，相应的串口就会被驱动起来，生成/dev/ttymxcX(X=0….n)文件。</p><p>uart_driver 结构体表示 UART 驱动，uart_driver 定义在 include/linux/serial_core.h 文件中，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct uart_driver &#123;</span><br><span class="line">    struct module *owner; &#x2F;* 模块所属者 *&#x2F;</span><br><span class="line">    const char *driver_name; &#x2F;* 驱动名字 *&#x2F;</span><br><span class="line">    const char *dev_name; &#x2F;* 设备名字 *&#x2F;</span><br><span class="line">    int major; &#x2F;* 主设备号 *&#x2F;</span><br><span class="line">    int minor; &#x2F;* 次设备号 *&#x2F;</span><br><span class="line">    int nr; &#x2F;* 设备数 *&#x2F;</span><br><span class="line">    struct console *cons; &#x2F;* 控制台 *&#x2F;</span><br><span class="line">    struct uart_state *state; </span><br><span class="line">    struct tty_driver *tty_driver;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个串口驱动都需要定义一个 uart_driver，加载驱动的时候通过 uart_register_driver 函数向系统注册这个 uart_driver，注销驱动的时候也需要注销掉前面注册的 uart_driver，需要用到 uart_unregister_driver 函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int uart_register_driver(struct uart_driver *drv)</span><br><span class="line">&#x2F;&#x2F;drv：要注册的 uart_driver。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br><span class="line"></span><br><span class="line">void uart_unregister_driver(struct uart_driver *drv)</span><br><span class="line">&#x2F;&#x2F;drv：要注销的 uart_driver。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h2 id="2、uart-port-的添加与移除"><a href="#2、uart-port-的添加与移除" class="headerlink" title="2、uart_port 的添加与移除"></a>2、uart_port 的添加与移除</h2><p>uart_port 表示一个具体的 port，uart_port 定义在 include/linux/serial_core.h 文件每个 UART 都有一个 uart_port，uart_port 中最主要的就 ops，ops 包含了串口的具体驱动函数。那么 uart_port 和 uart_driver 结合要用到 uart_add_one_port 函数，卸载 UART 驱动的时候也需要将 uart_port 从相应的 uart_driver 中移除，需要用到uart_remove_one_port 函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int uart_add_one_port(struct uart_driver *drv, struct uart_port *uport)</span><br><span class="line">&#x2F;&#x2F;drv：此 port 对应的 uart_driver。</span><br><span class="line">&#x2F;&#x2F;uport：要添加到 uart_driver 中的 port。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br><span class="line"></span><br><span class="line">int uart_remove_one_port(struct uart_driver *drv, struct uart_port *uport)</span><br><span class="line">&#x2F;&#x2F;drv：要卸载的 port 所对应的 uart_driver。</span><br><span class="line">&#x2F;&#x2F;uport：要卸载的 uart_port。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br></pre></td></tr></table></figure><h3 id="3、uart-ops-实现"><a href="#3、uart-ops-实现" class="headerlink" title="3、uart_ops 实现"></a>3、uart_ops 实现</h3><p>uart_port 中的 ops 成员变量很重要，因为 ops 包含了针对 UART 具体的驱动函数，Linux 系统收发数据最终调用的都是 ops 中的函数。ops 是 uart_ops类型的结构体指针变量，uart_ops 定义在 include/linux/serial_core.h 文件中。UART 驱动编写人员需要实现 uart_ops，因为 uart_ops 是最底层的 UART 驱动接口，是实实在在的和 UART 寄存器打交道的。</p><h1 id="I-MX6U-UART-驱动分析"><a href="#I-MX6U-UART-驱动分析" class="headerlink" title="I.MX6U UART 驱动分析"></a>I.MX6U UART 驱动分析</h1><h2 id="1、UART-的-platform-驱动框架"><a href="#1、UART-的-platform-驱动框架" class="headerlink" title="1、UART 的 platform 驱动框架"></a>1、UART 的 platform 驱动框架</h2><p>I.MX6U 的 UART 本质上是一个 platform 驱动。打开 imx6ull.dtsi 文件，找到 UART3 对应的子节点的compatible 属性，这里一共有三个值：“fsl,imx6ul-uart”、“fsl,imx6q-uart”和“fsl,imx21-uart”。对应的 UART 驱动文件件为 drivers/tty/serial/imx.c，驱动文件的主要工作就是通过传统匹配表或设备树所匹配表匹配设备和驱动，然后初始化platform 驱动框架platform_driver类型的结构体 serial_imx_driver。最后就是驱动入口函数调用 uart_register_driver 函数向 Linux 内核注册 uart_driver，驱动出口函数调用 uart_unregister_driver 函数注销掉前面注 册的 uart_driver。</p><h2 id="2、uart-driver-初始化"><a href="#2、uart-driver-初始化" class="headerlink" title="2、uart_driver 初始化"></a>2、uart_driver 初始化</h2><p>在 imx_serial_init 函数中向 Linux 内核注册了 imx_reg，imx_reg 就是 uart_driver 类型的结构体变量，imx_reg 定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct uart_driver imx_reg &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .driver_name &#x3D; DRIVER_NAME,</span><br><span class="line">    .dev_name &#x3D; DEV_NAME,</span><br><span class="line">    .major &#x3D; SERIAL_IMX_MAJOR,</span><br><span class="line">    .minor &#x3D; MINOR_START,</span><br><span class="line">    .nr &#x3D; ARRAY_SIZE(imx_ports),</span><br><span class="line">    .cons &#x3D; IMX_CONSOLE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3、uart-port-初始化与添加"><a href="#3、uart-port-初始化与添加" class="headerlink" title="3、uart_port 初始化与添加"></a>3、uart_port 初始化与添加</h3><p>当 UART 设备和驱动匹配成功以后 serial_imx_probe 函数就会执行，此函数的重点工作就是初始化 uart_port，然后将其添加到对应的 uart_driver 中。imx_port 结构体 NXP 为 I.MX 系列 SOC 定义的一个设备结构体，此结构体内部就包含了 uart_port 成员变量。</p><p>serial_imx_probe 函数，函数内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int serial_imx_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct imx_port *sport;</span><br><span class="line">    sport &#x3D; devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*sport), GFP_KERNEL);</span><br><span class="line">    res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line"></span><br><span class="line">    base &#x3D; devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">    rxirq &#x3D; platform_get_irq(pdev, 0);</span><br><span class="line">    1993 txirq &#x3D; platform_get_irq(pdev, 1);</span><br><span class="line">    1994 rtsirq &#x3D; platform_get_irq(pdev, 2);</span><br><span class="line">    sport-&gt;port.ops &#x3D; &amp;imx_pops;</span><br><span class="line">    ……………………</span><br><span class="line">    return uart_add_one_port(&amp;imx_reg, &amp;sport-&gt;port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先定义一个 imx_port 类型的结构体指针变量 sport。然后为 sport 申请内存。<br>从设备树中获取 I.MX 系列 SOC UART 外设寄存器首地址，对于I.MX6ULL 的 UART3 来说就是 0X021EC000。得到寄存器首地址以后对其进行内存映射，得到对应的虚拟地址。<br>获取中断信息，申请中断。<br>初始化 sport 的 port 成员变量，也就是设置 uart_ops 为 imx_pops，imx_pops 就是 I.MX6ULL 最底层的驱动函数集合。<br>使用 uart_add_one_port 向 uart_driver 添加 uart_port，在这里就是向 imx_reg 添 加 sport-&gt;port。</p><h2 id="4、imx-pops-结构体变量"><a href="#4、imx-pops-结构体变量" class="headerlink" title="4、imx_pops 结构体变量"></a>4、imx_pops 结构体变量</h2><p>imx_pops 就是 uart_ops 类型的结构体变量，保存了 I.MX6ULL 串口最底层的操作函数，imx_pops 中的函数基本都是和 I.MX6ULL 的 UART 寄存器打交道的，</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据电平的不同，串口分为 TTL 和 RS232。不管是什么样的接口电平，其驱动程序都是一样的，通过外接 RS485 这样的芯片就可以将串口转换为 RS485 信号，正点原子的 I.MX6U-ALPHA 开发板就是这么做的。对于正点原子的 I.MX6U-ALPHA 开发板而言， RS232、RS485 以及 GPS 模 块接口通通连接到了 I.MX6U 的 UART3 接口上，因此这些外设最终都归结为 UART3 的串口驱动。学习一下如何驱动 I.MX6U-ALPHA 开发板上的 UART3 串口，进而实现 RS232、RS485 以及 GSP 驱动。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-SPI驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/17/Linux%E9%A9%B1%E5%8A%A8-SPI%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/17/Linux%E9%A9%B1%E5%8A%A8-SPI%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-17T14:50:57.000Z</published>
    <updated>2021-05-05T04:46:14.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-下-SPI-驱动框架"><a href="#Linux-下-SPI-驱动框架" class="headerlink" title="Linux 下 SPI 驱动框架"></a><strong>Linux</strong> <strong>下</strong> <strong>SPI</strong> <strong>驱动框架</strong></h1><h2 id="SPI-主机驱动"><a href="#SPI-主机驱动" class="headerlink" title="SPI 主机驱动"></a><strong>SPI</strong> <strong>主机驱动</strong></h2><p>SPI 主机驱动就是 SOC 的 SPI 控制器驱动，类似 I2C 驱动里面的适配器驱动。Linux 内核使用 spi_master表示 SPI 主机驱动，spi_master 是个结构体，定义在 include/linux/spi/spi.h 文件中，内容如下(有缩减)：</p> <a id="more"></a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct spi_master &#123;</span><br><span class="line">    struct device dev;</span><br><span class="line">    struct list_head list;</span><br><span class="line">    ......</span><br><span class="line">    (*transfer)(struct spi_device *spi, struct spi_message *mesg);</span><br><span class="line">    ......</span><br><span class="line">    int (*transfer_one_message)(struct spi_master *master, struct spi_message *mesg);</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;transfer函数，和 i2c_algorithm 中的 master_xfer 函数一样，控制器数据传输函数。</span><br><span class="line">&#x2F;&#x2F;transfer_one_message函数，也用于 SPI 数据发送，用于发送一个spi_message，SPI的数据会打包成 spi_message，然后以队列方式发送出去。</span><br></pre></td></tr></table></figure><p>SPI 主机端最终会通过 transfer 函数与 SPI 设备进行通信，因此对于 SPI 主机控制器的驱动编写者而言 transfer 函数是需要实现的，因为不同的 SOC 其 SPI 控制器不同，寄存器都不一样。SPI 主机驱动一般都是 SOC 厂商去编写的。</p><p>SPI 主机驱动的核心就是申请 spi_master，然后初始化 spi_master，最后向 Linux 内核注册 spi_master。 </p><p><strong>1、spi_master 申请与释放</strong></p><p>spi_alloc_master 函数用于申请 spi_master，当我们删除一个 SPI 主机驱动的时候就需要释放掉前面申请的 spi_master，spi_master 的释放通过 spi_master_put 函数来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct spi_master *spi_alloc_master(struct device *dev, </span><br><span class="line">unsigned size)</span><br><span class="line">&#x2F;&#x2F;dev：设备，一般是 platform_device 中的 dev 成员变量。</span><br><span class="line">&#x2F;&#x2F;size：私有数据大小，可以通过 spi_master_get_devdata 函数获取到这些私有数据。</span><br><span class="line">&#x2F;&#x2F;返回值：申请到的 spi_master。</span><br><span class="line"></span><br><span class="line">void spi_master_put(struct spi_master *master)</span><br><span class="line">&#x2F;&#x2F;master：要释放的 spi_master。</span><br><span class="line">&#x2F;&#x2F;返回值：无</span><br></pre></td></tr></table></figure><p><strong>2、spi_master 的注册与注销</strong></p><p>当 spi_master 初始化完成以后就需要将其注册到 Linux 内核，如果要注销 spi_master 的话可以使用 spi_unregister_master 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int spi_register_master(struct spi_master *master)</span><br><span class="line">&#x2F;&#x2F;master：要注册的 spi_master。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br><span class="line"></span><br><span class="line">void spi_unregister_master(struct spi_master *master)</span><br><span class="line">&#x2F;&#x2F;master：要注销的 spi_master。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h2 id="SPI-设备驱动"><a href="#SPI-设备驱动" class="headerlink" title="SPI 设备驱动"></a>SPI 设备驱动</h2><p>Linux 内核使用 spi_driver 结构体来表示 spi 设备驱动，spi_driver 结构体定义在include/linux/spi/spi.h 文件中，结构体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct spi_driver &#123;</span><br><span class="line">    const struct spi_device_id *id_table;</span><br><span class="line">    int (*probe)(struct spi_device *spi);</span><br><span class="line">    int (*remove)(struct spi_device *spi);</span><br><span class="line">    void (*shutdown)(struct spi_device *spi);</span><br><span class="line">    struct device_driver driver;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>spi_driver 和 i2c_driver、platform_driver 基本一样，当 SPI 设备和驱动匹配成功以后 probe 函数就会执行。 </p><p>spi_driver 初始化完成以后需要向 Linux 内核注册，spi_driver 注册函数为spi_register_driver，注销 SPI 设备驱动以后也需要注销掉前面注册的 spi_driver，使用 spi_unregister_driver 函<br>数完成 spi_driver 的注销，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int spi_register_driver(struct spi_driver *sdrv)</span><br><span class="line">&#x2F;&#x2F;sdrv：要注册的 spi_driver。</span><br><span class="line">&#x2F;&#x2F;返回值：0，注册成功；赋值，注册失败。</span><br><span class="line"></span><br><span class="line">void spi_unregister_driver(struct spi_driver *sdrv)</span><br><span class="line">&#x2F;&#x2F;sdrv：要注销的 spi_driver。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p>**spi_driver 注册示例程序如下： **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* probe 函数 *&#x2F;</span><br><span class="line">static int xxx_probe(struct spi_device *spi) </span><br><span class="line">&#123; </span><br><span class="line">    &#x2F;* 具体函数内容 *&#x2F;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* remove 函数 *&#x2F;</span><br><span class="line">static int xxx_remove(struct spi_device *spi)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* 具体函数内容 *&#x2F;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 传统匹配方式 ID 列表 *&#x2F;</span><br><span class="line">static const struct spi_device_id xxx_id[] &#x3D; &#123;</span><br><span class="line">    &#123;&quot;xxx&quot;, 0&#125;, </span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备树匹配列表 *&#x2F;</span><br><span class="line">static const struct of_device_id xxx_of_match[] &#x3D; &#123;</span><br><span class="line">    &#123; .compatible &#x3D; &quot;xxx&quot; &#125;,</span><br><span class="line">    &#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* SPI 驱动结构体 *&#x2F;</span><br><span class="line">static struct spi_driver xxx_driver &#x3D; &#123;</span><br><span class="line">    .probe &#x3D; xxx_probe,</span><br><span class="line">    .remove &#x3D; xxx_remove,</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .owner &#x3D; THIS_MODULE,</span><br><span class="line">        .name &#x3D; &quot;xxx&quot;,</span><br><span class="line">        .of_match_table &#x3D; xxx_of_match,</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table &#x3D; xxx_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动入口函数 *&#x2F;</span><br><span class="line">static int __init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return spi_register_driver(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动出口函数 *&#x2F;</span><br><span class="line">static void __exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">spi_unregister_driver(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SPI-设备和驱动匹配过程"><a href="#SPI-设备和驱动匹配过程" class="headerlink" title="SPI 设备和驱动匹配过程"></a>SPI 设备和驱动匹配过程</h3><p>SPI 设备和驱动的匹配过程是由 SPI 总线来完成的，这点和 platform、I2C 等驱动一样，SPI 总线为 spi_bus_type，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type spi_bus_type &#x3D; &#123;</span><br><span class="line">    .name &#x3D; &quot;spi&quot;,</span><br><span class="line">    .dev_groups &#x3D; spi_dev_groups,</span><br><span class="line">    .match &#x3D; spi_match_device,</span><br><span class="line">    .uevent &#x3D; spi_uevent,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SPI 设备和驱动的匹配函数为 spi_match_device，spi_match_device函数中的of_driver_match_device 函数用于完成设备树设备和驱动匹配，比较 SPI 设备节 点的 compatible 属性和 of_device_id 中的 compatible 属性是否相等，如果相当的话就表示 SPI 设备和驱动匹配。 spi_match_device函数中spi_match_id 函数用于传统的、无设备树的 SPI 设备和驱动匹配过程。比较 SPI设备名字和 spi_device_id 的 name 字段是否相等，相等的话就说明 SPI 设备和驱动匹配。 </p><h1 id="SPI-设备驱动编写流程"><a href="#SPI-设备驱动编写流程" class="headerlink" title="SPI 设备驱动编写流程"></a><strong>SPI</strong> <strong>设备驱动编写流程</strong></h1><h2 id="1、SPI-设备信息描述"><a href="#1、SPI-设备信息描述" class="headerlink" title="1、SPI 设备信息描述"></a><strong>1、SPI</strong> <strong>设备信息描述</strong></h2><p><strong>1、IO 的 pinctrl 子节点创建与修改</strong></p><p>首先肯定是根据所使用的 IO 来创建或修改 pinctrl 子节点，这个没什么好说的，唯独要注意的就是检查相应的 IO 有没有被其他的设备所使用，如果有的话需要将其删除掉！ </p><p><strong>2、SPI 设备节点的创建与修改</strong></p><p>采用设备树的情况下，SPI 设备信息描述就通过创建相应的设备子节点来完成，</p><h2 id="SPI-设备数据收发处理流程"><a href="#SPI-设备数据收发处理流程" class="headerlink" title="SPI 设备数据收发处理流程"></a><strong>SPI</strong> <strong>设备数据收发处理流程</strong></h2><p>SPI 设备驱动的核心是 spi_driver，当我们向 Linux 内 </p><p>核注册成功 spi_driver 以后就可以使用 SPI 核心层提供的 API 函数来对设备进行读写操作了。 </p><p>首先是 spi_transfer 结构体，此结构体用于描述 SPI 传输信息，结构体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct spi_transfer &#123;</span><br><span class="line">const void *tx_buf;</span><br><span class="line">610 void *rx_buf;</span><br><span class="line">611 unsigned len;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;tx_buf 保存着要发送的数据。</span><br><span class="line">&#x2F;&#x2F;rx_buf 用于保存接收到的数据。</span><br><span class="line">&#x2F;&#x2F;len是要进行传输的数据长度，SPI是全双工通信，因此在一次通信中发送和接收的字节数都是一样的，所以 spi_transfer中也就没有发送长度和接收长度之分。</span><br></pre></td></tr></table></figure><p>spi_transfer 需要组织成 spi_message，spi_message 也是一个结构体，在使用spi_message之前需要对其进行初始化，spi_message初始化函数为spi_message_init，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void spi_message_init(struct spi_message *m)</span><br><span class="line">函数参数和返回值含义如下：</span><br><span class="line">m：要初始化的 spi_message。</span><br><span class="line">返回值：无。</span><br></pre></td></tr></table></figure><p>spi_message 初始化完成以后需要将 spi_transfer 添加到 spi_message 队列中，这里我们要用到 spi_message_add_tail 函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m)</span><br><span class="line">t：要添加到队列中的 spi_transfer。 m：spi_transfer 要加入的 spi_message。</span><br><span class="line">返回值：无。</span><br></pre></td></tr></table></figure><p>spi_message 准备好以后既可以进行数据传输了，数据传输分为同步传输和异步传输。同步传输会阻塞的等待 SPI 数据传输完成，同步传输函数为 spi_sync。异步传输不会阻塞的等到 SPI 数据传输完成，异步传输需要设置 spi_message 中的 complete成员变量，complete 是一个回调函数，当 SPI 异步传输完成以后此函数就会被调用。SPI 异步传输函数为 spi_async，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int spi_sync(struct spi_device *spi, struct spi_message *message)</span><br><span class="line">&#x2F;&#x2F;spi：要进行数据传输的 spi_device。</span><br><span class="line">&#x2F;&#x2F;message：要传输的 spi_message。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br><span class="line"></span><br><span class="line">int spi_async(struct spi_device *spi, struct spi_message *message)</span><br><span class="line">&#x2F;&#x2F;spi：要进行数据传输的 spi_device。</span><br><span class="line">&#x2F;&#x2F;message：要传输的 spi_message。</span><br><span class="line">&#x2F;&#x2F;返回值：无</span><br></pre></td></tr></table></figure><p>SPI 数据传输步骤如下：</p><p>①、申请并初始化 spi_transfer，设置 spi_transfer 的 tx_buf 成员变量，tx_buf 为要发送的数<br>据。然后设置 rx_buf 成员变量，rx_buf 保存着接收到的数据。最后设置 len 成员变量，也就是<br>要进行数据通信的长度。<br>②、使用 spi_message_init 函数初始化 spi_message。<br>③、使用spi_message_add_tail函数将前面设置好的spi_transfer添加到spi_message队列中。<br>④、使用 spi_sync 函数完成 SPI 数据同步传输。</p><p>**通过 SPI 进行 n 个字节的数据发送和接收的示例代码如下所示： **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* SPI 多字节发送 *&#x2F;</span><br><span class="line">static int spi_send(struct spi_device *spi, u8 *buf, int len) &#123;</span><br><span class="line">     int ret;</span><br><span class="line">     struct spi_message m;</span><br><span class="line"></span><br><span class="line">     struct spi_transfer t &#x3D; &#123;</span><br><span class="line">     .tx_buf &#x3D; buf,</span><br><span class="line">     .len &#x3D; len,</span><br><span class="line">     &#125;;</span><br><span class="line">     spi_message_init(&amp;m); &#x2F;* 初始化 spi_message *&#x2F;</span><br><span class="line">     spi_message_add_tail(t, &amp;m);&#x2F;* 将 spi_transfer 添加到 spi_message 队列 *&#x2F;</span><br><span class="line">     ret &#x3D; spi_sync(spi, &amp;m); &#x2F;* 同步传输 *&#x2F;</span><br><span class="line">     return ret;</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;* SPI 多字节接收 *&#x2F;</span><br><span class="line">static int spi_receive(struct spi_device *spi, u8 *buf, int len) &#123;</span><br><span class="line">     int ret;</span><br><span class="line">     struct spi_message m;</span><br><span class="line"></span><br><span class="line">     struct spi_transfer t &#x3D; &#123;</span><br><span class="line">     .rx_buf &#x3D; buf,</span><br><span class="line">     .len &#x3D; len,</span><br><span class="line">     &#125;;</span><br><span class="line">     spi_message_init(&amp;m); &#x2F;* 初始化 spi_message *&#x2F;</span><br><span class="line">     spi_message_add_tail(t, &amp;m);&#x2F;* 将 spi_transfer 添加到 spi_message 队列 *&#x2F;</span><br><span class="line">     ret &#x3D; spi_sync(spi, &amp;m); &#x2F;* 同步传输 *&#x2F;</span><br><span class="line">     return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="试验程序编写"><a href="#试验程序编写" class="headerlink" title="试验程序编写"></a>试验程序编写</h1><h2 id="1、修改设备树"><a href="#1、修改设备树" class="headerlink" title="1、修改设备树"></a><strong>1、修改设备树</strong></h2><p><strong>1、添加 ICM20608 所使用的 IO</strong></p><p>首先在 imx6ull-alientek-emmc.dts 文件中添加 ICM20608 所使用的 IO 信息，在 iomuxc 节点中添加一个新的子节点来描述 ICM20608 所使用的 SPI 引脚，子节点名字为 pinctrl_ecspi3，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_ecspi3: icm20608 &#123; </span><br><span class="line">    fsl,pins &#x3D; &lt; </span><br><span class="line">        MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20 0x10b0 &#x2F;* CS *&#x2F;</span><br><span class="line">        MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK 0x10b1 &#x2F;* SCLK *&#x2F;</span><br><span class="line">        MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO 0x10b1 &#x2F;* MISO *&#x2F;</span><br><span class="line">        MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI 0x10b1 &#x2F;* MOSI *&#x2F;</span><br><span class="line">    &gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>UART2_TX_DATA 这个 IO 是 ICM20608 的片选信号，这里我们并没有将其复用为 ECSPI3的SS0 信号，而是将其复用为了普通的 GPIO。因为我们需要自己控制片选信号，所以将其复用为普通的 GPIO。 </p><p><strong>2、在 ecspi3 节点追加 icm20608 子节点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&amp;ecspi3 &#123; 2 fsl,spi-num-chipselects &#x3D; &lt;1&gt;;</span><br><span class="line">3 cs-gpio &#x3D; &lt;&amp;gpio1 20 GPIO_ACTIVE_LOW&gt;; &#x2F;* cant&#39;t use cs-gpios! *&#x2F;</span><br><span class="line">4 pinctrl-names &#x3D; &quot;default&quot;; 5 pinctrl-0 &#x3D; &lt;&amp;pinctrl_ecspi3&gt;;</span><br><span class="line">6 status &#x3D; &quot;okay&quot;; 7 </span><br><span class="line">8 spidev: icm20608@0 &#123; 9 compatible &#x3D; &quot;alientek,icm20608&quot;;</span><br><span class="line">10 spi-max-frequency &#x3D; &lt;8000000&gt;;</span><br><span class="line">11 reg &#x3D; &lt;0&gt;;</span><br><span class="line">12 &#125;;</span><br><span class="line">13 &#125;;</span><br></pre></td></tr></table></figure><p>第 2 行，设置当前片选数量为 1，因为就只接了一个 ICM20608。 第 3 行，注意！这里并没有用到“cs-gpios”属性，而是用了一个自己定义的“cs-gpio”属性，因为我们要自己控制片选引脚。如果使用“cs-gpios”属性的话 SPI 主机驱动就会控制片选引脚。</p><p>第 5 行，设置 IO 要使用的 pinctrl_ecspi3子节点，第 6 行，imx6ull.dtsi 文件中默认将 ecspi3 节点状态(status)设置为“disable”，这里我们要将其改为“okay”。</p><p>第 8~12 行，icm20608 设备子节点，因为 icm20608 连接在 ECSPI3 的第 0 个通道上，因此@后面为 0。</p><p>第 9 行设置节点属性兼容值为“alientek,icm20608”，</p><p>第 10 行设置 SPI 最大时钟频率为 8MHz，这是 ICM20608 的 SPI 接口所能支持的最大的时钟频率。</p><p>第 11 行，icm20608 连接在通道 0 上，因此 reg 为 0。</p><h2 id="2、编写-ICM20608-驱动"><a href="#2、编写-ICM20608-驱动" class="headerlink" title="2、编写 ICM20608 驱动"></a>2、编写 ICM20608 驱动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: icm20608.c</span><br><span class="line">描述   : ICM20608 SPI驱动程序</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">struct icm20608_dev &#123;</span><br><span class="line">void *private_data;&#x2F;* 私有数据 *&#x2F;</span><br><span class="line">int cs_gpio;&#x2F;* 片选所使用的GPIO编号*&#x2F;</span><br><span class="line">signed int gyro_x_adc;&#x2F;* 陀螺仪X轴原始值  *&#x2F;</span><br><span class="line">signed int gyro_y_adc;&#x2F;* 陀螺仪Y轴原始值*&#x2F;</span><br><span class="line">signed int gyro_z_adc;&#x2F;* 陀螺仪Z轴原始值 *&#x2F;</span><br><span class="line">signed int accel_x_adc;&#x2F;* 加速度计X轴原始值 *&#x2F;</span><br><span class="line">signed int accel_y_adc;&#x2F;* 加速度计Y轴原始值*&#x2F;</span><br><span class="line">signed int accel_z_adc;&#x2F;* 加速度计Z轴原始值 *&#x2F;</span><br><span class="line">signed int temp_adc;&#x2F;* 温度原始值 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">static struct icm20608_dev icm20608dev;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 从icm20608读取多个寄存器数据</span><br><span class="line"> * @param - dev:  icm20608设备</span><br><span class="line"> * @param - reg:  要读取的寄存器首地址</span><br><span class="line"> * @param - val:  读取到的数据</span><br><span class="line"> * @param - len:  要读取的数据长度</span><br><span class="line"> * @return : 操作结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int icm20608_read_regs(struct icm20608_dev *dev, u8 reg, void *buf, int len)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">unsigned char txdata[len];</span><br><span class="line">struct spi_message m;</span><br><span class="line">struct spi_transfer *t;</span><br><span class="line">struct spi_device *spi &#x3D; (struct spi_device *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">gpio_set_value(dev-&gt;cs_gpio, 0);&#x2F;* 片选拉低，选中ICM20608 *&#x2F;</span><br><span class="line">t &#x3D; kzalloc(sizeof(struct spi_transfer), GFP_KERNEL);&#x2F;* 申请内存 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 第1次，发送要读取的寄存地址 *&#x2F;</span><br><span class="line">txdata[0] &#x3D; reg | 0x80;&#x2F;* 写数据的时候寄存器地址bit8要置1 *&#x2F;</span><br><span class="line">t-&gt;tx_buf &#x3D; txdata;&#x2F;* 要发送的数据 *&#x2F;</span><br><span class="line">t-&gt;len &#x3D; 1;&#x2F;* 1个字节 *&#x2F;</span><br><span class="line">spi_message_init(&amp;m);&#x2F;* 初始化spi_message *&#x2F;</span><br><span class="line">spi_message_add_tail(t, &amp;m);&#x2F;* 将spi_transfer添加到spi_message队列 *&#x2F;</span><br><span class="line">ret &#x3D; spi_sync(spi, &amp;m);&#x2F;* 同步发送 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 第2次，读取数据 *&#x2F;</span><br><span class="line">txdata[0] &#x3D; 0xff;&#x2F;* 随便一个值，此处无意义 *&#x2F;</span><br><span class="line">t-&gt;rx_buf &#x3D; buf;&#x2F;* 读取到的数据 *&#x2F;</span><br><span class="line">t-&gt;len &#x3D; len;&#x2F;* 要读取的数据长度 *&#x2F;</span><br><span class="line">spi_message_init(&amp;m);&#x2F;* 初始化spi_message *&#x2F;</span><br><span class="line">spi_message_add_tail(t, &amp;m);&#x2F;* 将spi_transfer添加到spi_message队列 *&#x2F;</span><br><span class="line">ret &#x3D; spi_sync(spi, &amp;m);&#x2F;* 同步发送 *&#x2F;</span><br><span class="line"></span><br><span class="line">kfree(t);&#x2F;* 释放内存 *&#x2F;</span><br><span class="line">gpio_set_value(dev-&gt;cs_gpio, 1);&#x2F;* 片选拉高，释放ICM20608 *&#x2F;</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 向icm20608多个寄存器写入数据</span><br><span class="line"> * @param - dev:  icm20608设备</span><br><span class="line"> * @param - reg:  要写入的寄存器首地址</span><br><span class="line"> * @param - val:  要写入的数据缓冲区</span><br><span class="line"> * @param - len:  要写入的数据长度</span><br><span class="line"> * @return   :   操作结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static s32 icm20608_write_regs(struct icm20608_dev *dev, u8 reg, u8 *buf, u8 len)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">unsigned char txdata[len];</span><br><span class="line">struct spi_message m;</span><br><span class="line">struct spi_transfer *t;</span><br><span class="line">struct spi_device *spi &#x3D; (struct spi_device *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">t &#x3D; kzalloc(sizeof(struct spi_transfer), GFP_KERNEL);&#x2F;* 申请内存 *&#x2F;</span><br><span class="line">gpio_set_value(dev-&gt;cs_gpio, 0);&#x2F;* 片选拉低 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 第1次，发送要读取的寄存地址 *&#x2F;</span><br><span class="line">txdata[0] &#x3D; reg &amp; ~0x80;&#x2F;* 写数据的时候寄存器地址bit8要清零 *&#x2F;</span><br><span class="line">t-&gt;tx_buf &#x3D; txdata;&#x2F;* 要发送的数据 *&#x2F;</span><br><span class="line">t-&gt;len &#x3D; 1;&#x2F;* 1个字节 *&#x2F;</span><br><span class="line">spi_message_init(&amp;m);&#x2F;* 初始化spi_message *&#x2F;</span><br><span class="line">spi_message_add_tail(t, &amp;m);&#x2F;* 将spi_transfer添加到spi_message队列 *&#x2F;</span><br><span class="line">ret &#x3D; spi_sync(spi, &amp;m);&#x2F;* 同步发送 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 第2次，发送要写入的数据 *&#x2F;</span><br><span class="line">t-&gt;tx_buf &#x3D; buf;&#x2F;* 要写入的数据 *&#x2F;</span><br><span class="line">t-&gt;len &#x3D; len;&#x2F;* 写入的字节数 *&#x2F;</span><br><span class="line">spi_message_init(&amp;m);&#x2F;* 初始化spi_message *&#x2F;</span><br><span class="line">spi_message_add_tail(t, &amp;m);&#x2F;* 将spi_transfer添加到spi_message队列 *&#x2F;</span><br><span class="line">ret &#x3D; spi_sync(spi, &amp;m);&#x2F;* 同步发送 *&#x2F;</span><br><span class="line"></span><br><span class="line">kfree(t);&#x2F;* 释放内存 *&#x2F;</span><br><span class="line">gpio_set_value(dev-&gt;cs_gpio, 1);&#x2F;* 片选拉高，释放ICM20608 *&#x2F;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 读取icm20608指定寄存器值，读取一个寄存器</span><br><span class="line"> * @param - dev:  icm20608设备</span><br><span class="line"> * @param - reg:  要读取的寄存器</span><br><span class="line"> * @return   :   读取到的寄存器值</span><br><span class="line"> *&#x2F;</span><br><span class="line">static unsigned char icm20608_read_onereg(struct icm20608_dev *dev, u8 reg)</span><br><span class="line">&#123;</span><br><span class="line">u8 data &#x3D; 0;</span><br><span class="line">icm20608_read_regs(dev, reg, &amp;data, 1);</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 向icm20608指定寄存器写入指定的值，写一个寄存器</span><br><span class="line"> * @param - dev:  icm20608设备</span><br><span class="line"> * @param - reg:  要写的寄存器</span><br><span class="line"> * @param - data: 要写入的值</span><br><span class="line"> * @return   :    无</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">static void icm20608_write_onereg(struct icm20608_dev *dev, u8 reg, u8 value)</span><br><span class="line">&#123;</span><br><span class="line">u8 buf &#x3D; value;</span><br><span class="line">icm20608_write_regs(dev, reg, &amp;buf, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 读取ICM20608的数据，读取原始数据，包括三轴陀螺仪、</span><br><span class="line"> * : 三轴加速度计和内部温度。</span><br><span class="line"> * @param - dev: ICM20608设备</span><br><span class="line"> * @return : 无。</span><br><span class="line"> *&#x2F;</span><br><span class="line">void icm20608_readdata(struct icm20608_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char data[14];</span><br><span class="line">icm20608_read_regs(dev, ICM20_ACCEL_XOUT_H, data, 14);</span><br><span class="line"></span><br><span class="line">dev-&gt;accel_x_adc &#x3D; (signed short)((data[0] &lt;&lt; 8) | data[1]); </span><br><span class="line">dev-&gt;accel_y_adc &#x3D; (signed short)((data[2] &lt;&lt; 8) | data[3]); </span><br><span class="line">dev-&gt;accel_z_adc &#x3D; (signed short)((data[4] &lt;&lt; 8) | data[5]); </span><br><span class="line">dev-&gt;temp_adc    &#x3D; (signed short)((data[6] &lt;&lt; 8) | data[7]); </span><br><span class="line">dev-&gt;gyro_x_adc  &#x3D; (signed short)((data[8] &lt;&lt; 8) | data[9]); </span><br><span class="line">dev-&gt;gyro_y_adc  &#x3D; (signed short)((data[10] &lt;&lt; 8) | data[11]);</span><br><span class="line">dev-&gt;gyro_z_adc  &#x3D; (signed short)((data[12] &lt;&lt; 8) | data[13]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 打开设备</span><br><span class="line"> * @param - inode : 传递给驱动的inode</span><br><span class="line"> * @param - filp : 设备文件，file结构体有个叫做pr似有ate_data的成员变量</span><br><span class="line"> *   一般在open的时候将private_data似有向设备结构体。</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int icm20608_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data &#x3D; &amp;icm20608dev; &#x2F;* 设置私有数据 *&#x2F;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 从设备读取数据 </span><br><span class="line"> * @param - filp : 要打开的设备文件(文件描述符)</span><br><span class="line"> * @param - buf : 返回给用户空间的数据缓冲区</span><br><span class="line"> * @param - cnt : 要读取的数据长度</span><br><span class="line"> * @param - offt : 相对于文件首地址的偏移</span><br><span class="line"> * @return : 读取的字节数，如果为负值，表示读取失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static ssize_t icm20608_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off)</span><br><span class="line">&#123;</span><br><span class="line">signed int data[7];</span><br><span class="line">long err &#x3D; 0;</span><br><span class="line">struct icm20608_dev *dev &#x3D; (struct icm20608_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">icm20608_readdata(dev);</span><br><span class="line">data[0] &#x3D; dev-&gt;gyro_x_adc;</span><br><span class="line">data[1] &#x3D; dev-&gt;gyro_y_adc;</span><br><span class="line">data[2] &#x3D; dev-&gt;gyro_z_adc;</span><br><span class="line">data[3] &#x3D; dev-&gt;accel_x_adc;</span><br><span class="line">data[4] &#x3D; dev-&gt;accel_y_adc;</span><br><span class="line">data[5] &#x3D; dev-&gt;accel_z_adc;</span><br><span class="line">data[6] &#x3D; dev-&gt;temp_adc;</span><br><span class="line">err &#x3D; copy_to_user(buf, data, sizeof(data));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 关闭&#x2F;释放设备</span><br><span class="line"> * @param - filp : 要关闭的设备文件(文件描述符)</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int icm20608_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* icm20608操作函数 *&#x2F;</span><br><span class="line">static const struct file_operations icm20608_ops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; icm20608_open,</span><br><span class="line">.read &#x3D; icm20608_read,</span><br><span class="line">.release &#x3D; icm20608_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * ICM20608内部寄存器初始化函数 </span><br><span class="line"> * @param  : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">void icm20608_reginit(void)</span><br><span class="line">&#123;</span><br><span class="line">u8 value &#x3D; 0;</span><br><span class="line"></span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, 0x80);</span><br><span class="line">mdelay(50);</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, 0x01);</span><br><span class="line">mdelay(50);</span><br><span class="line"></span><br><span class="line">value &#x3D; icm20608_read_onereg(&amp;icm20608dev, ICM20_WHO_AM_I);</span><br><span class="line">printk(&quot;ICM20608 ID &#x3D; %#X\r\n&quot;, value);</span><br><span class="line"></span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_SMPLRT_DIV, 0x00); &#x2F;* 输出速率是内部采样率*&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_GYRO_CONFIG, 0x18); &#x2F;* 陀螺仪±2000dps量程 *&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG, 0x18); &#x2F;* 加速度计±16G量程 *&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_CONFIG, 0x04); &#x2F;* 陀螺仪低通滤波BW&#x3D;20Hz *&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG2, 0x04); &#x2F;* 加速度计低通滤波BW&#x3D;21.2Hz *&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_2, 0x00); &#x2F;* 打开加速度计和陀螺仪所有轴 *&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_LP_MODE_CFG, 0x00); &#x2F;* 关闭低功耗 *&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_FIFO_EN, 0x00);&#x2F;* 关闭FIFO*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : spi驱动的probe函数，当驱动与</span><br><span class="line">  *                    设备匹配以后此函数就会执行</span><br><span class="line">  * @param - client  : spi设备</span><br><span class="line">  * @param - id      : spi设备ID</span><br><span class="line">  * </span><br><span class="line">  *&#x2F;</span><br><span class="line">static int icm20608_probe(struct spi_device *spi)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;* 1、构建设备号 *&#x2F;</span><br><span class="line">&#x2F;* 2、注册设备 *&#x2F;</span><br><span class="line">&#x2F;* 3、创建类 *&#x2F;</span><br><span class="line">&#x2F;* 4、创建设备 *&#x2F;</span><br><span class="line">&#x2F;* 获取设备树中cs片选信号 *&#x2F;</span><br><span class="line">icm20608dev.nd &#x3D; of_find_node_by_path(&quot;&#x2F;soc&#x2F;aips-bus@02000000&#x2F;spba-bus@02000000&#x2F;ecspi@02010000&quot;);</span><br><span class="line">if(icm20608dev.nd &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">printk(&quot;ecspi3 node not find!\r\n&quot;);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;*初始化spi_device *&#x2F;</span><br><span class="line">spi-&gt;mode &#x3D; SPI_MODE_0;&#x2F;*MODE0，CPOL&#x3D;0，CPHA&#x3D;0*&#x2F;</span><br><span class="line">spi_setup(spi);</span><br><span class="line">icm20608dev.private_data &#x3D; spi; &#x2F;* 设置私有数据 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 初始化ICM20608内部寄存器 *&#x2F;</span><br><span class="line">icm20608_reginit();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 传统匹配方式ID列表 *&#x2F;</span><br><span class="line">static const struct spi_device_id icm20608_id[] &#x3D; &#123;</span><br><span class="line">&#123;&quot;alientek,icm20608&quot;, 0&#125;,  </span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备树匹配列表 *&#x2F;</span><br><span class="line">static const struct of_device_id icm20608_of_match[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;alientek,icm20608&quot; &#125;,</span><br><span class="line">&#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* SPI驱动结构体 *&#x2F;</span><br><span class="line">static struct spi_driver icm20608_driver &#x3D; &#123;</span><br><span class="line">.probe &#x3D; icm20608_probe,</span><br><span class="line">.remove &#x3D; icm20608_remove,</span><br><span class="line">.driver &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">   .name &#x3D; &quot;icm20608&quot;,</span><br><span class="line">   .of_match_table &#x3D; icm20608_of_match, </span><br><span class="line">   &#125;,</span><br><span class="line">.id_table &#x3D; icm20608_id,</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动入口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init icm20608_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return spi_register_driver(&amp;icm20608_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动出口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __exit icm20608_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">spi_unregister_driver(&amp;icm20608_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Linux-下-SPI-驱动框架&quot;&gt;&lt;a href=&quot;#Linux-下-SPI-驱动框架&quot; class=&quot;headerlink&quot; title=&quot;Linux 下 SPI 驱动框架&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux&lt;/strong&gt; &lt;strong&gt;下&lt;/strong&gt; &lt;strong&gt;SPI&lt;/strong&gt; &lt;strong&gt;驱动框架&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;SPI-主机驱动&quot;&gt;&lt;a href=&quot;#SPI-主机驱动&quot; class=&quot;headerlink&quot; title=&quot;SPI 主机驱动&quot;&gt;&lt;/a&gt;&lt;strong&gt;SPI&lt;/strong&gt; &lt;strong&gt;主机驱动&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;SPI 主机驱动就是 SOC 的 SPI 控制器驱动，类似 I2C 驱动里面的适配器驱动。Linux 内核使用 spi_master表示 SPI 主机驱动，spi_master 是个结构体，定义在 include/linux/spi/spi.h 文件中，内容如下(有缩减)：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-I2C驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/17/Linux%E9%A9%B1%E5%8A%A8-I2C%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/17/Linux%E9%A9%B1%E5%8A%A8-I2C%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-17T05:51:36.000Z</published>
    <updated>2021-05-05T04:43:45.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-I2C驱动框架"><a href="#Linux-I2C驱动框架" class="headerlink" title="Linux I2C驱动框架"></a>Linux I2C驱动框架</h1><p>裸机篇中编写 AP3216C 驱动的四个文件：bsp_i2c.c、bsp_i2c.h、bsp_ap3216c.c 和 bsp_ap3216c.h。其中前两个是 I.MX6U 的 IIC 接口驱动，后两个文 件是 AP3216C 这个 I2C 设备驱动文件。相当于有两部分驱动： I2C 主机驱动、I2C 设备驱动。 </p> <a id="more"></a> <p>对于 I2C 主机驱动，一旦编写完成就不需要再做修改，其他的 I2C 设备直接调用主机驱动提供的 API 函数完成读写操作即可。这个正好符合 Linux 的驱动分离与分层的思想，因此 Linux内核也将 I2C 驱动分为两部分：<br>①、I2C 总线驱动，I2C 总线驱动就是 SOC 的 I2C 控制器驱动，也叫做 I2C 适配器驱动。<br>②、I2C 设备驱动，I2C 设备驱动就是针对具体的 I2C 设备而编写的驱动。</p><h2 id="I2C-总线驱动"><a href="#I2C-总线驱动" class="headerlink" title="I2C 总线驱动"></a><strong>I2C</strong> <strong>总线驱动</strong></h2><p>platform 是虚拟出来的一条总线，目的是为了实现总线、设备、驱动框架。。对于 I2C 而言，不需要虚拟出一条总线，直接使用 I2C 总线即可。I2C 总线驱动重点是 I2C 适配器(也就是 SOC 的 I2C 接口控制器)驱动，这里要用到 两个重要的数据结构：i2c_adapter 和 i2c_algorithm，Linux 内核将 SOC 的 I2C 适配器(控制器) 抽象成 i2c_adapter，i2c_adapter 结构体定义在 include/linux/i2c.h 文件中，结构体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_adapter &#123;</span><br><span class="line">    struct module *owner;</span><br><span class="line">    unsigned int class; &#x2F;* classes to allow probing for *&#x2F;</span><br><span class="line">    const struct i2c_algorithm *algo; &#x2F;* 总线访问算法 *&#x2F;</span><br><span class="line">    void *algo_data;</span><br><span class="line">………………</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于一个 I2C 适配器，肯定要对外提供读写 API 函数，设备驱动程序可以使用这些 API 函数来完成读写操作。i2c_algorithm 就是 I2C 适配器与 IIC 设备进行通信的方法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_algorithm &#123;</span><br><span class="line">    ......</span><br><span class="line">    int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);</span><br><span class="line">    int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr, unsigned short flags,</span><br><span class="line">    char read_write, u8 command, int size, union i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">    &#x2F;* To determine what the adapter supports *&#x2F;</span><br><span class="line">    u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;master_xfer 就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之间的通信。</span><br><span class="line">&#x2F;&#x2F;smbus_xfer 就是 SMBUS 总线的传输函数。</span><br></pre></td></tr></table></figure><p>综上所述，I2C 总线驱动(I2C 适配器驱动)的主要工作就是初始化 i2c_adapter 结构体变量，然后设置 i2c_algorithm 中的 master_xfer 函数。</p><p>完成初始化以后通过 i2c_add_numbered_adapter或 i2c_add_adapter 这两个函数向系统注册设置好的 i2c_adapter，如果要删除 I2C 适配器的话使用 i2c_del_adapter 函数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int i2c_add_adapter(struct i2c_adapter *adapter)</span><br><span class="line">int i2c_add_numbered_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#x2F;&#x2F;这两个函数的区别在于 i2c_add_adapter 使用动态的总线号，而 i2c_add_numbered_adapter</span><br><span class="line">使用静态总线号。</span><br><span class="line">&#x2F;&#x2F;adapter 或 adap：要添加到 Linux 内核中的 i2c_adapter，也就是 I2C 适配器。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br><span class="line"></span><br><span class="line">void i2c_del_adapter(struct i2c_adapter * adap)</span><br><span class="line">&#x2F;&#x2F;adap：要删除的 I2C 适配器。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p>一般 SOC 的 I2C 总线驱动都是由半导体厂商编写的，比如 I.MX6U 的 I2C 适配器驱动 NXP 已经编写好了，这个不需要用户去编写。只要专注于 I2C 设备驱 动即可。</p><h2 id="I2C-设备驱动"><a href="#I2C-设备驱动" class="headerlink" title="I2C 设备驱动"></a>I2C 设备驱动</h2><p>I2C 设备驱动重点关注两个数据结构：i2c_client 和 i2c_driver，i2c_client 就是描述设备信息的，i2c_driver 描述驱动内容，类似于 platform_driver。 </p><h3 id="1、i2c-client-结构体"><a href="#1、i2c-client-结构体" class="headerlink" title="1、i2c_client 结构体"></a>1、i2c_client 结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_client &#123;</span><br><span class="line">    unsigned short flags; &#x2F;* 标志 *&#x2F;</span><br><span class="line">    unsigned short addr; &#x2F;* 芯片地址，7 位，存在低 7 位*&#x2F;</span><br><span class="line">    ......</span><br><span class="line">    char name[I2C_NAME_SIZE]; &#x2F;* 名字 *&#x2F;</span><br><span class="line">    struct i2c_adapter *adapter; &#x2F;* 对应的 I2C 适配器 *&#x2F;</span><br><span class="line">    struct device dev; &#x2F;* 设备结构体 *&#x2F;</span><br><span class="line">    int irq; &#x2F;* 中断 *&#x2F;</span><br><span class="line">    struct list_head detected;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个设备对应一个 i2c_client，每检测到一个 I2C 设备就会给这个 I2C 设备分配一个i2c_client。 </p><h3 id="2、i2c-driver-结构体"><a href="#2、i2c-driver-结构体" class="headerlink" title="2、i2c_driver 结构体"></a>2、i2c_driver 结构体</h3><p>i2c_driver 类似 platform_driver，是编写 I2C 设备驱动重点要处理的内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_driver &#123;</span><br><span class="line">………………</span><br><span class="line">int (*probe)(struct i2c_client *, const struct i2c_device_id *);</span><br><span class="line">………………</span><br><span class="line">struct device_driver driver;</span><br><span class="line">const struct i2c_device_id *id_table;</span><br><span class="line">………………</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当 I2C 设备和驱动匹配成功以后 probe 函数就会执行，和 platform 驱动一样。 </span><br><span class="line">&#x2F;&#x2F;device_driver 驱动结构体，如果使用设备树的话，需要设置 device_driver 的of_match_table 成员变量，也就是驱动的兼容(compatible)属性。 </span><br><span class="line">&#x2F;&#x2F;id_table 是传统的、未使用设备树的设备匹配 ID 表。 </span><br></pre></td></tr></table></figure><p>重点工作就是构建 i2c_driver，构建完成以后需要向Linux 内核注册这个 i2c_driver。i2c_driver 注册函数为 int i2c_register_driver，注销 I2C 设备驱动的时候需要将前面注册的 i2c_driver 从 Linux 内核中注销掉，需要用到 i2c_del_driver 函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i2c_register_driver(struct module *owner,  struct i2c_driver *driver)</span><br><span class="line">&#x2F;&#x2F;owner：一般为 THIS_MODULE。</span><br><span class="line">&#x2F;&#x2F;driver：要注册的 i2c_driver。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br><span class="line"></span><br><span class="line">void i2c_del_driver(struct i2c_driver *driver)</span><br><span class="line">&#x2F;&#x2F;driver：要注销的 i2c_driver。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p><strong>i2c_driver 的注册示例代码如下：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* i2c 驱动的 probe 函数 *&#x2F;</span><br><span class="line">static int xxx_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">&#123; </span><br><span class="line">    &#x2F;* 函数具体程序 *&#x2F;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* i2c 驱动的 remove 函数 *&#x2F;</span><br><span class="line">static int ap3216c_remove(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* 函数具体程序 *&#x2F;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 传统匹配方式 ID 列表 *&#x2F;</span><br><span class="line">static const struct i2c_device_id xxx_id[] &#x3D; &#123;</span><br><span class="line">    &#123;&quot;xxx&quot;, 0&#125;, </span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备树匹配列表 *&#x2F;</span><br><span class="line">static const struct of_device_id xxx_of_match[] &#x3D; &#123;</span><br><span class="line">    &#123; .compatible &#x3D; &quot;xxx&quot; &#125;,</span><br><span class="line">    &#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* i2c 驱动结构体 *&#x2F;</span><br><span class="line">static struct i2c_driver xxx_driver &#x3D; &#123;</span><br><span class="line">    .probe &#x3D; xxx_probe,</span><br><span class="line">    .remove &#x3D; xxx_remove,</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .name &#x3D; &quot;xxx&quot;,</span><br><span class="line">    .of_match_table &#x3D; xxx_of_match,</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table &#x3D; xxx_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动入口函数 *&#x2F;</span><br><span class="line">static int __init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    ret &#x3D; i2c_add_driver(&amp;xxx_driver);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动出口函数 *&#x2F;</span><br><span class="line">static void __exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">i2c_del_driver(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure><p>i2c_device_id，无设备树的时候匹配 ID 表。</p><p>of_device_id，设备树所使用的匹配表。</p><p>i2c_driver，当 I2C 设备和 I2C 驱动匹配成功以后 probe 函数就会执行，这些和 platform 驱动一样，probe 函数里面基本就是标准的字符设备驱动那一套了。 </p><h2 id="I2C-设备和驱动匹配过程"><a href="#I2C-设备和驱动匹配过程" class="headerlink" title="I2C 设备和驱动匹配过程"></a>I2C 设备和驱动匹配过程</h2><p>I2C 设备和驱动的匹配过程是由 I2C 核心来完成的，drivers/i2c/i2c-core.c 就是 I2C 的核心部分。</p><p>设备和驱动的匹配过程也是由 I2C 总线完成的，I2C 总线的数据结构为 i2c_bus_type，定义 在 drivers/i2c/i2c-core.c 文件，i2c_bus_type 内容如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class="line">    .name &#x3D; &quot;i2c&quot;,</span><br><span class="line">    .match &#x3D; i2c_device_match,&#x2F;&#x2F;.match 就是 I2C 总线的设备和驱动匹配函数，</span><br><span class="line">    .probe &#x3D; i2c_device_probe,</span><br><span class="line">    .remove &#x3D; i2c_device_remove,</span><br><span class="line">    .shutdown &#x3D; i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="I-MX6U-的-I2C-适配器驱动分析"><a href="#I-MX6U-的-I2C-适配器驱动分析" class="headerlink" title="I.MX6U 的 I2C 适配器驱动分析"></a>I.MX6U 的 I2C 适配器驱动分析</h1><p>Linux 下的 I2C 驱动框架，重点分为 I2C 适配器驱动和 I2C 设备驱动， 其中 I2C 适配器驱动就是 SOC 的 I2C 控制器驱动。I2C 设备驱动是需要用户根据不同的 I2C 设备去编写，而 I2C 适配器驱动一般都是 SOC 厂商去编写的，比如 NXP 就编写好了 I.MX6U 的I2C 适配器驱动。I.MX6U 的 I2C 适配器驱动是个标准的 platform 驱动，虽然 I2C 总线为别的设备提供了一种I2C总线驱动框架，但是 I2C 适配器却是 platform驱动。</p><p>在 imx6ull.dtsi 文件中找到 I.MX6U 的 I2C1 控制器节点，i2c1 节点的 compatible 属性值有两个：“fsl,imx6ul-i2c”和“fsl,imx21- i2c”。I.MX6U 的 I2C 适配器驱动文件为 drivers/i2c/busses/i2c-imx.c中设备树 ID为“fsl,imx21-i2c”属性值，设备树中 i2c1 节点的 compatible 属性值就是与此匹配上的。因此 i2c-imx.c 文件就是 I.MX6U 的 I2C 适配器驱动文件。 当设备和驱动匹配成功以后 i2c_imx_probe 函数就会执行，i2c_imx_probe 函数就会完成 I2C 适配器初始化工作。 </p><p>i2c_imx_probe 函数主要的工作就是一下两点：</p><ul><li>初始化 i2c_adapter，设置 i2c_algorithm 为 i2c_imx_algo，最后向 Linux 内核注册i2c_adapter。</li><li>初始化 I2C1 控制器的相关寄存器。</li></ul><p>i2c_imx_algo 包含 I2C1 适配器与 I2C 设备的通信函数 master_xfer，i2c_imx_probe中设置i2c_adapter的algo成员变量为i2c_imx_algo，也就是设置 i2c_algorithm。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct i2c_algorithm i2c_imx_algo &#x3D; &#123;</span><br><span class="line">    .master_xfer &#x3D; i2c_imx_xfer,</span><br><span class="line">    .functionality &#x3D; i2c_imx_func,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;.functionality用于返回此I2C适配器支持什么样的通信协议</span><br><span class="line">&#x2F;&#x2F;.master_xfer通过此函数来完成与 I2C 设备通信的</span><br></pre></td></tr></table></figure><p>functionality用于返回此I2C适配器支持什么样的通信协议，在这里 functionality 就是 i2c_imx_func 函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static u32 i2c_imx_func(struct i2c_adapter *adapter) &#123;</span><br><span class="line"> return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_READ_BLOCK_DATA; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>i2c_imx_xfer 函数，因为最终就是通过此函数来完成与 I2C 设备通信的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static int i2c_imx_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)</span><br><span class="line">&#123;</span><br><span class="line">………………</span><br><span class="line">&#x2F;* Start I2C transfer *&#x2F;</span><br><span class="line">result &#x3D; i2c_imx_start(i2c_imx);</span><br><span class="line"></span><br><span class="line">if (msgs[i].flags &amp; I2C_M_RD)</span><br><span class="line">result &#x3D; i2c_imx_read(i2c_imx, &amp;msgs[i], is_lastmsg);</span><br><span class="line">    else &#123;</span><br><span class="line">        if (i2c_imx-&gt;dma &amp;&amp; msgs[i].len &gt;&#x3D; DMA_THRESHOLD)</span><br><span class="line">        result &#x3D; i2c_imx_dma_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">        else</span><br><span class="line">        result &#x3D; i2c_imx_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ………………</span><br><span class="line">    i2c_imx_stop(i2c_imx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 i2c_imx_start 函数开启 I2C 通信。 </p><p>如果是从 I2C 设备读数据的话就调用 i2c_imx_read 函数</p><p>向 I2C 设备写数据，如果要用 DMA 的话就使用 i2c_imx_dma_write 函数来完成写数据。如果不使用 DMA 的话就使用 i2c_imx_write 函数完成写数据。 </p><p>I2C 通信完成以后调用 i2c_imx_stop 函数停止 I2C 通信。 </p><h1 id="I2C-设备驱动编写流程"><a href="#I2C-设备驱动编写流程" class="headerlink" title="I2C 设备驱动编写流程"></a>I2C 设备驱动编写流程</h1><p>I2C 适配器驱动 SOC 厂商已经替我们编写好了，我们需要做的就是编写具体的设备驱动</p><h3 id="1、I2C-设备信息描"><a href="#1、I2C-设备信息描" class="headerlink" title="1、I2C 设备信息描"></a>1、I2C 设备信息描</h3><p><strong>1、未使用设备树的时候</strong></p><p>首先肯定要描述 I2C 设备节点信息，在未使用设备树的时候需要在 BSP 里面使用 i2c_board_info 结构体来描述一个具体的 I2C 设备。i2c_board_info 结构体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_board_info &#123;</span><br><span class="line">    char type[I2C_NAME_SIZE]; &#x2F;* I2C 设备名字 *&#x2F;</span><br><span class="line">    unsigned short flags; &#x2F;* 标志 *&#x2F;</span><br><span class="line">    unsigned short addr; &#x2F;* I2C 器件地址 *&#x2F;</span><br><span class="line">    void *platform_data; </span><br><span class="line">    struct dev_archdata *archdata;</span><br><span class="line">    struct device_node *of_node;</span><br><span class="line">    struct fwnode_handle *fwnode;</span><br><span class="line">    int irq;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;type 和 addr 这两个成员变量是必须要设置的，一个是 I2C 设备的名字，一个是 I2C 设备的器件地址。</span><br></pre></td></tr></table></figure><p><strong>2、使用设备树的时候</strong></p><p>使用设备树的时候 I2C 设备信息通过在 i2c节点下创建子节点，然后在这个子节点内描述设备芯片的相关信息。</p><h3 id="2、I2C-设备数据收发处理流程"><a href="#2、I2C-设备数据收发处理流程" class="headerlink" title="2、I2C 设备数据收发处理流程"></a>2、I2C 设备数据收发处理流程</h3><p>I2C 设备驱动首先要做的就是初始化 i2c_driver 并向 Linux 内核注册。当设备和驱动匹配以后 i2c_driver 里面的 probe 函数就会执行，probe 函数里面所做的就是字符设备驱动那一套了。一般需要在 probe 函数里面初始化 I2C 设备，要初始化 I2C 设备就必须能够对 I2C 设备寄存器进行读写操作，这里就要用到 i2c_transfer 函数了。i2c_transfer 函数最终会调用 I2C 适配器中 i2c_algorithm 里面的 master_xfer 函数，对于 I.MX6U 而言就是<br>i2c_imx_xfer 这个函数。i2c_transfer 函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class="line">&#x2F;&#x2F;adap：所使用的 I2C 适配器，i2c_client 会保存其对应的 i2c_adapter。</span><br><span class="line">&#x2F;&#x2F;msgs：I2C 要发送的一个或多个消息。</span><br><span class="line">&#x2F;&#x2F;num：消息数量，也就是 msgs 的数量。</span><br><span class="line">&#x2F;&#x2F;返回值：负值，失败，其他非负值，发送的 msgs数量。</span><br></pre></td></tr></table></figure><p>参数msgs ，这是一个 i2c_msg 类型的指针参数，Linux 内核使用 i2c_msg 结构体来描述一个消息，使用 i2c_transfer 函数发送数据之前要先构建好 i2c_msg。i2c_msg 结构体定义 在 include/uapi/linux/i2c.h 文件中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">    __u16 addr; &#x2F;* 从机地址 *&#x2F;</span><br><span class="line">    __u16 flags; &#x2F;* 标志 *&#x2F;</span><br><span class="line">    #define I2C_M_TEN 0x0010</span><br><span class="line">    #define I2C_M_RD 0x0001</span><br><span class="line">    #define I2C_M_STOP 0x8000</span><br><span class="line">    #define I2C_M_NOSTART 0x4000</span><br><span class="line">    #define I2C_M_REV_DIR_ADDR 0x2000 </span><br><span class="line">    #define I2C_M_IGNORE_NAK 0x1000 </span><br><span class="line">    #define I2C_M_NO_RD_ACK 0x0800</span><br><span class="line">    #define I2C_M_RECV_LEN 0x0400</span><br><span class="line">    __u16 len; &#x2F;* 消息(本msg)长度 *&#x2F;</span><br><span class="line">    __u8 *buf; &#x2F;* 消息数据 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用 i2c_transfer 进行 I2C 数据收发的示例代码如下：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 设备结构体 *&#x2F;</span><br><span class="line">struct xxx_dev &#123; </span><br><span class="line">......</span><br><span class="line">void *private_data; &#x2F;* 私有数据，一般会设置为 i2c_client *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* @description : 读取 I2C 设备多个寄存器数据</span><br><span class="line">* @param – dev : I2C 设备</span><br><span class="line">* @param – reg : 要读取的寄存器首地址</span><br><span class="line">* @param – val : 读取到的数据</span><br><span class="line">* @param – len : 要读取的数据长度</span><br><span class="line">* @return : 操作结果</span><br><span class="line">*&#x2F;</span><br><span class="line">static int xxx_read_regs(struct xxx_dev *dev, u8 reg, void *val, int len)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct i2c_msg msg[2];</span><br><span class="line">    struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    &#x2F;* msg[0]，第一条写消息，发送要读取的寄存器首地址 *&#x2F;</span><br><span class="line">    msg[0].addr &#x3D; client-&gt;addr; &#x2F;* I2C 器件地址 *&#x2F;</span><br><span class="line">    msg[0].flags &#x3D; 0; &#x2F;* 标记为发送数据 *&#x2F;</span><br><span class="line">    msg[0].buf &#x3D; &amp;reg; &#x2F;* 读取的首地址 *&#x2F;</span><br><span class="line">    msg[0].len &#x3D; 1; &#x2F;* reg 长度 *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* msg[1]，第二条读消息，读取寄存器数据 *&#x2F;</span><br><span class="line">    msg[1].addr &#x3D; client-&gt;addr; &#x2F;* I2C 器件地址 *&#x2F;</span><br><span class="line">    msg[1].flags &#x3D; I2C_M_RD; &#x2F;* 标记为读取数据 *&#x2F;</span><br><span class="line">    msg[1].buf &#x3D; val; &#x2F;* 读取数据缓冲区 *&#x2F;</span><br><span class="line">    msg[1].len &#x3D; len; &#x2F;* 要读取的数据长度 *&#x2F;</span><br><span class="line">    ret &#x3D; i2c_transfer(client-&gt;adapter, msg, 2);</span><br><span class="line">    if(ret &#x3D;&#x3D; 2) &#123;</span><br><span class="line">        ret &#x3D; 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    ret &#x3D; -EREMOTEIO;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* @description : 向 I2C 设备多个寄存器写入数据</span><br><span class="line">* @param – dev : 要写入的设备结构体</span><br><span class="line">* @param – reg : 要写入的寄存器首地址</span><br><span class="line">* @param – val : 要写入的数据缓冲区</span><br><span class="line">* @param – len : 要写入的数据长度</span><br><span class="line">* @return : 操作结果</span><br><span class="line">*&#x2F;</span><br><span class="line">static s32 xxx_write_regs(struct xxx_dev *dev, u8 reg, u8 *buf, u8 len)</span><br><span class="line">&#123;</span><br><span class="line">    u8 b[256];</span><br><span class="line">    struct i2c_msg msg;</span><br><span class="line">    struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    b[0] &#x3D; reg; &#x2F;* 寄存器首地址 *&#x2F;</span><br><span class="line">    memcpy(&amp;b[1],buf,len); &#x2F;* 将要发送的数据拷贝到数组 b 里面 *&#x2F;</span><br><span class="line"></span><br><span class="line">    msg.addr &#x3D; client-&gt;addr; &#x2F;* I2C 器件地址 *&#x2F;</span><br><span class="line">    msg.flags &#x3D; 0; &#x2F;* 标记为写数据 *&#x2F;</span><br><span class="line">    msg.buf &#x3D; b; &#x2F;* 要发送的数据缓冲区 *&#x2F;</span><br><span class="line">    msg.len &#x3D; len + 1; &#x2F;* 要发送的数据长度 *&#x2F;</span><br><span class="line">    return i2c_transfer(client-&gt;adapter, &amp;msg, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设备结构体里面添加一个执行void的指针成员变量private_data，此成员变量用于保存设备的私有数据。在 I2C 设备驱动中我们一般将其指向 I2C 设备对应的i2c_client。 </p><p>xxx_read_regs 函数用于读取 I2C 设备多个寄存器数据。定义了一个i2c_msg 数组，2 个数组元素，因为 I2C 读取数据的时候要先发送要读取的寄存器地址，然后再读取数据，所以需要准备两个 i2c_msg。一个用于发送寄存器地址，一个用于读取寄存器值。对于 msg[0]，将 flags 设置为 0，表示写数据。msg[0]的 addr 是 I2C 设备的器件地址，msg[0]的 buf成员变量就是要读取的寄存器地址。对于 msg[1]，将 flags 设置为 I2C_M_RD，表示读取数据。msg[1]的 buf 成员变量用于保存读取到的数据，len 成员变量就是要读取的数据长度。调用i2c_transfer 函数完成 I2C 数据读操作。</p><p>xxx_write_regs 函数用于向 I2C 设备多个寄存器写数据，I2C 写操作要比读操作简单一点，因此一个 i2c_msg 即可。数组 b 用于存放寄存器首地址和要发送的数据，第 59 行设置 msg 的 addr 为 I2C 器件地址。第 60 行设置 msg 的 flags 为 0，也就是写数据。第 62 行设置要发送的数据，也就是数组 b。第 63 行设置 msg 的 len 为 len+1，因为要加上一个字节的寄存器地址。最后通过 i2c_transfer 函数完成向 I2C 设备的写操作。</p><h1 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a><strong>实验程序编写</strong></h1><h2 id="1、修改设备树"><a href="#1、修改设备树" class="headerlink" title="1、修改设备树"></a>1、修改设备树</h2><p><strong>1.IO 修改或添加</strong></p><p>首先肯定是要修改 IO，AP3216C 用到了 I2C1 接口，I.MX6U-ALPHA 开发板上的 I2C1 接口使用到了 UART4_TXD 和 UART4_RXD，因此肯定要在设备树里面设置这两个 IO。如果要用 到 AP3216C 的中断功能的话还需要初始化 AP_INT 对应的 GIO1_IO01 这个 IO，不使用中断功能。因此只需要设置 UART4_TXD 和 UART4_RXD 这两个 IO，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_i2c1: i2c1grp &#123; </span><br><span class="line">    fsl,pins &#x3D; &lt; </span><br><span class="line">        MX6UL_PAD_UART4_TX_DATA__I2C1_SCL 0x4001b8b0</span><br><span class="line">        MX6UL_PAD_UART4_RX_DATA__I2C1_SDA 0x4001b8b0</span><br><span class="line">    &gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pinctrl_i2c1 就是 I2C1 的 IO 节点，这里将 UART4_TXD 和 UART4_RXD 这两个 IO 分别复用为 I2C1_SCL 和 I2C1_SDA，电气属性都设置为 0x4001b8b0。 </p><p><strong>2.在 i2c1 节点追加 ap3216c 子节点</strong></p><p>将 i2c1 节点里面原有的 mag3110 和 fxls8471 这两个 I2C 子节点删除，然后添加 ap3216c子节点信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123; </span><br><span class="line">    clock-frequency &#x3D; &lt;100000&gt;;</span><br><span class="line">    pinctrl-names &#x3D; &quot;default&quot;; </span><br><span class="line">    pinctrl-0 &#x3D; &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">    status &#x3D; &quot;okay&quot;; </span><br><span class="line">    </span><br><span class="line">    ap3216c@1e &#123; </span><br><span class="line">        compatible &#x3D; &quot;alientek,ap3216c&quot;; </span><br><span class="line">        reg &#x3D; &lt;0x1e&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第 7 行，ap3216c 子节点，@后面的“1e”是 ap3216c 的器件地址。<br>第 8 行，设置 compatible 值为“alientek,ap3216c”。<br>第 9 行，reg 属性也是设置 ap3216c 器件地址的，因此 reg 设置为 0x1e。<br>设备树修改完成以后使用“make dtbs”重新编译一下，然后使用新的设备树启动 Linux 内核。/sys/bus/i2c/devices 目录下存放着所有 I2C 设备，如果设备树修改正确的话，会在/sys/bus/i2c/devices 目录下看到一个名为“0-001e”的子目录，“0-001e”就是 ap3216c 的设备目录，“1e”就是 ap3216c 器件地址。</p><h2 id="2、AP3216C-驱动编写"><a href="#2、AP3216C-驱动编写" class="headerlink" title="2、AP3216C 驱动编写"></a>2、AP3216C 驱动编写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: ap3216c.c</span><br><span class="line">描述   : AP3216C驱动程序</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">struct ap3216c_dev &#123;</span><br><span class="line">void *private_data;&#x2F;* 私有数据 *&#x2F;</span><br><span class="line">unsigned short ir, als, ps;&#x2F;* 三个光传感器数据 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">static struct ap3216c_dev ap3216cdev;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 从ap3216c读取多个寄存器数据</span><br><span class="line"> * @param - dev:  ap3216c设备</span><br><span class="line"> * @param - reg:  要读取的寄存器首地址</span><br><span class="line"> * @param - val:  读取到的数据</span><br><span class="line"> * @param - len:  要读取的数据长度</span><br><span class="line"> * @return : 操作结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ap3216c_read_regs(struct ap3216c_dev *dev, u8 reg, void *val, int len)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">struct i2c_msg msg[2];</span><br><span class="line">struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">&#x2F;* msg[0]为发送要读取的首地址 *&#x2F;</span><br><span class="line">msg[0].addr &#x3D; client-&gt;addr;&#x2F;* ap3216c地址 *&#x2F;</span><br><span class="line">msg[0].flags &#x3D; 0;&#x2F;* 标记为发送数据 *&#x2F;</span><br><span class="line">msg[0].buf &#x3D; &amp;reg;&#x2F;* 读取的首地址 *&#x2F;</span><br><span class="line">msg[0].len &#x3D; 1;&#x2F;* reg长度*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* msg[1]读取数据 *&#x2F;</span><br><span class="line">msg[1].addr &#x3D; client-&gt;addr;&#x2F;* ap3216c地址 *&#x2F;</span><br><span class="line">msg[1].flags &#x3D; I2C_M_RD;&#x2F;* 标记为读取数据*&#x2F;</span><br><span class="line">msg[1].buf &#x3D; val;&#x2F;* 读取数据缓冲区 *&#x2F;</span><br><span class="line">msg[1].len &#x3D; len;&#x2F;* 要读取的数据长度*&#x2F;</span><br><span class="line"></span><br><span class="line">ret &#x3D; i2c_transfer(client-&gt;adapter, msg, 2);</span><br><span class="line">if(ret &#x3D;&#x3D; 2) &#123;</span><br><span class="line">ret &#x3D; 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">printk(&quot;i2c rd failed&#x3D;%d reg&#x3D;%06x len&#x3D;%d\n&quot;,ret, reg, len);</span><br><span class="line">ret &#x3D; -EREMOTEIO;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 向ap3216c多个寄存器写入数据</span><br><span class="line"> * @param - dev:  ap3216c设备</span><br><span class="line"> * @param - reg:  要写入的寄存器首地址</span><br><span class="line"> * @param - val:  要写入的数据缓冲区</span><br><span class="line"> * @param - len:  要写入的数据长度</span><br><span class="line"> * @return   :   操作结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static s32 ap3216c_write_regs(struct ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)</span><br><span class="line">&#123;</span><br><span class="line">u8 b[256];</span><br><span class="line">struct i2c_msg msg;</span><br><span class="line">struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">b[0] &#x3D; reg;&#x2F;* 寄存器首地址 *&#x2F;</span><br><span class="line">memcpy(&amp;b[1],buf,len);&#x2F;* 将要写入的数据拷贝到数组b里面 *&#x2F;</span><br><span class="line"></span><br><span class="line">msg.addr &#x3D; client-&gt;addr;&#x2F;* ap3216c地址 *&#x2F;</span><br><span class="line">msg.flags &#x3D; 0;&#x2F;* 标记为写数据 *&#x2F;</span><br><span class="line"></span><br><span class="line">msg.buf &#x3D; b;&#x2F;* 要写入的数据缓冲区 *&#x2F;</span><br><span class="line">msg.len &#x3D; len + 1;&#x2F;* 要写入的数据长度 *&#x2F;</span><br><span class="line"></span><br><span class="line">return i2c_transfer(client-&gt;adapter, &amp;msg, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 读取ap3216c指定寄存器值，读取一个寄存器</span><br><span class="line"> * @param - dev:  ap3216c设备</span><br><span class="line"> * @param - reg:  要读取的寄存器</span><br><span class="line"> * @return   :   读取到的寄存器值</span><br><span class="line"> *&#x2F;</span><br><span class="line">static unsigned char ap3216c_read_reg(struct ap3216c_dev *dev, u8 reg)</span><br><span class="line">&#123;</span><br><span class="line">u8 data &#x3D; 0;</span><br><span class="line"></span><br><span class="line">ap3216c_read_regs(dev, reg, &amp;data, 1);</span><br><span class="line">return data;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data;</span><br><span class="line">return i2c_smbus_read_byte_data(client, reg);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 向ap3216c指定寄存器写入指定的值，写一个寄存器</span><br><span class="line"> * @param - dev:  ap3216c设备</span><br><span class="line"> * @param - reg:  要写的寄存器</span><br><span class="line"> * @param - data: 要写入的值</span><br><span class="line"> * @return   :    无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void ap3216c_write_reg(struct ap3216c_dev *dev, u8 reg, u8 data)</span><br><span class="line">&#123;</span><br><span class="line">u8 buf &#x3D; 0;</span><br><span class="line">buf &#x3D; data;</span><br><span class="line">ap3216c_write_regs(dev, reg, &amp;buf, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 读取AP3216C的数据，读取原始数据，包括ALS,PS和IR, 注意！</span><br><span class="line"> *: 如果同时打开ALS,IR+PS的话两次数据读取的时间间隔要大于112.5ms</span><br><span class="line"> * @param - ir: ir数据</span><br><span class="line"> * @param - ps : ps数据</span><br><span class="line"> * @param - ps : als数据 </span><br><span class="line"> * @return : 无。</span><br><span class="line"> *&#x2F;</span><br><span class="line">void ap3216c_readdata(struct ap3216c_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i &#x3D;0;</span><br><span class="line">    unsigned char buf[6];</span><br><span class="line"></span><br><span class="line">&#x2F;* 循环读取所有传感器数据 *&#x2F;</span><br><span class="line">    for(i &#x3D; 0; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[i] &#x3D; ap3216c_read_reg(dev, AP3216C_IRDATALOW + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(buf[0] &amp; 0X80) &#x2F;* IR_OF位为1,则数据无效 *&#x2F;</span><br><span class="line">dev-&gt;ir &#x3D; 0;</span><br><span class="line">else &#x2F;* 读取IR传感器的数据   *&#x2F;</span><br><span class="line">dev-&gt;ir &#x3D; ((unsigned short)buf[1] &lt;&lt; 2) | (buf[0] &amp; 0X03); </span><br><span class="line"></span><br><span class="line">dev-&gt;als &#x3D; ((unsigned short)buf[3] &lt;&lt; 8) | buf[2];&#x2F;* 读取ALS传感器的数据  *&#x2F;  </span><br><span class="line"></span><br><span class="line">    if(buf[4] &amp; 0x40)&#x2F;* IR_OF位为1,则数据无效 *&#x2F;</span><br><span class="line">dev-&gt;ps &#x3D; 0;    </span><br><span class="line">else &#x2F;* 读取PS传感器的数据    *&#x2F;</span><br><span class="line">dev-&gt;ps &#x3D; ((unsigned short)(buf[5] &amp; 0X3F) &lt;&lt; 4) | (buf[4] &amp; 0X0F); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 打开设备</span><br><span class="line"> * @param - inode : 传递给驱动的inode</span><br><span class="line"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span><br><span class="line"> *   一般在open的时候将private_data指向设备结构体。</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ap3216c_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data &#x3D; &amp;ap3216cdev;</span><br><span class="line"></span><br><span class="line">&#x2F;* 初始化AP3216C *&#x2F;</span><br><span class="line">ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, 0x04);&#x2F;* 复位AP3216C *&#x2F;</span><br><span class="line">mdelay(50);&#x2F;* AP3216C复位最少10ms *&#x2F;</span><br><span class="line">ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, 0X03);&#x2F;* 开启ALS、PS+IR *&#x2F;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 从设备读取数据 </span><br><span class="line"> * @param - filp : 要打开的设备文件(文件描述符)</span><br><span class="line"> * @param - buf : 返回给用户空间的数据缓冲区</span><br><span class="line"> * @param - cnt : 要读取的数据长度</span><br><span class="line"> * @param - offt : 相对于文件首地址的偏移</span><br><span class="line"> * @return : 读取的字节数，如果为负值，表示读取失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static ssize_t ap3216c_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off)</span><br><span class="line">&#123;</span><br><span class="line">short data[3];</span><br><span class="line">long err &#x3D; 0;</span><br><span class="line"></span><br><span class="line">struct ap3216c_dev *dev &#x3D; (struct ap3216c_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">ap3216c_readdata(dev);</span><br><span class="line"></span><br><span class="line">data[0] &#x3D; dev-&gt;ir;</span><br><span class="line">data[1] &#x3D; dev-&gt;als;</span><br><span class="line">data[2] &#x3D; dev-&gt;ps;</span><br><span class="line">err &#x3D; copy_to_user(buf, data, sizeof(data));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 关闭&#x2F;释放设备</span><br><span class="line"> * @param - filp : 要关闭的设备文件(文件描述符)</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ap3216c_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* AP3216C操作函数 *&#x2F;</span><br><span class="line">static const struct file_operations ap3216c_ops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; ap3216c_open,</span><br><span class="line">.read &#x3D; ap3216c_read,</span><br><span class="line">.release &#x3D; ap3216c_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : i2c驱动的probe函数，当驱动与</span><br><span class="line">  *                    设备匹配以后此函数就会执行</span><br><span class="line">  * @param - client  : i2c设备</span><br><span class="line">  * @param - id      : i2c设备ID</span><br><span class="line">  * @return          : 0，成功;其他负值,失败</span><br><span class="line">  *&#x2F;</span><br><span class="line">static int ap3216c_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 1、构建设备号 *&#x2F;</span><br><span class="line">&#x2F;* 2、注册设备 *&#x2F;</span><br><span class="line">&#x2F;* 3、创建类 *&#x2F;</span><br><span class="line">&#x2F;* 4、创建设备 *&#x2F;</span><br><span class="line"></span><br><span class="line">ap3216cdev.private_data &#x3D; client;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</span><br><span class="line"> * @param - client : i2c设备</span><br><span class="line"> * @return          : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ap3216c_remove(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 删除设备 *&#x2F;</span><br><span class="line">&#x2F;* 注销掉类和设备 *&#x2F;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 传统匹配方式ID列表 *&#x2F;</span><br><span class="line">static const struct i2c_device_id ap3216c_id[] &#x3D; &#123;</span><br><span class="line">&#123;&quot;alientek,ap3216c&quot;, 0&#125;,  </span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备树匹配列表 *&#x2F;</span><br><span class="line">static const struct of_device_id ap3216c_of_match[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;alientek,ap3216c&quot; &#125;,</span><br><span class="line">&#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* i2c驱动结构体 *&#x2F;</span><br><span class="line">static struct i2c_driver ap3216c_driver &#x3D; &#123;</span><br><span class="line">.probe &#x3D; ap3216c_probe,</span><br><span class="line">.remove &#x3D; ap3216c_remove,</span><br><span class="line">.driver &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">   .name &#x3D; &quot;ap3216c&quot;,</span><br><span class="line">   .of_match_table &#x3D; ap3216c_of_match, </span><br><span class="line">   &#125;,</span><br><span class="line">.id_table &#x3D; ap3216c_id,</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>ap3216c 设备结构体的 private_data 成员变量用于存放 ap3216c 对应的 i2c_client。 ir、als 和 ps 分别存储 AP3216C 的 IR、ALS 和 PS 数据。定义一个 ap3216c_dev 类型的设备结构体变量 ap3216cdev。 </p><p>ap3216c_read_regs 函数实现多字节读取，但是 AP3216C 好像不支持连续多字节读取，此函数在测试其他 I2C 设备的时候可以实现多给字节连续读取，但是在 AP3216C 上不能连续读取多个字节。不过读取一个字节没有问题的。ap3216c_write_regs 函数实现连续多字节写操作。</p><p>ap3216c_read_reg 函数用于读取 AP3216C 的指定寄存器数据，用于一个寄存器的数据读取。ap3216c_write_reg 函数用于向 AP3216C 的指定寄存器写入数据，用于一个寄存器的数据写操作。</p><p>ap3216c_probe 函数，当 I2C 设备和驱动匹配成功以后此函数就会执行，platform 驱动框架一样。此函数前面都是标准的字符设备注册代码，最后面会将此函数的第一个参数 client 传递给 ap3216cdev 的 private_data 成员变量。</p><p>ap3216c_id 匹配表，i2c_device_id 类型。用于传统的设备和驱动匹配，也就是没有使用设备树的时候。<br>ap3216c_of_match 匹配表，of_device_id 类型，用于设备树设备和驱动匹配。这里只写了一个 compatible 属性，值为“alientek,ap3216c”。</p><p>ap3216c_driver 结构体变量，i2c_driver 类型。</p><p>驱动入口函数 ap3216c_init，此函数通过调用 i2c_add_driver 来向 Linux 内核注册 i2c_driver，也就是ap3216c_driver。</p><p>驱动出口函数 ap3216c_exit，此函数通过调用 i2c_del_driver 来注销掉前面<br>注册的 ap3216c_driver。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Linux-I2C驱动框架&quot;&gt;&lt;a href=&quot;#Linux-I2C驱动框架&quot; class=&quot;headerlink&quot; title=&quot;Linux I2C驱动框架&quot;&gt;&lt;/a&gt;Linux I2C驱动框架&lt;/h1&gt;&lt;p&gt;裸机篇中编写 AP3216C 驱动的四个文件：bsp_i2c.c、bsp_i2c.h、bsp_ap3216c.c 和 bsp_ap3216c.h。其中前两个是 I.MX6U 的 IIC 接口驱动，后两个文 件是 AP3216C 这个 I2C 设备驱动文件。相当于有两部分驱动： I2C 主机驱动、I2C 设备驱动。 &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-RTC驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/17/Linux%E9%A9%B1%E5%8A%A8-RTC%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/17/Linux%E9%A9%B1%E5%8A%A8-RTC%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-17T05:04:41.000Z</published>
    <updated>2021-05-05T04:46:12.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-内核-RTC-驱动"><a href="#Linux-内核-RTC-驱动" class="headerlink" title="Linux 内核 RTC 驱动"></a><strong>Linux</strong> <strong>内核</strong> <strong>RTC</strong> <strong>驱动</strong></h1><p>RTC 设备驱动是一个标准的字符设备驱动，应用程序通过 open、release、read、write 和 ioctl等函数完成对 RTC 设备的操作。Linux 内核将 RTC 设备抽象为 rtc_device 结构体，因此 RTC 设备驱动就是申请并初始化<br>rtc_device，最后将 rtc_device 注册到 Linux 内核里面，这样 Linux 内核就有一个 RTC 设备的。</p> <a id="more"></a> <p> rtc_device 结构体，此结构体定义在 include/linux/rtc.h 文件中，结构体内容如下(删除条件编译)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct rtc_device</span><br><span class="line">&#123;</span><br><span class="line">    struct device dev; &#x2F;* 设备 *&#x2F;</span><br><span class="line">    struct module *owner;</span><br><span class="line"></span><br><span class="line">    int id; &#x2F;* ID *&#x2F; </span><br><span class="line">    char name[RTC_DEVICE_NAME_SIZE]; &#x2F;* 名字 *&#x2F;</span><br><span class="line"></span><br><span class="line">    const struct rtc_class_ops *ops; &#x2F;* RTC 设备底层操作函数 *&#x2F;</span><br><span class="line">    struct mutex ops_lock;</span><br><span class="line"></span><br><span class="line">    struct cdev char_dev; &#x2F;* 字符设备 *&#x2F;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">………………</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>RTC 设备的操作是用一个 rtc_class_ops 类型的操作集合(结构体)来表示的，就是是 ops 成员变量，这是一个 rtc_class_ops 类型的指针变量。rtc_class_ops为 RTC 设备的最底层操作函数集合，包括从 RTC 设备中读取时间、向 RTC 设备写入新的时间值等。因此，rtc_class_ops 是需要用户根据所使用的 RTC 设备编写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct rtc_class_ops &#123;</span><br><span class="line">    int (*open)(struct device *);</span><br><span class="line">    void (*release)(struct device *);</span><br><span class="line">    int (*ioctl)(struct device *, unsigned int, unsigned long);</span><br><span class="line">    int (*read_time)(struct device *, struct rtc_time *);</span><br><span class="line">    int (*set_time)(struct device *, struct rtc_time *);</span><br><span class="line">    int (*read_alarm)(struct device *, struct rtc_wkalrm *);</span><br><span class="line">    int (*set_alarm)(struct device *, struct rtc_wkalrm *);</span><br><span class="line">    int (*proc)(struct device *, struct seq_file *);</span><br><span class="line">    int (*set_mmss64)(struct device *, time64_t secs);</span><br><span class="line">    int (*set_mmss)(struct device *, unsigned long secs);</span><br><span class="line">    int (*read_callback)(struct device *, int data);</span><br><span class="line">    int (*alarm_irq_enable)(struct device *, unsigned int enabled);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>rtc_class_ops 中的这些函数只是最底层的 RTC 设备操作函数，并不是提供给应用层的file_operations 函数操作集。RTC 是个字符设备，那么肯定有字符设备的 file_operations 函数操作集，Linux 内核提供了一个 RTC 通用字符设备驱动文件，文件名为 drivers/rtc/rtc-dev.c，rtc-dev.c 文件提供了所有 RTC 设备共用的 file_operations 函数操作集，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations rtc_dev_fops &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .llseek &#x3D; no_llseek,</span><br><span class="line">    .read &#x3D; rtc_dev_read,</span><br><span class="line">    .poll &#x3D; rtc_dev_poll,</span><br><span class="line">    .unlocked_ioctl &#x3D; rtc_dev_ioctl,</span><br><span class="line">    .open &#x3D; rtc_dev_open,</span><br><span class="line">    .release &#x3D; rtc_dev_release,</span><br><span class="line">    .fasync &#x3D; rtc_dev_fasync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>rtc_dev_fops是标准的字符设备操作集。应用程序可以通过 ioctl 函数来设置/读取时间、设置/读取闹钟的操作，那么驱动中对应的 rtc_dev_ioctl 函数就会执行， rtc_dev_ioctl 最终会通过操作 rtc_class_ops 中的 read_time、set_time 等函数来对具体 RTC 设备的读写操作。</p><p> 如果向rtc_dev_ioctl 函数传入参数cmd=RTC_RD_TIME (时间读取命令)，就会调用 rtc_read_time 函数会调用_ _rtc_read_time函数，__rtc_read_time 函数再通过调用 rtc_class_ops 中的read_time 函数来从 RTC 设备中获取当前时间。rtc_dev_ioctl 函数对其他的命令处理都是类似的，传入参数cmd=RTC_ALM_READ (闹钟读取命令) ，就会调用 rtc_read_alarm ，而 rtc_read_alarm 函数再经过层层调用，最终会调用 rtc_class_ops 中的 read_alarm 函数来获取闹钟值。 </p><p><img src="Linux%E9%A9%B1%E5%8A%A8-RTC%E9%A9%B1%E5%8A%A8.assets/1618637052010.png" alt="1618637052010"></p><p>当 rtc_class_ops 准备好以后需要将其注册到 Linux 内核中，可以使用rtc_device_register函数完成注册工作。此函数会申请一个rtc_device并且初始化这个rtc_device，最后向调用者返回这个 rtc_device，当卸载 RTC 驱动的时候需要调用 rtc_device_unregister 函数来注销注册的 rtc_device，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct rtc_device *rtc_device_register(const char *name, struct device *dev,</span><br><span class="line">const struct rtc_class_ops *ops, struct module *owner)</span><br><span class="line">&#x2F;&#x2F;name：设备名字。</span><br><span class="line">&#x2F;&#x2F;dev：设备。</span><br><span class="line">&#x2F;&#x2F;ops：RTC 底层驱动函数集。</span><br><span class="line">&#x2F;&#x2F;owner：驱动模块拥有者。</span><br><span class="line">&#x2F;&#x2F;返回值：注册成功的话就返回 rtc_device，错误的话会返回一个负值。</span><br><span class="line"></span><br><span class="line">void rtc_device_unregister(struct rtc_device *rtc)</span><br><span class="line">&#x2F;&#x2F;rtc：要删除的 rtc_device。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h1 id="I-MX6U-内部-RTC-驱动分析"><a href="#I-MX6U-内部-RTC-驱动分析" class="headerlink" title="I.MX6U 内部 RTC 驱动分析"></a><strong>I.MX6U</strong> <strong>内部</strong> <strong>RTC</strong> <strong>驱动分析</strong></h1><p>I.MX6U 的 RTC 驱动不用自己编写，因为 NXP 已经写好了。其实对于大多数的 SOC 来讲，内部 RTC 驱动都不需要我们去编写，半导体厂商会编写好。得看一下这些原厂是怎么编写 RTC 驱动的。 </p><p>分析驱动，先从设备树入手，打开 imx6ull.dtsi，在里面找到如下 snvs_rtc 设备节点，设置兼容属性 compatible 的值为“fsl,sec-v4.0-mon-rtc-lp”。驱动文件rtc-snvs.c中的设备树 ID 表有一条 compatible 属性，值为“fsl,sec-v4.0-mon-rtc-lp”，因此 imx6ull.dtsi 中的 snvs_rtc 设备节点会和此驱动匹配。该驱动文件采用标准的 platform 驱动框架，当设备和驱动匹配成功以后 snvs_rtc_probe 函数就会执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static int snvs_rtc_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line"></span><br><span class="line">    mmio &#x3D; devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">    ………………</span><br><span class="line">    data-&gt;regmap &#x3D; devm_regmap_init_mmio(&amp;pdev-&gt;dev, mmio, &amp;snvs_rtc_config);</span><br><span class="line">    ………………</span><br><span class="line">    data-&gt;irq &#x3D; platform_get_irq(pdev, 0);</span><br><span class="line">    ………………</span><br><span class="line">    &#x2F;* Initialize glitch detect *&#x2F;</span><br><span class="line">regmap_write(data-&gt;regmap, data-&gt;offset + SNVS_LPPGDR,SNVS_LPPGDR_INIT);</span><br><span class="line"></span><br><span class="line">&#x2F;* Clear interrupt status *&#x2F;</span><br><span class="line">regmap_write(data-&gt;regmap, data-&gt;offset + SNVS_LPSR,0xffffffff);</span><br><span class="line"></span><br><span class="line">&#x2F;* Enable RTC *&#x2F;</span><br><span class="line">snvs_rtc_enable(data, true);</span><br><span class="line"></span><br><span class="line">    ret &#x3D; devm_request_irq(&amp;pdev-&gt;dev, data-&gt;irq,snvs_rtc_irq_handler,</span><br><span class="line">    IRQF_SHARED, &quot;rtc alarm&quot;, &amp;pdev-&gt;dev);</span><br><span class="line">    </span><br><span class="line">    data-&gt;rtc &#x3D; devm_rtc_device_register(&amp;pdev-&gt;dev, pdev-&gt;name,</span><br><span class="line">&amp;snvs_rtc_ops, THIS_MODULE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 platform_get_resource 函数从设备树中获取到 RTC 外设寄存器基地址。 </p><p>调用函数 devm_ioremap_resource 完成内存映射，得到 RTC 外设寄存器物理基地址对应的虚拟地址。 </p><p>Linux3.1 引入了一个全新的 regmap 机制，regmap 用于提供一套方便的 API 函数去操作底层硬件寄存器，以提高代码的可重用性。snvs-rtc.c 文件会采用 regmap 机制来读写RTC 底层硬件寄存器。这里使用 devm_regmap_init_mmio 函数将 RTC 的硬件寄存器转化为regmap 形式，这样 regmap 机制的 regmap_write、regmap_read 等 API 函数才能操作寄存器。</p><p>调用platform_get_irq从设备树中获取 RTC 的中断号。 </p><p>调用regmap_write设置 RTC_ LPPGDR 寄存器值为 SNVS_LPPGDR_INIT= 0x41736166，这里就是用的 regmap 机制的 regmap_write 函数完成对寄存器进行写操作。 </p><p>调用regmap_write设置 RTC_LPSR 寄存器，写入 0xffffffff，LPSR 是 RTC 状态寄存器，写 1 清零， 因此这一步就是清除 LPSR 寄存器。</p><p>调用 snvs_rtc_enable 函数使能 RTC，此函数会设置 RTC_LPCR 寄存器。 </p><p>调用devm_request_irq函数请求RTC中断，中断服务函数为snvs_rtc_irq_handler，用于 RTC 闹钟中断。 </p><p>调用 devm_rtc_device_register 函数向系统注册 rtc_devcie，RTC 底层驱动集为 snvs_rtc_ops。snvs_rtc_ops操作集包含了读取/设置RTC时间，读取/设置闹钟等函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static const struct rtc_class_ops snvs_rtc_ops &#x3D; &#123;</span><br><span class="line">    .read_time &#x3D; snvs_rtc_read_time,</span><br><span class="line">    .set_time &#x3D; snvs_rtc_set_time,</span><br><span class="line">    .read_alarm &#x3D; snvs_rtc_read_alarm,</span><br><span class="line">    .set_alarm &#x3D; snvs_rtc_set_alarm,</span><br><span class="line">    .alarm_irq_enable &#x3D; snvs_rtc_alarm_irq_enable,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Linux-内核-RTC-驱动&quot;&gt;&lt;a href=&quot;#Linux-内核-RTC-驱动&quot; class=&quot;headerlink&quot; title=&quot;Linux 内核 RTC 驱动&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux&lt;/strong&gt; &lt;strong&gt;内核&lt;/strong&gt; &lt;strong&gt;RTC&lt;/strong&gt; &lt;strong&gt;驱动&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;RTC 设备驱动是一个标准的字符设备驱动，应用程序通过 open、release、read、write 和 ioctl等函数完成对 RTC 设备的操作。Linux 内核将 RTC 设备抽象为 rtc_device 结构体，因此 RTC 设备驱动就是申请并初始化&lt;br&gt;rtc_device，最后将 rtc_device 注册到 Linux 内核里面，这样 Linux 内核就有一个 RTC 设备的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-LCD驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-LCD%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-LCD%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-16T15:59:08.000Z</published>
    <updated>2021-05-05T04:44:02.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Framebuffer-设备"><a href="#Framebuffer-设备" class="headerlink" title="Framebuffer 设备"></a><strong>Framebuffer</strong> <strong>设备</strong></h1><p>裸机 LCD 驱动编写流程如下：<br>①、初始化 I.MX6U 的 eLCDIF 控制器，重点是 LCD 屏幕宽(width)、高(height)、hspw、hbp、hfp、vspw、vbp 和 vfp 等信息。</p> <a id="more"></a> <p>②、初始化 LCD 像素时钟。<br>③、设置 RGBLCD 显存。<br>④、应用程序直接通过操作显存来操作 LCD，实现在 LCD 上显示字符、图片等信息。</p><p>在 Linux 中应用程序最终也是通过操作 RGB LCD 的显存来实现在 LCD 上显示字符、图片<br>等信息。在裸机中我们可以随意的分配显存，但是在 Linux 系统中内存的管理很严格，显存是<br>需要申请的，不是你想用就能用的。而且因为虚拟内存的存在，驱动程序设置的显存和应用程<br>序访问的显存要是同一片物理内存。</p><p>为了解决上述问题，Framebuffer 诞生了， Framebuffer 翻译过来就是帧缓冲，简称 fb，以后的 Linux 学习中见到“Framebuffer”或者“fb”的话第一反应应该想到 RGBLCD或者显示设备。fb 是一种机制，将系统中所有跟显示有关的硬件以及软件集合起来，虚拟出一个 fb 设备，当编写好 LCD 驱动以后会生成一个名为/dev/fbX(X=0~n)的设备，应用程序通过访问/dev/fbX 这个设备就可以访问 LCD。</p><p>/dev/fbX是个字符设备，因此肯定有file_operations 操作集，fb 的 file_operations 操作集定义在 drivers/video/fbdev/core/fbmem.c 文件中。</p><h1 id="LCD-驱动简析"><a href="#LCD-驱动简析" class="headerlink" title="LCD 驱动简析"></a><strong>LCD</strong> <strong>驱动简析</strong></h1><p>不同分辨率的 LCD 屏幕其 eLCDIF 控制器驱动代码都是一样的，只需要修改好对应的屏幕参数即可。屏幕参数信息属于屏幕设备信息内容，这些肯定是要放到设备树中的，因此我们本章实验的主要工作就是修改设备树，</p><p><strong>Linux 下 Framebuffer 驱动的编写流程，</strong></p><p>Linux 内核将所有的 Framebuffer 抽象为一个叫做 fb_info 的结构 体，fb_info 结构体包含了 Framebuffer 设备的完整属性和操作集合，因此每一个 Framebuffer 设备都必须有一个 fb_info。换言之就是，LCD 的驱动就是构建 fb_info，并且向系统注册 fb_info的过程。fb_info 结构体定义在 include/linux/fb.h 文件里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct fb_info &#123;</span><br><span class="line">        …………</span><br><span class="line">        struct fb_var_screeninfo var; &#x2F;* 当前可变参数 *&#x2F;</span><br><span class="line">        struct fb_fix_screeninfo fix; &#x2F;* 当前固定参数 *&#x2F;</span><br><span class="line">        struct fb_monspecs monspecs; &#x2F;* 当前显示器特性 *&#x2F;</span><br><span class="line">        struct work_struct queue; &#x2F;* 帧缓冲事件队列 *&#x2F;</span><br><span class="line">        struct fb_pixmap pixmap; &#x2F;* 图像硬件映射 *&#x2F;</span><br><span class="line">        struct fb_pixmap sprite; &#x2F;* 光标硬件映射 *&#x2F;</span><br><span class="line">        struct fb_cmap cmap; &#x2F;* 当前调色板 *&#x2F;</span><br><span class="line">        struct list_head modelist; &#x2F;* 当前模式列表 *&#x2F;</span><br><span class="line">        struct fb_videomode *mode; &#x2F;* 当前视频模式 *&#x2F;</span><br><span class="line">        ......</span><br><span class="line">        struct fb_ops *fbops; &#x2F;* 帧缓冲操作函数集 *&#x2F; </span><br><span class="line">        struct device *device; &#x2F;* 父设备 *&#x2F;</span><br><span class="line">        struct device *dev; &#x2F;* 当前 fb 设备 *&#x2F;</span><br><span class="line">        int class_flag; &#x2F;* 私有 sysfs 标志 *&#x2F;</span><br><span class="line">        ......</span><br><span class="line">        char __iomem *screen_base; &#x2F;* 虚拟内存基地址(屏幕显存) *&#x2F;</span><br><span class="line">        unsigned long screen_size; &#x2F;* 虚拟内存大小(屏幕显存大小) *&#x2F;</span><br><span class="line">        void *pseudo_palette; &#x2F;* 伪 16 位调色板 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>fb_info 结构体的成员变量很多，我们重点关注 var、fix、fbops、screen_base、screen_size<br>和 pseudo_palette。mxsfb_probe 函数的主要工作内容为：<br>①、申请 fb_info。<br>②、初始化 fb_info 结构体中的各个成员变量。<br>③、初始化 eLCDIF 控制器。<br>④、使用 register_framebuffer 函数向 Linux 内核注册初始化好的 fb_info</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int register_framebuffer(struct fb_info *fb_info)</span><br><span class="line">&#x2F;&#x2F;fb_info：需要上报的 fb_info。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br></pre></td></tr></table></figure><h1 id="LCD-驱动程序编写"><a href="#LCD-驱动程序编写" class="headerlink" title="LCD 驱动程序编写"></a>LCD 驱动程序编写</h1><p>6ULL 的 eLCDIF 接口驱动程序 NXP 已经编写好了，因此 LCD 驱动部分我们不需要去修改。我们需要做的就是按照所使用的 LCD 来修改设备树。重点要注意三个地方： </p><p>①、LCD 所使用的 IO 配置。 </p><p>②、LCD 屏幕节点修改，修改相应的属性值，换成我们所使用的 LCD 屏幕参数。 </p><p>③、LCD 背光节点信息修改，要根据实际所使用的背光 IO 来修改相应的设备节点信息。 </p><p><strong>1、LCD 屏幕 IO 配置</strong></p><p>首先要检查一下设备树中 LCD 所使用的 IO 配置，这个其实 NXP 都已经写好了，不需要修改，</p><p><strong>2、LCD 屏幕参数节点信息修改</strong></p><p>继续在 imx6ull-alientek-emmc.dts 文件中找到 lcdif 节点，节点内容如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;lcdif &#123; </span><br><span class="line">pinctrl-names &#x3D; &quot;default&quot;; </span><br><span class="line">pinctrl-0 &#x3D; &lt;&amp;pinctrl_lcdif_dat &#x2F;* 使用到的 IO *&#x2F;</span><br><span class="line">&amp;pinctrl_lcdif_ctrl</span><br><span class="line">&amp;pinctrl_lcdif_reset&gt;;</span><br><span class="line">display &#x3D; &lt;&amp;display0&gt;;</span><br><span class="line">status &#x3D; &quot;okay&quot;; 8 </span><br><span class="line">display0: display &#123; &#x2F;* LCD 属性信息 *&#x2F;</span><br><span class="line">bits-per-pixel &#x3D; &lt;16&gt;; &#x2F;* 一个像素占用几个 bit *&#x2F;</span><br><span class="line">bus-width &#x3D; &lt;24&gt;; &#x2F;* 总线宽度 *&#x2F;</span><br><span class="line"></span><br><span class="line">display-timings &#123;</span><br><span class="line">native-mode &#x3D; &lt;&amp;timing0&gt;; &#x2F;* 时序信息 *&#x2F;</span><br><span class="line">timing0: timing0 &#123; </span><br><span class="line">clock-frequency &#x3D; &lt;9200000&gt;; &#x2F;* LCD 像素时钟，单位 Hz *&#x2F;</span><br><span class="line">hactive &#x3D; &lt;480&gt;; &#x2F;* LCD X 轴像素个数 *&#x2F;</span><br><span class="line">vactive &#x3D; &lt;272&gt;; &#x2F;* LCD Y 轴像素个数 *&#x2F;</span><br><span class="line">hfront-porch &#x3D; &lt;8&gt;; &#x2F;* LCD hfp 参数 *&#x2F;</span><br><span class="line">hback-porch &#x3D; &lt;4&gt;; &#x2F;* LCD hbp 参数 *&#x2F;</span><br><span class="line">hsync-len &#x3D; &lt;41&gt;; &#x2F;* LCD hspw 参数 *&#x2F;</span><br><span class="line">vback-porch &#x3D; &lt;2&gt;; &#x2F;* LCD vbp 参数 *&#x2F;</span><br><span class="line">vfront-porch &#x3D; &lt;4&gt;; &#x2F;* LCD vfp 参数 *&#x2F;</span><br><span class="line">vsync-len &#x3D; &lt;10&gt;; &#x2F;* LCD vspw 参数 *&#x2F;</span><br><span class="line"></span><br><span class="line">hsync-active &#x3D; &lt;0&gt;; &#x2F;* hsync 数据线极性 *&#x2F;</span><br><span class="line">vsync-active &#x3D; &lt;0&gt;; &#x2F;* vsync 数据线极性 *&#x2F;</span><br><span class="line">de-active &#x3D; &lt;1&gt;; &#x2F;* de 数据线极性 *&#x2F;</span><br><span class="line">pixelclk-active &#x3D; &lt;0&gt;; &#x2F;* clk 数据线先极性 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第 3 行，pinctrl-0 属性，LCD 所使用的 IO 信息，这里用到了 pinctrl_lcdif_dat(RGB LCD 的 24 根数据线配置项)、pinctrl_lcdif_ctrl(RGB LCD 的 4 根控制线配置项，包括 CLK、ENABLE、VSYNC 和 HSYNC)和 pinctrl_lcdif_reset (LCD 复位 IO 信息节点)这三个 IO 相关的节点。<br>第 6 行，display 属性，指定 LCD 属性信息所在的子节点，这里为 display0，下面就是 display0子节点内容。<br>第 9<del>32 行，display0 子节点，描述 LCD 的参数信息，第 10 行的 bits-per-pixel 属性用于指明一个像素占用的 bit 数，默认为 16bit。将 LCD 配置为 RGB888 模式，因此一个像素点占用 24bit，bits-per-pixel 属性要改为 24。第 11 行的 bus-width 属性用于设置数据线宽度，因为要配置为 RGB888 模式，因此 bus-width 也要设置为 24。 第 13</del>30 行，这几行设置了 LCD 的时序参数信息，需要根据自己所使用的屏幕去修改。</p><p><strong>3、LCD 屏幕背光节点信息</strong></p><p>正点原子的 LCD 接口背光控制 IO 连接到了 I.MX6U 的 GPIO1_IO08 引脚上，GPIO1_IO08复用为 PWM1_OUT，通过 PWM 信号来控制 LCD 屏幕背光的亮度，正点原子 I.MX6U-ALPHA 开发板的 LCD 背光引脚和 NXP 官方 EVK 开发 板的背光引脚一样，因此背光的设备树节点是不需要修改的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> pinctrl_pwm1: pwm1grp &#123; </span><br><span class="line">     fsl,pins &#x3D; &lt; </span><br><span class="line">     MX6UL_PAD_GPIO1_IO08__PWM1_OUT 0x110b0</span><br><span class="line">    &gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pinctrl_pwm1 节点就是 GPIO1_IO08 的配置节点，设置 GPIO1_IO08 这个 IO 复用为 PWM1_OUT，并且设置电气属性值为 0x110b0。 </p><p>LCD 背光要用到 PWM1，因此也要设置 PWM1 节点，在 imx6ull.dtsi 文件中找到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwm1: pwm@02080000 &#123;</span><br><span class="line">    compatible &#x3D; &quot;fsl,imx6ul-pwm&quot;, &quot;fsl,imx27-pwm&quot;; </span><br><span class="line">    reg &#x3D; &lt;0x02080000 0x4000&gt;;</span><br><span class="line">    interrupts &#x3D; &lt;GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks &#x3D; &lt;&amp;clks IMX6UL_CLK_PWM1&gt;,</span><br><span class="line">    &lt;&amp;clks IMX6UL_CLK_PWM1&gt;;</span><br><span class="line">    clock-names &#x3D; &quot;ipg&quot;, &quot;per&quot;;</span><br><span class="line">    #pwm-cells &#x3D; &lt;2&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>imx6ull.dtsi 文件中的 pwm1 节点信息不要修改，如果要修改 pwm1 节点内容的话在imx6ull-alientek-emmc.dts 文件中修改。继续在 imx6ull-alientek-emmc.dts 文件中找到向 pwm1追加的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;pwm1 &#123; </span><br><span class="line">    pinctrl-names &#x3D; &quot;default&quot;; </span><br><span class="line">    pinctrl-0 &#x3D; &lt;&amp;pinctrl_pwm1&gt;;</span><br><span class="line">    status &#x3D; &quot;okay&quot;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设置 pwm1 所使用的 IO 为 pinctrl_pwm1，也就是GPIO1_IO08 这个 IO。将 status 设置为 okay。</p><p>需要一个节点来将 LCD 背光和 PWM1_OUT连接起来 ，Linux系统才知道PWM1_OUT 就是控制 LCD 背光的。 这 个节点就是backlight，backlight节点创建总结一下：<br>①、节点名称要为“backlight”。<br>②、节点的 compatible 属性值要为“pwm-backlight”，<br>③、pwms属性用于描述背光所使用的PWM以及PWM频率，比如要使用的pwm1，pwm 频率设置为 5KHz(<br>④、brightness-levels 属性描述亮度级别，范围为 0~255，0 表示 PWM 占空比为 0%，也就是亮度最低，255 表示 100%占空比，也就是亮度最高。<br>⑤、default-brightness-level 属性为默认亮度级别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">backlight &#123; </span><br><span class="line">    compatible &#x3D; &quot;pwm-backlight&quot;;</span><br><span class="line">    pwms &#x3D; &lt;&amp;pwm1 0 5000000&gt;;</span><br><span class="line">    brightness-levels &#x3D; &lt;0 4 8 16 32 64 128 255&gt;;</span><br><span class="line">    default-brightness-level &#x3D; &lt;6&gt;;</span><br><span class="line">    status &#x3D; &quot;okay&quot;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设置背光使用 pwm1，PWM 频率为 5KHz。设置背 8 级背光(0~7)，分别为 0、4、8、16、32、64、128、255，对应占空比为0%、1.57%、3.13%、6.27%、12.55%、25.1%、50.19%、100%。设置默认背光等级为 6，也就是 50.19%的亮度。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Framebuffer-设备&quot;&gt;&lt;a href=&quot;#Framebuffer-设备&quot; class=&quot;headerlink&quot; title=&quot;Framebuffer 设备&quot;&gt;&lt;/a&gt;&lt;strong&gt;Framebuffer&lt;/strong&gt; &lt;strong&gt;设备&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;裸机 LCD 驱动编写流程如下：&lt;br&gt;①、初始化 I.MX6U 的 eLCDIF 控制器，重点是 LCD 屏幕宽(width)、高(height)、hspw、hbp、hfp、vspw、vbp 和 vfp 等信息。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-INPUT子系统</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-04-16T12:58:20.000Z</published>
    <updated>2021-05-05T04:43:52.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="input-子系统"><a href="#input-子系统" class="headerlink" title="input 子系统"></a><strong>input</strong> <strong>子系统</strong></h1><p>按键、鼠标、键盘、触摸屏等都属于输入(input)设备，Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。输入设备本质上还是字符设备，只是在此基础上套上了 input 框架，用户只需要负责上报输入事件，比如按键值、坐标等信息，input 核心层负责处理这些事件。</p> <a id="more"></a> <p> input 子系统管理输入的子系统，和 pinctrl 和 gpio 子系统 一样，都是 Linux 内核针对某一类设备而创建的框架。比如按键输入、键盘、鼠标、触摸屏等等这些都属于输入设备，不同的输入设备所代表的含义不同，按键和键盘就是代表按键信息，鼠标和触摸屏代表坐标信息，因此在应用层的处理就不同。</p><p>对于驱动编写者而言不需要去关心应用层的事情，我们只需要按照要求上报这些输入事件即可。为此 input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点。input 子系统驱动分层模型，编写驱动程序的时候只需要关注中间的驱动层、核心层和事件层，这三个层的分工如下： </p><ul><li>驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。 </li><li>核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。 </li><li>事件层：主要和用户空间进行交互。</li></ul><h2 id="input-驱动编写流程"><a href="#input-驱动编写流程" class="headerlink" title="input 驱动编写流程"></a><strong>input</strong> <strong>驱动编写流程</strong></h2><p>input 核心层会向 Linux 内核注册一个字符设备，主设备号为 INPUT_MAJOR=13，因此input 子系统的所有设备主设备号都为 13，在使用 input 子系统处理输入设备的时候就不需要去注册字符设备了，只需要向系统注册一个 input_device 即可。 </p><h3 id="1、注册-input-dev"><a href="#1、注册-input-dev" class="headerlink" title="1、注册 input_dev"></a>1、注册 input_dev</h3><p>在使用 input 子系统的时候我们只需要注册一个 input 设备即可，input_dev 结构体表示 input设备，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct input_dev &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *phys;</span><br><span class="line">    const char *uniq;</span><br><span class="line">    struct input_id id;</span><br><span class="line"></span><br><span class="line">    unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line">    unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; &#x2F;* 事件类型的位图 *&#x2F;</span><br><span class="line">    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; &#x2F;* 按键值的位图 *&#x2F;</span><br><span class="line">    unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; &#x2F;* 相对坐标的位图 *&#x2F; </span><br><span class="line">    ......</span><br><span class="line">    bool devres_managed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>evbit、keybit、relbit 等等都是存放不同事件对应的值。</p><p>evbit 表示输入事件类型，可选的事件类型定义在 include/uapi/linux/input.h 文件 中，要使用到按键，那么就需要注册 EV_KEY 事件，如果要使用连按功能的话还需要注册 EV_REP 事件。 事件类型如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define EV_SYN 0x00 &#x2F;* 同步事件 *&#x2F;</span><br><span class="line">#define EV_KEY 0x01 &#x2F;* 按键事件 *&#x2F;</span><br><span class="line">#define EV_REL 0x02 &#x2F;* 相对坐标事件 *&#x2F;</span><br><span class="line">#define EV_ABS 0x03 &#x2F;* 绝对坐标事件 *&#x2F;</span><br><span class="line">#define EV_MSC 0x04 &#x2F;* 杂项(其他)事件 *&#x2F;</span><br><span class="line">#define EV_SW 0x05 &#x2F;* 开关事件 *&#x2F;</span><br><span class="line">#define EV_LED 0x11 &#x2F;* LED *&#x2F;</span><br><span class="line">#define EV_SND 0x12 &#x2F;* sound(声音) *&#x2F;</span><br><span class="line">#define EV_REP 0x14 &#x2F;* 重复事件 *&#x2F;</span><br><span class="line">#define EV_FF 0x15 &#x2F;* 压力事件 *&#x2F;</span><br><span class="line">#define EV_PWR 0x16 &#x2F;* 电源事件 *&#x2F;</span><br><span class="line">#define EV_FF_STATUS 0x17 &#x2F;* 压力状态事件 *&#x2F;</span><br></pre></td></tr></table></figure><p>要使用按键事件，因此要用到 keybit，keybit 就是按键事件使用的位图，Linux 内核定义了很多按键值，这些按键值定义在 include/uapi/linux/input.h 文件中，按键值如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define KEY_RESERVED 0</span><br><span class="line">#define KEY_ESC 1</span><br><span class="line">#define KEY_7 8</span><br><span class="line">#define KEY_8 9</span><br><span class="line">#define KEY_9 10</span><br><span class="line">#define KEY_0 11</span><br><span class="line">......</span><br><span class="line">#define BTN_TRIGGER_HAPPY39 0x2e6</span><br><span class="line">#define BTN_TRIGGER_HAPPY40 0x2e7</span><br></pre></td></tr></table></figure><p>可以将开发板上的按键值设置为任意一个，可将 I.MX6U-ALPHA 开发板上的 KEY 按键值设置为 KEY_0。 </p><p>在编写 input 设备驱动的时候需要先申请一个 input_dev 结构体变量，使用input_allocate_device 函数来申请一个 input_dev，如果要注销的 input 设备的话需要使用 input_free_device 函数来释放掉前面申请到的input_dev</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct input_dev *input_allocate_device(void)</span><br><span class="line">&#x2F;&#x2F;参数：无。</span><br><span class="line">&#x2F;&#x2F;返回值：申请到的 input_dev。</span><br><span class="line">void input_free_device(struct input_dev *dev)</span><br><span class="line">&#x2F;&#x2F;dev：需要释放的 input_dev。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p>申请好一个 input_dev 以后就需要初始化这个 input_dev，需要初始化的内容主要为事件类型(evbit)和事件值(keybit)这两种。input_dev 初始化完成以后就需要向 Linux 内核注册 input_dev了，需要用到 input_register_device 函数，注销 input 驱动的时候也需要使用 input_unregister_device 函数来注销掉前面注册<br>的 input_dev。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int input_register_device(struct input_dev *dev)</span><br><span class="line">&#x2F;&#x2F;dev：要注册的 input_dev 。</span><br><span class="line">&#x2F;&#x2F;返回值：0，input_dev 注册成功；负值，input_dev 注册失败。</span><br><span class="line">void input_unregister_device(struct input_dev *dev)</span><br><span class="line">&#x2F;&#x2F;dev：要注销的 input_dev 。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p>综上所述，input_dev 注册过程如下：</p><p>①、使用 input_allocate_device 函数申请一个 input_dev。<br>②、初始化 input_dev 的事件类型以及事件值。<br>③、使用 input_register_device 函数向 Linux 系统注册前面初始化好的 input_dev。<br>④、卸载input驱动的时候需要先使用input_unregister_device函数注销掉注册的input_dev，然后使用 input_free_device 函数释放掉前面申请的 input_dev。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">struct input_dev *inputdev; &#x2F;* input 结构体变量 *&#x2F;</span><br><span class="line">&#x2F;* 驱动入口函数 *&#x2F;</span><br><span class="line">static int __init xxx_init(void) </span><br><span class="line">&#123; </span><br><span class="line">    ......</span><br><span class="line">    inputdev &#x3D; input_allocate_device(); &#x2F;* 申请 input_dev *&#x2F;</span><br><span class="line">    inputdev-&gt;name &#x3D; &quot;test_inputdev&quot;; &#x2F;* 设置 input_dev 名字 *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*********第一种设置事件和事件值的方法***********&#x2F;</span><br><span class="line">    __set_bit(EV_KEY, inputdev-&gt;evbit); &#x2F;* 设置产生按键事件 *&#x2F;</span><br><span class="line">    __set_bit(EV_REP, inputdev-&gt;evbit); &#x2F;* 重复事件 *&#x2F;</span><br><span class="line">    __set_bit(KEY_0, inputdev-&gt;keybit); &#x2F;*设置产生哪些按键值 *&#x2F;</span><br><span class="line">    &#x2F;************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*********第二种设置事件和事件值的方法***********&#x2F;</span><br><span class="line">    keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) |BIT_MASK(EV_REP);</span><br><span class="line">    keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |&#x3D; BIT_MASK(KEY_0);</span><br><span class="line">    &#x2F;************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*********第三种设置事件和事件值的方法***********&#x2F;</span><br><span class="line">    keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">    input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line">    &#x2F;************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 注册 input_dev *&#x2F;</span><br><span class="line">    input_register_device(inputdev);</span><br><span class="line">    ......</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动出口函数 *&#x2F;</span><br><span class="line">static void __exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    input_unregister_device(inputdev); &#x2F;* 注销 input_dev *&#x2F;</span><br><span class="line">    input_free_device(inputdev); &#x2F;* 删除 input_dev *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先定义一个 input_dev 结构体指针变量。 </p><p>驱动入口函数，在此函数中完成 input_dev 的申请、设置、注册等工作调用 input_allocate_device 函数申请一个 input_dev。设置 input 设备事件和按键值，这里用了三种方法来设置事件和按键值。调用 input_register_device 函数向 Linux内核注册 inputdev。 </p><p>驱动出口函数，调用 input_unregister_device 函数注销前面注册的input_dev，调用 input_free_device 函数删除前面申请的 input_dev。 </p><h3 id="2、上报输入事件"><a href="#2、上报输入事件" class="headerlink" title="2、上报输入事件"></a><strong>2、上报输入事件</strong></h3><p>向 Linux 内核注册好 input_dev 以后需要获取到具体的输入值，或者说是输入事件，然后将输入事件上报给 Linux 内核。比如按键，我们需要在按键中断处理函数，或者消抖定时器中断函数中将按键值上报给 Linux 内核，这样 Linux 内核才能获取到正确的输入值。不同的事件，其上报事件的 API 函数不同，</p><p> input_event 函数用于上报指定的事件以及对应的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)</span><br><span class="line">&#x2F;&#x2F;dev：需要上报的 input_dev。</span><br><span class="line">&#x2F;&#x2F;type: 上报的事件类型，比如 EV_KEY。</span><br><span class="line">&#x2F;&#x2F;code：事件码，也就是我们注册的按键值，比如 KEY_0、KEY_1 等等。</span><br><span class="line">&#x2F;&#x2F;value：事件值，比如 1 表示按键按下，0 表示按键松开。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p>input_event 函数可以上报所有的事件类型和事件值，Linux 内核也提供了其他的针对具体事件的上报函数，这些函数其实都用到了 input_event 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void input_report_key(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_rel(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_abs(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">…………</span><br></pre></td></tr></table></figure><p>这些函数的本质就是 input_event 函数，如果要上报按键事件的话还是建议大家使用 input_report_key 函数。 </p><p>当上报事件以后还需要使用 input_sync 函数来告诉 Linux 内核 input 子系统上报结束，input_sync 函数本质是上报一个同步事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void input_sync(struct input_dev *dev)</span><br><span class="line">&#x2F;&#x2F;dev：需要上报同步事件的 input_dev。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p>综上所述，按键的上报事件的参考代码如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 用于按键消抖的定时器服务函数 *&#x2F;</span><br><span class="line">void timer_function(unsigned long arg) </span><br><span class="line">&#123; </span><br><span class="line">    unsigned char value; </span><br><span class="line">    value &#x3D; gpio_get_value(keydesc-&gt;gpio); &#x2F;* 读取 IO 值 *&#x2F;</span><br><span class="line">    if(value &#x3D;&#x3D; 0)&#123; &#x2F;* 按下按键 *&#x2F;</span><br><span class="line">        &#x2F;* 上报按键值 *&#x2F;</span><br><span class="line">        input_report_key(inputdev, KEY_0, 1); &#x2F;* 最后一个参数 1，按下 *&#x2F;</span><br><span class="line">        input_sync(inputdev); &#x2F;* 同步事件 *&#x2F;</span><br><span class="line">    &#125; else &#123; &#x2F;* 按键松开 *&#x2F;</span><br><span class="line">        input_report_key(inputdev, KEY_0, 0); &#x2F;* 最后一个参数 0，松开 *&#x2F;</span><br><span class="line">        input_sync(inputdev); &#x2F;* 同步事件 *&#x2F;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取按键值，判断按键是否按下。 如果按键值为 0 那么表示按键被按下了，如果按键按下的话就要使用 input_report_key 函数向 Linux 系统上报按键值，比如向 Linux 系统通知 KEY_0 这个按键按下了。 如果按键值为 1 的话就表示按键没有按下，是松开的。向 Linux 系统通知KEY_0 这个按键没有按下或松开了。 </p><h3 id="input-event-结构体"><a href="#input-event-结构体" class="headerlink" title="input_event 结构体"></a>input_event 结构体</h3><p>Linux 内核使用 input_event 这个结构体来表示所有的输入事件，input_event 结构体定义在 include/uapi/linux/input.h 文件中，结构体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct input_event &#123;</span><br><span class="line">    struct timeval time;</span><br><span class="line">    __u16 type;</span><br><span class="line">    __u16 code;</span><br><span class="line">    __s32 value;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;time：时间，也就是此事件发生的时间，为 timeval 结构体类型</span><br><span class="line">&#x2F;&#x2F;type：事件类型，比如 EV_KEY，表示此次事件为按键事件，此成员变量为 16 位。</span><br><span class="line">&#x2F;&#x2F;code：事件码，比如在EV_KEY事件中code就表示具体的按键码，如：KEY_0、KEY_1这些按键。此成员变量为16位。</span><br><span class="line">&#x2F;&#x2F;value：值，比如EV_KEY事件中value就是按键值，表示按键有没有被按下，如果为 1 的话说明按键按下，如果为 0 的话说明按键没有被按下或者按键松开了。</span><br></pre></td></tr></table></figure><p><strong>time</strong>：时间，也就是此事件发生的时间，为 timeval 结构体类型，timeval 结构体定义如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct timeval &#123; </span><br><span class="line">    __kernel_time_t tv_sec; &#x2F;* 秒 *&#x2F;</span><br><span class="line">    __kernel_suseconds_t tv_usec; &#x2F;* 微秒 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;tv_sec 和 tv_usec 这两个成员变量都为 long 类型，也就是32位。</span><br></pre></td></tr></table></figure><p>input_envent 这个结构体非常重要，因为所有的输入设备最终都是按照 input_event 结构体呈现给用户的，用户应用程序可以通过 input_event 来获取到具体的输入事件或相关的值。</p><h2 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a><strong>实验程序编写</strong></h2><h3 id="驱动程序编写"><a href="#驱动程序编写" class="headerlink" title="驱动程序编写"></a><strong>驱动程序编写</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: keyinput.c</span><br><span class="line">描述   : Linux按键input子系统实验</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* keyinput设备结构体 *&#x2F;</span><br><span class="line">struct keyinput_dev&#123;</span><br><span class="line">struct input_dev *inputdev;&#x2F;* input结构体 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct keyinput_dev keyinputdev;&#x2F;* key input设备 *&#x2F;</span><br><span class="line"></span><br><span class="line">void timer_function(unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">value &#x3D; gpio_get_value(keydesc-&gt;gpio); &#x2F;* 读取IO值 *&#x2F;</span><br><span class="line">if(value &#x3D;&#x3D; 0)&#123; &#x2F;* 按下按键 *&#x2F;</span><br><span class="line">&#x2F;* 上报按键值 *&#x2F;</span><br><span class="line">&#x2F;&#x2F;input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 1);</span><br><span class="line">input_report_key(dev-&gt;inputdev, keydesc-&gt;value, 1);&#x2F;* 最后一个参数表示按下还是松开，1为按下，0为松开 *&#x2F;</span><br><span class="line">input_sync(dev-&gt;inputdev);</span><br><span class="line">&#125; else &#123; &#x2F;* 按键松开 *&#x2F;</span><br><span class="line">&#x2F;&#x2F;input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 0);</span><br><span class="line">input_report_key(dev-&gt;inputdev, keydesc-&gt;value, 0);</span><br><span class="line">input_sync(dev-&gt;inputdev);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int keyio_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 申请input_dev *&#x2F;</span><br><span class="line">keyinputdev.inputdev &#x3D; input_allocate_device();</span><br><span class="line">keyinputdev.inputdev-&gt;name &#x3D; KEYINPUT_NAME;</span><br><span class="line">#if 0</span><br><span class="line">&#x2F;* 初始化input_dev，设置产生哪些事件 *&#x2F;</span><br><span class="line">__set_bit(EV_KEY, keyinputdev.inputdev-&gt;evbit);&#x2F;* 设置产生按键事件          *&#x2F;</span><br><span class="line">__set_bit(EV_REP, keyinputdev.inputdev-&gt;evbit);&#x2F;* 重复事件，比如按下去不放开，就会一直输出信息  *&#x2F;</span><br><span class="line">&#x2F;* 初始化input_dev，设置产生哪些按键 *&#x2F;</span><br><span class="line">__set_bit(KEY_0, keyinputdev.inputdev-&gt;keybit);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |&#x3D; BIT_MASK(KEY_0);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line"></span><br><span class="line">&#x2F;* 注册输入设备 *&#x2F;</span><br><span class="line">ret &#x3D; input_register_device(keyinputdev.inputdev);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit keyinput_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 释放input_dev *&#x2F;</span><br><span class="line">input_unregister_device(keyinputdev.inputdev);</span><br><span class="line">input_free_device(keyinputdev.inputdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设备结构体中定义一个 input_dev 指针变量。</p><p>在按键消抖定时器处理函数中上报输入事件，也就是使用 input_report_key函数上报按键事件以及按键值，最后使用 input_sync 函数上报一个同步事件，这一步一定得做！</p><p>使用 input_allocate_device 函数申请 input_dev，然后设置相应的事件以及事件码(也就是 KEY 模拟成那个按键，设置为 KEY_0)。最后使用 input_register_device函数向 Linux 内核注册 input_dev。 </p><p>当注销 input 设备驱动的时候使用 input_unregister_device 函数注销掉前面注册的 input_dev，最后使用 input_free_device 函数释放掉前面申请的 input_dev。</p><h3 id="编写测试-APP"><a href="#编写测试-APP" class="headerlink" title="编写测试 APP"></a><strong>编写测试</strong> <strong>APP</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: keyinputApp.c</span><br><span class="line">描述   : input子系统测试APP。</span><br><span class="line">使用方法 ：.&#x2F;keyinputApp &#x2F;dev&#x2F;input&#x2F;event1</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* 定义一个input_event变量，存放输入事件信息 *&#x2F;</span><br><span class="line">static struct input_event inputevent;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">fd &#x3D; open(filename, O_RDWR);</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">err &#x3D; read(fd, &amp;inputevent, sizeof(inputevent));</span><br><span class="line">        switch (inputevent.type) &#123;</span><br><span class="line">        case EV_KEY:</span><br><span class="line">            if (inputevent.code &lt; BTN_MISC) &#123; &#x2F;* 键盘键值 *&#x2F;</span><br><span class="line">            printf(&quot;key %d %s\r\n&quot;, inputevent.code, inputevent.value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            printf(&quot;button %d %s\r\n&quot;, inputevent.code, inputevent.value);</span><br><span class="line">            &#125;</span><br><span class="line">        break;</span><br><span class="line">            &#x2F;* 其他类型的事件，自行处理 *&#x2F;</span><br><span class="line">            case EV_REL:</span><br><span class="line">            break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux 内核会使用 input_event 结构体来表示输入事件，所以要获取按键输入信息，那么必须借助于 input_event 结构体。</p><p>向 Linux 内核成功注册 input_dev 设备以后，会在/dev/input 目录下生成一个名为“eventX(X=0….n)”的文件，这个/dev/input/eventX 就是对应的 input 设备文件。我们读取这个文件就可以获取到输入事件信息，使用read函数读取输入设备文件/dev/input/eventX，读取到的数据按照 input_event 结构体组织起来。获取到输入事件以后<br>(input_event 结构体类型)使用 switch case 语句来判断事件类型，设置的事件类型为 EV_KEY，因此只需要处理 EV_KEY 事件即可。</p><h2 id="自带按键驱动程序的使用"><a href="#自带按键驱动程序的使用" class="headerlink" title="自带按键驱动程序的使用"></a>自带按键驱动程序的使用</h2><p>要使用Linux内核自带的按键驱动程序很简单，只需要根据<br>Documentation/devicetree/bindings/input/gpio-keys.txt 这个文件在设备树中添加指定的设备节点即可，节点要求如下：<br>①、节点名字为“gpio-keys”。<br>②、gpio-keys 节点的 compatible 属性值一定要设置为“gpio-keys”。<br>③、所有的 KEY 都是 gpio-keys 的子节点，每个子节点可以用如下属性描述自己：<br>    gpios：KEY 所连接的 GPIO 信息。<br>    interrupts：KEY 所使用 GPIO 中断信息，不是必须的，可以不写。<br>    label：KEY 名字<br>    linux,code：KEY 要模拟的按键，也就是示例代码 58.1.2.4 中的这些按键。<br>④、如果按键要支持连按的话要加入 autorepeat。<br>打开 imx6ull-alientek-emmc.dts，根据上面的要求创建对应的设备节点，设备节点内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gpio-keys &#123; </span><br><span class="line">    compatible &#x3D; &quot;gpio-keys&quot;; </span><br><span class="line">    #address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">    #size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">    autorepeat; </span><br><span class="line">    key0 &#123; </span><br><span class="line">        label &#x3D; &quot;GPIO Key Enter&quot;; </span><br><span class="line">        linux,code &#x3D; &lt;KEY_ENTER&gt;;</span><br><span class="line">        gpios &#x3D; &lt;&amp;gpio1 18 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>autorepeat 表示按键支持连按。 </p><p>ALPHA 开发板 KEY 按键信息，名字设置为“GPIO Key Enter”，这里将 开发板上的 KEY 按键设置为“EKY_ENTER”这个按键，也就是回车键，效果和键盘上的回车键一样。将开发板上最后设置 KEY 所使用的 IO 为 GPIO1_IO18，一定要检查一下设备树看看此 GPIO 有没有被用到其他外设上，如果有的话要删除掉相关代码！ </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;input-子系统&quot;&gt;&lt;a href=&quot;#input-子系统&quot; class=&quot;headerlink&quot; title=&quot;input 子系统&quot;&gt;&lt;/a&gt;&lt;strong&gt;input&lt;/strong&gt; &lt;strong&gt;子系统&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;按键、鼠标、键盘、触摸屏等都属于输入(input)设备，Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。输入设备本质上还是字符设备，只是在此基础上套上了 input 框架，用户只需要负责上报输入事件，比如按键值、坐标等信息，input 核心层负责处理这些事件。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-MISC驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-MISC%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-MISC%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-16T11:05:33.000Z</published>
    <updated>2021-05-05T04:44:36.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MISC-设备驱动"><a href="#MISC-设备驱动" class="headerlink" title="MISC 设备驱动"></a><strong>MISC</strong> <strong>设备驱动</strong></h1><p>misc 的意思是混合、杂项的，因此 MISC 驱动也叫做杂项驱动，当某些外设无法进行分类的时候就可以使用 MISC 驱动。MISC 驱动其实就是最简单的字符设备驱动，通常嵌套在 platform 总线驱动中，实现复杂的驱动。</p> <a id="more"></a> <p>所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。随着 Linux字符设备驱动的不断增加，设备号变得越来越紧张，尤其是主设备号，MISC 设备驱动就用于解决此问题。MISC 设备会自动创建 cdev，不需要像我们以前那样手动创建，因此采用 MISC 设备驱动可以简化字符设备驱动的编写。</p><p>需要向 Linux 注册一个 miscdevice 设备，miscdevice是一个结构体，定义在文件 include/linux/miscdevice.h 中，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct miscdevice &#123;</span><br><span class="line">    int minor; &#x2F;* 子设备号 *&#x2F;</span><br><span class="line">    const char *name; &#x2F;* 设备名字 *&#x2F; </span><br><span class="line">    const struct file_operations *fops; &#x2F;* 设备操作集 *&#x2F;</span><br><span class="line">    struct list_head list;</span><br><span class="line">    struct device *parent;</span><br><span class="line">    struct device *this_device;</span><br><span class="line">    const struct attribute_group **groups;</span><br><span class="line">    const char *nodename;</span><br><span class="line">    umode_t mode;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;*minor 表示子设备号，MISC 设备的主设备号为 10，这个是固定的，需要用户指定子设备号，Linux系统已经预定义了一些MISC设备的子设备号，在使用时可以从这些预定义的子设备号中挑选一个，当然也可以自己定义，只要这个子设备号没有被其他设备使用接口。*&#x2F; </span><br><span class="line">&#x2F;&#x2F;name 就是此 MISC 设备名字，当此设备注册成功以后就会在&#x2F;dev 目录下生成一个名为 name的设备文件。</span><br><span class="line">&#x2F;&#x2F;fops 就是字符设备的操作集合，MISC 设备驱动最终是需要使用用户提供的 fops 操作集合。</span><br></pre></td></tr></table></figure><p>定义一个 MISC 设备(miscdevice 类型)以后需要设置 minor、name 和 fops 这三个成员变量。</p><p>当设置好 miscdevice 以后就需要使用 misc_register 函数向系统中注册一个 MISC 设备，卸载设备驱动模块的时候需要调用 misc_deregister 函数来注销掉 MISC 设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int misc_register(struct miscdevice * misc)</span><br><span class="line">&#x2F;&#x2F;misc：要注册的 MISC 设备。</span><br><span class="line">&#x2F;&#x2F;返回值：负数，失败；0，成功。</span><br><span class="line">int misc_deregister(struct miscdevice *misc)</span><br><span class="line">&#x2F;&#x2F;misc：要注销的 MISC 设备。</span><br><span class="line">&#x2F;&#x2F;返回值：负数，失败；0，成功。</span><br></pre></td></tr></table></figure><p>misc_register 函数会自动创建 cdev、设备等等， misc_deregister 函数会自动删除此前创建的 cdev、设备等等内容。</p><h1 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a>实验程序编写</h1><p>采用 platform 加 misc 的方式编写 beep 驱动，这也是实际的 Linux 驱动中很 </p><p>常用的方法。采用 platform 来实现总线、设备和驱动，misc 主要负责完成字符设备的创建。</p><p><strong>修改设备树</strong> </p><p><strong>驱动程序编写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: miscbeep.c</span><br><span class="line">描述   : 采用MISC的蜂鸣器驱动程序。</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">#define MISCBEEP_MINOR144&#x2F;* 子设备号 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* MISC设备结构体 *&#x2F;</span><br><span class="line">static struct miscdevice beep_miscdev &#x3D; &#123;</span><br><span class="line">.minor &#x3D; MISCBEEP_MINOR,</span><br><span class="line">.name &#x3D; MISCBEEP_NAME,</span><br><span class="line">.fops &#x3D; &amp;miscbeep_fops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : flatform驱动的probe函数，当驱动与</span><br><span class="line">  *                    设备匹配以后此函数就会执行</span><br><span class="line">  * @param - dev     : platform设备</span><br><span class="line">  * @return          : 0，成功;其他负值,失败</span><br><span class="line">  *&#x2F;</span><br><span class="line">static int miscbeep_probe(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 一般情况下会注册对应的字符设备，但是这里我们使用MISC设备</span><br><span class="line">   * 所以我们不需要自己注册字符设备驱动，只需要注册misc设备驱动即可</span><br><span class="line"> *&#x2F;</span><br><span class="line">ret &#x3D; misc_register(&amp;beep_miscdev);</span><br><span class="line">if(ret &lt; 0)&#123;</span><br><span class="line">printk(&quot;misc device register failed!\r\n&quot;);</span><br><span class="line">return -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : platform驱动的remove函数，移除platform驱动的时候此函数会执行</span><br><span class="line"> * @param - dev     : platform设备</span><br><span class="line"> * @return          : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int miscbeep_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 注销设备的时候关闭LED灯 *&#x2F;</span><br><span class="line">gpio_set_value(miscbeep.beep_gpio, 1);</span><br><span class="line"></span><br><span class="line">&#x2F;* 注销misc设备 *&#x2F;</span><br><span class="line">misc_deregister(&amp;beep_miscdev);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;* 匹配列表 *&#x2F;</span><br><span class="line"> static const struct of_device_id beep_of_match[] &#x3D; &#123;</span><br><span class="line">     &#123; .compatible &#x3D; &quot;atkalpha-beep&quot; &#125;,</span><br><span class="line">     &#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> &#x2F;* platform驱动结构体 *&#x2F;</span><br><span class="line">static struct platform_driver beep_driver &#x3D; &#123;</span><br><span class="line">     .driver     &#x3D; &#123;</span><br><span class="line">         .name   &#x3D; &quot;imx6ul-beep&quot;,         &#x2F;* 驱动名字，用于和设备匹配 *&#x2F;</span><br><span class="line">         .of_match_table &#x3D; beep_of_match, &#x2F;* 设备树匹配表          *&#x2F;</span><br><span class="line">     &#125;,</span><br><span class="line">     .probe      &#x3D; miscbeep_probe,</span><br><span class="line">     .remove     &#x3D; miscbeep_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动出口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init miscbeep_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return platform_driver_register(&amp;beep_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动出口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __exit miscbeep_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;beep_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MISC 设备 beep_miscdev，设置子设备号为 144，设置设备名字为“miscbeep”，这样当系统启动以后就会在/dev/目录下存在一个名为“miscbeep”的设备文件。设置 MISC 设备的操作函数集合，为 file_operations 类型。 </p><p>platform 框架的 probe 函数，当驱动与设备匹配以后此函数就会执行，首先在此函数中初始化 BEEP 所使用的 IO。最后通过 misc_register 函数向 Linux 内核注册MISC 设备，也就是前面定义的 beep_miscdev。 </p><p>platform 框架的 remove 函数，在此函数中调用 misc_deregister 函数来注销MISC 设备。 </p><p>第 163~196，标准的 platform 驱动</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MISC-设备驱动&quot;&gt;&lt;a href=&quot;#MISC-设备驱动&quot; class=&quot;headerlink&quot; title=&quot;MISC 设备驱动&quot;&gt;&lt;/a&gt;&lt;strong&gt;MISC&lt;/strong&gt; &lt;strong&gt;设备驱动&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;misc 的意思是混合、杂项的，因此 MISC 驱动也叫做杂项驱动，当某些外设无法进行分类的时候就可以使用 MISC 驱动。MISC 驱动其实就是最简单的字符设备驱动，通常嵌套在 platform 总线驱动中，实现复杂的驱动。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-platform设备驱动-设备树</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E6%A0%91/</id>
    <published>2021-04-16T10:24:46.000Z</published>
    <updated>2021-05-05T04:45:49.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设备树下的-platform-驱动"><a href="#设备树下的-platform-驱动" class="headerlink" title="设备树下的 platform 驱动"></a><strong>设备树下的</strong> <strong>platform</strong> <strong>驱动</strong></h1><p>platform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没 有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代 表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的 platform 驱动的时候我们需要注意一下几点：</p> <a id="more"></a> <p><strong>1、在设备树中创建设备节点</strong></p><p>毫无疑问，肯定要先在设备树中创建设备节点来描述设备信息，重点是要设置好 compatible 属性的值，因为 platform 总线需要通过设备节点的 compatible 属性值来匹配驱动！</p><p><strong>2、编写 platform 驱动的时候要注意兼容属性</strong></p><p>在使用设备树的时候 platform 驱动会通过 of_match_table 来保存兼容性值，也就是表明此驱动兼容哪些设备。所以，of_match_table 将会尤为重要，</p><p><strong>3、编写 platform 驱动</strong></p><p>基于设备树的 platform 驱动和上一章无设备树的 platform 驱动基本一样，都是当驱动和设备匹配成功以后就会执行 probe 函数。我们需要在 probe 函数里面执行字符设备驱动那一套，当注销驱动模块的时候 remove 函数就会执行，都是大同小异的。</p><h2 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a><strong>实验程序编写</strong></h2><p>编写基于设备树的 platform 驱动，所以需要在设备树中添加设备节点，然后只需要编写 platform 驱动即可。 </p><p><strong>修改设备树文件</strong> </p><p><strong>platform</strong> <strong>驱动程序编写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: leddriver.c</span><br><span class="line">描述   : 设备树下的platform驱动</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: flatform驱动的probe函数，当驱动与</span><br><span class="line"> *   设备匹配以后此函数就会执行</span><br><span class="line"> * @param - dev : platform设备</span><br><span class="line"> * @return : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_probe(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">…………</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: platform驱动的remove函数，移除platform驱动的时候此函数会执行</span><br><span class="line"> * @param - dev : platform设备</span><br><span class="line"> * @return : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(leddev.led0, 1); &#x2F;* 卸载驱动的时候关闭LED *&#x2F;</span><br><span class="line"></span><br><span class="line">cdev_del(&amp;leddev.cdev);&#x2F;*  删除cdev *&#x2F;</span><br><span class="line">unregister_chrdev_region(leddev.devid, LEDDEV_CNT); &#x2F;* 注销设备号 *&#x2F;</span><br><span class="line">device_destroy(leddev.class, leddev.devid);</span><br><span class="line">class_destroy(leddev.class);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 匹配列表 *&#x2F;</span><br><span class="line">static const struct of_device_id led_of_match[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;atkalpha-gpioled&quot; &#125;,</span><br><span class="line">&#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* platform驱动结构体 *&#x2F;</span><br><span class="line">static struct platform_driver led_driver &#x3D; &#123;</span><br><span class="line">.driver&#x3D; &#123;</span><br><span class="line">.name&#x3D; &quot;imx6ul-led&quot;,&#x2F;* 驱动名字，用于和设备匹配 *&#x2F;</span><br><span class="line">.of_match_table&#x3D; led_of_match, &#x2F;* 设备树匹配表  *&#x2F;</span><br><span class="line">&#125;,</span><br><span class="line">.probe&#x3D; led_probe,</span><br><span class="line">.remove&#x3D; led_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动模块加载函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init leddriver_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return platform_driver_register(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动模块卸载函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __exit leddriver_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(leddriver_init);</span><br><span class="line">module_exit(leddriver_exit);</span><br></pre></td></tr></table></figure><p>platform 驱动的 probe 函数，当设备树中的设备节点与驱动之间匹配成功以后此函数就会执行，原来在驱动加载函数里面做的工作现在全部放到 probe 函s数里面完成。 </p><p>remobe 函数，当卸载 platform 驱动的时候此函数就会执行。在此函数里面释放内存、注销字符设备等，也就是将原来驱动卸载函数里面的工作全部都放到 remove 函数中 完成。 </p><p>led_of_match匹配表，描述了此驱动都和什么样的设备匹配，添加了一条值为”atkalpha-gpioled”的 compatible 属性值，当设备树中某个设备节点的 compatible 属性值也为“atkalpha-gpioled”的时候就会与此驱动匹配。 在编最后一个元素一定要为空！ </p><p>platform_driver 驱动结构体，设置这个 platform 驱动的名字为“imx6ulled”，因此，当驱动加载成功以后就会在/sys/bus/platform/drivers/目录下存在一个名为“imx6uled”的文件。 设置 of_match_table 为上面的 led_of_match。 </p><p>驱动模块加载函数，在此函数里面通过 platforms_driver_register 向 Linux 内核注册 led_driver 驱动。 </p><p>驱动模块卸载函数，在此函数里面通过 platform_driver_unregister 从 Linux内核卸载 led_driver 驱动。 </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;设备树下的-platform-驱动&quot;&gt;&lt;a href=&quot;#设备树下的-platform-驱动&quot; class=&quot;headerlink&quot; title=&quot;设备树下的 platform 驱动&quot;&gt;&lt;/a&gt;&lt;strong&gt;设备树下的&lt;/strong&gt; &lt;strong&gt;platform&lt;/strong&gt; &lt;strong&gt;驱动&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;platform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没 有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代 表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的 platform 驱动的时候我们需要注意一下几点：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-platform设备驱动-非设备树</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E9%9D%9E%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E9%9D%9E%E8%AE%BE%E5%A4%87%E6%A0%91/</id>
    <published>2021-04-16T09:31:45.000Z</published>
    <updated>2021-05-05T04:45:07.373Z</updated>
    
    <content type="html"><![CDATA[<p>使用platform 驱动框架来编写一个 LED 灯驱动，不使用设备树来描述设备信息，我们采用自定义platform_device这种“古老”方式来编写LED的设备信息。</p> <a id="more"></a> <p>需要编写一个驱动模块和一个设备模块，其中驱动模块是 platform 驱动程序， </p><p>设备模块是 platform 的设备信息。当这两个模块都加载成功以后就会匹配成功，然后 platform </p><p>驱动模块中的 probe 函数就会执行，probe 函数中就是传统的字符设备驱动那一套。 </p><p><strong>试验程序编写</strong></p><p><strong>platform</strong> <strong>设备与驱动程序编写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: leddriver.c</span><br><span class="line">描述   : platform驱动</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: flatform驱动的probe函数，当驱动与设备匹配以后此函数就会执行</span><br><span class="line"> * @param - dev : platform设备</span><br><span class="line"> * @return : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_probe(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">…………</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: platform驱动的remove函数，移除platform驱动的时候此函数会执行</span><br><span class="line"> * @param - dev : platform设备</span><br><span class="line"> * @return : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">iounmap(IMX6U_CCM_CCGR1);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">…………</span><br><span class="line"></span><br><span class="line">cdev_del(&amp;leddev.cdev);&#x2F;*  删除cdev *&#x2F;</span><br><span class="line">unregister_chrdev_region(leddev.devid, LEDDEV_CNT); &#x2F;* 注销设备号 *&#x2F;</span><br><span class="line">device_destroy(leddev.class, leddev.devid);</span><br><span class="line">class_destroy(leddev.class);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* platform驱动结构体 *&#x2F;</span><br><span class="line">static struct platform_driver led_driver &#x3D; &#123;</span><br><span class="line">.driver&#x3D; &#123;</span><br><span class="line">.name&#x3D; &quot;imx6ul-led&quot;,&#x2F;* 驱动名字，用于和设备匹配 *&#x2F;</span><br><span class="line">&#125;,</span><br><span class="line">.probe&#x3D; led_probe,</span><br><span class="line">.remove&#x3D; led_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动模块加载函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init leddriver_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return platform_driver_register(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动模块卸载函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __exit leddriver_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(leddriver_init);</span><br><span class="line">module_exit(leddriver_exit);</span><br></pre></td></tr></table></figure><p>probe 函数，当设备和驱动匹配以后此函数就会执行，当匹配成功以后会在终端上输出“led driver and device has matched!”这样语句。在 probe 函数里面初始化 LED、注册字符设备驱动。也就是将原来在驱动加载函数里面做的工作全部放到 probe 函数里面完成。 </p><p>remobe 函数，当卸载 platform 驱动的时候此函数就会执行。在此函数里面 释放内存、注销字符设备等。也就是将原来驱动卸载函数里面的工作全部都放到 remove 函数中完成。 </p><p>platform_driver 驱动结构体，注意 name 字段为”imx6ul-led”，和leddevice.c 文件里面设置的设备 name 字段一致</p><p>驱动模块加载函数，在此函数里面通过 platform_driver_register 向 Linux 内核注册 led_driver 驱动。 </p><p>驱动模块卸载函数，在此函数里面通过 platform_driver_unregister 从 Linux 内核卸载 led_driver 驱动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: leddevice.c</span><br><span class="line">描述   : platform设备</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* </span><br><span class="line"> * 寄存器地址定义</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CCM_CCGR1_BASE(0X020C406C)</span><br><span class="line">#define SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span><br><span class="line">#define SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span><br><span class="line">#define GPIO1_DR_BASE(0X0209C000)</span><br><span class="line">#define GPIO1_GDIR_BASE(0X0209C004)</span><br><span class="line">#define REGISTER_LENGTH4</span><br><span class="line"></span><br><span class="line">&#x2F;* @description: 释放flatform设备模块的时候此函数会执行</span><br><span class="line"> * @param - dev : 要释放的设备 </span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static voidled_release(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;led device released!\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*  </span><br><span class="line"> * 设备资源信息，也就是LED0所使用的所有寄存器</span><br><span class="line"> *&#x2F;</span><br><span class="line">static struct resource led_resources[] &#x3D; &#123;</span><br><span class="line">[0] &#x3D; &#123;</span><br><span class="line">.start &#x3D; CCM_CCGR1_BASE,</span><br><span class="line">.end &#x3D; (CCM_CCGR1_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">.flags &#x3D; IORESOURCE_MEM,</span><br><span class="line">&#125;,</span><br><span class="line">[1] &#x3D; &#123;</span><br><span class="line">.start&#x3D; SW_MUX_GPIO1_IO03_BASE,</span><br><span class="line">.end&#x3D; (SW_MUX_GPIO1_IO03_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">.flags&#x3D; IORESOURCE_MEM,</span><br><span class="line">&#125;,</span><br><span class="line">[2] &#x3D; &#123;</span><br><span class="line">.start&#x3D; SW_PAD_GPIO1_IO03_BASE,</span><br><span class="line">.end&#x3D; (SW_PAD_GPIO1_IO03_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">.flags&#x3D; IORESOURCE_MEM,</span><br><span class="line">&#125;,</span><br><span class="line">[3] &#x3D; &#123;</span><br><span class="line">.start&#x3D; GPIO1_DR_BASE,</span><br><span class="line">.end&#x3D; (GPIO1_DR_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">.flags&#x3D; IORESOURCE_MEM,</span><br><span class="line">&#125;,</span><br><span class="line">[4] &#x3D; &#123;</span><br><span class="line">.start&#x3D; GPIO1_GDIR_BASE,</span><br><span class="line">.end&#x3D; (GPIO1_GDIR_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">.flags&#x3D; IORESOURCE_MEM,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * platform设备结构体 </span><br><span class="line"> *&#x2F;</span><br><span class="line">static struct platform_device leddevice &#x3D; &#123;</span><br><span class="line">.name &#x3D; &quot;imx6ul-led&quot;,</span><br><span class="line">.id &#x3D; -1,</span><br><span class="line">.dev &#x3D; &#123;</span><br><span class="line">.release &#x3D; &amp;led_release,</span><br><span class="line">&#125;,</span><br><span class="line">.num_resources &#x3D; ARRAY_SIZE(led_resources),</span><br><span class="line">.resource &#x3D; led_resources,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 设备模块加载 </span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init leddevice_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return platform_device_register(&amp;leddevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 设备模块注销</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __exit leddevice_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_device_unregister(&amp;leddevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(leddevice_init);</span><br><span class="line">module_exit(leddevice_exit);</span><br></pre></td></tr></table></figure><p>led_resources 数组，也就是设备资源，描述了 LED 所要使用到的寄存器信息，也就是 IORESOURCE_MEM 资源。 </p><p>platform 设备结构体变量 leddevice，这里要注意 name 字段为“imx6ul-led”， platform 驱动中的 name 字段也要为“imx6ul-led”，否则设备和驱动匹配失败。 </p><p>设备模块加载函数，在此函数里面通过 platform_device_register 向 Linux 内核注册 leddevice 这个 platform 设备。 </p><p>设备模块卸载函数，在此函数里面通过 platform_device_unregister 从 Linux内核中删除掉 leddevice 这个 platform 设备。 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用platform 驱动框架来编写一个 LED 灯驱动，不使用设备树来描述设备信息，我们采用自定义platform_device这种“古老”方式来编写LED的设备信息。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-platform设备驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-16T08:28:54.000Z</published>
    <updated>2021-05-05T04:44:57.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-驱动的分离与分层"><a href="#Linux-驱动的分离与分层" class="headerlink" title="Linux 驱动的分离与分层"></a><strong>Linux</strong> <strong>驱动的分离与分层</strong></h1><h2 id="驱动的分隔与分离"><a href="#驱动的分隔与分离" class="headerlink" title="驱动的分隔与分离"></a><strong>驱动的分隔与分离</strong></h2> <a id="more"></a> <p>对于 Linux 这样一个成熟、庞大、复杂的操作系统，代码的重用性非常重要，否则的话就会在 Linux 内核中存在大量无意义的重复代码。尤其是驱动程序，因为驱动程序占用了 Linux内核代码量的大头，如果不对驱动程序加以管理，任由重复的代码肆意增加，那么用不了多久Linux 内核的文件数量就庞大到无法接受的地步。 </p><p><strong>驱动的分隔，也就是将主机驱动和设备驱动分隔开来</strong>，比如 I2C、SPI 等等都会采用驱动分隔的方式来简化驱动的开发。在实际的驱动开发中，一般 I2C 主机控制器驱动已经由半导体厂家编写好了，而设备驱动一般也由设备器件的厂家编写好了，我们只需要提供设备信息即可，比如 I2C 设备的话提供设备连接到了哪个 I2C 接口上，I2C 的速度是多少等等。相当于将设备信息从设备驱动中剥离开来，驱动使用标准方法去获取到设备信息(比如从设备树中获取到设备信息)，然后根据获取到的设备信息来初始化设备。 这样就相当于<strong>驱动只负责驱动，设备只负责设备，</strong>想办法将两者进行匹配即可。这个就是 <strong>Linux 中的总线(bus)、驱动(driver)和设备(device)模型，</strong>也就是常说的<strong>驱动分离</strong>。总线就是驱动和设备信息的月老，负责给两者牵线搭桥。</p><p>当我们向系统注册一个驱动的时候，总线就会在右侧的设备中查找，看看有没有与之匹配的设备，如果有的话就将两者联系起来。同样的，当向系统中注册一个设备的时候，总线就会在左侧的驱动中查找看有没有与之匹配的设备，有的话也联系起来。Linux 内核中大量的驱动程序都采用总线、驱动和设备模式，platform 驱动就是这一思想下的产物</p><h2 id="驱动的分层"><a href="#驱动的分层" class="headerlink" title="驱动的分层"></a><strong>驱动的分层</strong></h2><p>Linux 下的驱动往往也是分层的，分层的目的也是为了在不同的层处理不同的内容。以其他书籍或者资料常常使用到的input(输入子系统)为例，简单介绍一下驱动的分层。input 子系统负责管理所有跟输入有关的驱动，包括键盘、鼠标、触摸等，最底层的就是设备原始驱动，负责获取输入设备的原始值，获取到的输入事件上报给 input 核心层。input 核心层会处理各种 IO 模型，并且提 供 file_operations 操作集合。我们在编写输入设备驱动的时候只需要处理好输入事件的上报即 可，至于如何处理这些上报的输入事件那是上层去考虑的，我们不用管。可以看出借助分层模型可以极大的简化我们的驱动编写，对于驱动编写来说非常的友好。 </p><h1 id="platform-平台驱动模型"><a href="#platform-平台驱动模型" class="headerlink" title="platform 平台驱动模型"></a>platform 平台驱动模型</h1><p>前面的设备驱动的分离引出了总线(bus)、驱动(driver)和设备(device)模型，比 如 I2C、SPI、USB 等总线。但是在 SOC 中有些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型该怎么办呢？为了解决此问题，Linux 提出了 platform 这个虚拟总线，相应的就有 platform_driver 和 platform_device。</p><h2 id="platform-总线"><a href="#platform-总线" class="headerlink" title="platform 总线"></a><strong>platform</strong> <strong>总线</strong></h2><p>Linux系统内核使用bus_type结构体表示总线，此结构体定义在文件include/linux/device.h， </p><p>bus_type 结构体内容如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> struct bus_type &#123; </span><br><span class="line">    const char *name; &#x2F;* 总线名字 *&#x2F;</span><br><span class="line">    const char *dev_name; </span><br><span class="line">    struct device *dev_root; 5 struct device_attribute *dev_attrs; </span><br><span class="line">    const struct attribute_group **bus_groups; &#x2F;* 总线属性 *&#x2F;</span><br><span class="line">    const struct attribute_group **dev_groups; &#x2F;* 设备属性 *&#x2F;</span><br><span class="line">    const struct attribute_group **drv_groups; &#x2F;* 驱动属性 *&#x2F;</span><br><span class="line">    </span><br><span class="line">    int (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    ………………</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>match 函数，匹配函数，完成设备和驱动之间匹配的，总线就是使用 match 函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备，因此每一条总线都必须实现此函数。两个参数：dev 和 drv，这两个参数分别为 device 和 device_driver 类型，也就是设备和驱动。</p><p>platform 总线 platform_bus_type是 bus_type 的一个具体实例，定义在文件 drivers/base/platform.c，platform 总线定义如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type platform_bus_type &#x3D; &#123; </span><br><span class="line">    .name &#x3D; &quot;platform&quot;,</span><br><span class="line">    .dev_groups &#x3D; platform_dev_groups, </span><br><span class="line">    .match &#x3D; platform_match, &#x2F;&#x2F;匹配函数。</span><br><span class="line">    .uevent &#x3D; platform_uevent, </span><br><span class="line">    .pm &#x3D; &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>驱动和设备的匹配有四种方法，我们依次来看一下：</p><ul><li>第一种匹配方式， OF 类型的匹配，也就是设备树采用的匹配方式，of_driver_match_device 函数定义在文件 include/linux/of_device.h 中。device_driver 结构体(表示设备驱动)中有个名为of_match_table的成员变量，此成员变量保存着驱动的compatible匹配表，设备树中的每个设备节点的 compatible 属性会和 of_match_table 表中的所有成员比较，查看是否有相同的条目，如果有的话就表示设备和此驱动匹配，设备和驱动匹配成功以后probe 函数就会执行。 </li><li>第二种匹配方式，ACPI 匹配方式。 </li><li>第三种匹配方式，id_table 匹配，每个 platform_driver 结构体有一个 id_table成员变量，保存了很多 id 信息。这些 id 信息存放着这个 platformd 驱动所支持的驱动类型。 </li><li>第四种匹配方式，如果第三种匹配方式的 id_table 不存在的话就直接比较驱动和设备的 name 字段，看看是不是相等，如果相等的话就匹配成功。 </li></ul><p>对于支持设备树的 Linux 版本号，一般设备驱动为了兼容性都支持设备树和无设备树两种匹配方式。也就是第一种匹配方式一般都会存在，第三种和第四种只要存在一种就可以，一般用的最多的还是第四种，也就是直接比较驱动和设备的 name 字段，毕竟这种方式最简单了。 </p><h2 id="platform-驱动"><a href="#platform-驱动" class="headerlink" title="platform 驱动"></a><strong>platform 驱动</strong></h2><p>platform_driver 结 构 体 表 示 platform 驱动，此结构体定义在文件include/linux/platform_device.h 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct platform_driver &#123; </span><br><span class="line">    int (*probe)(struct platform_device *);</span><br><span class="line">    int (*remove)(struct platform_device *);</span><br><span class="line">    void (*shutdown)(struct platform_device *);</span><br><span class="line">    int (*suspend)(struct platform_device *, pm_message_t state);</span><br><span class="line">    int (*resume)(struct platform_device *);</span><br><span class="line">    struct device_driver driver; </span><br><span class="line">    const struct platform_device_id *id_table; 9 bool prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>probe 函数</strong>，当驱动与设备匹配成功以后 probe 函数就会执行，非常重要的函数！一般驱动的提供者会编写，如果自己要编写一个全新的驱动，那么 probe 就需要自行实现。 </p><p><strong>driver 成员，</strong>为 device_driver 结构体变量，Linux 内核里面大量使用到了面向对象的思维，device_driver 相当于基类，提供了最基础的驱动框架。plaform_driver 继承了这个基类，然后在此基础上又添加了一些特有的成员变量。device_driver 结构体的成员of_match_table ，就是采用设备树的时候驱动使用的匹配表，同样是数组，每个匹配项都为 of_device_id 结构体类型，此结构体定义在文件 include/linux/mod_devicetable.h 中，内容如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct of_device_id &#123; </span><br><span class="line">    char name[32];</span><br><span class="line">    char type[32];</span><br><span class="line">    char compatible[128];</span><br><span class="line">    const void *data; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>device_driver 结构体的成员compatible 非常重要，因为对于设备树而言，就是通过设备节点的 compatible 属性值和 of_match_table 中每个项目的 compatible 成员变量进行比较，如果有相等的就表示设备和此驱动匹配成功。 </p><p><strong>id_table 表</strong>， platform 总线匹配驱动和设备的时候采用的第三种方法，id_table 是个表(也就是数组)，每个元素的类型为 platform_device_id，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct platform_device_id &#123; </span><br><span class="line">    char name[PLATFORM_NAME_SIZE];</span><br><span class="line">    kernel_ulong_t driver_data; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在编写 platform 驱动的时候，首先定义一个 platform_driver 结构体变量，然后实现结构体中的各个成员变量，重点是实现匹配方法以及 probe 函数。当驱动和设备匹配成功以后 probe函数就会执行，具体的驱动程序在 probe 函数里面编写，比如字符设备驱动等等。当我们定义并初始化好 platform_driver 结构体变量以后，需要在驱动入口函数里面调用platform_driver_register 函数向 Linux 内核注册一个 platform 驱动，还需要在驱动卸载函数中通过 platform_driver_unregister 函数卸载 platform 驱动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int platform_driver_register (struct platform_driver *driver)</span><br><span class="line">&#x2F;&#x2F;driver：要注册的 platform 驱动。</span><br><span class="line">&#x2F;&#x2F;返回值：负数，失败；0，成功。</span><br><span class="line"></span><br><span class="line">void platform_driver_unregister(struct platform_driver *drv)</span><br><span class="line">&#x2F;&#x2F;drv：要卸载的 platform 驱动。</span><br></pre></td></tr></table></figure><p><strong>platform 驱动框架如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 设备结构体 *&#x2F;</span><br><span class="line">struct xxx_dev&#123; </span><br><span class="line">    struct cdev cdev; </span><br><span class="line">    &#x2F;* 设备结构体其他具体内容 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct xxx_dev xxxdev; &#x2F;* 定义个设备结构体变量 *&#x2F;</span><br><span class="line"></span><br><span class="line">static struct file_operations xxx_fops &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* platform 驱动的 probe 函数</span><br><span class="line">* 驱动与设备匹配成功以后此函数就会执行</span><br><span class="line">*&#x2F;</span><br><span class="line">static int xxx_probe(struct platform_device *dev)</span><br><span class="line">&#123; </span><br><span class="line">    ......</span><br><span class="line">    cdev_init(&amp;xxxdev.cdev, &amp;xxx_fops); &#x2F;* 注册字符设备驱动 *&#x2F;</span><br><span class="line">    &#x2F;* 函数具体内容 *&#x2F;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int xxx_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    cdev_del(&amp;xxxdev.cdev);&#x2F;* 删除 cdev *&#x2F;</span><br><span class="line">     &#x2F;* 函数具体内容 *&#x2F;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 匹配列表 *&#x2F;</span><br><span class="line">static const struct of_device_id xxx_of_match[] &#x3D; &#123;</span><br><span class="line">    &#123; .compatible &#x3D; &quot;xxx-gpio&quot; &#125;,</span><br><span class="line">    &#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> &#x2F;* </span><br><span class="line"> * platform 平台驱动结构体</span><br><span class="line">*&#x2F;</span><br><span class="line">static struct platform_driver xxx_driver &#x3D; &#123;</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .name &#x3D; &quot;xxx&quot;,</span><br><span class="line">        .of_match_table &#x3D; xxx_of_match,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe &#x3D; xxx_probe,</span><br><span class="line">    .remove &#x3D; xxx_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> &#x2F;* 驱动模块加载 *&#x2F;</span><br><span class="line">static int __init xxxdriver_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return platform_driver_register(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动模块卸载 *&#x2F;</span><br><span class="line">static void __exit xxxdriver_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体来说，platform 驱动还是传统的字符设备驱动、块设备驱动或网络设备驱动，只是套上了一张“platform”的皮，目的是为了使用总线、驱动和设备这个驱动模型来实现驱动的分离与分层。 </p><h2 id="platform-设备"><a href="#platform-设备" class="headerlink" title="platform 设备"></a>platform 设备</h2><p>platform 驱动已经准备好了，我们还需要 platform 设备，否则的话单单一个驱动也做不了什么。platform_device 这个结构体表示 platform 设备，<strong>如果内核支持设备树的话就不要再使用 platform_device 来描述设备了，</strong>因为改用设备树去描述了。platform_device 结构体定义在文件include/linux/platform_device.h 中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct platform_device &#123;</span><br><span class="line">    const char *name; </span><br><span class="line">    …………</span><br><span class="line">    u32 num_resources; </span><br><span class="line">    struct resource *resource;</span><br><span class="line">    …………</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>name 表示设备名字，要和所使用的 platform 驱动的 name 字段相同，否则的话备就无法匹配到对应的驱动。比如对应的 platform 驱动的 name 字段为“xxx-gpio”，那么此 name字段也要设置为“xxx-gpio”。<br>num_resources 表示资源数量，一般为第 28 行 resource 资源的大小。<br>resource 表示资源，也就是设备信息，比如外设寄存器等。Linux 内核使用 resource结构体表示资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct resource &#123;</span><br><span class="line">    resource_size_t start;</span><br><span class="line">    resource_size_t end;</span><br><span class="line">    const char *name;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    struct resource *parent, *sibling, *child;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>start 和 end 分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址，name 表示资源名字，flags 表示资源类型，可选的资源类型都定义在了文件include/linux/ioport.h 里面。</p><p>在以前不支持设备树的Linux版本中，用户需要编写platform_device变量来描述设备信息，然后使用 platform_device_register 函数将设备信息注册到 Linux 内核中，如果不再使用 platform 的话可以通过 platform_device_unregister 函数注销掉相应的 platform设备，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int platform_device_register(struct platform_device *pdev)</span><br><span class="line">&#x2F;&#x2F;pdev：要注册的 platform 设备。</span><br><span class="line">&#x2F;&#x2F;返回值：负数，失败；0，成功。</span><br><span class="line">void platform_device_unregister(struct platform_device *pdev)</span><br><span class="line">&#x2F;&#x2F;pdev：要注销的 platform 设备。</span><br></pre></td></tr></table></figure><p>platform 设备信息框架如下所示，在不支持设备树的 Linux 版本中使用的，当 Linux 内核支持了设备树以后就不需要用户手动去注册 platform 设备了。因为设备信息都放到了设备树中去描述，Linux 内核启动的时候会从设备树中读取设备信息，然后将其组织成 platform_device 形式，至于设备树到 platform_device 的具体过程就不去详细的追究了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;* 寄存器地址定义*&#x2F;</span><br><span class="line">#define PERIPH1_REGISTER_BASE (0X20000000) &#x2F;* 外设 1 寄存器首地址 *&#x2F; </span><br><span class="line">#define PERIPH2_REGISTER_BASE (0X020E0068) &#x2F;* 外设 2 寄存器首地址 *&#x2F;</span><br><span class="line">#define REGISTER_LENGTH 4</span><br><span class="line"></span><br><span class="line">&#x2F;* 资源 *&#x2F;</span><br><span class="line">static struct resource xxx_resources[] &#x3D; &#123; </span><br><span class="line">    [0] &#x3D; &#123;</span><br><span class="line">    .start &#x3D; PERIPH1_REGISTER_BASE,</span><br><span class="line">        .end &#x3D; (PERIPH1_REGISTER_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">        .flags &#x3D; IORESOURCE_MEM,</span><br><span class="line">    &#125;, </span><br><span class="line">    [1] &#x3D; &#123;</span><br><span class="line">        .start &#x3D; PERIPH2_REGISTER_BASE,</span><br><span class="line">        .end &#x3D; (PERIPH2_REGISTER_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">        .flags &#x3D; IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* platform 设备结构体 *&#x2F;</span><br><span class="line">static struct platform_device xxxdevice &#x3D; &#123;</span><br><span class="line">    .name &#x3D; &quot;xxx-gpio&quot;,</span><br><span class="line">    .id &#x3D; -1,</span><br><span class="line">    .num_resources &#x3D; ARRAY_SIZE(xxx_resources),</span><br><span class="line">    .resource &#x3D; xxx_resources,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备模块加载 *&#x2F;</span><br><span class="line">static int __init xxxdevice_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return platform_device_register(&amp;xxxdevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备模块注销 *&#x2F;</span><br><span class="line">static void __exit xxx_resourcesdevice_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_device_unregister(&amp;xxxdevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组 xxx_resources 表示设备资源，一共有两个资源，分别为设备外设 1 和外设 2 的寄存器信息。因此 flags 都为 IORESOURCE_MEM，表示资源为内存类型的。 </p><p>platform 设备结构体变量，注意 name 字段要和所使用的驱动中的 name 字段一致，否则驱动和设备无法匹配成功。num_resources 表示资源大小，其实就是数组 xxx_resources的元素数量，这里用 ARRAY_SIZE 来测量一个数组的元素个数。 </p><p>设备模块加载函数，在此函数中调用 platform_device_register 向 Linux 内核注 册 platform 设备。 </p><p>设备模块卸载函数，在此函数中调用 platform_device_unregister 从 Linux 内核中卸载 platform 设备。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Linux-驱动的分离与分层&quot;&gt;&lt;a href=&quot;#Linux-驱动的分离与分层&quot; class=&quot;headerlink&quot; title=&quot;Linux 驱动的分离与分层&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux&lt;/strong&gt; &lt;strong&gt;驱动的分离与分层&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;驱动的分隔与分离&quot;&gt;&lt;a href=&quot;#驱动的分隔与分离&quot; class=&quot;headerlink&quot; title=&quot;驱动的分隔与分离&quot;&gt;&lt;/a&gt;&lt;strong&gt;驱动的分隔与分离&lt;/strong&gt;&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-异步通知</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/</id>
    <published>2021-04-16T07:40:56.000Z</published>
    <updated>2021-05-05T04:43:09.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步通知简介"><a href="#异步通知简介" class="headerlink" title="异步通知简介"></a>异步通知简介</h1><p>Linux 应用程序可以通过阻塞或者非阻塞这两种方式来访问驱动设备，通过阻塞方式访问的话应用程序会处于休眠态，等待驱动设备可以使用，非阻塞方式的话会通过 poll 函数来不断的轮询，查看驱动设备文件是否可以使用。这两种方式都需要应用程序主动的去查询设备的使用情况。</p> <a id="more"></a> <p>最好的方式就是驱动程序能主动向应用程序发出通知，报告自己可以访问，然后应用程序在从驱动程序中读取或写入数据，类似中断的机制。Linux 提供了异步通知这个机制来完成此功能。</p><p>信号类似于我们硬件上使用的“中断”，只不过信号是软件层次上的。算是在软件层次上对中断的一种模拟，驱动可以通过主动向应用程序发送信号的方式来报告自己可以访问了，应用程序获取到信号以后就可以从驱动设备中读取或者写入数据了。整个过程就相当于应用程序收到了驱动发送过来了的一个中断，然后应用程序去响应这个中断，在整个处理过程中应用程序并没有去查询驱动设备是否可以访问，一切都是由驱动设备自己告诉给应用程序的。 </p><p>阻塞、非阻塞、异步通知，这三种是针对不同的场合提出来的不同的解决方法，没有优劣之分，根据自己的实际需求选择合适的处理方法即可。</p><p>异步通知的核心就是信号，在 arch/xtensa/include/uapi/asm/signal.h 文件中定义了 Linux 所支持的所有信号，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define SIGKILL 9 &#x2F;* 杀死、终止进程 *&#x2F;</span><br><span class="line">#define SIGSTOP 19 &#x2F;* 停止进程的执行，只是暂停 *&#x2F;</span><br></pre></td></tr></table></figure><p>除了 SIGKILL(9)和 SIGSTOP(19)这两个信号不能被忽略外，其他的信号都可以忽略。这些信号就相当于中断号，不同的中断号代表了不同的中断，不同的中断所做的处理不同，因此，驱动程序可以通过向应用程序发送不同的信号来实现不同的功能。 </p><h2 id="驱动中的信号处理"><a href="#驱动中的信号处理" class="headerlink" title="驱动中的信号处理"></a><strong>驱动中的信号处理</strong></h2><h3 id="1、fasync-struct-结构体"><a href="#1、fasync-struct-结构体" class="headerlink" title="1、fasync_struct 结构体"></a>1、fasync_struct 结构体</h3><p>首先我们需要在驱动程序中定义一个 fasync_struct 结构体指针变量，一般将 fasync_struct 结构体指针变量定义到设备结构体中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct fasync_struct &#123;</span><br><span class="line">     spinlock_t fa_lock;</span><br><span class="line">     int magic;</span><br><span class="line">     int fa_fd;</span><br><span class="line">     struct fasync_struct *fa_next;</span><br><span class="line">     struct file *fa_file;</span><br><span class="line">     struct rcu_head fa_rcu;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、fasync-函数"><a href="#2、fasync-函数" class="headerlink" title="2、fasync 函数"></a>2、fasync 函数</h3><p>如果要使用异步通知，需要在设备驱动中实现 file_operations 操作集中的 fasync 函数，此函数格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*fasync) (int fd, struct file *filp, int on)</span><br></pre></td></tr></table></figure><p>fasync 函数里面一般通过调用 fasync_helper 函数来初始化前面定义的 fasync_struct 结构体指针。在关闭驱动文件的时候需要在 file_operations 操作集中的 release 函数中使用释放fasync_helper函数 释放fasync_struct。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)</span><br><span class="line">&#x2F;&#x2F;前三个参数就是 fasync 函数的那三个参数，第四个参数就是要初始化的 fasync_struct 结构体指针变量。</span><br></pre></td></tr></table></figure><p>当应用程序通过“fcntl(fd, F_SETFL, flags | FASYNC)”改变fasync 标记的时候，驱动程序 file_operations 操作集中的 fasync 函数就会执行。</p><p>驱动程序中的 fasync 函数参考示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct xxx_dev &#123; </span><br><span class="line">    ......</span><br><span class="line">    struct fasync_struct *async_queue; &#x2F;* 异步相关结构体 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int xxx_fasync(int fd, struct file *filp, int on) </span><br><span class="line">&#123; </span><br><span class="line">    struct xxx_dev *dev &#x3D; (xxx_dev)filp-&gt;private_data; </span><br><span class="line"></span><br><span class="line">    if (fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue) &lt; 0)</span><br><span class="line">        return -EIO;</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int xxx_release(struct inode *inode, struct file *filp) </span><br><span class="line">&#123; </span><br><span class="line">return xxx_fasync(-1, filp, 0); &#x2F;* 删除异步通知 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct file_operations xxx_ops &#x3D; &#123;</span><br><span class="line">    ......</span><br><span class="line">    .fasync &#x3D; xxx_fasync,</span><br><span class="line">    .release &#x3D; xxx_release,</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3、kill-fasync-函数"><a href="#3、kill-fasync-函数" class="headerlink" title="3、kill_fasync 函数"></a>3、kill_fasync 函数</h3><p>当设备可以访问的时候，驱动程序需要向应用程序发出信号，相当于产生“中断”。kill_fasync函数负责发送指定的信号，kill_fasync 函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void kill_fasync(struct fasync_struct **fp, int sig, int band)</span><br><span class="line">&#x2F;&#x2F;fp：要操作的 fasync_struct。</span><br><span class="line">&#x2F;&#x2F;sig：要发送的信号。</span><br><span class="line">&#x2F;&#x2F;band：可读时设置为 POLL_IN，可写时设置为 POLL_OUT。</span><br></pre></td></tr></table></figure><h2 id="应用程序对异步通知的处理"><a href="#应用程序对异步通知的处理" class="headerlink" title="应用程序对异步通知的处理"></a><strong>应用程序对异步通知的处理</strong></h2><p>应用程序对异步通知的处理包括以下三步：</p><h3 id="1、注册信号处理函数"><a href="#1、注册信号处理函数" class="headerlink" title="1、注册信号处理函数"></a>1、注册信号处理函数</h3><p>我们使用中断的时候需要设置中断处理函数，同样的，如果要在应用程序中使用信号，那么就必须设置信号所使用的信号处理函数，<strong>在应用程序中使用 signal 函数</strong>来设置指定信号的处理函数，signal 函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sighandler_t signal(int signum, sighandler_t handler)</span><br><span class="line">&#x2F;&#x2F;signum：要设置处理函数的信号。</span><br><span class="line">&#x2F;&#x2F;handler：信号的处理函数。信号处理函数原型：typedef void (*sighandler_t)(int)</span><br><span class="line">&#x2F;&#x2F;返回值：设置成功的话返回信号的前一个处理函数，设置失败的话返回 SIG_ERR。</span><br></pre></td></tr></table></figure><h3 id="2、将本应用程序的进程号告诉给内核"><a href="#2、将本应用程序的进程号告诉给内核" class="headerlink" title="2、将本应用程序的进程号告诉给内核"></a>2、将本应用程序的进程号告诉给内核</h3><p>使用 fcntl(fd, F_SETOWN, getpid())将本应用程序的进程号告诉给内核。 </p><h3 id="3、开启异步通知"><a href="#3、开启异步通知" class="headerlink" title="3、开启异步通知"></a>3、开启异步通知</h3><p>使用如下两行程序开启异步通知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flags &#x3D; fcntl(fd, F_GETFL); &#x2F;* 获取当前的进程状态 *&#x2F;</span><br><span class="line">fcntl(fd, F_SETFL, flags | FASYNC); &#x2F;* 开启当前进程异步通知功能 *&#x2F;</span><br></pre></td></tr></table></figure><p>重点就是通过 fcntl 函数设置进程状态为 FASYNC，经过这一步，驱动程序中的 fasync 函数就会执行。</p><h1 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a>实验程序编写</h1><p>当按键按下以后驱动程序向应用程序发送 SIGIO 信号，应用程序获取到 SIGIO 信号以后 读取并且打印出按键值。</p><h2 id="驱动程序编写"><a href="#驱动程序编写" class="headerlink" title="驱动程序编写"></a><strong>驱动程序编写</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: asyncnoti.c</span><br><span class="line">描述   : 非阻塞IO访问</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* imx6uirq设备结构体 *&#x2F;</span><br><span class="line">struct imx6uirq_dev&#123;</span><br><span class="line">struct fasync_struct *async_queue;&#x2F;* 异步相关结构体 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct imx6uirq_dev imx6uirq;&#x2F;* irq设备 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* @description: 定时器服务函数，用于按键消抖，定时器到了以后</span><br><span class="line"> *  再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><br><span class="line"> * @param - arg: 设备结构变量</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">void timer_function(unsigned long arg)</span><br><span class="line">&#123;           </span><br><span class="line">if(atomic_read(&amp;dev-&gt;releasekey)) &#123;&#x2F;* 一次完整的按键过程 *&#x2F;</span><br><span class="line">if(dev-&gt;async_queue)</span><br><span class="line">kill_fasync(&amp;dev-&gt;async_queue, SIGIO, POLL_IN);&#x2F;* 释放SIGIO信号 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : fasync函数，用于处理异步通知</span><br><span class="line"> * @param - fd: 文件描述符</span><br><span class="line"> * @param - filp    : 要打开的设备文件(文件描述符)</span><br><span class="line"> * @param - on      : 模式</span><br><span class="line"> * @return          : 负数表示函数执行失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int imx6uirq_fasync(int fd, struct file *filp, int on)</span><br><span class="line">&#123;</span><br><span class="line">struct imx6uirq_dev *dev &#x3D; (struct imx6uirq_dev *)filp-&gt;private_data;</span><br><span class="line">return fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : release函数，应用程序调用close关闭驱动文件的时候会执行</span><br><span class="line"> * @param - inode: inode节点</span><br><span class="line"> * @param - filp    : 要打开的设备文件(文件描述符)</span><br><span class="line"> * @return          : 负数表示函数执行失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int imx6uirq_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">return imx6uirq_fasync(-1, filp, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备操作函数 *&#x2F;</span><br><span class="line">static struct file_operations imx6uirq_fops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; imx6uirq_open,</span><br><span class="line">.read &#x3D; imx6uirq_read,</span><br><span class="line">.fasync &#x3D; imx6uirq_fasync,</span><br><span class="line">.release &#x3D; imx6uirq_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在设备结构体 imx6uirq_dev 中添加 fasync_struct 指针变量。<br>如果是一次完整的按键过程，那么就通过 kill_fasync 函数发送 SIGIO 信号。<br>imx6uirq_fasync 函数，为 file_operations 操作集中的 fasync 函数，此函数内容很简单，就是调用一下 fasync_helper。 </p><p>release 函数，应用程序调用 close 函数关闭驱动设备文件的时候此函数就会执行，在此函数中释放掉 fasync_struct 指针变量。<br>设置 file_operations 操作集中的 fasync 和 release 这两个成员变量。</p><h2 id="编写测试-APP"><a href="#编写测试-APP" class="headerlink" title="编写测试 APP"></a>编写测试 APP</h2><p>测试 APP 要实现的内容很简单，设置 SIGIO 信号的处理函数为 sigio_signal_func，当驱动 </p><p>程序向应用程序发送 SIGIO 信号以后 sigio_signal_func 函数就会执行。sigio_signal_func 函数内 </p><p>容很简单，就是通过 read 函数读取按键值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: asyncnotiApp.c</span><br><span class="line">描述   : 异步通知测试APP</span><br><span class="line">使用方法：.&#x2F;asyncnotiApp &#x2F;dev&#x2F;asyncnoti 打开测试App</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">static int fd &#x3D; 0;&#x2F;* 文件描述符 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * SIGIO信号处理函数</span><br><span class="line"> * @param - signum : 信号值</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void sigio_signal_func(int signum)</span><br><span class="line">&#123;</span><br><span class="line">int err &#x3D; 0;</span><br><span class="line">unsigned int keyvalue &#x3D; 0;</span><br><span class="line"></span><br><span class="line">err &#x3D; read(fd, &amp;keyvalue, sizeof(keyvalue));</span><br><span class="line">if(err &lt; 0) &#123;</span><br><span class="line">&#x2F;* 读取错误 *&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">printf(&quot;sigio signal! key value&#x3D;%d\r\n&quot;, keyvalue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: main主程序</span><br><span class="line"> * @param - argc : argv数组元素个数</span><br><span class="line"> * @param - argv : 具体参数</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">filename &#x3D; argv[1];</span><br><span class="line">fd &#x3D; open(filename, O_RDWR);</span><br><span class="line"></span><br><span class="line">&#x2F;* 设置信号SIGIO的处理函数 *&#x2F;</span><br><span class="line">signal(SIGIO, sigio_signal_func);</span><br><span class="line"></span><br><span class="line">fcntl(fd, F_SETOWN, getpid());&#x2F;* 设置当前进程接收SIGIO信号 *&#x2F;</span><br><span class="line">flags &#x3D; fcntl(fd, F_GETFL);&#x2F;* 获取当前的进程状态 *&#x2F;</span><br><span class="line">fcntl(fd, F_SETFL, flags | FASYNC);&#x2F;* 设置进程启用异步通知功能 *&#x2F;</span><br><span class="line"></span><br><span class="line">while(1) &#123;</span><br><span class="line">sleep(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sigio_signal_func 函数，SIGIO 信号的处理函数，当驱动程序有效按键按下以后就会发送 SIGIO 信号，此函数就会执行。此函数通过 read 函数读取按键值，然后通过printf 函数打印在终端上。 </p><p>通过 signal 函数设置 SIGIO 信号的处理函数为 sigio_signal_func。 </p><p>设置当前进程的状态，开启异步通知的功能。 </p><p>while 循环，等待信号产生。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;异步通知简介&quot;&gt;&lt;a href=&quot;#异步通知简介&quot; class=&quot;headerlink&quot; title=&quot;异步通知简介&quot;&gt;&lt;/a&gt;异步通知简介&lt;/h1&gt;&lt;p&gt;Linux 应用程序可以通过阻塞或者非阻塞这两种方式来访问驱动设备，通过阻塞方式访问的话应用程序会处于休眠态，等待驱动设备可以使用，非阻塞方式的话会通过 poll 函数来不断的轮询，查看驱动设备文件是否可以使用。这两种方式都需要应用程序主动的去查询设备的使用情况。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-非阻塞IO</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9EIO/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9EIO/</id>
    <published>2021-04-16T06:31:11.000Z</published>
    <updated>2021-05-05T04:43:31.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h1><p>对于非阻塞 IO，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。当使用非阻塞IO时，应用程序使用非阻塞访问方式从设备读取数据，当设备不可用或数据未准备好的时候会立即向内核返回一个错误码，表示数据读取失败。应用程序会再次重新读取数据，这样一直往复循环，直到数据读取成功。</p> <a id="more"></a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用程序非阻塞读取数据</span><br><span class="line">int fd; </span><br><span class="line">int data &#x3D; 0; </span><br><span class="line">fd &#x3D; open(&quot;&#x2F;dev&#x2F;xxx_dev&quot;, O_RDWR | O_NONBLOCK); &#x2F;* 非阻塞方式打开 *&#x2F;</span><br><span class="line">ret &#x3D; read(fd, &amp;data, sizeof(data)); &#x2F;* 读取数据 *&#x2F;</span><br></pre></td></tr></table></figure><p>第 4 行使用 open 函数打开“/dev/xxx_dev”设备文件的时候添加了参数“O_NONBLOCK”，表示以非阻塞方式打开设备，这样从设备中读取数据的时候就是非阻塞方式的了。</p><h2 id="非阻塞机制-轮询"><a href="#非阻塞机制-轮询" class="headerlink" title="非阻塞机制(轮询)"></a><strong>非阻塞机制(轮询)</strong></h2><p>如果用户应用程序以非阻塞的方式访问设备，设备驱动程序就要提供非阻塞的处理方式，也就是轮询。poll、epoll 和 select 可以用于处理轮询，应用程序通过 select、epoll 或 poll 函数来查询设备是否可以操作，如果可以操作的话就从设备读取或者向设备写入数据。当<strong>应用程序调用 select、epoll 或 poll 函数</strong>的时候<strong>设备驱动程序中的 poll 函数</strong>就会执行，因此需要在设备驱动程序中编写 poll 函数。</p><h3 id="1、Linux-驱动下的-poll-操作函数"><a href="#1、Linux-驱动下的-poll-操作函数" class="headerlink" title="1、Linux 驱动下的 poll 操作函数"></a><strong>1、Linux</strong> <strong>驱动下的</strong> <strong>poll</strong> <strong>操作函数</strong></h3><p>当应用程序调用 select 或 poll 函数来对驱动程序进行非阻塞访问的时候，驱动程序file_operations 操作集中的 poll 函数就会执行。所以驱动程序的编写者需要提供对应的 poll 函数，poll 函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unsigned int (*poll) (struct file *filp, struct poll_table_struct *wait)</span><br><span class="line">&#x2F;&#x2F;filp：要打开的设备文件(文件描述符)。</span><br><span class="line">&#x2F;&#x2F;wait：结构体 poll_table_struct 类型指针，由应用程序传递进来的。一般将此参数传递给</span><br><span class="line">&#x2F;&#x2F;poll_wait 函数。</span><br><span class="line">&#x2F;&#x2F;返回值:向应用程序返回设备或者资源状态，可以返回的资源状态如下：</span><br><span class="line">    POLLIN 有数据可以读取。</span><br><span class="line">    POLLPRI 有紧急的数据需要读取。</span><br><span class="line">    POLLOUT 可以写数据。</span><br><span class="line">    POLLERR 指定的文件描述符发生错误。</span><br><span class="line">    POLLHUP 指定的文件描述符挂起。</span><br><span class="line">    POLLNVAL 无效的请求。</span><br><span class="line">    POLLRDNORM 等同于 POLLIN，普通数据可读</span><br></pre></td></tr></table></figure><p>需要在驱动程序的 poll 函数中调用 poll_wait 函数，poll_wait 函数不会引起阻塞，只是将应用程序添加到 poll_table 中，poll_wait 函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)</span><br><span class="line">&#x2F;&#x2F;wait_address 是要添加到 poll_table 中的等待队列头，</span><br><span class="line">&#x2F;&#x2F;p 就是 poll_table，就是file_operations 中 poll 函数的 wait 参数。</span><br></pre></td></tr></table></figure><h3 id="应用程序调用-select、epoll-或-poll-函数"><a href="#应用程序调用-select、epoll-或-poll-函数" class="headerlink" title="应用程序调用 select、epoll 或 poll 函数"></a><strong>应用程序调用 select、epoll 或 poll 函数</strong></h3><h4 id="1、select-函数"><a href="#1、select-函数" class="headerlink" title="1、select 函数"></a>1、select 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">fd_set *exceptfds, struct timeval *timeout)</span><br><span class="line">&#x2F;&#x2F;nfds：所要监视的这三类文件描述集合中，最大文件描述符加 1。</span><br><span class="line">&#x2F;&#x2F;readfds、writefds 和 exceptfds：这三个指针指向描述符集合，这三个参数指明了关心哪些描述符、需要满足哪些条件等等，</span><br><span class="line">&#x2F;&#x2F;timeout:超时时间，当 timeout 为 NULL 的时候就表示无限期的等待。</span><br><span class="line">&#x2F;&#x2F;返回值：0，表示的话就表示超时发生，但是没有任何文件描述符可以进行操作；-1，发生</span><br><span class="line">&#x2F;&#x2F;错误；其他值，可以进行操作的文件描述符个数。</span><br></pre></td></tr></table></figure><p>readfds、writefds 和 exceptfds：这三个指针指向描述符集合，这三个参数指明了关心哪些描述符、需要满足哪些条件等等，这三个参数都是 fd_set 类型的，fd_set 类型变量的每一个位都代表了一个文件描述符。readfds 用于监视指定描述符集的读变化，也就是监视这些文件是否可以读取，只要这些集合里面有一个文件可以读取那么 seclect 就会返回一个大于 0 的值表示文件可以读取。如果没有文件可以读取，那么就会根据 timeout 参数来判断是否超时。可以将 readfs设置为 NULL，表示不关心任何文件的读变化。 writefs 用于监视这些文件是否可以进行写操作。exceptfds 用于监视这些文件的异常。</p><p>比如我们现在要从一个设备文件中读取数据，那么就可以定义一个 fd_set 变量，这个变量要传递给参数 readfds。当我们定义好一个 fd_set 变量以后可以使用如下所示几个宏进行操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void FD_ZERO(fd_set *set)</span><br><span class="line">void FD_SET(int fd, fd_set *set)</span><br><span class="line">void FD_CLR(int fd, fd_set *set)</span><br><span class="line">int FD_ISSET(int fd, fd_set *set)</span><br></pre></td></tr></table></figure><p>FD_ZERO 用于将 fd_set 变量的所有位都清零，FD_SET 用于将 fd_set 变量的某个位置 1，也就是向 fd_set 添加一个文件描述符 fd 。FD_CLR 用户将 fd_set变量的某个位清零，也就是将一个文件描述符 fd 从 fd_set 中删除FD_ISSET 用于测试一个文件描述符 fd是否属于某个集合。 </p><p>timeout:超时时间，当我们调用 select 函数等待某些文件描述符可以设置超时时间，超时时间使用结构体 timeval 表示，结构体定义如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct timeval &#123;</span><br><span class="line">    long tv_sec; &#x2F;* 秒 *&#x2F;</span><br><span class="line">    long tv_usec; &#x2F;* 微妙 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 select 函数对某个设备驱动文件进行读非阻塞访问的操作示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void main(void) </span><br><span class="line">&#123; </span><br><span class="line">    int ret, fd; &#x2F;* 要监视的文件描述符 *&#x2F;</span><br><span class="line">    fd_set readfds; &#x2F;* 读操作文件描述符集 *&#x2F;</span><br><span class="line">    struct timeval timeout; &#x2F;* 超时结构体 *&#x2F;</span><br><span class="line"></span><br><span class="line">    fd &#x3D; open(&quot;dev_xxx&quot;, O_RDWR | O_NONBLOCK); &#x2F;* 非阻塞式访问 *&#x2F;</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;readfds); &#x2F;* 清除 readfds *&#x2F;</span><br><span class="line">    FD_SET(fd, &amp;readfds); &#x2F;* 将 fd 添加到 readfds 里面 *&#x2F;</span><br><span class="line"></span><br><span class="line">     &#x2F;* 构造超时时间 *&#x2F;</span><br><span class="line">    timeout.tv_sec &#x3D; 0;</span><br><span class="line">    timeout.tv_usec &#x3D; 500000; &#x2F;* 500ms *&#x2F;</span><br><span class="line"></span><br><span class="line">    ret &#x3D; select(fd + 1, &amp;readfds, NULL, NULL, &amp;timeout);</span><br><span class="line">    switch (ret) &#123;</span><br><span class="line">        case 0: &#x2F;* 超时 *&#x2F;</span><br><span class="line">            printf(&quot;timeout!\r\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case -1: &#x2F;* 错误 *&#x2F;</span><br><span class="line">            printf(&quot;error!\r\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default: &#x2F;* 可以读取数据 *&#x2F;</span><br><span class="line">            if(FD_ISSET(fd, &amp;readfds)) &#123; &#x2F;* 判断是否为 fd 文件描述符 *&#x2F;</span><br><span class="line">            &#x2F;* 使用 read 函数读取数据 *&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、poll-函数"><a href="#2、poll-函数" class="headerlink" title="2、poll 函数"></a>2、poll 函数</h4><p>在单个线程中，select 函数能够监视的文件描述符数量有最大的限制，一般为 1024，可以修改内核将监视的文件描述符数量改大，但是这样会降低效率！这个时候就可以使用 poll 函数，poll 函数本质上和 select 没有太大的差别，但是 poll 函数没有最大文件描述符限制，Linux 应用程序中 poll 函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout)</span><br><span class="line">&#x2F;&#x2F;fds：要监视的文件描述符集合以及要监视的事件,为一个数组，数组元素都是结构体 pollfd类型的，</span><br><span class="line">&#x2F;&#x2F;nfds：poll 函数要监视的文件描述符数量。</span><br><span class="line">&#x2F;&#x2F;timeout：超时时间，单位为 ms。</span><br><span class="line">&#x2F;&#x2F;返回值：返回 revents 域中不为 0 的 pollfd 结构体个数，也就是发生事件或错误的文件描述符数量；0，超时；-1，发生错误，并且设置 errno 为错误类型。</span><br></pre></td></tr></table></figure><p>fds：要监视的文件描述符集合以及要监视的事件,为一个数组，数组元素都是结构体 pollfd类型的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd; &#x2F;* 文件描述符 *&#x2F;</span><br><span class="line">    short events; &#x2F;* 请求的事件 *&#x2F;</span><br><span class="line">     short revents; &#x2F;* 返回的事件 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;fd 是要监视的文件描述符，如果 fd 无效的话那么 events 监视事件也就无效，并且 revents返回 0。events 是要监视的事件，可监视的事件类型如下所示：</span><br><span class="line">    POLLIN 有数据可以读取。</span><br><span class="line">    POLLPRI 有紧急的数据需要读取。</span><br><span class="line">    POLLOUT 可以写数据。</span><br><span class="line">    POLLERR 指定的文件描述符发生错误。</span><br><span class="line">    POLLHUP 指定的文件描述符挂起。</span><br><span class="line">    POLLNVAL 无效的请求。</span><br><span class="line">    POLLRDNORM 等同于 POLLIN</span><br><span class="line">&#x2F;&#x2F;revents 是返回参数，也就是返回的事件，由 Linux 内核设置具体的返回事件。</span><br></pre></td></tr></table></figure><p>使用 poll 函数对某个设备驱动文件进行读非阻塞访问的操作示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void main(void)  </span><br><span class="line">&#123; </span><br><span class="line">int ret; </span><br><span class="line">    int fd; &#x2F;* 要监视的文件描述符 *&#x2F;</span><br><span class="line">    struct pollfd fds; </span><br><span class="line"></span><br><span class="line">    fd &#x3D; open(filename, O_RDWR | O_NONBLOCK); &#x2F;* 非阻塞式访问 *&#x2F;</span><br><span class="line"></span><br><span class="line">     &#x2F;* 构造结构体 *&#x2F;</span><br><span class="line">    fds.fd &#x3D; fd;</span><br><span class="line">    fds.events &#x3D; POLLIN; &#x2F;* 监视数据是否可以读取 *&#x2F;</span><br><span class="line"></span><br><span class="line">    ret &#x3D; poll(&amp;fds, 1, 500); &#x2F;* 轮询文件是否可操作，超时 500ms *&#x2F;</span><br><span class="line">    if (ret) &#123; &#x2F;* 数据有效 *&#x2F;</span><br><span class="line">        ......</span><br><span class="line">        &#x2F;* 读取数据 *&#x2F;</span><br><span class="line">        ......</span><br><span class="line">    &#125; else if (ret &#x3D;&#x3D; 0) &#123; &#x2F;* 超时 *&#x2F;</span><br><span class="line">    ......</span><br><span class="line">    &#125; else if (ret &lt; 0) &#123; &#x2F;* 错误 *&#x2F;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、epoll-函数"><a href="#3、epoll-函数" class="headerlink" title="3、epoll 函数"></a>3、epoll 函数</h4><p>传统的 selcet 和 poll 函数都会随着所监听的 fd 数量的增加，出现效率低下的问题，而且poll 函数每次必须遍历所有的描述符来检查就绪的描述符，这个过程很浪费时间。为此，epoll应运而生，epoll 就是为处理大并发而准备的，一般常常在网络编程中使用 epoll 函数。应用程序需要先使用 epoll_create 函数创建一个 epoll 句柄，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)</span><br><span class="line">&#x2F;&#x2F;size：从 Linux2.6.8 开始此参数已经没有意义了，随便填写一个大于 0 的值就可以。</span><br><span class="line">&#x2F;&#x2F;返回值：epoll 句柄，如果为-1 的话表示创建失败。</span><br></pre></td></tr></table></figure><p>epoll 句柄创建成功以后使用 epoll_ctl 函数向其中添加要监视的文件描述符以及监视的事件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd,struct epoll_event *event)</span><br><span class="line">epfd：要操作的 epoll 句柄，也就是使用 epoll_create 函数创建的 epoll 句柄。</span><br><span class="line">op：表示要对 epfd(epoll 句柄)进行的操作，可以设置为：</span><br><span class="line">        EPOLL_CTL_ADD 向 epfd 添加文件参数 fd 表示的描述符。</span><br><span class="line">        EPOLL_CTL_MOD 修改参数 fd 的 event 事件。</span><br><span class="line">        EPOLL_CTL_DEL 从 epfd 中删除 fd 描述符。</span><br><span class="line">fd：要监视的文件描述符。</span><br><span class="line">event：要监视的事件类型，为 epoll_event 结构体类型指针，</span><br><span class="line">返回值：0，成功；-1，失败，并且设置 errno 的值为相应的错误码。</span><br></pre></td></tr></table></figure><p>event：要监视的事件类型，为 epoll_event 结构体类型指针，epoll_event 结构体类型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event &#123;</span><br><span class="line">    uint32_t events; &#x2F;* epoll 事件 *&#x2F;</span><br><span class="line">    epoll_data_t data; &#x2F;* 用户数据 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;events 成员变量表示要监视的事件，可选的事件如下所示，这些事件可以进行“或”操作，即可以设置监视多个事件。</span><br><span class="line">EPOLLIN 有数据可以读取。</span><br><span class="line">EPOLLOUT 可以写数据。</span><br><span class="line">EPOLLPRI 有紧急的数据需要读取。</span><br><span class="line">EPOLLERR 指定的文件描述符发生错误。</span><br><span class="line">EPOLLHUP 指定的文件描述符挂起。</span><br><span class="line">EPOLLET 设置 epoll 为边沿触发，默认触发模式为水平触发。</span><br><span class="line">EPOLLONESHOT 一次性的监视，当监视完成以后还需要再次监视某个fd，那么就需要将fd 重新添加到 epoll 里面。</span><br></pre></td></tr></table></figure><p>一切都设置好以后应用程序就可以通过 epoll_wait 函数来等待事件的发生，类似 select 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout)</span><br><span class="line">&#x2F;&#x2F;epfd：要等待的 epoll。</span><br><span class="line">&#x2F;&#x2F;events：指向 epoll_event 结构体的数组，当有事件发生的时候 Linux 内核会填写 events，调</span><br><span class="line">用者可以根据 events 判断发生了哪些事件。</span><br><span class="line">&#x2F;&#x2F;maxevents：events 数组大小，必须大于 0。</span><br><span class="line">&#x2F;&#x2F;timeout：超时时间，单位为 ms。</span><br><span class="line">&#x2F;&#x2F;返回值：0，超时；-1，错误；其他值，准备就绪的文件描述符数量。</span><br></pre></td></tr></table></figure><p>epoll 更多的是用在大规模的并发服务器上，因为在这种场合下 select 和 poll 并不适合。当设计到的文件描述符(fd)比较少的时候就适合用 selcet 和 poll，本章我们就使用 sellect 和 poll 这两个函数。</p><h2 id="非阻塞-IO-实验"><a href="#非阻塞-IO-实验" class="headerlink" title="非阻塞 IO 实验"></a>非阻塞 IO 实验</h2><p>Linux 中断中，我们直接在应用程序中通过 read 函数不断的读取按键状态，当按键有效的时候就打印出按键值。这种方法有个缺点，那就是 imx6uirqApp 这个测试应用程序拥有很高的 CPU 占用率，原因就在于我们是直接在 while 循环中通过 read 函数读取按键值，因此 imx6uirqApp 这个软件会一直运行，一直读取 按键值，CPU 使用率肯定就会很高。最好的方法就是在没有有效的按键事件发生的时候，imx6uirqApp 这个应用程序应该处于休眠状态，当有按键事件发生以后 imx6uirqApp 这个应用程序才运行，打印出按键值，这样就会降低 CPU 使用率。</p><h3 id="1、驱动程序编写"><a href="#1、驱动程序编写" class="headerlink" title="1、驱动程序编写"></a>1、驱动程序编写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: noblock.c</span><br><span class="line">描述   : 非阻塞IO访问</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* imx6uirq设备结构体 *&#x2F;</span><br><span class="line">struct imx6uirq_dev&#123;</span><br><span class="line">wait_queue_head_t r_wait;&#x2F;* 读等待队列头 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct imx6uirq_dev imx6uirq;&#x2F;* irq设备 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* @description: 定时器服务函数，用于按键消抖，定时器到了以后</span><br><span class="line"> *  再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><br><span class="line"> * @param - arg: 设备结构变量</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">void timer_function(unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 唤醒进程 *&#x2F;</span><br><span class="line">if(atomic_read(&amp;dev-&gt;releasekey)) &#123;&#x2F;* 完成一次按键过程 *&#x2F;</span><br><span class="line">&#x2F;* wake_up(&amp;dev-&gt;r_wait); *&#x2F;</span><br><span class="line">wake_up_interruptible(&amp;dev-&gt;r_wait);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 按键IO初始化</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int keyio_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 初始化等待队列头 *&#x2F;</span><br><span class="line">init_waitqueue_head(&amp;imx6uirq.r_wait);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : 从设备读取数据 </span><br><span class="line">  * @param - filp    : 要打开的设备文件(文件描述符)</span><br><span class="line">  * @param - buf     : 返回给用户空间的数据缓冲区</span><br><span class="line">  * @param - cnt     : 要读取的数据长度</span><br><span class="line">  * @param - offt    : 相对于文件首地址的偏移</span><br><span class="line">  * @return          : 读取的字节数，如果为负值，表示读取失败</span><br><span class="line">  *&#x2F;</span><br><span class="line">static ssize_t imx6uirq_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)</span><br><span class="line">&#123;</span><br><span class="line">if (filp-&gt;f_flags &amp; O_NONBLOCK)&#123; &#x2F;* 非阻塞访问 *&#x2F;</span><br><span class="line">if(atomic_read(&amp;dev-&gt;releasekey) &#x3D;&#x3D; 0)&#x2F;* 没有按键按下，返回-EAGAIN *&#x2F;</span><br><span class="line">return -EAGAIN;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : poll函数，用于处理非阻塞访问</span><br><span class="line">  * @param - filp    : 要打开的设备文件(文件描述符)</span><br><span class="line">  * @param - wait    : 等待列表(poll_table)</span><br><span class="line">  * @return          : 设备或者资源状态，</span><br><span class="line">  *&#x2F;</span><br><span class="line">unsigned int imx6uirq_poll(struct file *filp, struct poll_table_struct *wait)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">poll_wait(filp, &amp;dev-&gt;r_wait, wait);&#x2F;* 将等待队列头添加到poll_table中 *&#x2F;</span><br><span class="line"></span><br><span class="line">if(atomic_read(&amp;dev-&gt;releasekey)) &#123;&#x2F;* 按键按下 *&#x2F;</span><br><span class="line">mask &#x3D; POLLIN | POLLRDNORM;&#x2F;* 返回PLLIN *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">return mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备操作函数 *&#x2F;</span><br><span class="line">static struct file_operations imx6uirq_fops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; imx6uirq_open,</span><br><span class="line">.read &#x3D; imx6uirq_read,</span><br><span class="line">.poll &#x3D; imx6uirq_poll,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>判断是否为非阻塞式读取访问，如果是的话就判断按键是否有效，也就是判断一下有没有按键按下，如果没有的话就返回-EAGAIN。</p><p>mx6uirq_poll 函数就是 file_operations 驱动操作集中的 poll 函数，当应用 程序调用 select 或者 poll 函数的时候 imx6uirq_poll 函数就会执行。调用 poll_wait 函数 将等待队列头添加到 poll_table 中，判断按键是否有效，如果按键有效的话就向应用程序返回 POLLIN 这个事件，表示有数据可以读取。 </p><p>设置 file_operations 的 poll 成员变量为 imx6uirq_poll</p><h3 id="编写测试-APP"><a href="#编写测试-APP" class="headerlink" title="编写测试 APP"></a><strong>编写测试</strong> <strong>APP</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: noblockApp.c</span><br><span class="line">描述   : 非阻塞访问测试APP</span><br><span class="line">使用方法：.&#x2F;blockApp &#x2F;dev&#x2F;blockio 打开测试App</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: main主程序</span><br><span class="line"> * @param - argc : argv数组元素个数</span><br><span class="line"> * @param - argv : 具体参数</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">filename &#x3D; argv[1];</span><br><span class="line">fd &#x3D; open(filename, O_RDWR | O_NONBLOCK);&#x2F;* 非阻塞访问 *&#x2F;</span><br><span class="line">#if 0</span><br><span class="line">&#x2F;* 构造结构体 *&#x2F;</span><br><span class="line">fds.fd &#x3D; fd;</span><br><span class="line">fds.events &#x3D; POLLIN;</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">ret &#x3D; poll(&amp;fds, 1, 500);</span><br><span class="line">if (ret) &#123;&#x2F;* 数据有效 *&#x2F;</span><br><span class="line">ret &#x3D; read(fd, &amp;data, sizeof(data));</span><br><span class="line">if(ret &lt; 0) &#123;</span><br><span class="line">&#x2F;* 读取错误 *&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if(data)</span><br><span class="line">printf(&quot;key value &#x3D; %d \r\n&quot;, data);</span><br><span class="line">&#125; </span><br><span class="line">&#125; else if (ret &#x3D;&#x3D; 0) &#123; &#x2F;* 超时 *&#x2F;</span><br><span class="line">&#x2F;* 用户自定义超时处理 *&#x2F;</span><br><span class="line">&#125; else if (ret &lt; 0) &#123;&#x2F;* 错误 *&#x2F;</span><br><span class="line">&#x2F;* 用户自定义错误处理 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">FD_ZERO(&amp;readfds);</span><br><span class="line">FD_SET(fd, &amp;readfds);</span><br><span class="line">&#x2F;* 构造超时时间 *&#x2F;</span><br><span class="line">timeout.tv_sec &#x3D; 0;</span><br><span class="line">timeout.tv_usec &#x3D; 500000; &#x2F;* 500ms *&#x2F;</span><br><span class="line">ret &#x3D; select(fd + 1, &amp;readfds, NULL, NULL, &amp;timeout);</span><br><span class="line">switch (ret) &#123;</span><br><span class="line">case 0: &#x2F;* 超时 *&#x2F;</span><br><span class="line">&#x2F;* 用户自定义超时处理 *&#x2F;</span><br><span class="line">break;</span><br><span class="line">case -1:&#x2F;* 错误 *&#x2F;</span><br><span class="line">&#x2F;* 用户自定义错误处理 *&#x2F;</span><br><span class="line">break;</span><br><span class="line">default:  &#x2F;* 可以读取数据 *&#x2F;</span><br><span class="line">if(FD_ISSET(fd, &amp;readfds)) &#123;</span><br><span class="line">ret &#x3D; read(fd, &amp;data, sizeof(data));</span><br><span class="line">if (ret &lt; 0) &#123;</span><br><span class="line">&#x2F;* 读取错误 *&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if (data)</span><br><span class="line">printf(&quot;key value&#x3D;%d\r\n&quot;, data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别使用 poll 函数、select 函数来实现非阻塞访问，</p><p>在 while 循环中使用 poll 函数不 断的轮询，检查驱动程序是否有数据可以读取，如果可以读取的话就调用 read 函数读取按键 数据。 </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;非阻塞-IO&quot;&gt;&lt;a href=&quot;#非阻塞-IO&quot; class=&quot;headerlink&quot; title=&quot;非阻塞 IO&quot;&gt;&lt;/a&gt;非阻塞 IO&lt;/h1&gt;&lt;p&gt;对于非阻塞 IO，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。当使用非阻塞IO时，应用程序使用非阻塞访问方式从设备读取数据，当设备不可用或数据未准备好的时候会立即向内核返回一个错误码，表示数据读取失败。应用程序会再次重新读取数据，这样一直往复循环，直到数据读取成功。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-阻塞IO</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-%E9%98%BB%E5%A1%9EIO/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-%E9%98%BB%E5%A1%9EIO/</id>
    <published>2021-04-16T06:31:02.000Z</published>
    <updated>2021-05-05T04:43:38.317Z</updated>
    
    <content type="html"><![CDATA[<p>这里的“IO”单片机的“GPIO”(也就是引脚)。 这里的 IO 指的是 Input/Output，也就是输入/输出，是应用程序对驱动设备的输入/输出操作。</p> <a id="more"></a> <h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a><strong>阻塞IO</strong></h2><p>当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么阻塞式 IO 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。当使用阻塞IO时，应用程序调用 read 函数从设备中读取数据，当设备不可用或数据未准备好的时候就会进入到休眠态。等设备可用的时候就会从休眠态唤醒，然后从设备中读取数据返回给应用程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;应用程序阻塞读取数据</span><br><span class="line">int fd; </span><br><span class="line">int data &#x3D; 0; </span><br><span class="line">fd &#x3D; open(&quot;&#x2F;dev&#x2F;xxx_dev&quot;, O_RDWR); &#x2F;* 阻塞方式打开 *&#x2F;</span><br><span class="line">ret &#x3D; read(fd, &amp;data, sizeof(data)); &#x2F;* 读取数据 *&#x2F;</span><br></pre></td></tr></table></figure><p>可以看出，对于设备驱动文件的默认读取方式就是阻塞式的，所以前面所有的例程测试 APP 都是采用阻塞 IO。 </p><h3 id="阻塞IO机制"><a href="#阻塞IO机制" class="headerlink" title="阻塞IO机制"></a><strong>阻塞IO机制</strong></h3><p><strong>等待队列</strong> </p><p>1、等待队列头IO</p><p>阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU 资源让出来。但是，当设备文件可以操作的时候就必须唤醒进程，一般在中断函数里面完成唤醒工作。Linux 内核提供了等待队列(wait queue)来实现阻塞进程的唤醒工作，如果我们要在驱动中使用等待队列，必须创建并初始化一个等待队列头，等待队列头使用结构体wait_queue_head_t 表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __wait_queue_head &#123;</span><br><span class="line">    spinlock_t lock;</span><br><span class="line">    struct list_head task_list;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct __wait_queue_head wait_queue_head_t;</span><br></pre></td></tr></table></figure><p>定义好等待队列头以后需要初始化，使用 init_waitqueue_head 函数初始化等待队列头，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void init_waitqueue_head(wait_queue_head_t *q)&#x2F;&#x2F;参数 q 就是要初始化的等待队列头。</span><br></pre></td></tr></table></figure><p><strong>2、等待队列项</strong></p><p>等待队列头就是一个等待队列的头部，每个访问设备的进程都是一个队列项，当设备不可用的时候就要将这些进程对应的等待队列项添加到等待队列里面。结构体 wait_queue_t 表示等待队列项，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __wait_queue &#123;</span><br><span class="line">     unsigned int flags;</span><br><span class="line">     void *private;</span><br><span class="line">     wait_queue_func_t func;</span><br><span class="line">     struct list_head task_list;</span><br><span class="line"> &#125;;</span><br><span class="line">typedef struct __wait_queue wait_queue_t;</span><br></pre></td></tr></table></figure><p>使用宏 DECLARE_WAITQUEUE 定义并初始化一个等待队列项，宏的内容如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAITQUEUE(name, tsk) </span><br></pre></td></tr></table></figure><p>name ，等待队列项的名字，tsk 表示这个等待队列项属于哪个任务(进程)，一般设置为current ， 在 Linux 内核中 current 相 当 于一个全 局 变 量 ， 表 示当前 进 程 。 因 此 宏 DECLARE_WAITQUEUE 就是给当前正在运行的进程创建并初始化了一个等待队列项。 </p><p><strong>3、将队列项添加/移除等待队列头</strong></p><p>当设备不可访问的时候就需要将进程对应的等待队列项添加到前面创建的等待队列头中，只有添加到等待队列头中以后进程才能进入休眠态。当设备可以访问以后再将进程对应的等待队列项从等待队列头中移除即可，等待队列项添加、等待队列项移除  API 函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)</span><br><span class="line">void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)</span><br><span class="line">&#x2F;&#x2F;q：要删除的等待队列项所处的等待队列头。wait：要删除的等待队列项。返回值：无</span><br></pre></td></tr></table></figure><p><strong>4、等待唤醒</strong><br>当设备可以使用的时候就要唤醒进入休眠态的进程(<strong>主动唤醒</strong>)，唤醒可以使用如下两个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void wake_up(wait_queue_head_t *q)</span><br><span class="line">void wake_up_interruptible(wait_queue_head_t *q)</span><br></pre></td></tr></table></figure><p>参数 q 就是要唤醒的等待队列头，这两个函数会将这个等待队列头中的所有进程都唤醒。wake_up 函数可以唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 状态的进程，而 wake_up_interruptible 函数只能唤醒处于 TASK_INTERRUPTIBLE 状态的进程。</p><p><strong>5、等待事件</strong><br>除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就<strong>自动唤醒</strong>等待队列中的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wait_event(wq, condition) </span><br><span class="line">&#x2F;&#x2F;等待以wq 为等待队列头的等待队列被唤醒，前提是 condition 条件必须满足(为真)，否则一直阻塞。此函数会将 进程设置为TASK_UNINTERRUPTIBLE 状态</span><br><span class="line"></span><br><span class="line">wait_event_timeout(wq, condition, timeout) </span><br><span class="line">&#x2F;&#x2F;功能和 wait_event 类似，但是此函数可以添加超时时间，以 jiffies 为单位。此函数有返回值，如果返回 0 的话表示超时时间到，而且 condition 为假。为 1 的话表示 condition 为真，也就是条件满足了。 </span><br><span class="line"></span><br><span class="line">wait_event_interruptible(wq, condition) </span><br><span class="line">&#x2F;&#x2F;与 wait_event 函数类似，但是此函数将进程设置为 TASK_INTERRUPTIBLE，就是可以被信号打断。</span><br><span class="line"></span><br><span class="line">wait_event_interruptible_timeout(wq, condition, timeout) </span><br><span class="line">&#x2F;&#x2F;与 wait_event_timeout 函数类似，此函数也将进程设置为 TASK_INTERRUPTIBLE，可以被信号打断。  </span><br></pre></td></tr></table></figure><h2 id="阻塞-IO-实验"><a href="#阻塞-IO-实验" class="headerlink" title="阻塞 IO 实验"></a><strong>阻塞</strong> <strong>IO</strong> <strong>实验</strong></h2><p>Linux 中断中，我们直接在应用程序中通过 read 函数不断的读取按键状态，当按键有效的时候就打印出按键值。这种方法有个缺点，那就是 imx6uirqApp 这个测试应用程序拥有很高的 CPU 占用率，原因就在于我们是直接在 while 循环中通过 read 函数读取按键值，因此 imx6uirqApp 这个软件会一直运行，一直读取 按键值，CPU 使用率肯定就会很高。最好的方法就是在没有有效的按键事件发生的时候，imx6uirqApp 这个应用程序应该处于休眠状态，当有按键事件发生以后 imx6uirqApp 这个应用程序才运行，打印出按键值，这样就会降低 CPU 使用率。</p><p>使用等待队列实现阻塞访问重点注意两点： </p><p>①、将任务或者进程加入到等待队列头， </p><p>②、在合适的点唤醒等待队列，一般都是中断处理函数里面</p><h3 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a><strong>实验程序编写</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: block.c</span><br><span class="line">描述   : 阻塞IO访问</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* imx6uirq设备结构体 *&#x2F;</span><br><span class="line">struct imx6uirq_dev&#123;</span><br><span class="line">wait_queue_head_t r_wait;&#x2F;* 读等待队列头 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct imx6uirq_dev imx6uirq;&#x2F;* irq设备 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* @description: 定时器服务函数，用于按键消抖，定时器到了以后</span><br><span class="line"> *  再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><br><span class="line"> * @param - arg: 设备结构变量</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">void timer_function(unsigned long arg)</span><br><span class="line">&#123;        </span><br><span class="line">&#x2F;* 唤醒进程 *&#x2F;</span><br><span class="line">if(atomic_read(&amp;dev-&gt;releasekey)) &#123;&#x2F;* 完成一次按键过程 *&#x2F;</span><br><span class="line">&#x2F;* wake_up(&amp;dev-&gt;r_wait); *&#x2F;</span><br><span class="line">wake_up_interruptible(&amp;dev-&gt;r_wait);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 按键IO初始化</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int keyio_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 初始化等待队列头 *&#x2F;</span><br><span class="line">init_waitqueue_head(&amp;imx6uirq.r_wait);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : 从设备读取数据 </span><br><span class="line">  * @param - filp    : 要打开的设备文件(文件描述符)</span><br><span class="line">  * @param - buf     : 返回给用户空间的数据缓冲区</span><br><span class="line">  * @param - cnt     : 要读取的数据长度</span><br><span class="line">  * @param - offt    : 相对于文件首地址的偏移</span><br><span class="line">  * @return          : 读取的字节数，如果为负值，表示读取失败</span><br><span class="line">  *&#x2F;</span><br><span class="line">static ssize_t imx6uirq_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)</span><br><span class="line">&#123;</span><br><span class="line">#if 0</span><br><span class="line">&#x2F;* 加入等待队列，等待被唤醒,也就是有按键按下 *&#x2F;</span><br><span class="line"> ret &#x3D; wait_event_interruptible(dev-&gt;r_wait, atomic_read(&amp;dev-&gt;releasekey)); </span><br><span class="line">if (ret) &#123;</span><br><span class="line">goto wait_error;</span><br><span class="line">&#125; </span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">DECLARE_WAITQUEUE(wait, current);&#x2F;* 定义一个等待队列 *&#x2F;</span><br><span class="line">if(atomic_read(&amp;dev-&gt;releasekey) &#x3D;&#x3D; 0) &#123;&#x2F;* 没有按键按下 *&#x2F;</span><br><span class="line">add_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);&#x2F;* 将等待队列添加到等待队列头 *&#x2F;</span><br><span class="line">__set_current_state(TASK_INTERRUPTIBLE);&#x2F;* 设置任务状态 *&#x2F;</span><br><span class="line">schedule();&#x2F;* 进行一次任务切换，当前进程就会进入到休眠态 *&#x2F;</span><br><span class="line">if(signal_pending(current))&#123;&#x2F;* 判断是否为信号引起的唤醒 *&#x2F;</span><br><span class="line">ret &#x3D; -ERESTARTSYS;</span><br><span class="line">goto wait_error;</span><br><span class="line">&#125;</span><br><span class="line">__set_current_state(TASK_RUNNING);      &#x2F;* 将当前任务设置为运行状态 *&#x2F;</span><br><span class="line">    remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);    &#x2F;* 将对应的队列项从等待队列头删除 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">keyvalue &#x3D; atomic_read(&amp;dev-&gt;keyvalue);</span><br><span class="line">releasekey &#x3D; atomic_read(&amp;dev-&gt;releasekey);</span><br><span class="line"></span><br><span class="line">if (releasekey) &#123; &#x2F;* 有按键按下 *&#x2F;</span><br><span class="line">if (keyvalue &amp; 0x80) &#123;</span><br><span class="line">keyvalue &amp;&#x3D; ~0x80;</span><br><span class="line">ret &#x3D; copy_to_user(buf, &amp;keyvalue, sizeof(keyvalue));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">goto data_error;</span><br><span class="line">&#125;</span><br><span class="line">atomic_set(&amp;dev-&gt;releasekey, 0);&#x2F;* 按下标志清零 *&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">goto data_error;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">wait_error:</span><br><span class="line">set_current_state(TASK_RUNNING);&#x2F;* 设置任务为运行态 *&#x2F;</span><br><span class="line">remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);&#x2F;* 将等待队列移除 *&#x2F;</span><br><span class="line">return ret;</span><br><span class="line"></span><br><span class="line">data_error:</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动入口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init imx6uirq_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 5、始化按键 *&#x2F;</span><br><span class="line">atomic_set(&amp;imx6uirq.keyvalue, INVAKEY);</span><br><span class="line">atomic_set(&amp;imx6uirq.releasekey, 0);</span><br><span class="line">keyio_init();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设备结构体中添加一个等待队列头 r_wait，因为在 Linux 驱动中处理阻塞 IO 需要用到等待队列。 </p><p>定时器中断处理函数执行，表示有按键按下，先判断一下是否是一次有效的按键，如果是的话就通过 wake_up 或者 wake_up_interruptible 函数来唤醒等待队列头r_wait。</p><p>调用 init_waitqueue_head 函数初始化等待队列头 r_wait</p><p>采用等待事件来处理 read 的阻塞访问，wait_event_interruptible 函数等待releasekey 有效，也就是有按键按下。如果按键没有按下的话进程就会进入休眠状态，因为采用了 wait_event_interruptible 函数，因此进入休眠态的进程可以被信号打断。</p><p>第 208~218 行，首先使用 DECLARE_WAITQUEUE 宏定义一个等待队列，如果没有按键按下的话就使用 add_wait_queue 函数将当前任务的等待队列添加到等待队列头 r_wait 中。随后调用 _set_current_state 函数设置当前进程的状态为 TASK_INTERRUPTIBLE，也就是可以被信号打断。接下来调用 schedule 函数进行一次任务切换，当前进程就会进入到休眠态。如果有按键按下，那么进入休眠态的进程就会唤醒，然后接着从休眠点开始运行。在这里也就是从第 213行开始运行，首先通过 signal_pending 函数判断一下进程是不是由信号唤醒的，如果是由信号唤醒的话就直接返回-ERESTARTSYS 这个错误码。如果不是由信号唤醒的(也就是被按键唤醒的) 那么就在 217 行调用__set_current_state 函数将任务状态设置为 TASK_RUNNING，然后在218 行调用 remove_wait_queue 函数将进程从等待队列中删除。 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里的“IO”单片机的“GPIO”(也就是引脚)。 这里的 IO 指的是 Input/Output，也就是输入/输出，是应用程序对驱动设备的输入/输出操作。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
