<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>国强-阿甘</title>
  <icon>https://www.gravatar.com/avatar/fa14b63fc1e68cede1bc60586c0cf7a7</icon>
  <subtitle>胆小认生，不易相处</subtitle>
  <link href="https://guoqiang-gump.github.io/atom.xml" rel="self"/>
  
  <link href="https://guoqiang-gump.github.io/"/>
  <updated>2021-04-18T15:18:41.107Z</updated>
  <id>https://guoqiang-gump.github.io/</id>
  
  <author>
    <name>GUMP</name>
    <email>1822006273@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="https://guoqiang-gump.github.io/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://guoqiang-gump.github.io/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-18T12:37:24.000Z</published>
    <updated>2021-04-18T15:18:41.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据结构理论"><a href="#1-数据结构理论" class="headerlink" title="1. 数据结构理论"></a>1. <strong>数据结构理论</strong></h1><p>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集</p><p>数据项:一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。（耳、鼻、嘴、手、脚）</p><p>数据元素:是组成数据的、有一定意义的基本单位,在计算机中通常作为整体处理。也被称为记录。（人）</p><p>数据对象:是性质相同的数据元素的集合,是数据的子集。既然数据对象是数据的子集,在实际应用中,处理的数据元素通常具有相同性质,在不产生混淆的情况下,我们都将数据对象简称为<strong>数据</strong>。</p><p><img src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/1618755737702.png" alt="1618755737702"></p><p><strong>数据结构</strong>是计算机存储、组织数据的方式。是相互之间存在一种或多种特定关系的数据元素集合</p><p><strong>算法</strong>是特定问题求解步骤的描述，在计算机中表现为<strong>指令的有限序列</strong>，算法是独立存在的一种解决问题的方法和思想。对于算法而言，语言并不重要，重要的是思想。</p><p><strong>算法和数据结构区别</strong></p><p>数据结构只是静态的描述了数据元素之间的关系，高效的程序需要在数据结构的基础上设计和选择算法。</p><p>算法是为了解决实际问题而设计的。<br>数据结构是算法需要处理的问题载体。<br>数据结构与算法相辅相成</p><p><strong>算法的特性</strong></p><p>算法具有五个基本的特性：输入、输出、有穷性、确定性和可行性</p><p>输入输出：算法具有零个或多个输入、至少有一个或多个输出。</p><p>有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</p><p>确定性：算法的每一步骤都有确定的含义，不会出现二义性。</p><p>可行性：算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成。</p><h1 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h1><h2 id="1、逻辑结构"><a href="#1、逻辑结构" class="headerlink" title="1、逻辑结构"></a>1、逻辑结构</h2><p>集合结构：集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。各个数据元素是平等的。他们共同属于同一个集合，</p><p>线性结构：线性结构中的数据元素之间是一对一的关系。（动态数组、链表、栈、队列）</p><p>树形结构：树形结构中是数据元素之间存在一种一对多的层次关系，</p><p>图形结构： 图形结构的数据元素是多对多的关系</p><h2 id="2、物理结构"><a href="#2、物理结构" class="headerlink" title="2、物理结构"></a>2、物理结构</h2><p>物理结构是指数据的逻辑结构在计算机中的存储形式，共分为两种：顺序存储和链式存储。</p><p>顺序存储：是把数据元素存放在地址连续的存储单元里，其数据的逻辑关系和物理关系是一致的，</p><p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据的位置。</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是零个或者多个数据元素的有限序列，数据元素之间是有顺序的，数据元素个数有限。通常线性表可以采用顺序存储和链式存储</p><h2 id="1、线性表的顺序存储"><a href="#1、线性表的顺序存储" class="headerlink" title="1、线性表的顺序存储"></a>1、线性表的顺序存储</h2><p>线性表的顺序存储结构,指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来<br>实现这一结构。</p><p>采用顺序存储是表示线性表最简单的方法，具体做法是：将线性表中的元素一个接一个的存储在一块连续的存储区域中，这种顺序表示的线性表也成为顺序表。</p><h2 id="2、线性表的链式存储"><a href="#2、线性表的链式存储" class="headerlink" title="2、线性表的链式存储"></a>2、线性表的链式存储</h2><p>单链表</p><p>静态链表</p><p>首先我们让数组的元素都是由两个数据域组成,data和cur。也就是说,数组的每个下标都对应一个data和一个cur。数据域data,用来存放数据元素,也就是通常我们要处理的数据;而游标cur相当于单链表中的next指针,存放该元素的后继在数组中的下标。我们把这种用数组描述的链表叫做静态链表,这种描述方法还有起名叫做游标实<br>现法。</p><p>循环链表</p><p>将单链表中终端结点的指针端由空指针改为指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表( circular linked list)。</p><p>双向链表</p><p>双向链表double linked list)是在单链表的每个结点中,再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域,一个指向直接后继,另一个指向直接前驱。</p><h1 id="受限线性表"><a href="#受限线性表" class="headerlink" title="受限线性表"></a><strong>受限线性表</strong></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-数据结构理论&quot;&gt;&lt;a href=&quot;#1-数据结构理论&quot; class=&quot;headerlink&quot; title=&quot;1. 数据结构理论&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;数据结构理论&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;数据：是描述客观事物的符号，是计算机中可以操作的对象，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-电容触摸屏驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/18/Linux%E9%A9%B1%E5%8A%A8-%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/18/Linux%E9%A9%B1%E5%8A%A8-%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-18T02:57:18.000Z</published>
    <updated>2021-04-18T04:04:23.804Z</updated>
    
    <content type="html"><![CDATA[<p>①、电容触摸屏是 IIC 接口的，需要触摸 IC，所谓的电容触摸驱动就是 IIC 设备驱动。<br>②、触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息。<br>③、电容触摸屏得到的是触摸位置绝对信息以及触摸屏是否有按下。<br>④、电容触摸屏不需要校准，</p><p>电容触摸屏驱动其实就是以下几种 linux 驱动框架的组合：<br>①、IIC 设备驱动，因为电容触摸 IC 基本都是 IIC 接口的，因此大框架就是 IIC 设备驱动。<br>②、通过中断引脚(INT)向 linux 内核上报触摸信息，因此需要用到 linux 中断驱动框架。坐标的上报在中断服务函数中完成。<br>③、触摸屏的坐标信息、屏幕按下和抬起信息都属于 linux 的 input 子系统，因此向 linux 内核上报触摸屏坐标信息就得使用 input 子系统。只是，我们得按照 linux 内核规定的规则来上报坐标信息。</p><h1 id="多点触摸-MT-协议详解"><a href="#多点触摸-MT-协议详解" class="headerlink" title="多点触摸(MT)协议详解"></a>多点触摸(MT)协议详解</h1><p>多点电容触摸的(Multi-touch，简称 MT)，MT 协议被分为两种类型，TypeA 和 TypeB，这两种类型的区别如下：<br>TypeA：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少！)。 Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个触摸点的信息，FT5426 就属于此类型，一般的多点电容触摸屏 IC 都有此能力。</p><p>触摸点的信息通过一系列的 ABS_MT 事件(有的资料也叫消息)上报给 linux 内核，只有ABS_MT 事件是用于多点触摸的，ABS_MT 事件定义在文件 linux/input.h 中，</p><p>在 众 多 的 ABS_MT 事 件 中 ， 我 们 最 常 用 的 就 是 ABS_MT_SLOT 、ABS_MT_POSITION_X 、ABS_MT_POSITION_Y 和 ABS_MT_TRACKING_ID 。其中ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y 用 来 上报 触 摸点 的 (X,Y) 坐 标 信息 ，ABS_MT_SLOT 用 来 上 报 触 摸 点 ID ，对于 Type B 类 型 的 设 备 ， 需 要 用 到<br>ABS_MT_TRACKING_ID 事件来区分触摸点。</p><p>对于 Type B 类型的设备，上报触摸点信息的时候需要通过 input_mt_slot()函数区分是哪一个触摸点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void input_mt_slot(struct input_dev *dev, int slot)</span><br></pre></td></tr></table></figure><p>第一个参数是 input_dev 设备，第二个参数 slot 用于指定当前上报的是哪个触摸点信息。input_mt_slot()函数会触发 ABS_MT_SLOT 事件，此事件会告诉接收者当前正在更新的是哪个触摸点(slot)的数据。</p><p>不管是哪个类型的设备，最终都要调用 input_sync()函数来标识多点触摸信息传输完成，告诉接收者处理之前累计的所有消息，并且准备好下一次接收。</p><p>Type B 和 Type A 相比最大的区别就是 Type B 可以区分出触摸点， 因此可以减少发送到用户空间的数据。</p><p>对于 TypeA 设备，内核驱动需要一次性将触摸屏上所有的触摸点信息全部上报，每个触摸点的信息在本次上报事件流中的顺序不重要，因为事件的过滤和手指(触摸点)跟踪是在内核空间处理的。</p><p>Type B 使用 slot 协议区分具体的触摸点，slot 需要用到 ABS_MT_TRACKING_ID 消息，这个 ID 需要硬件提供，<br>或者通过原始数据计算出来。Type B 设备驱动需要给每个识别出来的触摸点分配一个 slot，后面使用这个 slot 来上报触摸点信息。可以通过 slot 的 ABS_MT_TRACKING_ID 来新增、替换或删除触摸点。一个非负数 的 ID 表示一个有效的触摸点，-1 这个 ID 表示未使用 slot。一个以前不存在的 ID 表示这是一个新加的触摸点，一个 ID 如果再也不存在了就表示删除了。</p><h2 id="Type-B-触摸点信息上报时序"><a href="#Type-B-触摸点信息上报时序" class="headerlink" title="Type B 触摸点信息上报时序"></a>Type B 触摸点信息上报时序</h2><p>对于 Type B 类型的设备，发送触摸点信息的时序如下所示，这里以 2 个触摸点为例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_SLOT 0 </span><br><span class="line">ABS_MT_TRACKING_ID 45</span><br><span class="line">ABS_MT_POSITION_X x[0] </span><br><span class="line">ABS_MT_POSITION_Y y[0] </span><br><span class="line"></span><br><span class="line">ABS_MT_SLOT 1 </span><br><span class="line">ABS_MT_TRACKING_ID 46</span><br><span class="line">ABS_MT_POSITION_X x[1] </span><br><span class="line">ABS_MT_POSITION_Y y[1] </span><br><span class="line">SYN_REPORT</span><br><span class="line"></span><br><span class="line">ABS_MT_TRACKING_ID -1 </span><br><span class="line">SYN_REPORT</span><br></pre></td></tr></table></figure><p>第 1 行，上报 ABS_MT_SLOT 事件，也就是触摸点对应的 SLOT。每次上报一个触摸点坐 标之前要先使用input_mt_slot函数上报当前触摸点SLOT，触摸点的SLOT其实就是触摸点ID， 需要由触摸 IC 提供。 </p><p>第 2 行，根据 Type B 的要求，每个 SLOT 必须关联一个 ABS_MT_TRACKING_ID，通过 修改 SLOT 关联的 ABS_MT_TRACKING_ID 来完成对触摸点的添加、替换或删除。具体用到 的函数就是 input_mt_report_slot_state，如果是添加一个新的触摸点，那么此函数的第三个参数 active 要设置为 true，linux 内核会自动分配一个 ABS_MT_TRACKING_ID 值，不需要用户去指 定具体的 ABS_MT_TRACKING_ID 值。 </p><p>第 3 行，上报触摸点 0 的 X 轴坐标，使用函数 input_report_abs 来完成。 </p><p>第 4 行，上报触摸点 0 的 Y 轴坐标，使用函数 input_report_abs 来完成。 </p><p>第 5<del>8 行，和第 1</del>4 行类似，只是换成了上报触摸点 0 的(X,Y)坐标信息 </p><p>第 9 行，当所有的触摸点坐标都上传完毕以后就得发送 SYN_REPORT 事件，使用 input_sync 函数来完成。 </p><p>第 11行，当一个触摸点(SLOT)移除以后，需要通过 ABS_MT_TRACKING_ID 事件发送一 个-1 给内核。方法很简单，同样使用 input_mt_report_slot_state 函数来完成，只需要将此函数的第三个参数 active 设置为 false 即可，不需要用户手动去设置-1。 </p><p>第 12 行，当所有的触摸点坐标都上传完毕以后就得发送 SYN_REPORT 事件</p><h1 id="多点触摸所使用到的-API-函数"><a href="#多点触摸所使用到的-API-函数" class="headerlink" title="多点触摸所使用到的 API 函数"></a>多点触摸所使用到的 API 函数</h1><h2 id="1、input-mt-init-slots-函数"><a href="#1、input-mt-init-slots-函数" class="headerlink" title="1、input_mt_init_slots 函数"></a>1、input_mt_init_slots 函数</h2><p>input_mt_init_slots 函数用于初始化 MT 的输入 slots，编写 MT 驱动的时候必须先调用此函数初始化 slots，此函数定义在文件 drivers/input/input-mt.c 中，函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int input_mt_init_slots( struct input_dev *dev, unsigned int num_slots,</span><br><span class="line">unsigned int flags)</span><br><span class="line">&#x2F;&#x2F;dev： MT 设备对应的 input_dev，因为 MT 设备隶属于 input_dev。</span><br><span class="line">&#x2F;&#x2F;num_slots：设备要使用的 SLOT 数量，也就是触摸点的数量。</span><br><span class="line">&#x2F;&#x2F;flags：其他一些 flags 信息，可以采用‘|’运算来同时设置多个 flags 标识。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br></pre></td></tr></table></figure><p>flags：其他一些 flags 信息，可设置的 flags 如下所示：可以采用‘|’运算来同时设置多个 flags 标识。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define INPUT_MT_POINTER 0x0001 &#x2F;* pointer device, e.g. trackpad *&#x2F;</span><br><span class="line">#define INPUT_MT_DIRECT 0x0002 &#x2F;* direct device, e.g. touchscreen *&#x2F;</span><br><span class="line">#define INPUT_MT_DROP_UNUSED0x0004 &#x2F;* drop contacts not seen in frame *&#x2F;</span><br><span class="line">#define INPUT_MT_TRACK 0x0008 &#x2F;* use in-kernel tracking *&#x2F;</span><br><span class="line">#define INPUT_MT_SEMI_MT 0x0010 &#x2F;* semi-mt device, finger count handled manually *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="2、input-mt-slot-函数"><a href="#2、input-mt-slot-函数" class="headerlink" title="2、input_mt_slot 函数"></a>2、input_mt_slot 函数</h2><p>此函数用于 Type B 类型，此函数用于产生 ABS_MT_SLOT 事件，告诉内核当前上报的是哪个触摸点的坐标数据，此函数定义在文件 include/linux/input/mt.h 中，函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void input_mt_slot(struct input_dev *dev, int slot)</span><br><span class="line">&#x2F;&#x2F;dev： MT 设备对应的 input_dev。</span><br><span class="line">&#x2F;&#x2F;slot：当前发送的是哪个 slot 的坐标信息，也就是哪个触摸点。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h2 id="3、input-mt-report-slot-state-函数"><a href="#3、input-mt-report-slot-state-函数" class="headerlink" title="3、input_mt_report_slot_state 函数"></a>3、input_mt_report_slot_state 函数</h2><p>此函数用于 Type B 类型，用于产生 ABS_MT_TRACKING_ID 和 ABS_MT_TOOL_TYPE事件， ABS_MT_TRACKING_ID 事 件 给 slot 关联一个 ABS_MT_TRACKING_ID ，ABS_MT_TOOL_TYPE 事 件 指 定 触 摸 类 型 （ 是 笔 还 是 手 指 等 ）。 此 函 数 定 义 在 文 件drivers/input/input-mt.c 中，此函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void input_mt_report_slot_state( struct input_dev *dev, unsigned int tool_type, </span><br><span class="line">bool active)</span><br><span class="line">&#x2F;&#x2F;dev： MT 设备对应的 input_dev。</span><br><span class="line">&#x2F;&#x2F;tool_type：触摸类型，可以选择 MT_TOOL_FINGER(手指)、MT_TOOL_PEN(笔)或MT_TOOL_PALM(手掌)，</span><br><span class="line">&#x2F;&#x2F;active：true，连续触摸，input 子系统内核会自动分配一个 ABS_MT_TRACKING_ID 给 slot。false，触摸点抬起，表示某个触摸点无效了，input 子系统内核会分配一个-1 给 slot，表示触摸点溢出。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h2 id="4、input-report-abs-函数"><a href="#4、input-report-abs-函数" class="headerlink" title="4、input_report_abs 函数"></a>4、input_report_abs 函数</h2><p>TypeA 和 Type B 类型都使用此函数上报触摸点坐标信息，通过 ABS_MT_POSITION_X 和ABS_MT_POSITION_Y 事 件 实 现 X 和 Y 轴 坐 标 信 息 上 报 。 此 函 数 定 义 在 文 件<br>include/linux/input.h 中，函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void input_report_abs( struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">&#x2F;&#x2F;dev： MT 设备对应的 input_dev。</span><br><span class="line">&#x2F;&#x2F;code：要上报的是什么数据，可以设置为 ABS_MT_POSITION_X 或 ABS_MT_POSITION_Y，也就是 X 轴或者 Y 轴坐标数据。</span><br><span class="line">&#x2F;&#x2F;value：具体的 X 轴或 Y 轴坐标数据值。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h2 id="5、input-mt-report-pointer-emulation-函数"><a href="#5、input-mt-report-pointer-emulation-函数" class="headerlink" title="5、input_mt_report_pointer_emulation 函数"></a>5、input_mt_report_pointer_emulation 函数</h2><p>如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 BTN_TOOL_TAP 事件来通知用户空间当前追踪到的触摸点总数量，然后调用 input_mt_report_pointer_emulation 函数将use_count 参数设置为 false。否则的话将 use_count 参数设置为 true，表示当前的触摸点数量(此函数会获取到具体的触摸点数量，不需要用户给出)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void input_mt_report_pointer_emulation(struct input_dev *dev, </span><br><span class="line">bool use_count)</span><br><span class="line">&#x2F;&#x2F;dev： MT 设备对应的 input_dev。</span><br><span class="line">&#x2F;&#x2F;use_count：true，有效的触摸点数量；false，追踪到的触摸点数量多于当前上报的数量。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h1 id="多点电容触摸驱动框架"><a href="#多点电容触摸驱动框架" class="headerlink" title="多点电容触摸驱动框架"></a>多点电容触摸驱动框架</h1><p>①、多点电容触摸芯片的接口，一般都为 I2C 接口，因此驱动主框架肯定是 I2C。<br>②、linux 里面一般都是通过中断来上报触摸点坐标信息，因此需要用到中断框架。<br>③、多点电容触摸属于 input 子系统，因此还要用到 input 子系统框架。<br>④、在中断处理程序中按照 linux 的 MT 协议上报坐标信息。</p><h2 id="1、I2C-驱动框架"><a href="#1、I2C-驱动框架" class="headerlink" title="1、I2C 驱动框架"></a><strong>1、I2C</strong> <strong>驱动框架</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;* 设备树匹配表 *&#x2F;</span><br><span class="line">static const struct of_device_id xxx_of_match[] &#x3D; &#123; </span><br><span class="line">    &#123; .compatible &#x3D; &quot;xxx&quot;, &#125;,</span><br><span class="line">    &#123; &#x2F;* sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* i2c 驱动结构体 *&#x2F;</span><br><span class="line">static struct i2c_driver ft5x06_ts_driver &#x3D; &#123;</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .owner &#x3D; THIS_MODULE,</span><br><span class="line">        .name &#x3D; &quot;edt_ft5x06&quot;,</span><br><span class="line">        .of_match_table &#x3D; of_match_ptr(xxx_of_match),</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table &#x3D; xxx_ts_id,</span><br><span class="line">    .probe &#x3D; xxx_ts_probe,</span><br><span class="line">    .remove &#x3D; xxx_ts_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    ret &#x3D; i2c_add_driver(&amp;xxx_ts_driver);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    i2c_del_driver(&amp;ft5x06_ts_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、初始化触摸-IC、中断和-input-子系统"><a href="#2、初始化触摸-IC、中断和-input-子系统" class="headerlink" title="2、初始化触摸 IC、中断和 input 子系统"></a>2、初始化触摸 IC、中断和 input 子系统</h2><p>初始化操作都是在 xxx_ts_probe 函数中完成，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int xxx_ts_probe(struct i2c_client *client, const struct i2c_device_id *id) </span><br><span class="line">&#123; </span><br><span class="line">    struct input_dev *input;</span><br><span class="line">    &#x2F;* 1、初始化 I2C *&#x2F;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;* 2，申请中断， *&#x2F;</span><br><span class="line">    devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, NULL,</span><br><span class="line">    xxx_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,</span><br><span class="line">    client-&gt;name, &amp;xxx);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;* 3，input 设备申请与初始化 *&#x2F;</span><br><span class="line">    input &#x3D; devm_input_allocate_device(&amp;client-&gt;dev);</span><br><span class="line"></span><br><span class="line">    input-&gt;name &#x3D; client-&gt;name;</span><br><span class="line">    input-&gt;id.bustype &#x3D; BUS_I2C;</span><br><span class="line">    input-&gt;dev.parent &#x3D; &amp;client-&gt;dev;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;* 4，初始化 input 和 MT *&#x2F;</span><br><span class="line">    __set_bit(EV_ABS, input-&gt;evbit);</span><br><span class="line">    __set_bit(BTN_TOUCH, input-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    input_set_abs_params(input, ABS_X, 0, width, 0, 0);</span><br><span class="line">    input_set_abs_params(input, ABS_Y, 0, height, 0, 0);</span><br><span class="line">    input_set_abs_params(input, ABS_MT_POSITION_X,0, width, 0, 0);</span><br><span class="line">    input_set_abs_params(input, ABS_MT_POSITION_Y,0, height, 0, 0); </span><br><span class="line">    input_mt_init_slots(input, MAX_SUPPORT_POINTS, 0);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;* 5，注册 input_dev *&#x2F;</span><br><span class="line">    input_register_device(input);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 5~7 行，首先肯定是初始化触摸芯片，包括芯片的相关 IO，比如复位、中断等 IO 引脚， 然后就是芯片本身的初始化，也就是配置触摸芯片的相关寄存器。 </p><p>第 9 行，因为一般触摸芯片都是通过中断来向系统上报触摸点坐标信息的，因此我们需要初始化中断，采用了 devm_request_threaded_irq 这个函数。</p><p>第 15 行，接下来就是申请 input_dev，因为多点电容触摸属于 input 子系统。这里同样使用 devm_input_allocate_device 函数来申请 input_dev，申请到 input_dev 以后还需要对其进行初始化操作。 </p><p>第 23~24 行，设置 input_dev 需要上报的事件为 EV_ABS 和 BTN_TOUCH，因为多点电容 屏的触摸坐标为绝对值，因此需要上报 EV_ABS 事件。触摸屏有按下和抬起之分，因此需要上报 BTN_TOUCH 按键。</p><p>第 26~29 行，调用 input_set_abs_params 函数设置 EV_ABS 事件需要上报 ABS_X、ABS_Y、 ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。单点触摸需要上报 ABS_X 和 ABS_Y，对于多点触摸需要上报 ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。 </p><p>第 30 行，调用 input_mt_init_slots 函数初始化多点电容触摸的 slots。 </p><p>第 34 行，调用 input_register_device 函数系统注册前面申请到的 input_dev。</p><p><strong>devm_request_threaded_irq 函数特点如下：</strong> </p><p>①、用于申请中断，作用和 request_irq 函数类似。 </p><p>②、此函数的作用是中断线程化。硬件中断具有最高优先级，不论什么时候只要硬件中断发生，那么内核都会终止当前正在执行的操作，转而去执行中断处理程序(不考虑关闭中断和中断优先级的情况)，如果中断非常频繁的话那么内核将会频繁的执行中断处理程序，导致任务得不到及时的处理。中断线程化以后中断将作为内核线程运行，而且也可以被赋予不同的优先级，任务的优先级可能比中断线程的优先级高，这样做的目的就是保证高优先级的任务能被优先处理。使用“devm_”前缀的函数申请到的资源可以由系统自动释放，不需要我们手动处理。</p><h2 id="3、上报坐标信息"><a href="#3、上报坐标信息" class="headerlink" title="3、上报坐标信息"></a>3、上报坐标信息</h2><p>最后就是在中断服务程序中上报读取到的坐标信息，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static irqreturn_t xxx_handler(int irq, void *dev_id) </span><br><span class="line">&#123; </span><br><span class="line">    int num; &#x2F;* 触摸点数量 *&#x2F;</span><br><span class="line">    int x[n], y[n]; &#x2F;* 保存坐标值 *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 1、从触摸芯片获取各个触摸点坐标值 *&#x2F;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;* 2、上报每一个触摸点坐标 *&#x2F;</span><br><span class="line">    for (i &#x3D; 0; i &lt; num; i++) &#123;</span><br><span class="line">    input_mt_slot(input, id);</span><br><span class="line">    input_mt_report_slot_state(input, MT_TOOL_FINGER, true);</span><br><span class="line">    input_report_abs(input, ABS_MT_POSITION_X, x[i]);</span><br><span class="line">    input_report_abs(input, ABS_MT_POSITION_Y, y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    input_sync(input);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环上报每一个触摸点坐标，一定要按照 Type B 类型的时序进行，每一轮触摸点坐标上报完毕以后就调用一次 input_sync 函数发送一个SYN_REPORT 事件。 </p><h1 id="试验程序编写"><a href="#试验程序编写" class="headerlink" title="试验程序编写"></a>试验程序编写</h1><h2 id="1、修改设备树"><a href="#1、修改设备树" class="headerlink" title="1、修改设备树"></a><strong>1、修改设备树</strong></h2><p>1、添加 FT5426 所使用的 IO<br>FT5426 触摸芯片用到了 4 个 IO，一个复位 IO、一个中断 IO、I2C2 的 SCL 和 SDA，所以我们需要先在设备树中添加 IO 相关的信息。复位 IO 和中断 IO 是普通的 GPIO，因此这两个 IO可以放到同一个节点下去描述，I2C2 的 SCL 和 SDA 属于 I2C2，因此这两个要放到同一个节点下去描述。</p><p>2、添加 FT5426 节点</p><p>FT5426 这个触摸 IC 挂载 I2C2 下，因此需要向 I2C2 节点下添加一个子节点，此子节点用 </p><p>于描述FT5426，添加完成以后的 I2C2 节点内容如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ft5426: ft5426@38 &#123;</span><br><span class="line">13 compatible &#x3D; &quot;edt,edt-ft5426&quot;;</span><br><span class="line">14 reg &#x3D; &lt;0x38&gt;;</span><br><span class="line">15 pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">16 pinctrl-0 &#x3D; &lt;&amp;pinctrl_tsc</span><br><span class="line">17 &amp;pinctrl_tsc_reset &gt;;</span><br><span class="line">18 interrupt-parent &#x3D; &lt;&amp;gpio1&gt;;</span><br><span class="line">19 interrupts &#x3D; &lt;9 0&gt;;</span><br><span class="line">20 reset-gpios &#x3D; &lt;&amp;gpio5 9 GPIO_ACTIVE_LOW&gt;; </span><br><span class="line">21 interrupt-gpios &#x3D; &lt;&amp;gpio1 9 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">22 &#125;;</span><br><span class="line">23 &#125;;</span><br></pre></td></tr></table></figure><p>第 12 行，触摸屏所使用的 FT5426 芯片节点，挂载 I2C2 节点下，FT5426 的器件地址为 0X38。</p><p>第 14 行，reg 属性描述 FT5426 的器件地址为 0x38。 </p><p>第 16 和 17 行，pinctrl-0 属性描述 FT5426 的复位 IO 和中断 IO 所使用的节点为 pinctrl_tsc 和 pinctrl_tsc_reset。 </p><p>第 18 行，interrupt-parent 属性描述中断 IO 对应的 GPIO 组为 GPIO1。 </p><p>第 19 行，interrupts 属性描述中断 IO 对应的是 GPIO1 组的 IOI09。 </p><p>第 20 行，reset-gpios 属性描述复位 IO 对应的 GPIO 为 GPIO5_IO09。 </p><p>第 21 行，interrupt-gpios 属性描述中断 IO 对应的 GPIO 为 GPIO1_IO09</p><h2 id="2、编写多点电容触摸驱动"><a href="#2、编写多点电容触摸驱动" class="headerlink" title="2、编写多点电容触摸驱动"></a>2、编写多点电容触摸驱动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: ft5x06.c</span><br><span class="line">描述   : FT5X06，包括FT5206、FT5426等触摸屏驱动程序</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">#define MAX_SUPPORT_POINTS5&#x2F;* 5点触摸 *&#x2F;</span><br><span class="line">#define TOUCH_EVENT_DOWN0x00&#x2F;* 按下 *&#x2F;</span><br><span class="line">#define TOUCH_EVENT_UP0x01&#x2F;* 抬起 *&#x2F;</span><br><span class="line">#define TOUCH_EVENT_ON0x02&#x2F;* 接触 *&#x2F;</span><br><span class="line">#define TOUCH_EVENT_RESERVED0x03&#x2F;* 保留 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* FT5X06寄存器相关宏定义 *&#x2F;</span><br><span class="line">#define FT5X06_TD_STATUS_REG0X02&#x2F;*状态寄存器地址 *&#x2F;</span><br><span class="line">#define FT5x06_DEVICE_MODE_REG0X00 &#x2F;* 模式寄存器 *&#x2F;</span><br><span class="line">#define FT5426_IDG_MODE_REG0XA4&#x2F;* 中断模式*&#x2F;</span><br><span class="line">#define FT5X06_READLEN29&#x2F;* 要读取的寄存器个数 *&#x2F;</span><br><span class="line"></span><br><span class="line">struct ft5x06_dev &#123;</span><br><span class="line">struct device_node*nd; &#x2F;* 设备节点 *&#x2F;</span><br><span class="line">int irq_pin,reset_pin;&#x2F;* 中断和复位IO*&#x2F;</span><br><span class="line">int irqnum;&#x2F;* 中断号    *&#x2F;</span><br><span class="line">void *private_data;&#x2F;* 私有数据 *&#x2F;</span><br><span class="line">struct input_dev *input;&#x2F;* input结构体 *&#x2F;</span><br><span class="line">struct i2c_client *client;&#x2F;* I2C客户端 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">static struct ft5x06_dev ft5x06;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : 复位FT5X06</span><br><span class="line"> * @param - client : 要操作的i2c</span><br><span class="line"> * @param - multidev: 自定义的multitouch设备</span><br><span class="line"> * @return          : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ft5x06_ts_reset(struct i2c_client *client, struct ft5x06_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">if (gpio_is_valid(dev-&gt;reset_pin)) &#123;  &#x2F;* 检查IO是否有效 *&#x2F;</span><br><span class="line">&#x2F;* 申请复位IO，并且默认输出低电平 *&#x2F;</span><br><span class="line">ret &#x3D; devm_gpio_request_one(&amp;client-&gt;dev,</span><br><span class="line">dev-&gt;reset_pin, GPIOF_OUT_INIT_LOW,</span><br><span class="line">&quot;edt-ft5x06 reset&quot;);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msleep(5);</span><br><span class="line">gpio_set_value(dev-&gt;reset_pin, 1);&#x2F;* 输出高电平，停止复位 *&#x2F;</span><br><span class="line">msleep(300);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 从FT5X06读取多个寄存器数据</span><br><span class="line"> * @param - dev:  ft5x06设备</span><br><span class="line"> * @param - reg:  要读取的寄存器首地址</span><br><span class="line"> * @param - val:  读取到的数据</span><br><span class="line"> * @param - len:  要读取的数据长度</span><br><span class="line"> * @return : 操作结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ft5x06_read_regs(struct ft5x06_dev *dev, u8 reg, void *val, int len)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">struct i2c_msg msg[2];</span><br><span class="line">struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;client;</span><br><span class="line"></span><br><span class="line">&#x2F;* msg[0]为发送要读取的首地址 *&#x2F;</span><br><span class="line">msg[0].addr &#x3D; client-&gt;addr;&#x2F;* ft5x06地址 *&#x2F;</span><br><span class="line">msg[0].flags &#x3D; 0;&#x2F;* 标记为发送数据 *&#x2F;</span><br><span class="line">msg[0].buf &#x3D; &amp;reg;&#x2F;* 读取的首地址 *&#x2F;</span><br><span class="line">msg[0].len &#x3D; 1;&#x2F;* reg长度*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* msg[1]读取数据 *&#x2F;</span><br><span class="line">msg[1].addr &#x3D; client-&gt;addr;&#x2F;* ft5x06地址 *&#x2F;</span><br><span class="line">msg[1].flags &#x3D; I2C_M_RD;&#x2F;* 标记为读取数据*&#x2F;</span><br><span class="line">msg[1].buf &#x3D; val;&#x2F;* 读取数据缓冲区 *&#x2F;</span><br><span class="line">msg[1].len &#x3D; len;&#x2F;* 要读取的数据长度*&#x2F;</span><br><span class="line"></span><br><span class="line">ret &#x3D; i2c_transfer(client-&gt;adapter, msg, 2);</span><br><span class="line">if(ret &#x3D;&#x3D; 2) &#123;</span><br><span class="line">ret &#x3D; 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ret &#x3D; -EREMOTEIO;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 向ft5x06多个寄存器写入数据</span><br><span class="line"> * @param - dev:  ft5x06设备</span><br><span class="line"> * @param - reg:  要写入的寄存器首地址</span><br><span class="line"> * @param - val:  要写入的数据缓冲区</span><br><span class="line"> * @param - len:  要写入的数据长度</span><br><span class="line"> * @return   :   操作结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static s32 ft5x06_write_regs(struct ft5x06_dev *dev, u8 reg, u8 *buf, u8 len)</span><br><span class="line">&#123;</span><br><span class="line">u8 b[256];</span><br><span class="line">struct i2c_msg msg;</span><br><span class="line">struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;client;</span><br><span class="line"></span><br><span class="line">b[0] &#x3D; reg;&#x2F;* 寄存器首地址 *&#x2F;</span><br><span class="line">memcpy(&amp;b[1],buf,len);&#x2F;* 将要写入的数据拷贝到数组b里面 *&#x2F;</span><br><span class="line"></span><br><span class="line">msg.addr &#x3D; client-&gt;addr;&#x2F;* ft5x06地址 *&#x2F;</span><br><span class="line">msg.flags &#x3D; 0;&#x2F;* 标记为写数据 *&#x2F;</span><br><span class="line"></span><br><span class="line">msg.buf &#x3D; b;&#x2F;* 要写入的数据缓冲区 *&#x2F;</span><br><span class="line">msg.len &#x3D; len + 1;&#x2F;* 要写入的数据长度 *&#x2F;</span><br><span class="line"></span><br><span class="line">return i2c_transfer(client-&gt;adapter, &amp;msg, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 向ft5x06指定寄存器写入指定的值，写一个寄存器</span><br><span class="line"> * @param - dev:  ft5x06设备</span><br><span class="line"> * @param - reg:  要写的寄存器</span><br><span class="line"> * @param - data: 要写入的值</span><br><span class="line"> * @return   :    无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void ft5x06_write_reg(struct ft5x06_dev *dev, u8 reg, u8 data)</span><br><span class="line">&#123;</span><br><span class="line">u8 buf &#x3D; 0;</span><br><span class="line">buf &#x3D; data;</span><br><span class="line">ft5x06_write_regs(dev, reg, &amp;buf, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : FT5X06中断服务函数</span><br><span class="line"> * @param - irq : 中断号 </span><br><span class="line"> * @param - dev_id: 设备结构。</span><br><span class="line"> * @return : 中断执行结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static irqreturn_t ft5x06_handler(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">struct ft5x06_dev *multidata &#x3D; dev_id;</span><br><span class="line"></span><br><span class="line">u8 rdbuf[29];</span><br><span class="line">int i, type, x, y, id;</span><br><span class="line">int offset, tplen;</span><br><span class="line">int ret;</span><br><span class="line">bool down;</span><br><span class="line"></span><br><span class="line">offset &#x3D; 1; &#x2F;* 偏移1，也就是0X02+1&#x3D;0x03,从0X03开始是触摸值 *&#x2F;</span><br><span class="line">tplen &#x3D; 6;&#x2F;* 一个触摸点有6个寄存器来保存触摸值 *&#x2F;</span><br><span class="line"></span><br><span class="line">memset(rdbuf, 0, sizeof(rdbuf));&#x2F;* 清除 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 读取FT5X06触摸点坐标从0X02寄存器开始，连续读取29个寄存器 *&#x2F;</span><br><span class="line">ret &#x3D; ft5x06_read_regs(multidata, FT5X06_TD_STATUS_REG, rdbuf, FT5X06_READLEN);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 上报每一个触摸点坐标 *&#x2F;</span><br><span class="line">for (i &#x3D; 0; i &lt; MAX_SUPPORT_POINTS; i++) &#123;</span><br><span class="line">u8 *buf &#x3D; &amp;rdbuf[i * tplen + offset];</span><br><span class="line"></span><br><span class="line">&#x2F;* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下：</span><br><span class="line"> * bit7:6  Event flag  0:按下 1:释放 2：接触 3：没有事件</span><br><span class="line"> * bit5:4  保留</span><br><span class="line"> * bit3:0  X轴触摸点的11~8位。</span><br><span class="line"> *&#x2F;</span><br><span class="line">type &#x3D; buf[0] &gt;&gt; 6;     &#x2F;* 获取触摸类型 *&#x2F;</span><br><span class="line">if (type &#x3D;&#x3D; TOUCH_EVENT_RESERVED)</span><br><span class="line">continue;</span><br><span class="line"> </span><br><span class="line">&#x2F;* 我们所使用的触摸屏和FT5X06是反过来的 *&#x2F;</span><br><span class="line">x &#x3D; ((buf[2] &lt;&lt; 8) | buf[3]) &amp; 0x0fff;</span><br><span class="line">y &#x3D; ((buf[0] &lt;&lt; 8) | buf[1]) &amp; 0x0fff;</span><br><span class="line"></span><br><span class="line">&#x2F;* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下：</span><br><span class="line"> * bit7:4  Touch ID  触摸ID，表示是哪个触摸点</span><br><span class="line"> * bit3:0  Y轴触摸点的11~8位。</span><br><span class="line"> *&#x2F;</span><br><span class="line">id &#x3D; (buf[2] &gt;&gt; 4) &amp; 0x0f;</span><br><span class="line">down &#x3D; type !&#x3D; TOUCH_EVENT_UP;</span><br><span class="line"></span><br><span class="line">input_mt_slot(multidata-&gt;input, id);</span><br><span class="line">input_mt_report_slot_state(multidata-&gt;input, MT_TOOL_FINGER, down);</span><br><span class="line"></span><br><span class="line">if (!down)</span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">input_report_abs(multidata-&gt;input, ABS_MT_POSITION_X, x);</span><br><span class="line">input_report_abs(multidata-&gt;input, ABS_MT_POSITION_Y, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input_mt_report_pointer_emulation(multidata-&gt;input, true);</span><br><span class="line">input_sync(multidata-&gt;input);</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">return IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : FT5x06中断初始化</span><br><span class="line"> * @param - client : 要操作的i2c</span><br><span class="line"> * @param - multidev: 自定义的multitouch设备</span><br><span class="line"> * @return          : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ft5x06_ts_irq(struct i2c_client *client, struct ft5x06_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;* 1,申请中断GPIO *&#x2F;</span><br><span class="line">if (gpio_is_valid(dev-&gt;irq_pin)) &#123;</span><br><span class="line">ret &#x3D; devm_gpio_request_one(&amp;client-&gt;dev, dev-&gt;irq_pin,</span><br><span class="line">GPIOF_IN, &quot;edt-ft5x06 irq&quot;);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">dev_err(&amp;client-&gt;dev,</span><br><span class="line">&quot;Failed to request GPIO %d, error %d\n&quot;,</span><br><span class="line">dev-&gt;irq_pin, ret);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 2，申请中断,client-&gt;irq就是IO中断， *&#x2F;</span><br><span class="line">ret &#x3D; devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, NULL,</span><br><span class="line">ft5x06_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,</span><br><span class="line">client-&gt;name, &amp;ft5x06);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">dev_err(&amp;client-&gt;dev, &quot;Unable to request touchscreen IRQ.\n&quot;);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : i2c驱动的probe函数，当驱动与</span><br><span class="line">  *                    设备匹配以后此函数就会执行</span><br><span class="line">  * @param - client  : i2c设备</span><br><span class="line">  * @param - id      : i2c设备ID</span><br><span class="line">  * @return          : 0，成功;其他负值,失败</span><br><span class="line">  *&#x2F;</span><br><span class="line">static int ft5x06_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">ft5x06.client &#x3D; client;</span><br><span class="line"></span><br><span class="line">&#x2F;* 1，获取设备树中的中断和复位引脚 *&#x2F;</span><br><span class="line">ft5x06.irq_pin &#x3D; of_get_named_gpio(client-&gt;dev.of_node, &quot;interrupt-gpios&quot;, 0);</span><br><span class="line">ft5x06.reset_pin &#x3D; of_get_named_gpio(client-&gt;dev.of_node, &quot;reset-gpios&quot;, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;* 2，复位FT5x06 *&#x2F;</span><br><span class="line">ret &#x3D; ft5x06_ts_reset(client, &amp;ft5x06);</span><br><span class="line">if(ret &lt; 0) &#123;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 3，初始化中断 *&#x2F;</span><br><span class="line">ret &#x3D; ft5x06_ts_irq(client, &amp;ft5x06);</span><br><span class="line">if(ret &lt; 0) &#123;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 4，初始化FT5X06 *&#x2F;</span><br><span class="line">ft5x06_write_reg(&amp;ft5x06, FT5x06_DEVICE_MODE_REG, 0); &#x2F;* 进入正常模式 *&#x2F;</span><br><span class="line">ft5x06_write_reg(&amp;ft5x06, FT5426_IDG_MODE_REG, 1); &#x2F;* FT5426中断模式*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 5，input设备注册 *&#x2F;</span><br><span class="line">ft5x06.input &#x3D; devm_input_allocate_device(&amp;client-&gt;dev);</span><br><span class="line">if (!ft5x06.input) &#123;</span><br><span class="line">ret &#x3D; -ENOMEM;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line">ft5x06.input-&gt;name &#x3D; client-&gt;name;</span><br><span class="line">ft5x06.input-&gt;id.bustype &#x3D; BUS_I2C;</span><br><span class="line">ft5x06.input-&gt;dev.parent &#x3D; &amp;client-&gt;dev;</span><br><span class="line"></span><br><span class="line">__set_bit(EV_KEY, ft5x06.input-&gt;evbit);</span><br><span class="line">__set_bit(EV_ABS, ft5x06.input-&gt;evbit);</span><br><span class="line">__set_bit(BTN_TOUCH, ft5x06.input-&gt;keybit);</span><br><span class="line"></span><br><span class="line">input_set_abs_params(ft5x06.input, ABS_X, 0, 1024, 0, 0);</span><br><span class="line">input_set_abs_params(ft5x06.input, ABS_Y, 0, 600, 0, 0);</span><br><span class="line">input_set_abs_params(ft5x06.input, ABS_MT_POSITION_X,0, 1024, 0, 0);</span><br><span class="line">input_set_abs_params(ft5x06.input, ABS_MT_POSITION_Y,0, 600, 0, 0);     </span><br><span class="line">ret &#x3D; input_mt_init_slots(ft5x06.input, MAX_SUPPORT_POINTS, 0);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret &#x3D; input_register_device(ft5x06.input);</span><br><span class="line">if (ret)</span><br><span class="line">goto fail;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</span><br><span class="line"> * @param - client : i2c设备</span><br><span class="line"> * @return          : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ft5x06_ts_remove(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 释放input_dev *&#x2F;</span><br><span class="line">input_unregister_device(ft5x06.input);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 设备树匹配表 </span><br><span class="line"> *&#x2F;</span><br><span class="line">static const struct of_device_id ft5x06_of_match[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;edt,edt-ft5206&quot;, &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;edt,edt-ft5426&quot;, &#125;,</span><br><span class="line">&#123; &#x2F;* sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* i2c驱动结构体 *&#x2F;</span><br><span class="line">static struct i2c_driver ft5x06_ts_driver &#x3D; &#123;</span><br><span class="line">.driver &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.name &#x3D; &quot;edt_ft5x06&quot;,</span><br><span class="line">.of_match_table &#x3D; of_match_ptr(ft5x06_of_match),</span><br><span class="line">&#125;,</span><br><span class="line">.id_table &#x3D; ft5x06_ts_id,</span><br><span class="line">.probe    &#x3D; ft5x06_ts_probe,</span><br><span class="line">.remove   &#x3D; ft5x06_ts_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;①、电容触摸屏是 IIC 接口的，需要触摸 IC，所谓的电容触摸驱动就是 IIC 设备驱动。&lt;br&gt;②、触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息。&lt;br&gt;③、电容触摸屏得到的是触摸位置绝对信息以及触摸屏是否有按下。&lt;br&gt;④、电容触摸屏不需要校准</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-串口驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/18/Linux%E9%A9%B1%E5%8A%A8-%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/18/Linux%E9%A9%B1%E5%8A%A8-%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-18T02:23:45.000Z</published>
    <updated>2021-04-18T02:56:25.563Z</updated>
    
    <content type="html"><![CDATA[<p>根据电平的不同，串口分为 TTL 和 RS232。不管是什么样的接口电平，其驱动程序都是一样的，通过外接 RS485 这样的芯片就可以将串口转换为 RS485 信号，正点原子的 I.MX6U-ALPHA 开发板就是这么做的。对于正点原子的 I.MX6U-ALPHA 开发板而言， RS232、RS485 以及 GPS 模 块接口通通连接到了 I.MX6U 的 UART3 接口上，因此这些外设最终都归结为 UART3 的串口驱动。学习一下如何驱动 I.MX6U-ALPHA 开发板上的 UART3 串口，进而实现 RS232、RS485 以及 GSP 驱动。</p><h1 id="Linux-下-UART-驱动框架"><a href="#Linux-下-UART-驱动框架" class="headerlink" title="Linux 下 UART 驱动框架"></a><strong>Linux</strong> <strong>下</strong> <strong>UART</strong> <strong>驱动框架</strong></h1><h2 id="1、uart-driver-注册与注销"><a href="#1、uart-driver-注册与注销" class="headerlink" title="1、uart_driver 注册与注销"></a>1、uart_driver 注册与注销</h2><p>同 I2C、SPI 一样，Linux 也提供了串口驱动框架，我们只需要按照相应的串口框架编写驱动程序即可。串口驱动没有什么主机端和设备端之分，就只有一个串口驱动，而且这个驱动已经由 NXP 官方已经编写好了，我们真正要做的就是在设备树中添加所要使用的串口节点信息。当系统启动以后串口驱动和设备匹配成功，相应的串口就会被驱动起来，生成/dev/ttymxcX(X=0….n)文件。</p><p>uart_driver 结构体表示 UART 驱动，uart_driver 定义在 include/linux/serial_core.h 文件中，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct uart_driver &#123;</span><br><span class="line">    struct module *owner; &#x2F;* 模块所属者 *&#x2F;</span><br><span class="line">    const char *driver_name; &#x2F;* 驱动名字 *&#x2F;</span><br><span class="line">    const char *dev_name; &#x2F;* 设备名字 *&#x2F;</span><br><span class="line">    int major; &#x2F;* 主设备号 *&#x2F;</span><br><span class="line">    int minor; &#x2F;* 次设备号 *&#x2F;</span><br><span class="line">    int nr; &#x2F;* 设备数 *&#x2F;</span><br><span class="line">    struct console *cons; &#x2F;* 控制台 *&#x2F;</span><br><span class="line">    struct uart_state *state; </span><br><span class="line">    struct tty_driver *tty_driver;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个串口驱动都需要定义一个 uart_driver，加载驱动的时候通过 uart_register_driver 函数向系统注册这个 uart_driver，注销驱动的时候也需要注销掉前面注册的 uart_driver，需要用到 uart_unregister_driver 函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int uart_register_driver(struct uart_driver *drv)</span><br><span class="line">&#x2F;&#x2F;drv：要注册的 uart_driver。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br><span class="line"></span><br><span class="line">void uart_unregister_driver(struct uart_driver *drv)</span><br><span class="line">&#x2F;&#x2F;drv：要注销的 uart_driver。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h2 id="2、uart-port-的添加与移除"><a href="#2、uart-port-的添加与移除" class="headerlink" title="2、uart_port 的添加与移除"></a>2、uart_port 的添加与移除</h2><p>uart_port 表示一个具体的 port，uart_port 定义在 include/linux/serial_core.h 文件每个 UART 都有一个 uart_port，uart_port 中最主要的就 ops，ops 包含了串口的具体驱动函数。那么 uart_port 和 uart_driver 结合要用到 uart_add_one_port 函数，卸载 UART 驱动的时候也需要将 uart_port 从相应的 uart_driver 中移除，需要用到uart_remove_one_port 函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int uart_add_one_port(struct uart_driver *drv, struct uart_port *uport)</span><br><span class="line">&#x2F;&#x2F;drv：此 port 对应的 uart_driver。</span><br><span class="line">&#x2F;&#x2F;uport：要添加到 uart_driver 中的 port。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br><span class="line"></span><br><span class="line">int uart_remove_one_port(struct uart_driver *drv, struct uart_port *uport)</span><br><span class="line">&#x2F;&#x2F;drv：要卸载的 port 所对应的 uart_driver。</span><br><span class="line">&#x2F;&#x2F;uport：要卸载的 uart_port。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br></pre></td></tr></table></figure><h3 id="3、uart-ops-实现"><a href="#3、uart-ops-实现" class="headerlink" title="3、uart_ops 实现"></a>3、uart_ops 实现</h3><p>uart_port 中的 ops 成员变量很重要，因为 ops 包含了针对 UART 具体的驱动函数，Linux 系统收发数据最终调用的都是 ops 中的函数。ops 是 uart_ops类型的结构体指针变量，uart_ops 定义在 include/linux/serial_core.h 文件中。UART 驱动编写人员需要实现 uart_ops，因为 uart_ops 是最底层的 UART 驱动接口，是实实在在的和 UART 寄存器打交道的。</p><h1 id="I-MX6U-UART-驱动分析"><a href="#I-MX6U-UART-驱动分析" class="headerlink" title="I.MX6U UART 驱动分析"></a>I.MX6U UART 驱动分析</h1><h2 id="1、UART-的-platform-驱动框架"><a href="#1、UART-的-platform-驱动框架" class="headerlink" title="1、UART 的 platform 驱动框架"></a>1、UART 的 platform 驱动框架</h2><p>I.MX6U 的 UART 本质上是一个 platform 驱动。打开 imx6ull.dtsi 文件，找到 UART3 对应的子节点的compatible 属性，这里一共有三个值：“fsl,imx6ul-uart”、“fsl,imx6q-uart”和“fsl,imx21-uart”。对应的 UART 驱动文件件为 drivers/tty/serial/imx.c，驱动文件的主要工作就是通过传统匹配表或设备树所匹配表匹配设备和驱动，然后初始化platform 驱动框架platform_driver类型的结构体 serial_imx_driver。最后就是驱动入口函数调用 uart_register_driver 函数向 Linux 内核注册 uart_driver，驱动出口函数调用 uart_unregister_driver 函数注销掉前面注 册的 uart_driver。</p><h2 id="2、uart-driver-初始化"><a href="#2、uart-driver-初始化" class="headerlink" title="2、uart_driver 初始化"></a>2、uart_driver 初始化</h2><p>在 imx_serial_init 函数中向 Linux 内核注册了 imx_reg，imx_reg 就是 uart_driver 类型的结构体变量，imx_reg 定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct uart_driver imx_reg &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .driver_name &#x3D; DRIVER_NAME,</span><br><span class="line">    .dev_name &#x3D; DEV_NAME,</span><br><span class="line">    .major &#x3D; SERIAL_IMX_MAJOR,</span><br><span class="line">    .minor &#x3D; MINOR_START,</span><br><span class="line">    .nr &#x3D; ARRAY_SIZE(imx_ports),</span><br><span class="line">    .cons &#x3D; IMX_CONSOLE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3、uart-port-初始化与添加"><a href="#3、uart-port-初始化与添加" class="headerlink" title="3、uart_port 初始化与添加"></a>3、uart_port 初始化与添加</h3><p>当 UART 设备和驱动匹配成功以后 serial_imx_probe 函数就会执行，此函数的重点工作就是初始化 uart_port，然后将其添加到对应的 uart_driver 中。imx_port 结构体 NXP 为 I.MX 系列 SOC 定义的一个设备结构体，此结构体内部就包含了 uart_port 成员变量。</p><p>serial_imx_probe 函数，函数内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int serial_imx_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct imx_port *sport;</span><br><span class="line">    sport &#x3D; devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*sport), GFP_KERNEL);</span><br><span class="line">    res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line"></span><br><span class="line">    base &#x3D; devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">    rxirq &#x3D; platform_get_irq(pdev, 0);</span><br><span class="line">    1993 txirq &#x3D; platform_get_irq(pdev, 1);</span><br><span class="line">    1994 rtsirq &#x3D; platform_get_irq(pdev, 2);</span><br><span class="line">    sport-&gt;port.ops &#x3D; &amp;imx_pops;</span><br><span class="line">    ……………………</span><br><span class="line">    return uart_add_one_port(&amp;imx_reg, &amp;sport-&gt;port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先定义一个 imx_port 类型的结构体指针变量 sport。然后为 sport 申请内存。<br>从设备树中获取 I.MX 系列 SOC UART 外设寄存器首地址，对于I.MX6ULL 的 UART3 来说就是 0X021EC000。得到寄存器首地址以后对其进行内存映射，得到对应的虚拟地址。<br>获取中断信息，申请中断。<br>初始化 sport 的 port 成员变量，也就是设置 uart_ops 为 imx_pops，imx_pops 就是 I.MX6ULL 最底层的驱动函数集合。<br>使用 uart_add_one_port 向 uart_driver 添加 uart_port，在这里就是向 imx_reg 添 加 sport-&gt;port。</p><h2 id="4、imx-pops-结构体变量"><a href="#4、imx-pops-结构体变量" class="headerlink" title="4、imx_pops 结构体变量"></a>4、imx_pops 结构体变量</h2><p>imx_pops 就是 uart_ops 类型的结构体变量，保存了 I.MX6ULL 串口最底层的操作函数，imx_pops 中的函数基本都是和 I.MX6ULL 的 UART 寄存器打交道的，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;根据电平的不同，串口分为 TTL 和 RS232。不管是什么样的接口电平，其驱动程序都是一样的，通过外接 RS485 这样的芯片就可以将串口转换为 RS485 信号，正点原子的 I.MX6U-ALPHA 开发板就是这么做的。对于正点原子的 I.MX6U-ALPHA 开发板而</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-SPI驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/17/Linux%E9%A9%B1%E5%8A%A8-SPI%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/17/Linux%E9%A9%B1%E5%8A%A8-SPI%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-17T14:50:57.000Z</published>
    <updated>2021-04-17T15:53:47.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-下-SPI-驱动框架"><a href="#Linux-下-SPI-驱动框架" class="headerlink" title="Linux 下 SPI 驱动框架"></a><strong>Linux</strong> <strong>下</strong> <strong>SPI</strong> <strong>驱动框架</strong></h1><h2 id="SPI-主机驱动"><a href="#SPI-主机驱动" class="headerlink" title="SPI 主机驱动"></a><strong>SPI</strong> <strong>主机驱动</strong></h2><p>SPI 主机驱动就是 SOC 的 SPI 控制器驱动，类似 I2C 驱动里面的适配器驱动。Linux 内核使用 spi_master表示 SPI 主机驱动，spi_master 是个结构体，定义在 include/linux/spi/spi.h 文件中，内容如下(有缩减)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct spi_master &#123;</span><br><span class="line">    struct device dev;</span><br><span class="line">    struct list_head list;</span><br><span class="line">    ......</span><br><span class="line">    (*transfer)(struct spi_device *spi, struct spi_message *mesg);</span><br><span class="line">    ......</span><br><span class="line">    int (*transfer_one_message)(struct spi_master *master, struct spi_message *mesg);</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;transfer函数，和 i2c_algorithm 中的 master_xfer 函数一样，控制器数据传输函数。</span><br><span class="line">&#x2F;&#x2F;transfer_one_message函数，也用于 SPI 数据发送，用于发送一个spi_message，SPI的数据会打包成 spi_message，然后以队列方式发送出去。</span><br></pre></td></tr></table></figure><p>SPI 主机端最终会通过 transfer 函数与 SPI 设备进行通信，因此对于 SPI 主机控制器的驱动编写者而言 transfer 函数是需要实现的，因为不同的 SOC 其 SPI 控制器不同，寄存器都不一样。SPI 主机驱动一般都是 SOC 厂商去编写的。</p><p>SPI 主机驱动的核心就是申请 spi_master，然后初始化 spi_master，最后向 Linux 内核注册 spi_master。 </p><p><strong>1、spi_master 申请与释放</strong></p><p>spi_alloc_master 函数用于申请 spi_master，当我们删除一个 SPI 主机驱动的时候就需要释放掉前面申请的 spi_master，spi_master 的释放通过 spi_master_put 函数来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct spi_master *spi_alloc_master(struct device *dev, </span><br><span class="line">unsigned size)</span><br><span class="line">&#x2F;&#x2F;dev：设备，一般是 platform_device 中的 dev 成员变量。</span><br><span class="line">&#x2F;&#x2F;size：私有数据大小，可以通过 spi_master_get_devdata 函数获取到这些私有数据。</span><br><span class="line">&#x2F;&#x2F;返回值：申请到的 spi_master。</span><br><span class="line"></span><br><span class="line">void spi_master_put(struct spi_master *master)</span><br><span class="line">&#x2F;&#x2F;master：要释放的 spi_master。</span><br><span class="line">&#x2F;&#x2F;返回值：无</span><br></pre></td></tr></table></figure><p><strong>2、spi_master 的注册与注销</strong></p><p>当 spi_master 初始化完成以后就需要将其注册到 Linux 内核，如果要注销 spi_master 的话可以使用 spi_unregister_master 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int spi_register_master(struct spi_master *master)</span><br><span class="line">&#x2F;&#x2F;master：要注册的 spi_master。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br><span class="line"></span><br><span class="line">void spi_unregister_master(struct spi_master *master)</span><br><span class="line">&#x2F;&#x2F;master：要注销的 spi_master。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h2 id="SPI-设备驱动"><a href="#SPI-设备驱动" class="headerlink" title="SPI 设备驱动"></a>SPI 设备驱动</h2><p>Linux 内核使用 spi_driver 结构体来表示 spi 设备驱动，spi_driver 结构体定义在include/linux/spi/spi.h 文件中，结构体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct spi_driver &#123;</span><br><span class="line">    const struct spi_device_id *id_table;</span><br><span class="line">    int (*probe)(struct spi_device *spi);</span><br><span class="line">    int (*remove)(struct spi_device *spi);</span><br><span class="line">    void (*shutdown)(struct spi_device *spi);</span><br><span class="line">    struct device_driver driver;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>spi_driver 和 i2c_driver、platform_driver 基本一样，当 SPI 设备和驱动匹配成功以后 probe 函数就会执行。 </p><p>spi_driver 初始化完成以后需要向 Linux 内核注册，spi_driver 注册函数为spi_register_driver，注销 SPI 设备驱动以后也需要注销掉前面注册的 spi_driver，使用 spi_unregister_driver 函<br>数完成 spi_driver 的注销，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int spi_register_driver(struct spi_driver *sdrv)</span><br><span class="line">&#x2F;&#x2F;sdrv：要注册的 spi_driver。</span><br><span class="line">&#x2F;&#x2F;返回值：0，注册成功；赋值，注册失败。</span><br><span class="line"></span><br><span class="line">void spi_unregister_driver(struct spi_driver *sdrv)</span><br><span class="line">&#x2F;&#x2F;sdrv：要注销的 spi_driver。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p>**spi_driver 注册示例程序如下： **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* probe 函数 *&#x2F;</span><br><span class="line">static int xxx_probe(struct spi_device *spi) </span><br><span class="line">&#123; </span><br><span class="line">    &#x2F;* 具体函数内容 *&#x2F;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* remove 函数 *&#x2F;</span><br><span class="line">static int xxx_remove(struct spi_device *spi)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* 具体函数内容 *&#x2F;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 传统匹配方式 ID 列表 *&#x2F;</span><br><span class="line">static const struct spi_device_id xxx_id[] &#x3D; &#123;</span><br><span class="line">    &#123;&quot;xxx&quot;, 0&#125;, </span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备树匹配列表 *&#x2F;</span><br><span class="line">static const struct of_device_id xxx_of_match[] &#x3D; &#123;</span><br><span class="line">    &#123; .compatible &#x3D; &quot;xxx&quot; &#125;,</span><br><span class="line">    &#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* SPI 驱动结构体 *&#x2F;</span><br><span class="line">static struct spi_driver xxx_driver &#x3D; &#123;</span><br><span class="line">    .probe &#x3D; xxx_probe,</span><br><span class="line">    .remove &#x3D; xxx_remove,</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .owner &#x3D; THIS_MODULE,</span><br><span class="line">        .name &#x3D; &quot;xxx&quot;,</span><br><span class="line">        .of_match_table &#x3D; xxx_of_match,</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table &#x3D; xxx_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动入口函数 *&#x2F;</span><br><span class="line">static int __init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return spi_register_driver(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动出口函数 *&#x2F;</span><br><span class="line">static void __exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">spi_unregister_driver(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SPI-设备和驱动匹配过程"><a href="#SPI-设备和驱动匹配过程" class="headerlink" title="SPI 设备和驱动匹配过程"></a>SPI 设备和驱动匹配过程</h3><p>SPI 设备和驱动的匹配过程是由 SPI 总线来完成的，这点和 platform、I2C 等驱动一样，SPI 总线为 spi_bus_type，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type spi_bus_type &#x3D; &#123;</span><br><span class="line">    .name &#x3D; &quot;spi&quot;,</span><br><span class="line">    .dev_groups &#x3D; spi_dev_groups,</span><br><span class="line">    .match &#x3D; spi_match_device,</span><br><span class="line">    .uevent &#x3D; spi_uevent,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SPI 设备和驱动的匹配函数为 spi_match_device，spi_match_device函数中的of_driver_match_device 函数用于完成设备树设备和驱动匹配，比较 SPI 设备节 点的 compatible 属性和 of_device_id 中的 compatible 属性是否相等，如果相当的话就表示 SPI 设备和驱动匹配。 spi_match_device函数中spi_match_id 函数用于传统的、无设备树的 SPI 设备和驱动匹配过程。比较 SPI设备名字和 spi_device_id 的 name 字段是否相等，相等的话就说明 SPI 设备和驱动匹配。 </p><h1 id="SPI-设备驱动编写流程"><a href="#SPI-设备驱动编写流程" class="headerlink" title="SPI 设备驱动编写流程"></a><strong>SPI</strong> <strong>设备驱动编写流程</strong></h1><h2 id="1、SPI-设备信息描述"><a href="#1、SPI-设备信息描述" class="headerlink" title="1、SPI 设备信息描述"></a><strong>1、SPI</strong> <strong>设备信息描述</strong></h2><p><strong>1、IO 的 pinctrl 子节点创建与修改</strong></p><p>首先肯定是根据所使用的 IO 来创建或修改 pinctrl 子节点，这个没什么好说的，唯独要注意的就是检查相应的 IO 有没有被其他的设备所使用，如果有的话需要将其删除掉！ </p><p><strong>2、SPI 设备节点的创建与修改</strong></p><p>采用设备树的情况下，SPI 设备信息描述就通过创建相应的设备子节点来完成，</p><h2 id="SPI-设备数据收发处理流程"><a href="#SPI-设备数据收发处理流程" class="headerlink" title="SPI 设备数据收发处理流程"></a><strong>SPI</strong> <strong>设备数据收发处理流程</strong></h2><p>SPI 设备驱动的核心是 spi_driver，当我们向 Linux 内 </p><p>核注册成功 spi_driver 以后就可以使用 SPI 核心层提供的 API 函数来对设备进行读写操作了。 </p><p>首先是 spi_transfer 结构体，此结构体用于描述 SPI 传输信息，结构体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct spi_transfer &#123;</span><br><span class="line">const void *tx_buf;</span><br><span class="line">610 void *rx_buf;</span><br><span class="line">611 unsigned len;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;tx_buf 保存着要发送的数据。</span><br><span class="line">&#x2F;&#x2F;rx_buf 用于保存接收到的数据。</span><br><span class="line">&#x2F;&#x2F;len是要进行传输的数据长度，SPI是全双工通信，因此在一次通信中发送和接收的字节数都是一样的，所以 spi_transfer中也就没有发送长度和接收长度之分。</span><br></pre></td></tr></table></figure><p>spi_transfer 需要组织成 spi_message，spi_message 也是一个结构体，在使用spi_message之前需要对其进行初始化，spi_message初始化函数为spi_message_init，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void spi_message_init(struct spi_message *m)</span><br><span class="line">函数参数和返回值含义如下：</span><br><span class="line">m：要初始化的 spi_message。</span><br><span class="line">返回值：无。</span><br></pre></td></tr></table></figure><p>spi_message 初始化完成以后需要将 spi_transfer 添加到 spi_message 队列中，这里我们要用到 spi_message_add_tail 函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m)</span><br><span class="line">t：要添加到队列中的 spi_transfer。 m：spi_transfer 要加入的 spi_message。</span><br><span class="line">返回值：无。</span><br></pre></td></tr></table></figure><p>spi_message 准备好以后既可以进行数据传输了，数据传输分为同步传输和异步传输。同步传输会阻塞的等待 SPI 数据传输完成，同步传输函数为 spi_sync。异步传输不会阻塞的等到 SPI 数据传输完成，异步传输需要设置 spi_message 中的 complete成员变量，complete 是一个回调函数，当 SPI 异步传输完成以后此函数就会被调用。SPI 异步传输函数为 spi_async，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int spi_sync(struct spi_device *spi, struct spi_message *message)</span><br><span class="line">&#x2F;&#x2F;spi：要进行数据传输的 spi_device。</span><br><span class="line">&#x2F;&#x2F;message：要传输的 spi_message。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br><span class="line"></span><br><span class="line">int spi_async(struct spi_device *spi, struct spi_message *message)</span><br><span class="line">&#x2F;&#x2F;spi：要进行数据传输的 spi_device。</span><br><span class="line">&#x2F;&#x2F;message：要传输的 spi_message。</span><br><span class="line">&#x2F;&#x2F;返回值：无</span><br></pre></td></tr></table></figure><p>SPI 数据传输步骤如下：</p><p>①、申请并初始化 spi_transfer，设置 spi_transfer 的 tx_buf 成员变量，tx_buf 为要发送的数<br>据。然后设置 rx_buf 成员变量，rx_buf 保存着接收到的数据。最后设置 len 成员变量，也就是<br>要进行数据通信的长度。<br>②、使用 spi_message_init 函数初始化 spi_message。<br>③、使用spi_message_add_tail函数将前面设置好的spi_transfer添加到spi_message队列中。<br>④、使用 spi_sync 函数完成 SPI 数据同步传输。</p><p>**通过 SPI 进行 n 个字节的数据发送和接收的示例代码如下所示： **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* SPI 多字节发送 *&#x2F;</span><br><span class="line">static int spi_send(struct spi_device *spi, u8 *buf, int len) &#123;</span><br><span class="line">     int ret;</span><br><span class="line">     struct spi_message m;</span><br><span class="line"></span><br><span class="line">     struct spi_transfer t &#x3D; &#123;</span><br><span class="line">     .tx_buf &#x3D; buf,</span><br><span class="line">     .len &#x3D; len,</span><br><span class="line">     &#125;;</span><br><span class="line">     spi_message_init(&amp;m); &#x2F;* 初始化 spi_message *&#x2F;</span><br><span class="line">     spi_message_add_tail(t, &amp;m);&#x2F;* 将 spi_transfer 添加到 spi_message 队列 *&#x2F;</span><br><span class="line">     ret &#x3D; spi_sync(spi, &amp;m); &#x2F;* 同步传输 *&#x2F;</span><br><span class="line">     return ret;</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;* SPI 多字节接收 *&#x2F;</span><br><span class="line">static int spi_receive(struct spi_device *spi, u8 *buf, int len) &#123;</span><br><span class="line">     int ret;</span><br><span class="line">     struct spi_message m;</span><br><span class="line"></span><br><span class="line">     struct spi_transfer t &#x3D; &#123;</span><br><span class="line">     .rx_buf &#x3D; buf,</span><br><span class="line">     .len &#x3D; len,</span><br><span class="line">     &#125;;</span><br><span class="line">     spi_message_init(&amp;m); &#x2F;* 初始化 spi_message *&#x2F;</span><br><span class="line">     spi_message_add_tail(t, &amp;m);&#x2F;* 将 spi_transfer 添加到 spi_message 队列 *&#x2F;</span><br><span class="line">     ret &#x3D; spi_sync(spi, &amp;m); &#x2F;* 同步传输 *&#x2F;</span><br><span class="line">     return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="试验程序编写"><a href="#试验程序编写" class="headerlink" title="试验程序编写"></a>试验程序编写</h1><h2 id="1、修改设备树"><a href="#1、修改设备树" class="headerlink" title="1、修改设备树"></a><strong>1、修改设备树</strong></h2><p><strong>1、添加 ICM20608 所使用的 IO</strong></p><p>首先在 imx6ull-alientek-emmc.dts 文件中添加 ICM20608 所使用的 IO 信息，在 iomuxc 节点中添加一个新的子节点来描述 ICM20608 所使用的 SPI 引脚，子节点名字为 pinctrl_ecspi3，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_ecspi3: icm20608 &#123; </span><br><span class="line">    fsl,pins &#x3D; &lt; </span><br><span class="line">        MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20 0x10b0 &#x2F;* CS *&#x2F;</span><br><span class="line">        MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK 0x10b1 &#x2F;* SCLK *&#x2F;</span><br><span class="line">        MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO 0x10b1 &#x2F;* MISO *&#x2F;</span><br><span class="line">        MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI 0x10b1 &#x2F;* MOSI *&#x2F;</span><br><span class="line">    &gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>UART2_TX_DATA 这个 IO 是 ICM20608 的片选信号，这里我们并没有将其复用为 ECSPI3的SS0 信号，而是将其复用为了普通的 GPIO。因为我们需要自己控制片选信号，所以将其复用为普通的 GPIO。 </p><p><strong>2、在 ecspi3 节点追加 icm20608 子节点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&amp;ecspi3 &#123; 2 fsl,spi-num-chipselects &#x3D; &lt;1&gt;;</span><br><span class="line">3 cs-gpio &#x3D; &lt;&amp;gpio1 20 GPIO_ACTIVE_LOW&gt;; &#x2F;* cant&#39;t use cs-gpios! *&#x2F;</span><br><span class="line">4 pinctrl-names &#x3D; &quot;default&quot;; 5 pinctrl-0 &#x3D; &lt;&amp;pinctrl_ecspi3&gt;;</span><br><span class="line">6 status &#x3D; &quot;okay&quot;; 7 </span><br><span class="line">8 spidev: icm20608@0 &#123; 9 compatible &#x3D; &quot;alientek,icm20608&quot;;</span><br><span class="line">10 spi-max-frequency &#x3D; &lt;8000000&gt;;</span><br><span class="line">11 reg &#x3D; &lt;0&gt;;</span><br><span class="line">12 &#125;;</span><br><span class="line">13 &#125;;</span><br></pre></td></tr></table></figure><p>第 2 行，设置当前片选数量为 1，因为就只接了一个 ICM20608。 第 3 行，注意！这里并没有用到“cs-gpios”属性，而是用了一个自己定义的“cs-gpio”属性，因为我们要自己控制片选引脚。如果使用“cs-gpios”属性的话 SPI 主机驱动就会控制片选引脚。</p><p>第 5 行，设置 IO 要使用的 pinctrl_ecspi3子节点，第 6 行，imx6ull.dtsi 文件中默认将 ecspi3 节点状态(status)设置为“disable”，这里我们要将其改为“okay”。</p><p>第 8~12 行，icm20608 设备子节点，因为 icm20608 连接在 ECSPI3 的第 0 个通道上，因此@后面为 0。</p><p>第 9 行设置节点属性兼容值为“alientek,icm20608”，</p><p>第 10 行设置 SPI 最大时钟频率为 8MHz，这是 ICM20608 的 SPI 接口所能支持的最大的时钟频率。</p><p>第 11 行，icm20608 连接在通道 0 上，因此 reg 为 0。</p><h2 id="2、编写-ICM20608-驱动"><a href="#2、编写-ICM20608-驱动" class="headerlink" title="2、编写 ICM20608 驱动"></a>2、编写 ICM20608 驱动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: icm20608.c</span><br><span class="line">描述   : ICM20608 SPI驱动程序</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">struct icm20608_dev &#123;</span><br><span class="line">void *private_data;&#x2F;* 私有数据 *&#x2F;</span><br><span class="line">int cs_gpio;&#x2F;* 片选所使用的GPIO编号*&#x2F;</span><br><span class="line">signed int gyro_x_adc;&#x2F;* 陀螺仪X轴原始值  *&#x2F;</span><br><span class="line">signed int gyro_y_adc;&#x2F;* 陀螺仪Y轴原始值*&#x2F;</span><br><span class="line">signed int gyro_z_adc;&#x2F;* 陀螺仪Z轴原始值 *&#x2F;</span><br><span class="line">signed int accel_x_adc;&#x2F;* 加速度计X轴原始值 *&#x2F;</span><br><span class="line">signed int accel_y_adc;&#x2F;* 加速度计Y轴原始值*&#x2F;</span><br><span class="line">signed int accel_z_adc;&#x2F;* 加速度计Z轴原始值 *&#x2F;</span><br><span class="line">signed int temp_adc;&#x2F;* 温度原始值 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">static struct icm20608_dev icm20608dev;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 从icm20608读取多个寄存器数据</span><br><span class="line"> * @param - dev:  icm20608设备</span><br><span class="line"> * @param - reg:  要读取的寄存器首地址</span><br><span class="line"> * @param - val:  读取到的数据</span><br><span class="line"> * @param - len:  要读取的数据长度</span><br><span class="line"> * @return : 操作结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int icm20608_read_regs(struct icm20608_dev *dev, u8 reg, void *buf, int len)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">unsigned char txdata[len];</span><br><span class="line">struct spi_message m;</span><br><span class="line">struct spi_transfer *t;</span><br><span class="line">struct spi_device *spi &#x3D; (struct spi_device *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">gpio_set_value(dev-&gt;cs_gpio, 0);&#x2F;* 片选拉低，选中ICM20608 *&#x2F;</span><br><span class="line">t &#x3D; kzalloc(sizeof(struct spi_transfer), GFP_KERNEL);&#x2F;* 申请内存 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 第1次，发送要读取的寄存地址 *&#x2F;</span><br><span class="line">txdata[0] &#x3D; reg | 0x80;&#x2F;* 写数据的时候寄存器地址bit8要置1 *&#x2F;</span><br><span class="line">t-&gt;tx_buf &#x3D; txdata;&#x2F;* 要发送的数据 *&#x2F;</span><br><span class="line">t-&gt;len &#x3D; 1;&#x2F;* 1个字节 *&#x2F;</span><br><span class="line">spi_message_init(&amp;m);&#x2F;* 初始化spi_message *&#x2F;</span><br><span class="line">spi_message_add_tail(t, &amp;m);&#x2F;* 将spi_transfer添加到spi_message队列 *&#x2F;</span><br><span class="line">ret &#x3D; spi_sync(spi, &amp;m);&#x2F;* 同步发送 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 第2次，读取数据 *&#x2F;</span><br><span class="line">txdata[0] &#x3D; 0xff;&#x2F;* 随便一个值，此处无意义 *&#x2F;</span><br><span class="line">t-&gt;rx_buf &#x3D; buf;&#x2F;* 读取到的数据 *&#x2F;</span><br><span class="line">t-&gt;len &#x3D; len;&#x2F;* 要读取的数据长度 *&#x2F;</span><br><span class="line">spi_message_init(&amp;m);&#x2F;* 初始化spi_message *&#x2F;</span><br><span class="line">spi_message_add_tail(t, &amp;m);&#x2F;* 将spi_transfer添加到spi_message队列 *&#x2F;</span><br><span class="line">ret &#x3D; spi_sync(spi, &amp;m);&#x2F;* 同步发送 *&#x2F;</span><br><span class="line"></span><br><span class="line">kfree(t);&#x2F;* 释放内存 *&#x2F;</span><br><span class="line">gpio_set_value(dev-&gt;cs_gpio, 1);&#x2F;* 片选拉高，释放ICM20608 *&#x2F;</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 向icm20608多个寄存器写入数据</span><br><span class="line"> * @param - dev:  icm20608设备</span><br><span class="line"> * @param - reg:  要写入的寄存器首地址</span><br><span class="line"> * @param - val:  要写入的数据缓冲区</span><br><span class="line"> * @param - len:  要写入的数据长度</span><br><span class="line"> * @return   :   操作结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static s32 icm20608_write_regs(struct icm20608_dev *dev, u8 reg, u8 *buf, u8 len)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">unsigned char txdata[len];</span><br><span class="line">struct spi_message m;</span><br><span class="line">struct spi_transfer *t;</span><br><span class="line">struct spi_device *spi &#x3D; (struct spi_device *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">t &#x3D; kzalloc(sizeof(struct spi_transfer), GFP_KERNEL);&#x2F;* 申请内存 *&#x2F;</span><br><span class="line">gpio_set_value(dev-&gt;cs_gpio, 0);&#x2F;* 片选拉低 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 第1次，发送要读取的寄存地址 *&#x2F;</span><br><span class="line">txdata[0] &#x3D; reg &amp; ~0x80;&#x2F;* 写数据的时候寄存器地址bit8要清零 *&#x2F;</span><br><span class="line">t-&gt;tx_buf &#x3D; txdata;&#x2F;* 要发送的数据 *&#x2F;</span><br><span class="line">t-&gt;len &#x3D; 1;&#x2F;* 1个字节 *&#x2F;</span><br><span class="line">spi_message_init(&amp;m);&#x2F;* 初始化spi_message *&#x2F;</span><br><span class="line">spi_message_add_tail(t, &amp;m);&#x2F;* 将spi_transfer添加到spi_message队列 *&#x2F;</span><br><span class="line">ret &#x3D; spi_sync(spi, &amp;m);&#x2F;* 同步发送 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 第2次，发送要写入的数据 *&#x2F;</span><br><span class="line">t-&gt;tx_buf &#x3D; buf;&#x2F;* 要写入的数据 *&#x2F;</span><br><span class="line">t-&gt;len &#x3D; len;&#x2F;* 写入的字节数 *&#x2F;</span><br><span class="line">spi_message_init(&amp;m);&#x2F;* 初始化spi_message *&#x2F;</span><br><span class="line">spi_message_add_tail(t, &amp;m);&#x2F;* 将spi_transfer添加到spi_message队列 *&#x2F;</span><br><span class="line">ret &#x3D; spi_sync(spi, &amp;m);&#x2F;* 同步发送 *&#x2F;</span><br><span class="line"></span><br><span class="line">kfree(t);&#x2F;* 释放内存 *&#x2F;</span><br><span class="line">gpio_set_value(dev-&gt;cs_gpio, 1);&#x2F;* 片选拉高，释放ICM20608 *&#x2F;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 读取icm20608指定寄存器值，读取一个寄存器</span><br><span class="line"> * @param - dev:  icm20608设备</span><br><span class="line"> * @param - reg:  要读取的寄存器</span><br><span class="line"> * @return   :   读取到的寄存器值</span><br><span class="line"> *&#x2F;</span><br><span class="line">static unsigned char icm20608_read_onereg(struct icm20608_dev *dev, u8 reg)</span><br><span class="line">&#123;</span><br><span class="line">u8 data &#x3D; 0;</span><br><span class="line">icm20608_read_regs(dev, reg, &amp;data, 1);</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 向icm20608指定寄存器写入指定的值，写一个寄存器</span><br><span class="line"> * @param - dev:  icm20608设备</span><br><span class="line"> * @param - reg:  要写的寄存器</span><br><span class="line"> * @param - data: 要写入的值</span><br><span class="line"> * @return   :    无</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">static void icm20608_write_onereg(struct icm20608_dev *dev, u8 reg, u8 value)</span><br><span class="line">&#123;</span><br><span class="line">u8 buf &#x3D; value;</span><br><span class="line">icm20608_write_regs(dev, reg, &amp;buf, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 读取ICM20608的数据，读取原始数据，包括三轴陀螺仪、</span><br><span class="line"> * : 三轴加速度计和内部温度。</span><br><span class="line"> * @param - dev: ICM20608设备</span><br><span class="line"> * @return : 无。</span><br><span class="line"> *&#x2F;</span><br><span class="line">void icm20608_readdata(struct icm20608_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char data[14];</span><br><span class="line">icm20608_read_regs(dev, ICM20_ACCEL_XOUT_H, data, 14);</span><br><span class="line"></span><br><span class="line">dev-&gt;accel_x_adc &#x3D; (signed short)((data[0] &lt;&lt; 8) | data[1]); </span><br><span class="line">dev-&gt;accel_y_adc &#x3D; (signed short)((data[2] &lt;&lt; 8) | data[3]); </span><br><span class="line">dev-&gt;accel_z_adc &#x3D; (signed short)((data[4] &lt;&lt; 8) | data[5]); </span><br><span class="line">dev-&gt;temp_adc    &#x3D; (signed short)((data[6] &lt;&lt; 8) | data[7]); </span><br><span class="line">dev-&gt;gyro_x_adc  &#x3D; (signed short)((data[8] &lt;&lt; 8) | data[9]); </span><br><span class="line">dev-&gt;gyro_y_adc  &#x3D; (signed short)((data[10] &lt;&lt; 8) | data[11]);</span><br><span class="line">dev-&gt;gyro_z_adc  &#x3D; (signed short)((data[12] &lt;&lt; 8) | data[13]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 打开设备</span><br><span class="line"> * @param - inode : 传递给驱动的inode</span><br><span class="line"> * @param - filp : 设备文件，file结构体有个叫做pr似有ate_data的成员变量</span><br><span class="line"> *   一般在open的时候将private_data似有向设备结构体。</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int icm20608_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data &#x3D; &amp;icm20608dev; &#x2F;* 设置私有数据 *&#x2F;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 从设备读取数据 </span><br><span class="line"> * @param - filp : 要打开的设备文件(文件描述符)</span><br><span class="line"> * @param - buf : 返回给用户空间的数据缓冲区</span><br><span class="line"> * @param - cnt : 要读取的数据长度</span><br><span class="line"> * @param - offt : 相对于文件首地址的偏移</span><br><span class="line"> * @return : 读取的字节数，如果为负值，表示读取失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static ssize_t icm20608_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off)</span><br><span class="line">&#123;</span><br><span class="line">signed int data[7];</span><br><span class="line">long err &#x3D; 0;</span><br><span class="line">struct icm20608_dev *dev &#x3D; (struct icm20608_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">icm20608_readdata(dev);</span><br><span class="line">data[0] &#x3D; dev-&gt;gyro_x_adc;</span><br><span class="line">data[1] &#x3D; dev-&gt;gyro_y_adc;</span><br><span class="line">data[2] &#x3D; dev-&gt;gyro_z_adc;</span><br><span class="line">data[3] &#x3D; dev-&gt;accel_x_adc;</span><br><span class="line">data[4] &#x3D; dev-&gt;accel_y_adc;</span><br><span class="line">data[5] &#x3D; dev-&gt;accel_z_adc;</span><br><span class="line">data[6] &#x3D; dev-&gt;temp_adc;</span><br><span class="line">err &#x3D; copy_to_user(buf, data, sizeof(data));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 关闭&#x2F;释放设备</span><br><span class="line"> * @param - filp : 要关闭的设备文件(文件描述符)</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int icm20608_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* icm20608操作函数 *&#x2F;</span><br><span class="line">static const struct file_operations icm20608_ops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; icm20608_open,</span><br><span class="line">.read &#x3D; icm20608_read,</span><br><span class="line">.release &#x3D; icm20608_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * ICM20608内部寄存器初始化函数 </span><br><span class="line"> * @param  : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">void icm20608_reginit(void)</span><br><span class="line">&#123;</span><br><span class="line">u8 value &#x3D; 0;</span><br><span class="line"></span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, 0x80);</span><br><span class="line">mdelay(50);</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, 0x01);</span><br><span class="line">mdelay(50);</span><br><span class="line"></span><br><span class="line">value &#x3D; icm20608_read_onereg(&amp;icm20608dev, ICM20_WHO_AM_I);</span><br><span class="line">printk(&quot;ICM20608 ID &#x3D; %#X\r\n&quot;, value);</span><br><span class="line"></span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_SMPLRT_DIV, 0x00); &#x2F;* 输出速率是内部采样率*&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_GYRO_CONFIG, 0x18); &#x2F;* 陀螺仪±2000dps量程 *&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG, 0x18); &#x2F;* 加速度计±16G量程 *&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_CONFIG, 0x04); &#x2F;* 陀螺仪低通滤波BW&#x3D;20Hz *&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG2, 0x04); &#x2F;* 加速度计低通滤波BW&#x3D;21.2Hz *&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_2, 0x00); &#x2F;* 打开加速度计和陀螺仪所有轴 *&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_LP_MODE_CFG, 0x00); &#x2F;* 关闭低功耗 *&#x2F;</span><br><span class="line">icm20608_write_onereg(&amp;icm20608dev, ICM20_FIFO_EN, 0x00);&#x2F;* 关闭FIFO*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : spi驱动的probe函数，当驱动与</span><br><span class="line">  *                    设备匹配以后此函数就会执行</span><br><span class="line">  * @param - client  : spi设备</span><br><span class="line">  * @param - id      : spi设备ID</span><br><span class="line">  * </span><br><span class="line">  *&#x2F;</span><br><span class="line">static int icm20608_probe(struct spi_device *spi)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;* 1、构建设备号 *&#x2F;</span><br><span class="line">&#x2F;* 2、注册设备 *&#x2F;</span><br><span class="line">&#x2F;* 3、创建类 *&#x2F;</span><br><span class="line">&#x2F;* 4、创建设备 *&#x2F;</span><br><span class="line">&#x2F;* 获取设备树中cs片选信号 *&#x2F;</span><br><span class="line">icm20608dev.nd &#x3D; of_find_node_by_path(&quot;&#x2F;soc&#x2F;aips-bus@02000000&#x2F;spba-bus@02000000&#x2F;ecspi@02010000&quot;);</span><br><span class="line">if(icm20608dev.nd &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">printk(&quot;ecspi3 node not find!\r\n&quot;);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;*初始化spi_device *&#x2F;</span><br><span class="line">spi-&gt;mode &#x3D; SPI_MODE_0;&#x2F;*MODE0，CPOL&#x3D;0，CPHA&#x3D;0*&#x2F;</span><br><span class="line">spi_setup(spi);</span><br><span class="line">icm20608dev.private_data &#x3D; spi; &#x2F;* 设置私有数据 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 初始化ICM20608内部寄存器 *&#x2F;</span><br><span class="line">icm20608_reginit();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 传统匹配方式ID列表 *&#x2F;</span><br><span class="line">static const struct spi_device_id icm20608_id[] &#x3D; &#123;</span><br><span class="line">&#123;&quot;alientek,icm20608&quot;, 0&#125;,  </span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备树匹配列表 *&#x2F;</span><br><span class="line">static const struct of_device_id icm20608_of_match[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;alientek,icm20608&quot; &#125;,</span><br><span class="line">&#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* SPI驱动结构体 *&#x2F;</span><br><span class="line">static struct spi_driver icm20608_driver &#x3D; &#123;</span><br><span class="line">.probe &#x3D; icm20608_probe,</span><br><span class="line">.remove &#x3D; icm20608_remove,</span><br><span class="line">.driver &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">   .name &#x3D; &quot;icm20608&quot;,</span><br><span class="line">   .of_match_table &#x3D; icm20608_of_match, </span><br><span class="line">   &#125;,</span><br><span class="line">.id_table &#x3D; icm20608_id,</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动入口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init icm20608_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return spi_register_driver(&amp;icm20608_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动出口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __exit icm20608_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">spi_unregister_driver(&amp;icm20608_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-下-SPI-驱动框架&quot;&gt;&lt;a href=&quot;#Linux-下-SPI-驱动框架&quot; class=&quot;headerlink&quot; title=&quot;Linux 下 SPI 驱动框架&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux&lt;/strong&gt; &lt;strong&gt;下&lt;/stro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-I2C驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/17/Linux%E9%A9%B1%E5%8A%A8-I2C%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/17/Linux%E9%A9%B1%E5%8A%A8-I2C%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-17T05:51:36.000Z</published>
    <updated>2021-04-17T14:05:56.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-I2C-驱动框架"><a href="#Linux-I2C-驱动框架" class="headerlink" title="Linux I2C 驱动框架"></a><strong>Linux I2C</strong> <strong>驱动框架</strong></h1><p>裸机篇中编写 AP3216C 驱动的四个文件：bsp_i2c.c、bsp_i2c.h、bsp_ap3216c.c 和 bsp_ap3216c.h。其中前两个是 I.MX6U 的 IIC 接口驱动，后两个文 件是 AP3216C 这个 I2C 设备驱动文件。相当于有两部分驱动： I2C 主机驱动、I2C 设备驱动。 </p><p>对于 I2C 主机驱动，一旦编写完成就不需要再做修改，其他的 I2C 设备直接调用主机驱动提供的 API 函数完成读写操作即可。这个正好符合 Linux 的驱动分离与分层的思想，因此 Linux内核也将 I2C 驱动分为两部分：<br>①、I2C 总线驱动，I2C 总线驱动就是 SOC 的 I2C 控制器驱动，也叫做 I2C 适配器驱动。<br>②、I2C 设备驱动，I2C 设备驱动就是针对具体的 I2C 设备而编写的驱动。</p><h2 id="I2C-总线驱动"><a href="#I2C-总线驱动" class="headerlink" title="I2C 总线驱动"></a><strong>I2C</strong> <strong>总线驱动</strong></h2><p>platform 是虚拟出来的一条总线，目的是为了实现总线、设备、驱动框架。。对于 I2C 而言，不需要虚拟出一条总线，直接使用 I2C 总线即可。I2C 总线驱动重点是 I2C 适配器(也就是 SOC 的 I2C 接口控制器)驱动，这里要用到 两个重要的数据结构：i2c_adapter 和 i2c_algorithm，Linux 内核将 SOC 的 I2C 适配器(控制器) 抽象成 i2c_adapter，i2c_adapter 结构体定义在 include/linux/i2c.h 文件中，结构体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_adapter &#123;</span><br><span class="line">    struct module *owner;</span><br><span class="line">    unsigned int class; &#x2F;* classes to allow probing for *&#x2F;</span><br><span class="line">    const struct i2c_algorithm *algo; &#x2F;* 总线访问算法 *&#x2F;</span><br><span class="line">    void *algo_data;</span><br><span class="line">………………</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于一个 I2C 适配器，肯定要对外提供读写 API 函数，设备驱动程序可以使用这些 API 函数来完成读写操作。i2c_algorithm 就是 I2C 适配器与 IIC 设备进行通信的方法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_algorithm &#123;</span><br><span class="line">    ......</span><br><span class="line">    int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);</span><br><span class="line">    int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr, unsigned short flags,</span><br><span class="line">    char read_write, u8 command, int size, union i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">    &#x2F;* To determine what the adapter supports *&#x2F;</span><br><span class="line">    u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;master_xfer 就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之间的通信。</span><br><span class="line">&#x2F;&#x2F;smbus_xfer 就是 SMBUS 总线的传输函数。</span><br></pre></td></tr></table></figure><p>综上所述，I2C 总线驱动(I2C 适配器驱动)的主要工作就是初始化 i2c_adapter 结构体变量，然后设置 i2c_algorithm 中的 master_xfer 函数。</p><p>完成初始化以后通过 i2c_add_numbered_adapter或 i2c_add_adapter 这两个函数向系统注册设置好的 i2c_adapter，如果要删除 I2C 适配器的话使用 i2c_del_adapter 函数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int i2c_add_adapter(struct i2c_adapter *adapter)</span><br><span class="line">int i2c_add_numbered_adapter(struct i2c_adapter *adap)</span><br><span class="line">&#x2F;&#x2F;这两个函数的区别在于 i2c_add_adapter 使用动态的总线号，而 i2c_add_numbered_adapter</span><br><span class="line">使用静态总线号。</span><br><span class="line">&#x2F;&#x2F;adapter 或 adap：要添加到 Linux 内核中的 i2c_adapter，也就是 I2C 适配器。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br><span class="line"></span><br><span class="line">void i2c_del_adapter(struct i2c_adapter * adap)</span><br><span class="line">&#x2F;&#x2F;adap：要删除的 I2C 适配器。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p>一般 SOC 的 I2C 总线驱动都是由半导体厂商编写的，比如 I.MX6U 的 I2C 适配器驱动 NXP 已经编写好了，这个不需要用户去编写。只要专注于 I2C 设备驱 动即可。</p><h2 id="I2C-设备驱动"><a href="#I2C-设备驱动" class="headerlink" title="I2C 设备驱动"></a>I2C 设备驱动</h2><p>I2C 设备驱动重点关注两个数据结构：i2c_client 和 i2c_driver，i2c_client 就是描述设备信息的，i2c_driver 描述驱动内容，类似于 platform_driver。 </p><h3 id="1、i2c-client-结构体"><a href="#1、i2c-client-结构体" class="headerlink" title="1、i2c_client 结构体"></a>1、i2c_client 结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_client &#123;</span><br><span class="line">    unsigned short flags; &#x2F;* 标志 *&#x2F;</span><br><span class="line">    unsigned short addr; &#x2F;* 芯片地址，7 位，存在低 7 位*&#x2F;</span><br><span class="line">    ......</span><br><span class="line">    char name[I2C_NAME_SIZE]; &#x2F;* 名字 *&#x2F;</span><br><span class="line">    struct i2c_adapter *adapter; &#x2F;* 对应的 I2C 适配器 *&#x2F;</span><br><span class="line">    struct device dev; &#x2F;* 设备结构体 *&#x2F;</span><br><span class="line">    int irq; &#x2F;* 中断 *&#x2F;</span><br><span class="line">    struct list_head detected;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个设备对应一个 i2c_client，每检测到一个 I2C 设备就会给这个 I2C 设备分配一个i2c_client。 </p><h3 id="2、i2c-driver-结构体"><a href="#2、i2c-driver-结构体" class="headerlink" title="2、i2c_driver 结构体"></a>2、i2c_driver 结构体</h3><p>i2c_driver 类似 platform_driver，是编写 I2C 设备驱动重点要处理的内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_driver &#123;</span><br><span class="line">………………</span><br><span class="line">int (*probe)(struct i2c_client *, const struct i2c_device_id *);</span><br><span class="line">………………</span><br><span class="line">struct device_driver driver;</span><br><span class="line">const struct i2c_device_id *id_table;</span><br><span class="line">………………</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;当 I2C 设备和驱动匹配成功以后 probe 函数就会执行，和 platform 驱动一样。 </span><br><span class="line">&#x2F;&#x2F;device_driver 驱动结构体，如果使用设备树的话，需要设置 device_driver 的of_match_table 成员变量，也就是驱动的兼容(compatible)属性。 </span><br><span class="line">&#x2F;&#x2F;id_table 是传统的、未使用设备树的设备匹配 ID 表。 </span><br></pre></td></tr></table></figure><p>重点工作就是构建 i2c_driver，构建完成以后需要向Linux 内核注册这个 i2c_driver。i2c_driver 注册函数为 int i2c_register_driver，注销 I2C 设备驱动的时候需要将前面注册的 i2c_driver 从 Linux 内核中注销掉，需要用到 i2c_del_driver 函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i2c_register_driver(struct module *owner,  struct i2c_driver *driver)</span><br><span class="line">&#x2F;&#x2F;owner：一般为 THIS_MODULE。</span><br><span class="line">&#x2F;&#x2F;driver：要注册的 i2c_driver。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br><span class="line"></span><br><span class="line">void i2c_del_driver(struct i2c_driver *driver)</span><br><span class="line">&#x2F;&#x2F;driver：要注销的 i2c_driver。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p><strong>i2c_driver 的注册示例代码如下：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* i2c 驱动的 probe 函数 *&#x2F;</span><br><span class="line">static int xxx_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">&#123; </span><br><span class="line">    &#x2F;* 函数具体程序 *&#x2F;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* i2c 驱动的 remove 函数 *&#x2F;</span><br><span class="line">static int ap3216c_remove(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* 函数具体程序 *&#x2F;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 传统匹配方式 ID 列表 *&#x2F;</span><br><span class="line">static const struct i2c_device_id xxx_id[] &#x3D; &#123;</span><br><span class="line">    &#123;&quot;xxx&quot;, 0&#125;, </span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备树匹配列表 *&#x2F;</span><br><span class="line">static const struct of_device_id xxx_of_match[] &#x3D; &#123;</span><br><span class="line">    &#123; .compatible &#x3D; &quot;xxx&quot; &#125;,</span><br><span class="line">    &#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* i2c 驱动结构体 *&#x2F;</span><br><span class="line">static struct i2c_driver xxx_driver &#x3D; &#123;</span><br><span class="line">    .probe &#x3D; xxx_probe,</span><br><span class="line">    .remove &#x3D; xxx_remove,</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .name &#x3D; &quot;xxx&quot;,</span><br><span class="line">    .of_match_table &#x3D; xxx_of_match,</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table &#x3D; xxx_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动入口函数 *&#x2F;</span><br><span class="line">static int __init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    ret &#x3D; i2c_add_driver(&amp;xxx_driver);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动出口函数 *&#x2F;</span><br><span class="line">static void __exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">i2c_del_driver(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure><p>i2c_device_id，无设备树的时候匹配 ID 表。</p><p>of_device_id，设备树所使用的匹配表。</p><p>i2c_driver，当 I2C 设备和 I2C 驱动匹配成功以后 probe 函数就会执行，这些和 platform 驱动一样，probe 函数里面基本就是标准的字符设备驱动那一套了。 </p><h2 id="I2C-设备和驱动匹配过程"><a href="#I2C-设备和驱动匹配过程" class="headerlink" title="I2C 设备和驱动匹配过程"></a>I2C 设备和驱动匹配过程</h2><p>I2C 设备和驱动的匹配过程是由 I2C 核心来完成的，drivers/i2c/i2c-core.c 就是 I2C 的核心部分。</p><p>设备和驱动的匹配过程也是由 I2C 总线完成的，I2C 总线的数据结构为 i2c_bus_type，定义 在 drivers/i2c/i2c-core.c 文件，i2c_bus_type 内容如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type i2c_bus_type &#x3D; &#123;</span><br><span class="line">    .name &#x3D; &quot;i2c&quot;,</span><br><span class="line">    .match &#x3D; i2c_device_match,&#x2F;&#x2F;.match 就是 I2C 总线的设备和驱动匹配函数，</span><br><span class="line">    .probe &#x3D; i2c_device_probe,</span><br><span class="line">    .remove &#x3D; i2c_device_remove,</span><br><span class="line">    .shutdown &#x3D; i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="I-MX6U-的-I2C-适配器驱动分析"><a href="#I-MX6U-的-I2C-适配器驱动分析" class="headerlink" title="I.MX6U 的 I2C 适配器驱动分析"></a>I.MX6U 的 I2C 适配器驱动分析</h1><p>Linux 下的 I2C 驱动框架，重点分为 I2C 适配器驱动和 I2C 设备驱动， 其中 I2C 适配器驱动就是 SOC 的 I2C 控制器驱动。I2C 设备驱动是需要用户根据不同的 I2C 设备去编写，而 I2C 适配器驱动一般都是 SOC 厂商去编写的，比如 NXP 就编写好了 I.MX6U 的I2C 适配器驱动。I.MX6U 的 I2C 适配器驱动是个标准的 platform 驱动，虽然 I2C 总线为别的设备提供了一种I2C总线驱动框架，但是 I2C 适配器却是 platform驱动。</p><p>在 imx6ull.dtsi 文件中找到 I.MX6U 的 I2C1 控制器节点，i2c1 节点的 compatible 属性值有两个：“fsl,imx6ul-i2c”和“fsl,imx21- i2c”。I.MX6U 的 I2C 适配器驱动文件为 drivers/i2c/busses/i2c-imx.c中设备树 ID为“fsl,imx21-i2c”属性值，设备树中 i2c1 节点的 compatible 属性值就是与此匹配上的。因此 i2c-imx.c 文件就是 I.MX6U 的 I2C 适配器驱动文件。 当设备和驱动匹配成功以后 i2c_imx_probe 函数就会执行，i2c_imx_probe 函数就会完成 I2C 适配器初始化工作。 </p><p>i2c_imx_probe 函数主要的工作就是一下两点：</p><ul><li>初始化 i2c_adapter，设置 i2c_algorithm 为 i2c_imx_algo，最后向 Linux 内核注册i2c_adapter。</li><li>初始化 I2C1 控制器的相关寄存器。</li></ul><p>i2c_imx_algo 包含 I2C1 适配器与 I2C 设备的通信函数 master_xfer，i2c_imx_probe中设置i2c_adapter的algo成员变量为i2c_imx_algo，也就是设置 i2c_algorithm。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct i2c_algorithm i2c_imx_algo &#x3D; &#123;</span><br><span class="line">    .master_xfer &#x3D; i2c_imx_xfer,</span><br><span class="line">    .functionality &#x3D; i2c_imx_func,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;.functionality用于返回此I2C适配器支持什么样的通信协议</span><br><span class="line">&#x2F;&#x2F;.master_xfer通过此函数来完成与 I2C 设备通信的</span><br></pre></td></tr></table></figure><p>functionality用于返回此I2C适配器支持什么样的通信协议，在这里 functionality 就是 i2c_imx_func 函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static u32 i2c_imx_func(struct i2c_adapter *adapter) &#123;</span><br><span class="line"> return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_READ_BLOCK_DATA; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>i2c_imx_xfer 函数，因为最终就是通过此函数来完成与 I2C 设备通信的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static int i2c_imx_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)</span><br><span class="line">&#123;</span><br><span class="line">………………</span><br><span class="line">&#x2F;* Start I2C transfer *&#x2F;</span><br><span class="line">result &#x3D; i2c_imx_start(i2c_imx);</span><br><span class="line"></span><br><span class="line">if (msgs[i].flags &amp; I2C_M_RD)</span><br><span class="line">result &#x3D; i2c_imx_read(i2c_imx, &amp;msgs[i], is_lastmsg);</span><br><span class="line">    else &#123;</span><br><span class="line">        if (i2c_imx-&gt;dma &amp;&amp; msgs[i].len &gt;&#x3D; DMA_THRESHOLD)</span><br><span class="line">        result &#x3D; i2c_imx_dma_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">        else</span><br><span class="line">        result &#x3D; i2c_imx_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ………………</span><br><span class="line">    i2c_imx_stop(i2c_imx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 i2c_imx_start 函数开启 I2C 通信。 </p><p>如果是从 I2C 设备读数据的话就调用 i2c_imx_read 函数</p><p>向 I2C 设备写数据，如果要用 DMA 的话就使用 i2c_imx_dma_write 函数来完成写数据。如果不使用 DMA 的话就使用 i2c_imx_write 函数完成写数据。 </p><p>I2C 通信完成以后调用 i2c_imx_stop 函数停止 I2C 通信。 </p><h1 id="I2C-设备驱动编写流程"><a href="#I2C-设备驱动编写流程" class="headerlink" title="I2C 设备驱动编写流程"></a>I2C 设备驱动编写流程</h1><p>I2C 适配器驱动 SOC 厂商已经替我们编写好了，我们需要做的就是编写具体的设备驱动</p><h3 id="1、I2C-设备信息描"><a href="#1、I2C-设备信息描" class="headerlink" title="1、I2C 设备信息描"></a>1、I2C 设备信息描</h3><p><strong>1、未使用设备树的时候</strong></p><p>首先肯定要描述 I2C 设备节点信息，在未使用设备树的时候需要在 BSP 里面使用 i2c_board_info 结构体来描述一个具体的 I2C 设备。i2c_board_info 结构体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_board_info &#123;</span><br><span class="line">    char type[I2C_NAME_SIZE]; &#x2F;* I2C 设备名字 *&#x2F;</span><br><span class="line">    unsigned short flags; &#x2F;* 标志 *&#x2F;</span><br><span class="line">    unsigned short addr; &#x2F;* I2C 器件地址 *&#x2F;</span><br><span class="line">    void *platform_data; </span><br><span class="line">    struct dev_archdata *archdata;</span><br><span class="line">    struct device_node *of_node;</span><br><span class="line">    struct fwnode_handle *fwnode;</span><br><span class="line">    int irq;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;type 和 addr 这两个成员变量是必须要设置的，一个是 I2C 设备的名字，一个是 I2C 设备的器件地址。</span><br></pre></td></tr></table></figure><p><strong>2、使用设备树的时候</strong></p><p>使用设备树的时候 I2C 设备信息通过在 i2c节点下创建子节点，然后在这个子节点内描述设备芯片的相关信息。</p><h3 id="2、I2C-设备数据收发处理流程"><a href="#2、I2C-设备数据收发处理流程" class="headerlink" title="2、I2C 设备数据收发处理流程"></a>2、I2C 设备数据收发处理流程</h3><p>I2C 设备驱动首先要做的就是初始化 i2c_driver 并向 Linux 内核注册。当设备和驱动匹配以后 i2c_driver 里面的 probe 函数就会执行，probe 函数里面所做的就是字符设备驱动那一套了。一般需要在 probe 函数里面初始化 I2C 设备，要初始化 I2C 设备就必须能够对 I2C 设备寄存器进行读写操作，这里就要用到 i2c_transfer 函数了。i2c_transfer 函数最终会调用 I2C 适配器中 i2c_algorithm 里面的 master_xfer 函数，对于 I.MX6U 而言就是<br>i2c_imx_xfer 这个函数。i2c_transfer 函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</span><br><span class="line">&#x2F;&#x2F;adap：所使用的 I2C 适配器，i2c_client 会保存其对应的 i2c_adapter。</span><br><span class="line">&#x2F;&#x2F;msgs：I2C 要发送的一个或多个消息。</span><br><span class="line">&#x2F;&#x2F;num：消息数量，也就是 msgs 的数量。</span><br><span class="line">&#x2F;&#x2F;返回值：负值，失败，其他非负值，发送的 msgs数量。</span><br></pre></td></tr></table></figure><p>参数msgs ，这是一个 i2c_msg 类型的指针参数，Linux 内核使用 i2c_msg 结构体来描述一个消息，使用 i2c_transfer 函数发送数据之前要先构建好 i2c_msg。i2c_msg 结构体定义 在 include/uapi/linux/i2c.h 文件中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_msg &#123;</span><br><span class="line">    __u16 addr; &#x2F;* 从机地址 *&#x2F;</span><br><span class="line">    __u16 flags; &#x2F;* 标志 *&#x2F;</span><br><span class="line">    #define I2C_M_TEN 0x0010</span><br><span class="line">    #define I2C_M_RD 0x0001</span><br><span class="line">    #define I2C_M_STOP 0x8000</span><br><span class="line">    #define I2C_M_NOSTART 0x4000</span><br><span class="line">    #define I2C_M_REV_DIR_ADDR 0x2000 </span><br><span class="line">    #define I2C_M_IGNORE_NAK 0x1000 </span><br><span class="line">    #define I2C_M_NO_RD_ACK 0x0800</span><br><span class="line">    #define I2C_M_RECV_LEN 0x0400</span><br><span class="line">    __u16 len; &#x2F;* 消息(本msg)长度 *&#x2F;</span><br><span class="line">    __u8 *buf; &#x2F;* 消息数据 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用 i2c_transfer 进行 I2C 数据收发的示例代码如下：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 设备结构体 *&#x2F;</span><br><span class="line">struct xxx_dev &#123; </span><br><span class="line">......</span><br><span class="line">void *private_data; &#x2F;* 私有数据，一般会设置为 i2c_client *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* @description : 读取 I2C 设备多个寄存器数据</span><br><span class="line">* @param – dev : I2C 设备</span><br><span class="line">* @param – reg : 要读取的寄存器首地址</span><br><span class="line">* @param – val : 读取到的数据</span><br><span class="line">* @param – len : 要读取的数据长度</span><br><span class="line">* @return : 操作结果</span><br><span class="line">*&#x2F;</span><br><span class="line">static int xxx_read_regs(struct xxx_dev *dev, u8 reg, void *val, int len)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct i2c_msg msg[2];</span><br><span class="line">    struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    &#x2F;* msg[0]，第一条写消息，发送要读取的寄存器首地址 *&#x2F;</span><br><span class="line">    msg[0].addr &#x3D; client-&gt;addr; &#x2F;* I2C 器件地址 *&#x2F;</span><br><span class="line">    msg[0].flags &#x3D; 0; &#x2F;* 标记为发送数据 *&#x2F;</span><br><span class="line">    msg[0].buf &#x3D; &amp;reg; &#x2F;* 读取的首地址 *&#x2F;</span><br><span class="line">    msg[0].len &#x3D; 1; &#x2F;* reg 长度 *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* msg[1]，第二条读消息，读取寄存器数据 *&#x2F;</span><br><span class="line">    msg[1].addr &#x3D; client-&gt;addr; &#x2F;* I2C 器件地址 *&#x2F;</span><br><span class="line">    msg[1].flags &#x3D; I2C_M_RD; &#x2F;* 标记为读取数据 *&#x2F;</span><br><span class="line">    msg[1].buf &#x3D; val; &#x2F;* 读取数据缓冲区 *&#x2F;</span><br><span class="line">    msg[1].len &#x3D; len; &#x2F;* 要读取的数据长度 *&#x2F;</span><br><span class="line">    ret &#x3D; i2c_transfer(client-&gt;adapter, msg, 2);</span><br><span class="line">    if(ret &#x3D;&#x3D; 2) &#123;</span><br><span class="line">        ret &#x3D; 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    ret &#x3D; -EREMOTEIO;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* @description : 向 I2C 设备多个寄存器写入数据</span><br><span class="line">* @param – dev : 要写入的设备结构体</span><br><span class="line">* @param – reg : 要写入的寄存器首地址</span><br><span class="line">* @param – val : 要写入的数据缓冲区</span><br><span class="line">* @param – len : 要写入的数据长度</span><br><span class="line">* @return : 操作结果</span><br><span class="line">*&#x2F;</span><br><span class="line">static s32 xxx_write_regs(struct xxx_dev *dev, u8 reg, u8 *buf, u8 len)</span><br><span class="line">&#123;</span><br><span class="line">    u8 b[256];</span><br><span class="line">    struct i2c_msg msg;</span><br><span class="line">    struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    b[0] &#x3D; reg; &#x2F;* 寄存器首地址 *&#x2F;</span><br><span class="line">    memcpy(&amp;b[1],buf,len); &#x2F;* 将要发送的数据拷贝到数组 b 里面 *&#x2F;</span><br><span class="line"></span><br><span class="line">    msg.addr &#x3D; client-&gt;addr; &#x2F;* I2C 器件地址 *&#x2F;</span><br><span class="line">    msg.flags &#x3D; 0; &#x2F;* 标记为写数据 *&#x2F;</span><br><span class="line">    msg.buf &#x3D; b; &#x2F;* 要发送的数据缓冲区 *&#x2F;</span><br><span class="line">    msg.len &#x3D; len + 1; &#x2F;* 要发送的数据长度 *&#x2F;</span><br><span class="line">    return i2c_transfer(client-&gt;adapter, &amp;msg, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设备结构体里面添加一个执行void的指针成员变量private_data，此成员变量用于保存设备的私有数据。在 I2C 设备驱动中我们一般将其指向 I2C 设备对应的i2c_client。 </p><p>xxx_read_regs 函数用于读取 I2C 设备多个寄存器数据。定义了一个i2c_msg 数组，2 个数组元素，因为 I2C 读取数据的时候要先发送要读取的寄存器地址，然后再读取数据，所以需要准备两个 i2c_msg。一个用于发送寄存器地址，一个用于读取寄存器值。对于 msg[0]，将 flags 设置为 0，表示写数据。msg[0]的 addr 是 I2C 设备的器件地址，msg[0]的 buf成员变量就是要读取的寄存器地址。对于 msg[1]，将 flags 设置为 I2C_M_RD，表示读取数据。msg[1]的 buf 成员变量用于保存读取到的数据，len 成员变量就是要读取的数据长度。调用i2c_transfer 函数完成 I2C 数据读操作。</p><p>xxx_write_regs 函数用于向 I2C 设备多个寄存器写数据，I2C 写操作要比读操作简单一点，因此一个 i2c_msg 即可。数组 b 用于存放寄存器首地址和要发送的数据，第 59 行设置 msg 的 addr 为 I2C 器件地址。第 60 行设置 msg 的 flags 为 0，也就是写数据。第 62 行设置要发送的数据，也就是数组 b。第 63 行设置 msg 的 len 为 len+1，因为要加上一个字节的寄存器地址。最后通过 i2c_transfer 函数完成向 I2C 设备的写操作。</p><h1 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a><strong>实验程序编写</strong></h1><h2 id="1、修改设备树"><a href="#1、修改设备树" class="headerlink" title="1、修改设备树"></a>1、修改设备树</h2><p><strong>1.IO 修改或添加</strong></p><p>首先肯定是要修改 IO，AP3216C 用到了 I2C1 接口，I.MX6U-ALPHA 开发板上的 I2C1 接口使用到了 UART4_TXD 和 UART4_RXD，因此肯定要在设备树里面设置这两个 IO。如果要用 到 AP3216C 的中断功能的话还需要初始化 AP_INT 对应的 GIO1_IO01 这个 IO，不使用中断功能。因此只需要设置 UART4_TXD 和 UART4_RXD 这两个 IO，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_i2c1: i2c1grp &#123; </span><br><span class="line">    fsl,pins &#x3D; &lt; </span><br><span class="line">        MX6UL_PAD_UART4_TX_DATA__I2C1_SCL 0x4001b8b0</span><br><span class="line">        MX6UL_PAD_UART4_RX_DATA__I2C1_SDA 0x4001b8b0</span><br><span class="line">    &gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pinctrl_i2c1 就是 I2C1 的 IO 节点，这里将 UART4_TXD 和 UART4_RXD 这两个 IO 分别复用为 I2C1_SCL 和 I2C1_SDA，电气属性都设置为 0x4001b8b0。 </p><p><strong>2.在 i2c1 节点追加 ap3216c 子节点</strong></p><p>将 i2c1 节点里面原有的 mag3110 和 fxls8471 这两个 I2C 子节点删除，然后添加 ap3216c子节点信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123; </span><br><span class="line">    clock-frequency &#x3D; &lt;100000&gt;;</span><br><span class="line">    pinctrl-names &#x3D; &quot;default&quot;; </span><br><span class="line">    pinctrl-0 &#x3D; &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">    status &#x3D; &quot;okay&quot;; </span><br><span class="line">    </span><br><span class="line">    ap3216c@1e &#123; </span><br><span class="line">        compatible &#x3D; &quot;alientek,ap3216c&quot;; </span><br><span class="line">        reg &#x3D; &lt;0x1e&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第 7 行，ap3216c 子节点，@后面的“1e”是 ap3216c 的器件地址。<br>第 8 行，设置 compatible 值为“alientek,ap3216c”。<br>第 9 行，reg 属性也是设置 ap3216c 器件地址的，因此 reg 设置为 0x1e。<br>设备树修改完成以后使用“make dtbs”重新编译一下，然后使用新的设备树启动 Linux 内核。/sys/bus/i2c/devices 目录下存放着所有 I2C 设备，如果设备树修改正确的话，会在/sys/bus/i2c/devices 目录下看到一个名为“0-001e”的子目录，“0-001e”就是 ap3216c 的设备目录，“1e”就是 ap3216c 器件地址。</p><h2 id="2、AP3216C-驱动编写"><a href="#2、AP3216C-驱动编写" class="headerlink" title="2、AP3216C 驱动编写"></a>2、AP3216C 驱动编写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: ap3216c.c</span><br><span class="line">描述   : AP3216C驱动程序</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">struct ap3216c_dev &#123;</span><br><span class="line">void *private_data;&#x2F;* 私有数据 *&#x2F;</span><br><span class="line">unsigned short ir, als, ps;&#x2F;* 三个光传感器数据 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">static struct ap3216c_dev ap3216cdev;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 从ap3216c读取多个寄存器数据</span><br><span class="line"> * @param - dev:  ap3216c设备</span><br><span class="line"> * @param - reg:  要读取的寄存器首地址</span><br><span class="line"> * @param - val:  读取到的数据</span><br><span class="line"> * @param - len:  要读取的数据长度</span><br><span class="line"> * @return : 操作结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ap3216c_read_regs(struct ap3216c_dev *dev, u8 reg, void *val, int len)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">struct i2c_msg msg[2];</span><br><span class="line">struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">&#x2F;* msg[0]为发送要读取的首地址 *&#x2F;</span><br><span class="line">msg[0].addr &#x3D; client-&gt;addr;&#x2F;* ap3216c地址 *&#x2F;</span><br><span class="line">msg[0].flags &#x3D; 0;&#x2F;* 标记为发送数据 *&#x2F;</span><br><span class="line">msg[0].buf &#x3D; &amp;reg;&#x2F;* 读取的首地址 *&#x2F;</span><br><span class="line">msg[0].len &#x3D; 1;&#x2F;* reg长度*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* msg[1]读取数据 *&#x2F;</span><br><span class="line">msg[1].addr &#x3D; client-&gt;addr;&#x2F;* ap3216c地址 *&#x2F;</span><br><span class="line">msg[1].flags &#x3D; I2C_M_RD;&#x2F;* 标记为读取数据*&#x2F;</span><br><span class="line">msg[1].buf &#x3D; val;&#x2F;* 读取数据缓冲区 *&#x2F;</span><br><span class="line">msg[1].len &#x3D; len;&#x2F;* 要读取的数据长度*&#x2F;</span><br><span class="line"></span><br><span class="line">ret &#x3D; i2c_transfer(client-&gt;adapter, msg, 2);</span><br><span class="line">if(ret &#x3D;&#x3D; 2) &#123;</span><br><span class="line">ret &#x3D; 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">printk(&quot;i2c rd failed&#x3D;%d reg&#x3D;%06x len&#x3D;%d\n&quot;,ret, reg, len);</span><br><span class="line">ret &#x3D; -EREMOTEIO;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 向ap3216c多个寄存器写入数据</span><br><span class="line"> * @param - dev:  ap3216c设备</span><br><span class="line"> * @param - reg:  要写入的寄存器首地址</span><br><span class="line"> * @param - val:  要写入的数据缓冲区</span><br><span class="line"> * @param - len:  要写入的数据长度</span><br><span class="line"> * @return   :   操作结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static s32 ap3216c_write_regs(struct ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)</span><br><span class="line">&#123;</span><br><span class="line">u8 b[256];</span><br><span class="line">struct i2c_msg msg;</span><br><span class="line">struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">b[0] &#x3D; reg;&#x2F;* 寄存器首地址 *&#x2F;</span><br><span class="line">memcpy(&amp;b[1],buf,len);&#x2F;* 将要写入的数据拷贝到数组b里面 *&#x2F;</span><br><span class="line"></span><br><span class="line">msg.addr &#x3D; client-&gt;addr;&#x2F;* ap3216c地址 *&#x2F;</span><br><span class="line">msg.flags &#x3D; 0;&#x2F;* 标记为写数据 *&#x2F;</span><br><span class="line"></span><br><span class="line">msg.buf &#x3D; b;&#x2F;* 要写入的数据缓冲区 *&#x2F;</span><br><span class="line">msg.len &#x3D; len + 1;&#x2F;* 要写入的数据长度 *&#x2F;</span><br><span class="line"></span><br><span class="line">return i2c_transfer(client-&gt;adapter, &amp;msg, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 读取ap3216c指定寄存器值，读取一个寄存器</span><br><span class="line"> * @param - dev:  ap3216c设备</span><br><span class="line"> * @param - reg:  要读取的寄存器</span><br><span class="line"> * @return   :   读取到的寄存器值</span><br><span class="line"> *&#x2F;</span><br><span class="line">static unsigned char ap3216c_read_reg(struct ap3216c_dev *dev, u8 reg)</span><br><span class="line">&#123;</span><br><span class="line">u8 data &#x3D; 0;</span><br><span class="line"></span><br><span class="line">ap3216c_read_regs(dev, reg, &amp;data, 1);</span><br><span class="line">return data;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;private_data;</span><br><span class="line">return i2c_smbus_read_byte_data(client, reg);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 向ap3216c指定寄存器写入指定的值，写一个寄存器</span><br><span class="line"> * @param - dev:  ap3216c设备</span><br><span class="line"> * @param - reg:  要写的寄存器</span><br><span class="line"> * @param - data: 要写入的值</span><br><span class="line"> * @return   :    无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void ap3216c_write_reg(struct ap3216c_dev *dev, u8 reg, u8 data)</span><br><span class="line">&#123;</span><br><span class="line">u8 buf &#x3D; 0;</span><br><span class="line">buf &#x3D; data;</span><br><span class="line">ap3216c_write_regs(dev, reg, &amp;buf, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 读取AP3216C的数据，读取原始数据，包括ALS,PS和IR, 注意！</span><br><span class="line"> *: 如果同时打开ALS,IR+PS的话两次数据读取的时间间隔要大于112.5ms</span><br><span class="line"> * @param - ir: ir数据</span><br><span class="line"> * @param - ps : ps数据</span><br><span class="line"> * @param - ps : als数据 </span><br><span class="line"> * @return : 无。</span><br><span class="line"> *&#x2F;</span><br><span class="line">void ap3216c_readdata(struct ap3216c_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i &#x3D;0;</span><br><span class="line">    unsigned char buf[6];</span><br><span class="line"></span><br><span class="line">&#x2F;* 循环读取所有传感器数据 *&#x2F;</span><br><span class="line">    for(i &#x3D; 0; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[i] &#x3D; ap3216c_read_reg(dev, AP3216C_IRDATALOW + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(buf[0] &amp; 0X80) &#x2F;* IR_OF位为1,则数据无效 *&#x2F;</span><br><span class="line">dev-&gt;ir &#x3D; 0;</span><br><span class="line">else &#x2F;* 读取IR传感器的数据   *&#x2F;</span><br><span class="line">dev-&gt;ir &#x3D; ((unsigned short)buf[1] &lt;&lt; 2) | (buf[0] &amp; 0X03); </span><br><span class="line"></span><br><span class="line">dev-&gt;als &#x3D; ((unsigned short)buf[3] &lt;&lt; 8) | buf[2];&#x2F;* 读取ALS传感器的数据  *&#x2F;  </span><br><span class="line"></span><br><span class="line">    if(buf[4] &amp; 0x40)&#x2F;* IR_OF位为1,则数据无效 *&#x2F;</span><br><span class="line">dev-&gt;ps &#x3D; 0;    </span><br><span class="line">else &#x2F;* 读取PS传感器的数据    *&#x2F;</span><br><span class="line">dev-&gt;ps &#x3D; ((unsigned short)(buf[5] &amp; 0X3F) &lt;&lt; 4) | (buf[4] &amp; 0X0F); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 打开设备</span><br><span class="line"> * @param - inode : 传递给驱动的inode</span><br><span class="line"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span><br><span class="line"> *   一般在open的时候将private_data指向设备结构体。</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ap3216c_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data &#x3D; &amp;ap3216cdev;</span><br><span class="line"></span><br><span class="line">&#x2F;* 初始化AP3216C *&#x2F;</span><br><span class="line">ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, 0x04);&#x2F;* 复位AP3216C *&#x2F;</span><br><span class="line">mdelay(50);&#x2F;* AP3216C复位最少10ms *&#x2F;</span><br><span class="line">ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, 0X03);&#x2F;* 开启ALS、PS+IR *&#x2F;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 从设备读取数据 </span><br><span class="line"> * @param - filp : 要打开的设备文件(文件描述符)</span><br><span class="line"> * @param - buf : 返回给用户空间的数据缓冲区</span><br><span class="line"> * @param - cnt : 要读取的数据长度</span><br><span class="line"> * @param - offt : 相对于文件首地址的偏移</span><br><span class="line"> * @return : 读取的字节数，如果为负值，表示读取失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static ssize_t ap3216c_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off)</span><br><span class="line">&#123;</span><br><span class="line">short data[3];</span><br><span class="line">long err &#x3D; 0;</span><br><span class="line"></span><br><span class="line">struct ap3216c_dev *dev &#x3D; (struct ap3216c_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">ap3216c_readdata(dev);</span><br><span class="line"></span><br><span class="line">data[0] &#x3D; dev-&gt;ir;</span><br><span class="line">data[1] &#x3D; dev-&gt;als;</span><br><span class="line">data[2] &#x3D; dev-&gt;ps;</span><br><span class="line">err &#x3D; copy_to_user(buf, data, sizeof(data));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 关闭&#x2F;释放设备</span><br><span class="line"> * @param - filp : 要关闭的设备文件(文件描述符)</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ap3216c_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* AP3216C操作函数 *&#x2F;</span><br><span class="line">static const struct file_operations ap3216c_ops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; ap3216c_open,</span><br><span class="line">.read &#x3D; ap3216c_read,</span><br><span class="line">.release &#x3D; ap3216c_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : i2c驱动的probe函数，当驱动与</span><br><span class="line">  *                    设备匹配以后此函数就会执行</span><br><span class="line">  * @param - client  : i2c设备</span><br><span class="line">  * @param - id      : i2c设备ID</span><br><span class="line">  * @return          : 0，成功;其他负值,失败</span><br><span class="line">  *&#x2F;</span><br><span class="line">static int ap3216c_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 1、构建设备号 *&#x2F;</span><br><span class="line">&#x2F;* 2、注册设备 *&#x2F;</span><br><span class="line">&#x2F;* 3、创建类 *&#x2F;</span><br><span class="line">&#x2F;* 4、创建设备 *&#x2F;</span><br><span class="line"></span><br><span class="line">ap3216cdev.private_data &#x3D; client;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</span><br><span class="line"> * @param - client : i2c设备</span><br><span class="line"> * @return          : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int ap3216c_remove(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 删除设备 *&#x2F;</span><br><span class="line">&#x2F;* 注销掉类和设备 *&#x2F;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 传统匹配方式ID列表 *&#x2F;</span><br><span class="line">static const struct i2c_device_id ap3216c_id[] &#x3D; &#123;</span><br><span class="line">&#123;&quot;alientek,ap3216c&quot;, 0&#125;,  </span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备树匹配列表 *&#x2F;</span><br><span class="line">static const struct of_device_id ap3216c_of_match[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;alientek,ap3216c&quot; &#125;,</span><br><span class="line">&#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* i2c驱动结构体 *&#x2F;</span><br><span class="line">static struct i2c_driver ap3216c_driver &#x3D; &#123;</span><br><span class="line">.probe &#x3D; ap3216c_probe,</span><br><span class="line">.remove &#x3D; ap3216c_remove,</span><br><span class="line">.driver &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">   .name &#x3D; &quot;ap3216c&quot;,</span><br><span class="line">   .of_match_table &#x3D; ap3216c_of_match, </span><br><span class="line">   &#125;,</span><br><span class="line">.id_table &#x3D; ap3216c_id,</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>ap3216c 设备结构体的 private_data 成员变量用于存放 ap3216c 对应的 i2c_client。 ir、als 和 ps 分别存储 AP3216C 的 IR、ALS 和 PS 数据。定义一个 ap3216c_dev 类型的设备结构体变量 ap3216cdev。 </p><p>ap3216c_read_regs 函数实现多字节读取，但是 AP3216C 好像不支持连续多字节读取，此函数在测试其他 I2C 设备的时候可以实现多给字节连续读取，但是在 AP3216C 上不能连续读取多个字节。不过读取一个字节没有问题的。ap3216c_write_regs 函数实现连续多字节写操作。</p><p>ap3216c_read_reg 函数用于读取 AP3216C 的指定寄存器数据，用于一个寄存器的数据读取。ap3216c_write_reg 函数用于向 AP3216C 的指定寄存器写入数据，用于一个寄存器的数据写操作。</p><p>ap3216c_probe 函数，当 I2C 设备和驱动匹配成功以后此函数就会执行，platform 驱动框架一样。此函数前面都是标准的字符设备注册代码，最后面会将此函数的第一个参数 client 传递给 ap3216cdev 的 private_data 成员变量。</p><p>ap3216c_id 匹配表，i2c_device_id 类型。用于传统的设备和驱动匹配，也就是没有使用设备树的时候。<br>ap3216c_of_match 匹配表，of_device_id 类型，用于设备树设备和驱动匹配。这里只写了一个 compatible 属性，值为“alientek,ap3216c”。</p><p>ap3216c_driver 结构体变量，i2c_driver 类型。</p><p>驱动入口函数 ap3216c_init，此函数通过调用 i2c_add_driver 来向 Linux 内核注册 i2c_driver，也就是ap3216c_driver。</p><p>驱动出口函数 ap3216c_exit，此函数通过调用 i2c_del_driver 来注销掉前面<br>注册的 ap3216c_driver。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-I2C-驱动框架&quot;&gt;&lt;a href=&quot;#Linux-I2C-驱动框架&quot; class=&quot;headerlink&quot; title=&quot;Linux I2C 驱动框架&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux I2C&lt;/strong&gt; &lt;strong&gt;驱动框架&lt;/str</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-RTC驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/17/Linux%E9%A9%B1%E5%8A%A8-RTC%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/17/Linux%E9%A9%B1%E5%8A%A8-RTC%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-17T05:04:41.000Z</published>
    <updated>2021-04-17T05:49:15.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-内核-RTC-驱动"><a href="#Linux-内核-RTC-驱动" class="headerlink" title="Linux 内核 RTC 驱动"></a><strong>Linux</strong> <strong>内核</strong> <strong>RTC</strong> <strong>驱动</strong></h1><p>RTC 设备驱动是一个标准的字符设备驱动，应用程序通过 open、release、read、write 和 ioctl等函数完成对 RTC 设备的操作。Linux 内核将 RTC 设备抽象为 rtc_device 结构体，因此 RTC 设备驱动就是申请并初始化<br>rtc_device，最后将 rtc_device 注册到 Linux 内核里面，这样 Linux 内核就有一个 RTC 设备的。<br> rtc_device 结构体，此结构体定义在 include/linux/rtc.h 文件中，结构体内容如下(删除条件编译)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct rtc_device</span><br><span class="line">&#123;</span><br><span class="line">    struct device dev; &#x2F;* 设备 *&#x2F;</span><br><span class="line">    struct module *owner;</span><br><span class="line"></span><br><span class="line">    int id; &#x2F;* ID *&#x2F; </span><br><span class="line">    char name[RTC_DEVICE_NAME_SIZE]; &#x2F;* 名字 *&#x2F;</span><br><span class="line"></span><br><span class="line">    const struct rtc_class_ops *ops; &#x2F;* RTC 设备底层操作函数 *&#x2F;</span><br><span class="line">    struct mutex ops_lock;</span><br><span class="line"></span><br><span class="line">    struct cdev char_dev; &#x2F;* 字符设备 *&#x2F;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">………………</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>RTC 设备的操作是用一个 rtc_class_ops 类型的操作集合(结构体)来表示的，就是是 ops 成员变量，这是一个 rtc_class_ops 类型的指针变量。rtc_class_ops为 RTC 设备的最底层操作函数集合，包括从 RTC 设备中读取时间、向 RTC 设备写入新的时间值等。因此，rtc_class_ops 是需要用户根据所使用的 RTC 设备编写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct rtc_class_ops &#123;</span><br><span class="line">    int (*open)(struct device *);</span><br><span class="line">    void (*release)(struct device *);</span><br><span class="line">    int (*ioctl)(struct device *, unsigned int, unsigned long);</span><br><span class="line">    int (*read_time)(struct device *, struct rtc_time *);</span><br><span class="line">    int (*set_time)(struct device *, struct rtc_time *);</span><br><span class="line">    int (*read_alarm)(struct device *, struct rtc_wkalrm *);</span><br><span class="line">    int (*set_alarm)(struct device *, struct rtc_wkalrm *);</span><br><span class="line">    int (*proc)(struct device *, struct seq_file *);</span><br><span class="line">    int (*set_mmss64)(struct device *, time64_t secs);</span><br><span class="line">    int (*set_mmss)(struct device *, unsigned long secs);</span><br><span class="line">    int (*read_callback)(struct device *, int data);</span><br><span class="line">    int (*alarm_irq_enable)(struct device *, unsigned int enabled);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>rtc_class_ops 中的这些函数只是最底层的 RTC 设备操作函数，并不是提供给应用层的file_operations 函数操作集。RTC 是个字符设备，那么肯定有字符设备的 file_operations 函数操作集，Linux 内核提供了一个 RTC 通用字符设备驱动文件，文件名为 drivers/rtc/rtc-dev.c，rtc-dev.c 文件提供了所有 RTC 设备共用的 file_operations 函数操作集，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations rtc_dev_fops &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">    .llseek &#x3D; no_llseek,</span><br><span class="line">    .read &#x3D; rtc_dev_read,</span><br><span class="line">    .poll &#x3D; rtc_dev_poll,</span><br><span class="line">    .unlocked_ioctl &#x3D; rtc_dev_ioctl,</span><br><span class="line">    .open &#x3D; rtc_dev_open,</span><br><span class="line">    .release &#x3D; rtc_dev_release,</span><br><span class="line">    .fasync &#x3D; rtc_dev_fasync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>rtc_dev_fops是标准的字符设备操作集。应用程序可以通过 ioctl 函数来设置/读取时间、设置/读取闹钟的操作，那么驱动中对应的 rtc_dev_ioctl 函数就会执行， rtc_dev_ioctl 最终会通过操作 rtc_class_ops 中的 read_time、set_time 等函数来对具体 RTC 设备的读写操作。</p><p> 如果向rtc_dev_ioctl 函数传入参数cmd=RTC_RD_TIME (时间读取命令)，就会调用 rtc_read_time 函数会调用_ _rtc_read_time函数，__rtc_read_time 函数再通过调用 rtc_class_ops 中的read_time 函数来从 RTC 设备中获取当前时间。rtc_dev_ioctl 函数对其他的命令处理都是类似的，传入参数cmd=RTC_ALM_READ (闹钟读取命令) ，就会调用 rtc_read_alarm ，而 rtc_read_alarm 函数再经过层层调用，最终会调用 rtc_class_ops 中的 read_alarm 函数来获取闹钟值。 </p><p><img src="Linux%E9%A9%B1%E5%8A%A8-RTC%E9%A9%B1%E5%8A%A8.assets/1618637052010.png" alt="1618637052010"></p><p>当 rtc_class_ops 准备好以后需要将其注册到 Linux 内核中，可以使用rtc_device_register函数完成注册工作。此函数会申请一个rtc_device并且初始化这个rtc_device，最后向调用者返回这个 rtc_device，当卸载 RTC 驱动的时候需要调用 rtc_device_unregister 函数来注销注册的 rtc_device，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct rtc_device *rtc_device_register(const char *name, struct device *dev,</span><br><span class="line">const struct rtc_class_ops *ops, struct module *owner)</span><br><span class="line">&#x2F;&#x2F;name：设备名字。</span><br><span class="line">&#x2F;&#x2F;dev：设备。</span><br><span class="line">&#x2F;&#x2F;ops：RTC 底层驱动函数集。</span><br><span class="line">&#x2F;&#x2F;owner：驱动模块拥有者。</span><br><span class="line">&#x2F;&#x2F;返回值：注册成功的话就返回 rtc_device，错误的话会返回一个负值。</span><br><span class="line"></span><br><span class="line">void rtc_device_unregister(struct rtc_device *rtc)</span><br><span class="line">&#x2F;&#x2F;rtc：要删除的 rtc_device。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><h1 id="I-MX6U-内部-RTC-驱动分析"><a href="#I-MX6U-内部-RTC-驱动分析" class="headerlink" title="I.MX6U 内部 RTC 驱动分析"></a><strong>I.MX6U</strong> <strong>内部</strong> <strong>RTC</strong> <strong>驱动分析</strong></h1><p>I.MX6U 的 RTC 驱动不用自己编写，因为 NXP 已经写好了。其实对于大多数的 SOC 来讲，内部 RTC 驱动都不需要我们去编写，半导体厂商会编写好。得看一下这些原厂是怎么编写 RTC 驱动的。 </p><p>分析驱动，先从设备树入手，打开 imx6ull.dtsi，在里面找到如下 snvs_rtc 设备节点，设置兼容属性 compatible 的值为“fsl,sec-v4.0-mon-rtc-lp”。驱动文件rtc-snvs.c中的设备树 ID 表有一条 compatible 属性，值为“fsl,sec-v4.0-mon-rtc-lp”，因此 imx6ull.dtsi 中的 snvs_rtc 设备节点会和此驱动匹配。该驱动文件采用标准的 platform 驱动框架，当设备和驱动匹配成功以后 snvs_rtc_probe 函数就会执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static int snvs_rtc_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    res &#x3D; platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line"></span><br><span class="line">    mmio &#x3D; devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">    ………………</span><br><span class="line">    data-&gt;regmap &#x3D; devm_regmap_init_mmio(&amp;pdev-&gt;dev, mmio, &amp;snvs_rtc_config);</span><br><span class="line">    ………………</span><br><span class="line">    data-&gt;irq &#x3D; platform_get_irq(pdev, 0);</span><br><span class="line">    ………………</span><br><span class="line">    &#x2F;* Initialize glitch detect *&#x2F;</span><br><span class="line">regmap_write(data-&gt;regmap, data-&gt;offset + SNVS_LPPGDR,SNVS_LPPGDR_INIT);</span><br><span class="line"></span><br><span class="line">&#x2F;* Clear interrupt status *&#x2F;</span><br><span class="line">regmap_write(data-&gt;regmap, data-&gt;offset + SNVS_LPSR,0xffffffff);</span><br><span class="line"></span><br><span class="line">&#x2F;* Enable RTC *&#x2F;</span><br><span class="line">snvs_rtc_enable(data, true);</span><br><span class="line"></span><br><span class="line">    ret &#x3D; devm_request_irq(&amp;pdev-&gt;dev, data-&gt;irq,snvs_rtc_irq_handler,</span><br><span class="line">    IRQF_SHARED, &quot;rtc alarm&quot;, &amp;pdev-&gt;dev);</span><br><span class="line">    </span><br><span class="line">    data-&gt;rtc &#x3D; devm_rtc_device_register(&amp;pdev-&gt;dev, pdev-&gt;name,</span><br><span class="line">&amp;snvs_rtc_ops, THIS_MODULE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 platform_get_resource 函数从设备树中获取到 RTC 外设寄存器基地址。 </p><p>调用函数 devm_ioremap_resource 完成内存映射，得到 RTC 外设寄存器物理基地址对应的虚拟地址。 </p><p>Linux3.1 引入了一个全新的 regmap 机制，regmap 用于提供一套方便的 API 函数去操作底层硬件寄存器，以提高代码的可重用性。snvs-rtc.c 文件会采用 regmap 机制来读写RTC 底层硬件寄存器。这里使用 devm_regmap_init_mmio 函数将 RTC 的硬件寄存器转化为regmap 形式，这样 regmap 机制的 regmap_write、regmap_read 等 API 函数才能操作寄存器。</p><p>调用platform_get_irq从设备树中获取 RTC 的中断号。 </p><p>调用regmap_write设置 RTC_ LPPGDR 寄存器值为 SNVS_LPPGDR_INIT= 0x41736166，这里就是用的 regmap 机制的 regmap_write 函数完成对寄存器进行写操作。 </p><p>调用regmap_write设置 RTC_LPSR 寄存器，写入 0xffffffff，LPSR 是 RTC 状态寄存器，写 1 清零， 因此这一步就是清除 LPSR 寄存器。</p><p>调用 snvs_rtc_enable 函数使能 RTC，此函数会设置 RTC_LPCR 寄存器。 </p><p>调用devm_request_irq函数请求RTC中断，中断服务函数为snvs_rtc_irq_handler，用于 RTC 闹钟中断。 </p><p>调用 devm_rtc_device_register 函数向系统注册 rtc_devcie，RTC 底层驱动集为 snvs_rtc_ops。snvs_rtc_ops操作集包含了读取/设置RTC时间，读取/设置闹钟等函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static const struct rtc_class_ops snvs_rtc_ops &#x3D; &#123;</span><br><span class="line">    .read_time &#x3D; snvs_rtc_read_time,</span><br><span class="line">    .set_time &#x3D; snvs_rtc_set_time,</span><br><span class="line">    .read_alarm &#x3D; snvs_rtc_read_alarm,</span><br><span class="line">    .set_alarm &#x3D; snvs_rtc_set_alarm,</span><br><span class="line">    .alarm_irq_enable &#x3D; snvs_rtc_alarm_irq_enable,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-内核-RTC-驱动&quot;&gt;&lt;a href=&quot;#Linux-内核-RTC-驱动&quot; class=&quot;headerlink&quot; title=&quot;Linux 内核 RTC 驱动&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux&lt;/strong&gt; &lt;strong&gt;内核&lt;/strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-LCD驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-LCD%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-LCD%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-16T15:59:08.000Z</published>
    <updated>2021-04-16T16:41:54.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Framebuffer-设备"><a href="#Framebuffer-设备" class="headerlink" title="Framebuffer 设备"></a><strong>Framebuffer</strong> <strong>设备</strong></h1><p>裸机 LCD 驱动编写流程如下：<br>①、初始化 I.MX6U 的 eLCDIF 控制器，重点是 LCD 屏幕宽(width)、高(height)、hspw、hbp、hfp、vspw、vbp 和 vfp 等信息。<br>②、初始化 LCD 像素时钟。<br>③、设置 RGBLCD 显存。<br>④、应用程序直接通过操作显存来操作 LCD，实现在 LCD 上显示字符、图片等信息。</p><p>在 Linux 中应用程序最终也是通过操作 RGB LCD 的显存来实现在 LCD 上显示字符、图片<br>等信息。在裸机中我们可以随意的分配显存，但是在 Linux 系统中内存的管理很严格，显存是<br>需要申请的，不是你想用就能用的。而且因为虚拟内存的存在，驱动程序设置的显存和应用程<br>序访问的显存要是同一片物理内存。</p><p>为了解决上述问题，Framebuffer 诞生了， Framebuffer 翻译过来就是帧缓冲，简称 fb，以后的 Linux 学习中见到“Framebuffer”或者“fb”的话第一反应应该想到 RGBLCD或者显示设备。fb 是一种机制，将系统中所有跟显示有关的硬件以及软件集合起来，虚拟出一个 fb 设备，当编写好 LCD 驱动以后会生成一个名为/dev/fbX(X=0~n)的设备，应用程序通过访问/dev/fbX 这个设备就可以访问 LCD。</p><p>/dev/fbX是个字符设备，因此肯定有file_operations 操作集，fb 的 file_operations 操作集定义在 drivers/video/fbdev/core/fbmem.c 文件中。</p><h1 id="LCD-驱动简析"><a href="#LCD-驱动简析" class="headerlink" title="LCD 驱动简析"></a><strong>LCD</strong> <strong>驱动简析</strong></h1><p>不同分辨率的 LCD 屏幕其 eLCDIF 控制器驱动代码都是一样的，只需要修改好对应的屏幕参数即可。屏幕参数信息属于屏幕设备信息内容，这些肯定是要放到设备树中的，因此我们本章实验的主要工作就是修改设备树，</p><p><strong>Linux 下 Framebuffer 驱动的编写流程，</strong></p><p>Linux 内核将所有的 Framebuffer 抽象为一个叫做 fb_info 的结构 体，fb_info 结构体包含了 Framebuffer 设备的完整属性和操作集合，因此每一个 Framebuffer 设备都必须有一个 fb_info。换言之就是，LCD 的驱动就是构建 fb_info，并且向系统注册 fb_info的过程。fb_info 结构体定义在 include/linux/fb.h 文件里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct fb_info &#123;</span><br><span class="line">        …………</span><br><span class="line">        struct fb_var_screeninfo var; &#x2F;* 当前可变参数 *&#x2F;</span><br><span class="line">        struct fb_fix_screeninfo fix; &#x2F;* 当前固定参数 *&#x2F;</span><br><span class="line">        struct fb_monspecs monspecs; &#x2F;* 当前显示器特性 *&#x2F;</span><br><span class="line">        struct work_struct queue; &#x2F;* 帧缓冲事件队列 *&#x2F;</span><br><span class="line">        struct fb_pixmap pixmap; &#x2F;* 图像硬件映射 *&#x2F;</span><br><span class="line">        struct fb_pixmap sprite; &#x2F;* 光标硬件映射 *&#x2F;</span><br><span class="line">        struct fb_cmap cmap; &#x2F;* 当前调色板 *&#x2F;</span><br><span class="line">        struct list_head modelist; &#x2F;* 当前模式列表 *&#x2F;</span><br><span class="line">        struct fb_videomode *mode; &#x2F;* 当前视频模式 *&#x2F;</span><br><span class="line">        ......</span><br><span class="line">        struct fb_ops *fbops; &#x2F;* 帧缓冲操作函数集 *&#x2F; </span><br><span class="line">        struct device *device; &#x2F;* 父设备 *&#x2F;</span><br><span class="line">        struct device *dev; &#x2F;* 当前 fb 设备 *&#x2F;</span><br><span class="line">        int class_flag; &#x2F;* 私有 sysfs 标志 *&#x2F;</span><br><span class="line">        ......</span><br><span class="line">        char __iomem *screen_base; &#x2F;* 虚拟内存基地址(屏幕显存) *&#x2F;</span><br><span class="line">        unsigned long screen_size; &#x2F;* 虚拟内存大小(屏幕显存大小) *&#x2F;</span><br><span class="line">        void *pseudo_palette; &#x2F;* 伪 16 位调色板 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>fb_info 结构体的成员变量很多，我们重点关注 var、fix、fbops、screen_base、screen_size<br>和 pseudo_palette。mxsfb_probe 函数的主要工作内容为：<br>①、申请 fb_info。<br>②、初始化 fb_info 结构体中的各个成员变量。<br>③、初始化 eLCDIF 控制器。<br>④、使用 register_framebuffer 函数向 Linux 内核注册初始化好的 fb_info</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int register_framebuffer(struct fb_info *fb_info)</span><br><span class="line">&#x2F;&#x2F;fb_info：需要上报的 fb_info。</span><br><span class="line">&#x2F;&#x2F;返回值：0，成功；负值，失败。</span><br></pre></td></tr></table></figure><h1 id="LCD-驱动程序编写"><a href="#LCD-驱动程序编写" class="headerlink" title="LCD 驱动程序编写"></a>LCD 驱动程序编写</h1><p>6ULL 的 eLCDIF 接口驱动程序 NXP 已经编写好了，因此 LCD 驱动部分我们不需要去修改。我们需要做的就是按照所使用的 LCD 来修改设备树。重点要注意三个地方： </p><p>①、LCD 所使用的 IO 配置。 </p><p>②、LCD 屏幕节点修改，修改相应的属性值，换成我们所使用的 LCD 屏幕参数。 </p><p>③、LCD 背光节点信息修改，要根据实际所使用的背光 IO 来修改相应的设备节点信息。 </p><p><strong>1、LCD 屏幕 IO 配置</strong></p><p>首先要检查一下设备树中 LCD 所使用的 IO 配置，这个其实 NXP 都已经写好了，不需要修改，</p><p><strong>2、LCD 屏幕参数节点信息修改</strong></p><p>继续在 imx6ull-alientek-emmc.dts 文件中找到 lcdif 节点，节点内容如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;lcdif &#123; </span><br><span class="line">pinctrl-names &#x3D; &quot;default&quot;; </span><br><span class="line">pinctrl-0 &#x3D; &lt;&amp;pinctrl_lcdif_dat &#x2F;* 使用到的 IO *&#x2F;</span><br><span class="line">&amp;pinctrl_lcdif_ctrl</span><br><span class="line">&amp;pinctrl_lcdif_reset&gt;;</span><br><span class="line">display &#x3D; &lt;&amp;display0&gt;;</span><br><span class="line">status &#x3D; &quot;okay&quot;; 8 </span><br><span class="line">display0: display &#123; &#x2F;* LCD 属性信息 *&#x2F;</span><br><span class="line">bits-per-pixel &#x3D; &lt;16&gt;; &#x2F;* 一个像素占用几个 bit *&#x2F;</span><br><span class="line">bus-width &#x3D; &lt;24&gt;; &#x2F;* 总线宽度 *&#x2F;</span><br><span class="line"></span><br><span class="line">display-timings &#123;</span><br><span class="line">native-mode &#x3D; &lt;&amp;timing0&gt;; &#x2F;* 时序信息 *&#x2F;</span><br><span class="line">timing0: timing0 &#123; </span><br><span class="line">clock-frequency &#x3D; &lt;9200000&gt;; &#x2F;* LCD 像素时钟，单位 Hz *&#x2F;</span><br><span class="line">hactive &#x3D; &lt;480&gt;; &#x2F;* LCD X 轴像素个数 *&#x2F;</span><br><span class="line">vactive &#x3D; &lt;272&gt;; &#x2F;* LCD Y 轴像素个数 *&#x2F;</span><br><span class="line">hfront-porch &#x3D; &lt;8&gt;; &#x2F;* LCD hfp 参数 *&#x2F;</span><br><span class="line">hback-porch &#x3D; &lt;4&gt;; &#x2F;* LCD hbp 参数 *&#x2F;</span><br><span class="line">hsync-len &#x3D; &lt;41&gt;; &#x2F;* LCD hspw 参数 *&#x2F;</span><br><span class="line">vback-porch &#x3D; &lt;2&gt;; &#x2F;* LCD vbp 参数 *&#x2F;</span><br><span class="line">vfront-porch &#x3D; &lt;4&gt;; &#x2F;* LCD vfp 参数 *&#x2F;</span><br><span class="line">vsync-len &#x3D; &lt;10&gt;; &#x2F;* LCD vspw 参数 *&#x2F;</span><br><span class="line"></span><br><span class="line">hsync-active &#x3D; &lt;0&gt;; &#x2F;* hsync 数据线极性 *&#x2F;</span><br><span class="line">vsync-active &#x3D; &lt;0&gt;; &#x2F;* vsync 数据线极性 *&#x2F;</span><br><span class="line">de-active &#x3D; &lt;1&gt;; &#x2F;* de 数据线极性 *&#x2F;</span><br><span class="line">pixelclk-active &#x3D; &lt;0&gt;; &#x2F;* clk 数据线先极性 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第 3 行，pinctrl-0 属性，LCD 所使用的 IO 信息，这里用到了 pinctrl_lcdif_dat(RGB LCD 的 24 根数据线配置项)、pinctrl_lcdif_ctrl(RGB LCD 的 4 根控制线配置项，包括 CLK、ENABLE、VSYNC 和 HSYNC)和 pinctrl_lcdif_reset (LCD 复位 IO 信息节点)这三个 IO 相关的节点。<br>第 6 行，display 属性，指定 LCD 属性信息所在的子节点，这里为 display0，下面就是 display0子节点内容。<br>第 9<del>32 行，display0 子节点，描述 LCD 的参数信息，第 10 行的 bits-per-pixel 属性用于指明一个像素占用的 bit 数，默认为 16bit。将 LCD 配置为 RGB888 模式，因此一个像素点占用 24bit，bits-per-pixel 属性要改为 24。第 11 行的 bus-width 属性用于设置数据线宽度，因为要配置为 RGB888 模式，因此 bus-width 也要设置为 24。 第 13</del>30 行，这几行设置了 LCD 的时序参数信息，需要根据自己所使用的屏幕去修改。</p><p><strong>3、LCD 屏幕背光节点信息</strong></p><p>正点原子的 LCD 接口背光控制 IO 连接到了 I.MX6U 的 GPIO1_IO08 引脚上，GPIO1_IO08复用为 PWM1_OUT，通过 PWM 信号来控制 LCD 屏幕背光的亮度，正点原子 I.MX6U-ALPHA 开发板的 LCD 背光引脚和 NXP 官方 EVK 开发 板的背光引脚一样，因此背光的设备树节点是不需要修改的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> pinctrl_pwm1: pwm1grp &#123; </span><br><span class="line">     fsl,pins &#x3D; &lt; </span><br><span class="line">     MX6UL_PAD_GPIO1_IO08__PWM1_OUT 0x110b0</span><br><span class="line">    &gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pinctrl_pwm1 节点就是 GPIO1_IO08 的配置节点，设置 GPIO1_IO08 这个 IO 复用为 PWM1_OUT，并且设置电气属性值为 0x110b0。 </p><p>LCD 背光要用到 PWM1，因此也要设置 PWM1 节点，在 imx6ull.dtsi 文件中找到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwm1: pwm@02080000 &#123;</span><br><span class="line">    compatible &#x3D; &quot;fsl,imx6ul-pwm&quot;, &quot;fsl,imx27-pwm&quot;; </span><br><span class="line">    reg &#x3D; &lt;0x02080000 0x4000&gt;;</span><br><span class="line">    interrupts &#x3D; &lt;GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks &#x3D; &lt;&amp;clks IMX6UL_CLK_PWM1&gt;,</span><br><span class="line">    &lt;&amp;clks IMX6UL_CLK_PWM1&gt;;</span><br><span class="line">    clock-names &#x3D; &quot;ipg&quot;, &quot;per&quot;;</span><br><span class="line">    #pwm-cells &#x3D; &lt;2&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>imx6ull.dtsi 文件中的 pwm1 节点信息不要修改，如果要修改 pwm1 节点内容的话在imx6ull-alientek-emmc.dts 文件中修改。继续在 imx6ull-alientek-emmc.dts 文件中找到向 pwm1追加的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;pwm1 &#123; </span><br><span class="line">    pinctrl-names &#x3D; &quot;default&quot;; </span><br><span class="line">    pinctrl-0 &#x3D; &lt;&amp;pinctrl_pwm1&gt;;</span><br><span class="line">    status &#x3D; &quot;okay&quot;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设置 pwm1 所使用的 IO 为 pinctrl_pwm1，也就是GPIO1_IO08 这个 IO。将 status 设置为 okay。</p><p>需要一个节点来将 LCD 背光和 PWM1_OUT连接起来 ，Linux系统才知道PWM1_OUT 就是控制 LCD 背光的。 这 个节点就是backlight，backlight节点创建总结一下：<br>①、节点名称要为“backlight”。<br>②、节点的 compatible 属性值要为“pwm-backlight”，<br>③、pwms属性用于描述背光所使用的PWM以及PWM频率，比如要使用的pwm1，pwm 频率设置为 5KHz(<br>④、brightness-levels 属性描述亮度级别，范围为 0~255，0 表示 PWM 占空比为 0%，也就是亮度最低，255 表示 100%占空比，也就是亮度最高。<br>⑤、default-brightness-level 属性为默认亮度级别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">backlight &#123; </span><br><span class="line">    compatible &#x3D; &quot;pwm-backlight&quot;;</span><br><span class="line">    pwms &#x3D; &lt;&amp;pwm1 0 5000000&gt;;</span><br><span class="line">    brightness-levels &#x3D; &lt;0 4 8 16 32 64 128 255&gt;;</span><br><span class="line">    default-brightness-level &#x3D; &lt;6&gt;;</span><br><span class="line">    status &#x3D; &quot;okay&quot;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设置背光使用 pwm1，PWM 频率为 5KHz。设置背 8 级背光(0~7)，分别为 0、4、8、16、32、64、128、255，对应占空比为0%、1.57%、3.13%、6.27%、12.55%、25.1%、50.19%、100%。设置默认背光等级为 6，也就是 50.19%的亮度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Framebuffer-设备&quot;&gt;&lt;a href=&quot;#Framebuffer-设备&quot; class=&quot;headerlink&quot; title=&quot;Framebuffer 设备&quot;&gt;&lt;/a&gt;&lt;strong&gt;Framebuffer&lt;/strong&gt; &lt;strong&gt;设备&lt;/str</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-INPUT子系统</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-INPUT%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-04-16T12:58:20.000Z</published>
    <updated>2021-04-16T15:55:24.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="input-子系统"><a href="#input-子系统" class="headerlink" title="input 子系统"></a><strong>input</strong> <strong>子系统</strong></h1><p>按键、鼠标、键盘、触摸屏等都属于输入(input)设备，Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。输入设备本质上还是字符设备，只是在此基础上套上了 input 框架，用户只需要负责上报输入事件，比如按键值、坐标等信息，input 核心层负责处理这些事件。</p><p> input 子系统管理输入的子系统，和 pinctrl 和 gpio 子系统 一样，都是 Linux 内核针对某一类设备而创建的框架。比如按键输入、键盘、鼠标、触摸屏等等这些都属于输入设备，不同的输入设备所代表的含义不同，按键和键盘就是代表按键信息，鼠标和触摸屏代表坐标信息，因此在应用层的处理就不同。</p><p>对于驱动编写者而言不需要去关心应用层的事情，我们只需要按照要求上报这些输入事件即可。为此 input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点。input 子系统驱动分层模型，编写驱动程序的时候只需要关注中间的驱动层、核心层和事件层，这三个层的分工如下： </p><ul><li>驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。 </li><li>核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。 </li><li>事件层：主要和用户空间进行交互。</li></ul><h2 id="input-驱动编写流程"><a href="#input-驱动编写流程" class="headerlink" title="input 驱动编写流程"></a><strong>input</strong> <strong>驱动编写流程</strong></h2><p>input 核心层会向 Linux 内核注册一个字符设备，主设备号为 INPUT_MAJOR=13，因此input 子系统的所有设备主设备号都为 13，在使用 input 子系统处理输入设备的时候就不需要去注册字符设备了，只需要向系统注册一个 input_device 即可。 </p><h3 id="1、注册-input-dev"><a href="#1、注册-input-dev" class="headerlink" title="1、注册 input_dev"></a>1、注册 input_dev</h3><p>在使用 input 子系统的时候我们只需要注册一个 input 设备即可，input_dev 结构体表示 input设备，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct input_dev &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *phys;</span><br><span class="line">    const char *uniq;</span><br><span class="line">    struct input_id id;</span><br><span class="line"></span><br><span class="line">    unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line">    unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; &#x2F;* 事件类型的位图 *&#x2F;</span><br><span class="line">    unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; &#x2F;* 按键值的位图 *&#x2F;</span><br><span class="line">    unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; &#x2F;* 相对坐标的位图 *&#x2F; </span><br><span class="line">    ......</span><br><span class="line">    bool devres_managed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>evbit、keybit、relbit 等等都是存放不同事件对应的值。</p><p>evbit 表示输入事件类型，可选的事件类型定义在 include/uapi/linux/input.h 文件 中，要使用到按键，那么就需要注册 EV_KEY 事件，如果要使用连按功能的话还需要注册 EV_REP 事件。 事件类型如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define EV_SYN 0x00 &#x2F;* 同步事件 *&#x2F;</span><br><span class="line">#define EV_KEY 0x01 &#x2F;* 按键事件 *&#x2F;</span><br><span class="line">#define EV_REL 0x02 &#x2F;* 相对坐标事件 *&#x2F;</span><br><span class="line">#define EV_ABS 0x03 &#x2F;* 绝对坐标事件 *&#x2F;</span><br><span class="line">#define EV_MSC 0x04 &#x2F;* 杂项(其他)事件 *&#x2F;</span><br><span class="line">#define EV_SW 0x05 &#x2F;* 开关事件 *&#x2F;</span><br><span class="line">#define EV_LED 0x11 &#x2F;* LED *&#x2F;</span><br><span class="line">#define EV_SND 0x12 &#x2F;* sound(声音) *&#x2F;</span><br><span class="line">#define EV_REP 0x14 &#x2F;* 重复事件 *&#x2F;</span><br><span class="line">#define EV_FF 0x15 &#x2F;* 压力事件 *&#x2F;</span><br><span class="line">#define EV_PWR 0x16 &#x2F;* 电源事件 *&#x2F;</span><br><span class="line">#define EV_FF_STATUS 0x17 &#x2F;* 压力状态事件 *&#x2F;</span><br></pre></td></tr></table></figure><p>要使用按键事件，因此要用到 keybit，keybit 就是按键事件使用的位图，Linux 内核定义了很多按键值，这些按键值定义在 include/uapi/linux/input.h 文件中，按键值如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define KEY_RESERVED 0</span><br><span class="line">#define KEY_ESC 1</span><br><span class="line">#define KEY_7 8</span><br><span class="line">#define KEY_8 9</span><br><span class="line">#define KEY_9 10</span><br><span class="line">#define KEY_0 11</span><br><span class="line">......</span><br><span class="line">#define BTN_TRIGGER_HAPPY39 0x2e6</span><br><span class="line">#define BTN_TRIGGER_HAPPY40 0x2e7</span><br></pre></td></tr></table></figure><p>可以将开发板上的按键值设置为任意一个，可将 I.MX6U-ALPHA 开发板上的 KEY 按键值设置为 KEY_0。 </p><p>在编写 input 设备驱动的时候需要先申请一个 input_dev 结构体变量，使用input_allocate_device 函数来申请一个 input_dev，如果要注销的 input 设备的话需要使用 input_free_device 函数来释放掉前面申请到的input_dev</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct input_dev *input_allocate_device(void)</span><br><span class="line">&#x2F;&#x2F;参数：无。</span><br><span class="line">&#x2F;&#x2F;返回值：申请到的 input_dev。</span><br><span class="line">void input_free_device(struct input_dev *dev)</span><br><span class="line">&#x2F;&#x2F;dev：需要释放的 input_dev。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p>申请好一个 input_dev 以后就需要初始化这个 input_dev，需要初始化的内容主要为事件类型(evbit)和事件值(keybit)这两种。input_dev 初始化完成以后就需要向 Linux 内核注册 input_dev了，需要用到 input_register_device 函数，注销 input 驱动的时候也需要使用 input_unregister_device 函数来注销掉前面注册<br>的 input_dev。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int input_register_device(struct input_dev *dev)</span><br><span class="line">&#x2F;&#x2F;dev：要注册的 input_dev 。</span><br><span class="line">&#x2F;&#x2F;返回值：0，input_dev 注册成功；负值，input_dev 注册失败。</span><br><span class="line">void input_unregister_device(struct input_dev *dev)</span><br><span class="line">&#x2F;&#x2F;dev：要注销的 input_dev 。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p>综上所述，input_dev 注册过程如下：</p><p>①、使用 input_allocate_device 函数申请一个 input_dev。<br>②、初始化 input_dev 的事件类型以及事件值。<br>③、使用 input_register_device 函数向 Linux 系统注册前面初始化好的 input_dev。<br>④、卸载input驱动的时候需要先使用input_unregister_device函数注销掉注册的input_dev，然后使用 input_free_device 函数释放掉前面申请的 input_dev。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">struct input_dev *inputdev; &#x2F;* input 结构体变量 *&#x2F;</span><br><span class="line">&#x2F;* 驱动入口函数 *&#x2F;</span><br><span class="line">static int __init xxx_init(void) </span><br><span class="line">&#123; </span><br><span class="line">    ......</span><br><span class="line">    inputdev &#x3D; input_allocate_device(); &#x2F;* 申请 input_dev *&#x2F;</span><br><span class="line">    inputdev-&gt;name &#x3D; &quot;test_inputdev&quot;; &#x2F;* 设置 input_dev 名字 *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*********第一种设置事件和事件值的方法***********&#x2F;</span><br><span class="line">    __set_bit(EV_KEY, inputdev-&gt;evbit); &#x2F;* 设置产生按键事件 *&#x2F;</span><br><span class="line">    __set_bit(EV_REP, inputdev-&gt;evbit); &#x2F;* 重复事件 *&#x2F;</span><br><span class="line">    __set_bit(KEY_0, inputdev-&gt;keybit); &#x2F;*设置产生哪些按键值 *&#x2F;</span><br><span class="line">    &#x2F;************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*********第二种设置事件和事件值的方法***********&#x2F;</span><br><span class="line">    keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) |BIT_MASK(EV_REP);</span><br><span class="line">    keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |&#x3D; BIT_MASK(KEY_0);</span><br><span class="line">    &#x2F;************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*********第三种设置事件和事件值的方法***********&#x2F;</span><br><span class="line">    keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">    input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line">    &#x2F;************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 注册 input_dev *&#x2F;</span><br><span class="line">    input_register_device(inputdev);</span><br><span class="line">    ......</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动出口函数 *&#x2F;</span><br><span class="line">static void __exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    input_unregister_device(inputdev); &#x2F;* 注销 input_dev *&#x2F;</span><br><span class="line">    input_free_device(inputdev); &#x2F;* 删除 input_dev *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先定义一个 input_dev 结构体指针变量。 </p><p>驱动入口函数，在此函数中完成 input_dev 的申请、设置、注册等工作调用 input_allocate_device 函数申请一个 input_dev。设置 input 设备事件和按键值，这里用了三种方法来设置事件和按键值。调用 input_register_device 函数向 Linux内核注册 inputdev。 </p><p>驱动出口函数，调用 input_unregister_device 函数注销前面注册的input_dev，调用 input_free_device 函数删除前面申请的 input_dev。 </p><h3 id="2、上报输入事件"><a href="#2、上报输入事件" class="headerlink" title="2、上报输入事件"></a><strong>2、上报输入事件</strong></h3><p>向 Linux 内核注册好 input_dev 以后需要获取到具体的输入值，或者说是输入事件，然后将输入事件上报给 Linux 内核。比如按键，我们需要在按键中断处理函数，或者消抖定时器中断函数中将按键值上报给 Linux 内核，这样 Linux 内核才能获取到正确的输入值。不同的事件，其上报事件的 API 函数不同，</p><p> input_event 函数用于上报指定的事件以及对应的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)</span><br><span class="line">&#x2F;&#x2F;dev：需要上报的 input_dev。</span><br><span class="line">&#x2F;&#x2F;type: 上报的事件类型，比如 EV_KEY。</span><br><span class="line">&#x2F;&#x2F;code：事件码，也就是我们注册的按键值，比如 KEY_0、KEY_1 等等。</span><br><span class="line">&#x2F;&#x2F;value：事件值，比如 1 表示按键按下，0 表示按键松开。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p>input_event 函数可以上报所有的事件类型和事件值，Linux 内核也提供了其他的针对具体事件的上报函数，这些函数其实都用到了 input_event 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void input_report_key(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_rel(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">void input_report_abs(struct input_dev *dev, unsigned int code, int value)</span><br><span class="line">…………</span><br></pre></td></tr></table></figure><p>这些函数的本质就是 input_event 函数，如果要上报按键事件的话还是建议大家使用 input_report_key 函数。 </p><p>当上报事件以后还需要使用 input_sync 函数来告诉 Linux 内核 input 子系统上报结束，input_sync 函数本质是上报一个同步事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void input_sync(struct input_dev *dev)</span><br><span class="line">&#x2F;&#x2F;dev：需要上报同步事件的 input_dev。</span><br><span class="line">&#x2F;&#x2F;返回值：无。</span><br></pre></td></tr></table></figure><p>综上所述，按键的上报事件的参考代码如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 用于按键消抖的定时器服务函数 *&#x2F;</span><br><span class="line">void timer_function(unsigned long arg) </span><br><span class="line">&#123; </span><br><span class="line">    unsigned char value; </span><br><span class="line">    value &#x3D; gpio_get_value(keydesc-&gt;gpio); &#x2F;* 读取 IO 值 *&#x2F;</span><br><span class="line">    if(value &#x3D;&#x3D; 0)&#123; &#x2F;* 按下按键 *&#x2F;</span><br><span class="line">        &#x2F;* 上报按键值 *&#x2F;</span><br><span class="line">        input_report_key(inputdev, KEY_0, 1); &#x2F;* 最后一个参数 1，按下 *&#x2F;</span><br><span class="line">        input_sync(inputdev); &#x2F;* 同步事件 *&#x2F;</span><br><span class="line">    &#125; else &#123; &#x2F;* 按键松开 *&#x2F;</span><br><span class="line">        input_report_key(inputdev, KEY_0, 0); &#x2F;* 最后一个参数 0，松开 *&#x2F;</span><br><span class="line">        input_sync(inputdev); &#x2F;* 同步事件 *&#x2F;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取按键值，判断按键是否按下。 如果按键值为 0 那么表示按键被按下了，如果按键按下的话就要使用 input_report_key 函数向 Linux 系统上报按键值，比如向 Linux 系统通知 KEY_0 这个按键按下了。 如果按键值为 1 的话就表示按键没有按下，是松开的。向 Linux 系统通知KEY_0 这个按键没有按下或松开了。 </p><h3 id="input-event-结构体"><a href="#input-event-结构体" class="headerlink" title="input_event 结构体"></a>input_event 结构体</h3><p>Linux 内核使用 input_event 这个结构体来表示所有的输入事件，input_event 结构体定义在 include/uapi/linux/input.h 文件中，结构体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct input_event &#123;</span><br><span class="line">    struct timeval time;</span><br><span class="line">    __u16 type;</span><br><span class="line">    __u16 code;</span><br><span class="line">    __s32 value;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;time：时间，也就是此事件发生的时间，为 timeval 结构体类型</span><br><span class="line">&#x2F;&#x2F;type：事件类型，比如 EV_KEY，表示此次事件为按键事件，此成员变量为 16 位。</span><br><span class="line">&#x2F;&#x2F;code：事件码，比如在EV_KEY事件中code就表示具体的按键码，如：KEY_0、KEY_1这些按键。此成员变量为16位。</span><br><span class="line">&#x2F;&#x2F;value：值，比如EV_KEY事件中value就是按键值，表示按键有没有被按下，如果为 1 的话说明按键按下，如果为 0 的话说明按键没有被按下或者按键松开了。</span><br></pre></td></tr></table></figure><p><strong>time</strong>：时间，也就是此事件发生的时间，为 timeval 结构体类型，timeval 结构体定义如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct timeval &#123; </span><br><span class="line">    __kernel_time_t tv_sec; &#x2F;* 秒 *&#x2F;</span><br><span class="line">    __kernel_suseconds_t tv_usec; &#x2F;* 微秒 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;tv_sec 和 tv_usec 这两个成员变量都为 long 类型，也就是32位。</span><br></pre></td></tr></table></figure><p>input_envent 这个结构体非常重要，因为所有的输入设备最终都是按照 input_event 结构体呈现给用户的，用户应用程序可以通过 input_event 来获取到具体的输入事件或相关的值。</p><h2 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a><strong>实验程序编写</strong></h2><h3 id="驱动程序编写"><a href="#驱动程序编写" class="headerlink" title="驱动程序编写"></a><strong>驱动程序编写</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: keyinput.c</span><br><span class="line">描述   : Linux按键input子系统实验</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* keyinput设备结构体 *&#x2F;</span><br><span class="line">struct keyinput_dev&#123;</span><br><span class="line">struct input_dev *inputdev;&#x2F;* input结构体 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct keyinput_dev keyinputdev;&#x2F;* key input设备 *&#x2F;</span><br><span class="line"></span><br><span class="line">void timer_function(unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">value &#x3D; gpio_get_value(keydesc-&gt;gpio); &#x2F;* 读取IO值 *&#x2F;</span><br><span class="line">if(value &#x3D;&#x3D; 0)&#123; &#x2F;* 按下按键 *&#x2F;</span><br><span class="line">&#x2F;* 上报按键值 *&#x2F;</span><br><span class="line">&#x2F;&#x2F;input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 1);</span><br><span class="line">input_report_key(dev-&gt;inputdev, keydesc-&gt;value, 1);&#x2F;* 最后一个参数表示按下还是松开，1为按下，0为松开 *&#x2F;</span><br><span class="line">input_sync(dev-&gt;inputdev);</span><br><span class="line">&#125; else &#123; &#x2F;* 按键松开 *&#x2F;</span><br><span class="line">&#x2F;&#x2F;input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 0);</span><br><span class="line">input_report_key(dev-&gt;inputdev, keydesc-&gt;value, 0);</span><br><span class="line">input_sync(dev-&gt;inputdev);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int keyio_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 申请input_dev *&#x2F;</span><br><span class="line">keyinputdev.inputdev &#x3D; input_allocate_device();</span><br><span class="line">keyinputdev.inputdev-&gt;name &#x3D; KEYINPUT_NAME;</span><br><span class="line">#if 0</span><br><span class="line">&#x2F;* 初始化input_dev，设置产生哪些事件 *&#x2F;</span><br><span class="line">__set_bit(EV_KEY, keyinputdev.inputdev-&gt;evbit);&#x2F;* 设置产生按键事件          *&#x2F;</span><br><span class="line">__set_bit(EV_REP, keyinputdev.inputdev-&gt;evbit);&#x2F;* 重复事件，比如按下去不放开，就会一直输出信息  *&#x2F;</span><br><span class="line">&#x2F;* 初始化input_dev，设置产生哪些按键 *&#x2F;</span><br><span class="line">__set_bit(KEY_0, keyinputdev.inputdev-&gt;keybit);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |&#x3D; BIT_MASK(KEY_0);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">keyinputdev.inputdev-&gt;evbit[0] &#x3D; BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line"></span><br><span class="line">&#x2F;* 注册输入设备 *&#x2F;</span><br><span class="line">ret &#x3D; input_register_device(keyinputdev.inputdev);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit keyinput_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 释放input_dev *&#x2F;</span><br><span class="line">input_unregister_device(keyinputdev.inputdev);</span><br><span class="line">input_free_device(keyinputdev.inputdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设备结构体中定义一个 input_dev 指针变量。</p><p>在按键消抖定时器处理函数中上报输入事件，也就是使用 input_report_key函数上报按键事件以及按键值，最后使用 input_sync 函数上报一个同步事件，这一步一定得做！</p><p>使用 input_allocate_device 函数申请 input_dev，然后设置相应的事件以及事件码(也就是 KEY 模拟成那个按键，设置为 KEY_0)。最后使用 input_register_device函数向 Linux 内核注册 input_dev。 </p><p>当注销 input 设备驱动的时候使用 input_unregister_device 函数注销掉前面注册的 input_dev，最后使用 input_free_device 函数释放掉前面申请的 input_dev。</p><h3 id="编写测试-APP"><a href="#编写测试-APP" class="headerlink" title="编写测试 APP"></a><strong>编写测试</strong> <strong>APP</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: keyinputApp.c</span><br><span class="line">描述   : input子系统测试APP。</span><br><span class="line">使用方法 ：.&#x2F;keyinputApp &#x2F;dev&#x2F;input&#x2F;event1</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* 定义一个input_event变量，存放输入事件信息 *&#x2F;</span><br><span class="line">static struct input_event inputevent;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">fd &#x3D; open(filename, O_RDWR);</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">err &#x3D; read(fd, &amp;inputevent, sizeof(inputevent));</span><br><span class="line">        switch (inputevent.type) &#123;</span><br><span class="line">        case EV_KEY:</span><br><span class="line">            if (inputevent.code &lt; BTN_MISC) &#123; &#x2F;* 键盘键值 *&#x2F;</span><br><span class="line">            printf(&quot;key %d %s\r\n&quot;, inputevent.code, inputevent.value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            printf(&quot;button %d %s\r\n&quot;, inputevent.code, inputevent.value);</span><br><span class="line">            &#125;</span><br><span class="line">        break;</span><br><span class="line">            &#x2F;* 其他类型的事件，自行处理 *&#x2F;</span><br><span class="line">            case EV_REL:</span><br><span class="line">            break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux 内核会使用 input_event 结构体来表示输入事件，所以要获取按键输入信息，那么必须借助于 input_event 结构体。</p><p>向 Linux 内核成功注册 input_dev 设备以后，会在/dev/input 目录下生成一个名为“eventX(X=0….n)”的文件，这个/dev/input/eventX 就是对应的 input 设备文件。我们读取这个文件就可以获取到输入事件信息，使用read函数读取输入设备文件/dev/input/eventX，读取到的数据按照 input_event 结构体组织起来。获取到输入事件以后<br>(input_event 结构体类型)使用 switch case 语句来判断事件类型，设置的事件类型为 EV_KEY，因此只需要处理 EV_KEY 事件即可。</p><h2 id="自带按键驱动程序的使用"><a href="#自带按键驱动程序的使用" class="headerlink" title="自带按键驱动程序的使用"></a>自带按键驱动程序的使用</h2><p>要使用Linux内核自带的按键驱动程序很简单，只需要根据<br>Documentation/devicetree/bindings/input/gpio-keys.txt 这个文件在设备树中添加指定的设备节点即可，节点要求如下：<br>①、节点名字为“gpio-keys”。<br>②、gpio-keys 节点的 compatible 属性值一定要设置为“gpio-keys”。<br>③、所有的 KEY 都是 gpio-keys 的子节点，每个子节点可以用如下属性描述自己：<br>    gpios：KEY 所连接的 GPIO 信息。<br>    interrupts：KEY 所使用 GPIO 中断信息，不是必须的，可以不写。<br>    label：KEY 名字<br>    linux,code：KEY 要模拟的按键，也就是示例代码 58.1.2.4 中的这些按键。<br>④、如果按键要支持连按的话要加入 autorepeat。<br>打开 imx6ull-alientek-emmc.dts，根据上面的要求创建对应的设备节点，设备节点内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gpio-keys &#123; </span><br><span class="line">    compatible &#x3D; &quot;gpio-keys&quot;; </span><br><span class="line">    #address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">    #size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">    autorepeat; </span><br><span class="line">    key0 &#123; </span><br><span class="line">        label &#x3D; &quot;GPIO Key Enter&quot;; </span><br><span class="line">        linux,code &#x3D; &lt;KEY_ENTER&gt;;</span><br><span class="line">        gpios &#x3D; &lt;&amp;gpio1 18 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>autorepeat 表示按键支持连按。 </p><p>ALPHA 开发板 KEY 按键信息，名字设置为“GPIO Key Enter”，这里将 开发板上的 KEY 按键设置为“EKY_ENTER”这个按键，也就是回车键，效果和键盘上的回车键一样。将开发板上最后设置 KEY 所使用的 IO 为 GPIO1_IO18，一定要检查一下设备树看看此 GPIO 有没有被用到其他外设上，如果有的话要删除掉相关代码！ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;input-子系统&quot;&gt;&lt;a href=&quot;#input-子系统&quot; class=&quot;headerlink&quot; title=&quot;input 子系统&quot;&gt;&lt;/a&gt;&lt;strong&gt;input&lt;/strong&gt; &lt;strong&gt;子系统&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;按键、鼠标、键盘</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-MISC驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-MISC%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-MISC%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-16T11:05:33.000Z</published>
    <updated>2021-04-16T12:57:06.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MISC-设备驱动"><a href="#MISC-设备驱动" class="headerlink" title="MISC 设备驱动"></a><strong>MISC</strong> <strong>设备驱动</strong></h1><p>misc 的意思是混合、杂项的，因此 MISC 驱动也叫做杂项驱动，当某些外设无法进行分类的时候就可以使用 MISC 驱动。MISC 驱动其实就是最简单的字符设备驱动，通常嵌套在 platform 总线驱动中，实现复杂的驱动。</p><p>所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。随着 Linux字符设备驱动的不断增加，设备号变得越来越紧张，尤其是主设备号，MISC 设备驱动就用于解决此问题。MISC 设备会自动创建 cdev，不需要像我们以前那样手动创建，因此采用 MISC 设备驱动可以简化字符设备驱动的编写。</p><p>需要向 Linux 注册一个 miscdevice 设备，miscdevice是一个结构体，定义在文件 include/linux/miscdevice.h 中，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct miscdevice &#123;</span><br><span class="line">    int minor; &#x2F;* 子设备号 *&#x2F;</span><br><span class="line">    const char *name; &#x2F;* 设备名字 *&#x2F; </span><br><span class="line">    const struct file_operations *fops; &#x2F;* 设备操作集 *&#x2F;</span><br><span class="line">    struct list_head list;</span><br><span class="line">    struct device *parent;</span><br><span class="line">    struct device *this_device;</span><br><span class="line">    const struct attribute_group **groups;</span><br><span class="line">    const char *nodename;</span><br><span class="line">    umode_t mode;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;*minor 表示子设备号，MISC 设备的主设备号为 10，这个是固定的，需要用户指定子设备号，Linux系统已经预定义了一些MISC设备的子设备号，在使用时可以从这些预定义的子设备号中挑选一个，当然也可以自己定义，只要这个子设备号没有被其他设备使用接口。*&#x2F; </span><br><span class="line">&#x2F;&#x2F;name 就是此 MISC 设备名字，当此设备注册成功以后就会在&#x2F;dev 目录下生成一个名为 name的设备文件。</span><br><span class="line">&#x2F;&#x2F;fops 就是字符设备的操作集合，MISC 设备驱动最终是需要使用用户提供的 fops 操作集合。</span><br></pre></td></tr></table></figure><p>定义一个 MISC 设备(miscdevice 类型)以后需要设置 minor、name 和 fops 这三个成员变量。</p><p>当设置好 miscdevice 以后就需要使用 misc_register 函数向系统中注册一个 MISC 设备，卸载设备驱动模块的时候需要调用 misc_deregister 函数来注销掉 MISC 设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int misc_register(struct miscdevice * misc)</span><br><span class="line">&#x2F;&#x2F;misc：要注册的 MISC 设备。</span><br><span class="line">&#x2F;&#x2F;返回值：负数，失败；0，成功。</span><br><span class="line">int misc_deregister(struct miscdevice *misc)</span><br><span class="line">&#x2F;&#x2F;misc：要注销的 MISC 设备。</span><br><span class="line">&#x2F;&#x2F;返回值：负数，失败；0，成功。</span><br></pre></td></tr></table></figure><p>misc_register 函数会自动创建 cdev、设备等等， misc_deregister 函数会自动删除此前创建的 cdev、设备等等内容。</p><h1 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a>实验程序编写</h1><p>采用 platform 加 misc 的方式编写 beep 驱动，这也是实际的 Linux 驱动中很 </p><p>常用的方法。采用 platform 来实现总线、设备和驱动，misc 主要负责完成字符设备的创建。</p><p><strong>修改设备树</strong> </p><p><strong>驱动程序编写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: miscbeep.c</span><br><span class="line">描述   : 采用MISC的蜂鸣器驱动程序。</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">#define MISCBEEP_MINOR144&#x2F;* 子设备号 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* MISC设备结构体 *&#x2F;</span><br><span class="line">static struct miscdevice beep_miscdev &#x3D; &#123;</span><br><span class="line">.minor &#x3D; MISCBEEP_MINOR,</span><br><span class="line">.name &#x3D; MISCBEEP_NAME,</span><br><span class="line">.fops &#x3D; &amp;miscbeep_fops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : flatform驱动的probe函数，当驱动与</span><br><span class="line">  *                    设备匹配以后此函数就会执行</span><br><span class="line">  * @param - dev     : platform设备</span><br><span class="line">  * @return          : 0，成功;其他负值,失败</span><br><span class="line">  *&#x2F;</span><br><span class="line">static int miscbeep_probe(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 一般情况下会注册对应的字符设备，但是这里我们使用MISC设备</span><br><span class="line">   * 所以我们不需要自己注册字符设备驱动，只需要注册misc设备驱动即可</span><br><span class="line"> *&#x2F;</span><br><span class="line">ret &#x3D; misc_register(&amp;beep_miscdev);</span><br><span class="line">if(ret &lt; 0)&#123;</span><br><span class="line">printk(&quot;misc device register failed!\r\n&quot;);</span><br><span class="line">return -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : platform驱动的remove函数，移除platform驱动的时候此函数会执行</span><br><span class="line"> * @param - dev     : platform设备</span><br><span class="line"> * @return          : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int miscbeep_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 注销设备的时候关闭LED灯 *&#x2F;</span><br><span class="line">gpio_set_value(miscbeep.beep_gpio, 1);</span><br><span class="line"></span><br><span class="line">&#x2F;* 注销misc设备 *&#x2F;</span><br><span class="line">misc_deregister(&amp;beep_miscdev);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;* 匹配列表 *&#x2F;</span><br><span class="line"> static const struct of_device_id beep_of_match[] &#x3D; &#123;</span><br><span class="line">     &#123; .compatible &#x3D; &quot;atkalpha-beep&quot; &#125;,</span><br><span class="line">     &#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> &#x2F;* platform驱动结构体 *&#x2F;</span><br><span class="line">static struct platform_driver beep_driver &#x3D; &#123;</span><br><span class="line">     .driver     &#x3D; &#123;</span><br><span class="line">         .name   &#x3D; &quot;imx6ul-beep&quot;,         &#x2F;* 驱动名字，用于和设备匹配 *&#x2F;</span><br><span class="line">         .of_match_table &#x3D; beep_of_match, &#x2F;* 设备树匹配表          *&#x2F;</span><br><span class="line">     &#125;,</span><br><span class="line">     .probe      &#x3D; miscbeep_probe,</span><br><span class="line">     .remove     &#x3D; miscbeep_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动出口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init miscbeep_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return platform_driver_register(&amp;beep_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动出口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __exit miscbeep_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;beep_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MISC 设备 beep_miscdev，设置子设备号为 144，设置设备名字为“miscbeep”，这样当系统启动以后就会在/dev/目录下存在一个名为“miscbeep”的设备文件。设置 MISC 设备的操作函数集合，为 file_operations 类型。 </p><p>platform 框架的 probe 函数，当驱动与设备匹配以后此函数就会执行，首先在此函数中初始化 BEEP 所使用的 IO。最后通过 misc_register 函数向 Linux 内核注册MISC 设备，也就是前面定义的 beep_miscdev。 </p><p>platform 框架的 remove 函数，在此函数中调用 misc_deregister 函数来注销MISC 设备。 </p><p>第 163~196，标准的 platform 驱动</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MISC-设备驱动&quot;&gt;&lt;a href=&quot;#MISC-设备驱动&quot; class=&quot;headerlink&quot; title=&quot;MISC 设备驱动&quot;&gt;&lt;/a&gt;&lt;strong&gt;MISC&lt;/strong&gt; &lt;strong&gt;设备驱动&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;misc 的意思</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-platform设备驱动-设备树</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E8%AE%BE%E5%A4%87%E6%A0%91/</id>
    <published>2021-04-16T10:24:46.000Z</published>
    <updated>2021-04-16T11:04:01.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设备树下的-platform-驱动"><a href="#设备树下的-platform-驱动" class="headerlink" title="设备树下的 platform 驱动"></a><strong>设备树下的</strong> <strong>platform</strong> <strong>驱动</strong></h1><p>platform 驱动框架分为总线、设备和驱动，其中总线不需要我们这些驱动程序员去管理，这 </p><p>个是 Linux 内核提供的，我们在编写驱动的时候只要关注于设备和驱动的具体实现即可。在没 </p><p>有设备树的 Linux 内核下，我们需要分别编写并注册 platform_device 和 platform_driver，分别代 </p><p>表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就 </p><p>不需要我们去编写了，我们只需要实现 platform_driver 即可。在编写基于设备树的 platform 驱 </p><p>动的时候我们需要注意一下几点：</p><p><strong>1、在设备树中创建设备节点</strong></p><p>毫无疑问，肯定要先在设备树中创建设备节点来描述设备信息，重点是要设置好 compatible </p><p>属性的值，因为 platform 总线需要通过设备节点的 compatible 属性值来匹配驱动！</p><p><strong>2、编写 platform 驱动的时候要注意兼容属性</strong></p><p>在使用设备树的时候 platform 驱动会通过 of_match_table 来 </p><p>保存兼容性值，也就是表明此驱动兼容哪些设备。所以，of_match_table 将会尤为重要，</p><p><strong>3、编写 platform 驱动</strong></p><p>基于设备树的 platform 驱动和上一章无设备树的 platform 驱动基本一样，都是当驱动和设<br>备匹配成功以后就会执行 probe 函数。我们需要在 probe 函数里面执行字符设备驱动那一套，<br>当注销驱动模块的时候 remove 函数就会执行，都是大同小异的。</p><h2 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a><strong>实验程序编写</strong></h2><p>编写基于设备树的 platform 驱动，所以需要在设备树中添加设备节点，然后只需要编写 platform 驱动即可。 </p><p><strong>修改设备树文件</strong> </p><p><strong>platform</strong> <strong>驱动程序编写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: leddriver.c</span><br><span class="line">描述   : 设备树下的platform驱动</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: flatform驱动的probe函数，当驱动与</span><br><span class="line"> *   设备匹配以后此函数就会执行</span><br><span class="line"> * @param - dev : platform设备</span><br><span class="line"> * @return : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_probe(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">…………</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: platform驱动的remove函数，移除platform驱动的时候此函数会执行</span><br><span class="line"> * @param - dev : platform设备</span><br><span class="line"> * @return : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(leddev.led0, 1); &#x2F;* 卸载驱动的时候关闭LED *&#x2F;</span><br><span class="line"></span><br><span class="line">cdev_del(&amp;leddev.cdev);&#x2F;*  删除cdev *&#x2F;</span><br><span class="line">unregister_chrdev_region(leddev.devid, LEDDEV_CNT); &#x2F;* 注销设备号 *&#x2F;</span><br><span class="line">device_destroy(leddev.class, leddev.devid);</span><br><span class="line">class_destroy(leddev.class);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 匹配列表 *&#x2F;</span><br><span class="line">static const struct of_device_id led_of_match[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;atkalpha-gpioled&quot; &#125;,</span><br><span class="line">&#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* platform驱动结构体 *&#x2F;</span><br><span class="line">static struct platform_driver led_driver &#x3D; &#123;</span><br><span class="line">.driver&#x3D; &#123;</span><br><span class="line">.name&#x3D; &quot;imx6ul-led&quot;,&#x2F;* 驱动名字，用于和设备匹配 *&#x2F;</span><br><span class="line">.of_match_table&#x3D; led_of_match, &#x2F;* 设备树匹配表  *&#x2F;</span><br><span class="line">&#125;,</span><br><span class="line">.probe&#x3D; led_probe,</span><br><span class="line">.remove&#x3D; led_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动模块加载函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init leddriver_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return platform_driver_register(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动模块卸载函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __exit leddriver_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(leddriver_init);</span><br><span class="line">module_exit(leddriver_exit);</span><br></pre></td></tr></table></figure><p>platform 驱动的 probe 函数，当设备树中的设备节点与驱动之间匹配成功以后此函数就会执行，原来在驱动加载函数里面做的工作现在全部放到 probe 函s数里面完成。 </p><p>remobe 函数，当卸载 platform 驱动的时候此函数就会执行。在此函数里面释放内存、注销字符设备等，也就是将原来驱动卸载函数里面的工作全部都放到 remove 函数中 完成。 </p><p>led_of_match匹配表，描述了此驱动都和什么样的设备匹配，添加了一条值为”atkalpha-gpioled”的 compatible 属性值，当设备树中某个设备节点的 compatible 属性值也为“atkalpha-gpioled”的时候就会与此驱动匹配。 在编最后一个元素一定要为空！ </p><p>platform_driver 驱动结构体，设置这个 platform 驱动的名字为“imx6ulled”，因此，当驱动加载成功以后就会在/sys/bus/platform/drivers/目录下存在一个名为“imx6uled”的文件。 设置 of_match_table 为上面的 led_of_match。 </p><p>驱动模块加载函数，在此函数里面通过 platforms_driver_register 向 Linux 内核注册 led_driver 驱动。 </p><p>驱动模块卸载函数，在此函数里面通过 platform_driver_unregister 从 Linux内核卸载 led_driver 驱动。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设备树下的-platform-驱动&quot;&gt;&lt;a href=&quot;#设备树下的-platform-驱动&quot; class=&quot;headerlink&quot; title=&quot;设备树下的 platform 驱动&quot;&gt;&lt;/a&gt;&lt;strong&gt;设备树下的&lt;/strong&gt; &lt;strong&gt;plat</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-platform设备驱动-非设备树</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E9%9D%9E%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E9%9D%9E%E8%AE%BE%E5%A4%87%E6%A0%91/</id>
    <published>2021-04-16T09:31:45.000Z</published>
    <updated>2021-04-16T09:43:10.344Z</updated>
    
    <content type="html"><![CDATA[<p>使用platform 驱动框架来编写一个 LED 灯驱动，不使用设备树来描述设备信息，我们采用自定义platform_device这种“古老”方式来编写LED的设备信息。</p><p>需要编写一个驱动模块和一个设备模块，其中驱动模块是 platform 驱动程序， </p><p>设备模块是 platform 的设备信息。当这两个模块都加载成功以后就会匹配成功，然后 platform </p><p>驱动模块中的 probe 函数就会执行，probe 函数中就是传统的字符设备驱动那一套。 </p><p><strong>试验程序编写</strong></p><p><strong>platform</strong> <strong>设备与驱动程序编写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: leddriver.c</span><br><span class="line">描述   : platform驱动</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: flatform驱动的probe函数，当驱动与设备匹配以后此函数就会执行</span><br><span class="line"> * @param - dev : platform设备</span><br><span class="line"> * @return : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_probe(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">…………</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: platform驱动的remove函数，移除platform驱动的时候此函数会执行</span><br><span class="line"> * @param - dev : platform设备</span><br><span class="line"> * @return : 0，成功;其他负值,失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">iounmap(IMX6U_CCM_CCGR1);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">…………</span><br><span class="line"></span><br><span class="line">cdev_del(&amp;leddev.cdev);&#x2F;*  删除cdev *&#x2F;</span><br><span class="line">unregister_chrdev_region(leddev.devid, LEDDEV_CNT); &#x2F;* 注销设备号 *&#x2F;</span><br><span class="line">device_destroy(leddev.class, leddev.devid);</span><br><span class="line">class_destroy(leddev.class);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* platform驱动结构体 *&#x2F;</span><br><span class="line">static struct platform_driver led_driver &#x3D; &#123;</span><br><span class="line">.driver&#x3D; &#123;</span><br><span class="line">.name&#x3D; &quot;imx6ul-led&quot;,&#x2F;* 驱动名字，用于和设备匹配 *&#x2F;</span><br><span class="line">&#125;,</span><br><span class="line">.probe&#x3D; led_probe,</span><br><span class="line">.remove&#x3D; led_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动模块加载函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init leddriver_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return platform_driver_register(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动模块卸载函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __exit leddriver_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(leddriver_init);</span><br><span class="line">module_exit(leddriver_exit);</span><br></pre></td></tr></table></figure><p>probe 函数，当设备和驱动匹配以后此函数就会执行，当匹配成功以后会在终端上输出“led driver and device has matched!”这样语句。在 probe 函数里面初始化 LED、注册字符设备驱动。也就是将原来在驱动加载函数里面做的工作全部放到 probe 函数里面完成。 </p><p>remobe 函数，当卸载 platform 驱动的时候此函数就会执行。在此函数里面 释放内存、注销字符设备等。也就是将原来驱动卸载函数里面的工作全部都放到 remove 函数中完成。 </p><p>platform_driver 驱动结构体，注意 name 字段为”imx6ul-led”，和leddevice.c 文件里面设置的设备 name 字段一致</p><p>驱动模块加载函数，在此函数里面通过 platform_driver_register 向 Linux 内核注册 led_driver 驱动。 </p><p>驱动模块卸载函数，在此函数里面通过 platform_driver_unregister 从 Linux 内核卸载 led_driver 驱动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: leddevice.c</span><br><span class="line">描述   : platform设备</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* </span><br><span class="line"> * 寄存器地址定义</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CCM_CCGR1_BASE(0X020C406C)</span><br><span class="line">#define SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span><br><span class="line">#define SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span><br><span class="line">#define GPIO1_DR_BASE(0X0209C000)</span><br><span class="line">#define GPIO1_GDIR_BASE(0X0209C004)</span><br><span class="line">#define REGISTER_LENGTH4</span><br><span class="line"></span><br><span class="line">&#x2F;* @description: 释放flatform设备模块的时候此函数会执行</span><br><span class="line"> * @param - dev : 要释放的设备 </span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static voidled_release(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;led device released!\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*  </span><br><span class="line"> * 设备资源信息，也就是LED0所使用的所有寄存器</span><br><span class="line"> *&#x2F;</span><br><span class="line">static struct resource led_resources[] &#x3D; &#123;</span><br><span class="line">[0] &#x3D; &#123;</span><br><span class="line">.start &#x3D; CCM_CCGR1_BASE,</span><br><span class="line">.end &#x3D; (CCM_CCGR1_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">.flags &#x3D; IORESOURCE_MEM,</span><br><span class="line">&#125;,</span><br><span class="line">[1] &#x3D; &#123;</span><br><span class="line">.start&#x3D; SW_MUX_GPIO1_IO03_BASE,</span><br><span class="line">.end&#x3D; (SW_MUX_GPIO1_IO03_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">.flags&#x3D; IORESOURCE_MEM,</span><br><span class="line">&#125;,</span><br><span class="line">[2] &#x3D; &#123;</span><br><span class="line">.start&#x3D; SW_PAD_GPIO1_IO03_BASE,</span><br><span class="line">.end&#x3D; (SW_PAD_GPIO1_IO03_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">.flags&#x3D; IORESOURCE_MEM,</span><br><span class="line">&#125;,</span><br><span class="line">[3] &#x3D; &#123;</span><br><span class="line">.start&#x3D; GPIO1_DR_BASE,</span><br><span class="line">.end&#x3D; (GPIO1_DR_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">.flags&#x3D; IORESOURCE_MEM,</span><br><span class="line">&#125;,</span><br><span class="line">[4] &#x3D; &#123;</span><br><span class="line">.start&#x3D; GPIO1_GDIR_BASE,</span><br><span class="line">.end&#x3D; (GPIO1_GDIR_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">.flags&#x3D; IORESOURCE_MEM,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * platform设备结构体 </span><br><span class="line"> *&#x2F;</span><br><span class="line">static struct platform_device leddevice &#x3D; &#123;</span><br><span class="line">.name &#x3D; &quot;imx6ul-led&quot;,</span><br><span class="line">.id &#x3D; -1,</span><br><span class="line">.dev &#x3D; &#123;</span><br><span class="line">.release &#x3D; &amp;led_release,</span><br><span class="line">&#125;,</span><br><span class="line">.num_resources &#x3D; ARRAY_SIZE(led_resources),</span><br><span class="line">.resource &#x3D; led_resources,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 设备模块加载 </span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init leddevice_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return platform_device_register(&amp;leddevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 设备模块注销</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __exit leddevice_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_device_unregister(&amp;leddevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(leddevice_init);</span><br><span class="line">module_exit(leddevice_exit);</span><br></pre></td></tr></table></figure><p>led_resources 数组，也就是设备资源，描述了 LED 所要使用到的寄存器信息，也就是 IORESOURCE_MEM 资源。 </p><p>platform 设备结构体变量 leddevice，这里要注意 name 字段为“imx6ul-led”， platform 驱动中的 name 字段也要为“imx6ul-led”，否则设备和驱动匹配失败。 </p><p>设备模块加载函数，在此函数里面通过 platform_device_register 向 Linux 内核注册 leddevice 这个 platform 设备。 </p><p>设备模块卸载函数，在此函数里面通过 platform_device_unregister 从 Linux内核中删除掉 leddevice 这个 platform 设备。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用platform 驱动框架来编写一个 LED 灯驱动，不使用设备树来描述设备信息，我们采用自定义platform_device这种“古老”方式来编写LED的设备信息。&lt;/p&gt;
&lt;p&gt;需要编写一个驱动模块和一个设备模块，其中驱动模块是 platform 驱动程序， &lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-platform设备驱动</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-04-16T08:28:54.000Z</published>
    <updated>2021-04-16T09:31:03.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-驱动的分离与分层"><a href="#Linux-驱动的分离与分层" class="headerlink" title="Linux 驱动的分离与分层"></a><strong>Linux</strong> <strong>驱动的分离与分层</strong></h1><h2 id="驱动的分隔与分离"><a href="#驱动的分隔与分离" class="headerlink" title="驱动的分隔与分离"></a><strong>驱动的分隔与分离</strong></h2><p>对于 Linux 这样一个成熟、庞大、复杂的操作系统，代码的重用性非常重要，否则的话就会在 Linux 内核中存在大量无意义的重复代码。尤其是驱动程序，因为驱动程序占用了 Linux内核代码量的大头，如果不对驱动程序加以管理，任由重复的代码肆意增加，那么用不了多久Linux 内核的文件数量就庞大到无法接受的地步。 </p><p><strong>驱动的分隔，也就是将主机驱动和设备驱动分隔开来</strong>，比如 I2C、SPI 等等都会采用驱动分隔的方式来简化驱动的开发。在实际的驱动开发中，一般 I2C 主机控制器驱动已经由半导体厂家编写好了，而设备驱动一般也由设备器件的厂家编写好了，我们只需要提供设备信息即可，比如 I2C 设备的话提供设备连接到了哪个 I2C 接口上，I2C 的速度是多少等等。相当于将设备信息从设备驱动中剥离开来，驱动使用标准方法去获取到设备信息(比如从设备树中获取到设备信息)，然后根据获取到的设备信息来初始化设备。 这样就相当于<strong>驱动只负责驱动，设备只负责设备，</strong>想办法将两者进行匹配即可。这个就是 <strong>Linux 中的总线(bus)、驱动(driver)和设备(device)模型，</strong>也就是常说的<strong>驱动分离</strong>。总线就是驱动和设备信息的月老，负责给两者牵线搭桥。</p><p>当我们向系统注册一个驱动的时候，总线就会在右侧的设备中查找，看看有没有与之匹配的设备，如果有的话就将两者联系起来。同样的，当向系统中注册一个设备的时候，总线就会在左侧的驱动中查找看有没有与之匹配的设备，有的话也联系起来。Linux 内核中大量的驱动程序都采用总线、驱动和设备模式，platform 驱动就是这一思想下的产物</p><h2 id="驱动的分层"><a href="#驱动的分层" class="headerlink" title="驱动的分层"></a><strong>驱动的分层</strong></h2><p>Linux 下的驱动往往也是分层的，分层的目的也是为了在不同的层处理不同的内容。以其他书籍或者资料常常使用到的input(输入子系统)为例，简单介绍一下驱动的分层。input 子系统负责管理所有跟输入有关的驱动，包括键盘、鼠标、触摸等，最底层的就是设备原始驱动，负责获取输入设备的原始值，获取到的输入事件上报给 input 核心层。input 核心层会处理各种 IO 模型，并且提 供 file_operations 操作集合。我们在编写输入设备驱动的时候只需要处理好输入事件的上报即 可，至于如何处理这些上报的输入事件那是上层去考虑的，我们不用管。可以看出借助分层模型可以极大的简化我们的驱动编写，对于驱动编写来说非常的友好。 </p><h1 id="platform-平台驱动模型"><a href="#platform-平台驱动模型" class="headerlink" title="platform 平台驱动模型"></a>platform 平台驱动模型</h1><p>前面的设备驱动的分离引出了总线(bus)、驱动(driver)和设备(device)模型，比 如 I2C、SPI、USB 等总线。但是在 SOC 中有些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型该怎么办呢？为了解决此问题，Linux 提出了 platform 这个虚拟总线，相应的就有 platform_driver 和 platform_device。</p><h2 id="platform-总线"><a href="#platform-总线" class="headerlink" title="platform 总线"></a><strong>platform</strong> <strong>总线</strong></h2><p>Linux系统内核使用bus_type结构体表示总线，此结构体定义在文件include/linux/device.h， </p><p>bus_type 结构体内容如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> struct bus_type &#123; </span><br><span class="line">    const char *name; &#x2F;* 总线名字 *&#x2F;</span><br><span class="line">    const char *dev_name; </span><br><span class="line">    struct device *dev_root; 5 struct device_attribute *dev_attrs; </span><br><span class="line">    const struct attribute_group **bus_groups; &#x2F;* 总线属性 *&#x2F;</span><br><span class="line">    const struct attribute_group **dev_groups; &#x2F;* 设备属性 *&#x2F;</span><br><span class="line">    const struct attribute_group **drv_groups; &#x2F;* 驱动属性 *&#x2F;</span><br><span class="line">    </span><br><span class="line">    int (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    ………………</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>match 函数，匹配函数，完成设备和驱动之间匹配的，总线就是使用 match 函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备，因此每一条总线都必须实现此函数。两个参数：dev 和 drv，这两个参数分别为 device 和 device_driver 类型，也就是设备和驱动。</p><p>platform 总线 platform_bus_type是 bus_type 的一个具体实例，定义在文件 drivers/base/platform.c，platform 总线定义如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type platform_bus_type &#x3D; &#123; </span><br><span class="line">    .name &#x3D; &quot;platform&quot;,</span><br><span class="line">    .dev_groups &#x3D; platform_dev_groups, </span><br><span class="line">    .match &#x3D; platform_match, &#x2F;&#x2F;匹配函数。</span><br><span class="line">    .uevent &#x3D; platform_uevent, </span><br><span class="line">    .pm &#x3D; &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>驱动和设备的匹配有四种方法，我们依次来看一下：</p><ul><li>第一种匹配方式， OF 类型的匹配，也就是设备树采用的匹配方式，of_driver_match_device 函数定义在文件 include/linux/of_device.h 中。device_driver 结构体(表示设备驱动)中有个名为of_match_table的成员变量，此成员变量保存着驱动的compatible匹配表，设备树中的每个设备节点的 compatible 属性会和 of_match_table 表中的所有成员比较，查看是否有相同的条目，如果有的话就表示设备和此驱动匹配，设备和驱动匹配成功以后probe 函数就会执行。 </li><li>第二种匹配方式，ACPI 匹配方式。 </li><li>第三种匹配方式，id_table 匹配，每个 platform_driver 结构体有一个 id_table成员变量，保存了很多 id 信息。这些 id 信息存放着这个 platformd 驱动所支持的驱动类型。 </li><li>第四种匹配方式，如果第三种匹配方式的 id_table 不存在的话就直接比较驱动和设备的 name 字段，看看是不是相等，如果相等的话就匹配成功。 </li></ul><p>对于支持设备树的 Linux 版本号，一般设备驱动为了兼容性都支持设备树和无设备树两种匹配方式。也就是第一种匹配方式一般都会存在，第三种和第四种只要存在一种就可以，一般用的最多的还是第四种，也就是直接比较驱动和设备的 name 字段，毕竟这种方式最简单了。 </p><h2 id="platform-驱动"><a href="#platform-驱动" class="headerlink" title="platform 驱动"></a><strong>platform 驱动</strong></h2><p>platform_driver 结 构 体 表 示 platform 驱动，此结构体定义在文件include/linux/platform_device.h 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct platform_driver &#123; </span><br><span class="line">    int (*probe)(struct platform_device *);</span><br><span class="line">    int (*remove)(struct platform_device *);</span><br><span class="line">    void (*shutdown)(struct platform_device *);</span><br><span class="line">    int (*suspend)(struct platform_device *, pm_message_t state);</span><br><span class="line">    int (*resume)(struct platform_device *);</span><br><span class="line">    struct device_driver driver; </span><br><span class="line">    const struct platform_device_id *id_table; 9 bool prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>probe 函数</strong>，当驱动与设备匹配成功以后 probe 函数就会执行，非常重要的函数！一般驱动的提供者会编写，如果自己要编写一个全新的驱动，那么 probe 就需要自行实现。 </p><p><strong>driver 成员，</strong>为 device_driver 结构体变量，Linux 内核里面大量使用到了面向对象的思维，device_driver 相当于基类，提供了最基础的驱动框架。plaform_driver 继承了这个基类，然后在此基础上又添加了一些特有的成员变量。device_driver 结构体的成员of_match_table ，就是采用设备树的时候驱动使用的匹配表，同样是数组，每个匹配项都为 of_device_id 结构体类型，此结构体定义在文件 include/linux/mod_devicetable.h 中，内容如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct of_device_id &#123; </span><br><span class="line">    char name[32];</span><br><span class="line">    char type[32];</span><br><span class="line">    char compatible[128];</span><br><span class="line">    const void *data; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>device_driver 结构体的成员compatible 非常重要，因为对于设备树而言，就是通过设备节点的 compatible 属性值和 of_match_table 中每个项目的 compatible 成员变量进行比较，如果有相等的就表示设备和此驱动匹配成功。 </p><p><strong>id_table 表</strong>， platform 总线匹配驱动和设备的时候采用的第三种方法，id_table 是个表(也就是数组)，每个元素的类型为 platform_device_id，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct platform_device_id &#123; </span><br><span class="line">    char name[PLATFORM_NAME_SIZE];</span><br><span class="line">    kernel_ulong_t driver_data; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在编写 platform 驱动的时候，首先定义一个 platform_driver 结构体变量，然后实现结构体中的各个成员变量，重点是实现匹配方法以及 probe 函数。当驱动和设备匹配成功以后 probe函数就会执行，具体的驱动程序在 probe 函数里面编写，比如字符设备驱动等等。当我们定义并初始化好 platform_driver 结构体变量以后，需要在驱动入口函数里面调用platform_driver_register 函数向 Linux 内核注册一个 platform 驱动，还需要在驱动卸载函数中通过 platform_driver_unregister 函数卸载 platform 驱动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int platform_driver_register (struct platform_driver *driver)</span><br><span class="line">&#x2F;&#x2F;driver：要注册的 platform 驱动。</span><br><span class="line">&#x2F;&#x2F;返回值：负数，失败；0，成功。</span><br><span class="line"></span><br><span class="line">void platform_driver_unregister(struct platform_driver *drv)</span><br><span class="line">&#x2F;&#x2F;drv：要卸载的 platform 驱动。</span><br></pre></td></tr></table></figure><p><strong>platform 驱动框架如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 设备结构体 *&#x2F;</span><br><span class="line">struct xxx_dev&#123; </span><br><span class="line">    struct cdev cdev; </span><br><span class="line">    &#x2F;* 设备结构体其他具体内容 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct xxx_dev xxxdev; &#x2F;* 定义个设备结构体变量 *&#x2F;</span><br><span class="line"></span><br><span class="line">static struct file_operations xxx_fops &#x3D; &#123;</span><br><span class="line">    .owner &#x3D; THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* platform 驱动的 probe 函数</span><br><span class="line">* 驱动与设备匹配成功以后此函数就会执行</span><br><span class="line">*&#x2F;</span><br><span class="line">static int xxx_probe(struct platform_device *dev)</span><br><span class="line">&#123; </span><br><span class="line">    ......</span><br><span class="line">    cdev_init(&amp;xxxdev.cdev, &amp;xxx_fops); &#x2F;* 注册字符设备驱动 *&#x2F;</span><br><span class="line">    &#x2F;* 函数具体内容 *&#x2F;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int xxx_remove(struct platform_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    cdev_del(&amp;xxxdev.cdev);&#x2F;* 删除 cdev *&#x2F;</span><br><span class="line">     &#x2F;* 函数具体内容 *&#x2F;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 匹配列表 *&#x2F;</span><br><span class="line">static const struct of_device_id xxx_of_match[] &#x3D; &#123;</span><br><span class="line">    &#123; .compatible &#x3D; &quot;xxx-gpio&quot; &#125;,</span><br><span class="line">    &#123; &#x2F;* Sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> &#x2F;* </span><br><span class="line"> * platform 平台驱动结构体</span><br><span class="line">*&#x2F;</span><br><span class="line">static struct platform_driver xxx_driver &#x3D; &#123;</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .name &#x3D; &quot;xxx&quot;,</span><br><span class="line">        .of_match_table &#x3D; xxx_of_match,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe &#x3D; xxx_probe,</span><br><span class="line">    .remove &#x3D; xxx_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> &#x2F;* 驱动模块加载 *&#x2F;</span><br><span class="line">static int __init xxxdriver_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return platform_driver_register(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动模块卸载 *&#x2F;</span><br><span class="line">static void __exit xxxdriver_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体来说，platform 驱动还是传统的字符设备驱动、块设备驱动或网络设备驱动，只是套上了一张“platform”的皮，目的是为了使用总线、驱动和设备这个驱动模型来实现驱动的分离与分层。 </p><h2 id="platform-设备"><a href="#platform-设备" class="headerlink" title="platform 设备"></a>platform 设备</h2><p>platform 驱动已经准备好了，我们还需要 platform 设备，否则的话单单一个驱动也做不了什么。platform_device 这个结构体表示 platform 设备，<strong>如果内核支持设备树的话就不要再使用 platform_device 来描述设备了，</strong>因为改用设备树去描述了。platform_device 结构体定义在文件include/linux/platform_device.h 中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct platform_device &#123;</span><br><span class="line">    const char *name; </span><br><span class="line">    …………</span><br><span class="line">    u32 num_resources; </span><br><span class="line">    struct resource *resource;</span><br><span class="line">    …………</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>name 表示设备名字，要和所使用的 platform 驱动的 name 字段相同，否则的话备就无法匹配到对应的驱动。比如对应的 platform 驱动的 name 字段为“xxx-gpio”，那么此 name字段也要设置为“xxx-gpio”。<br>num_resources 表示资源数量，一般为第 28 行 resource 资源的大小。<br>resource 表示资源，也就是设备信息，比如外设寄存器等。Linux 内核使用 resource结构体表示资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct resource &#123;</span><br><span class="line">    resource_size_t start;</span><br><span class="line">    resource_size_t end;</span><br><span class="line">    const char *name;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    struct resource *parent, *sibling, *child;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>start 和 end 分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址，name 表示资源名字，flags 表示资源类型，可选的资源类型都定义在了文件include/linux/ioport.h 里面。</p><p>在以前不支持设备树的Linux版本中，用户需要编写platform_device变量来描述设备信息，然后使用 platform_device_register 函数将设备信息注册到 Linux 内核中，如果不再使用 platform 的话可以通过 platform_device_unregister 函数注销掉相应的 platform设备，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int platform_device_register(struct platform_device *pdev)</span><br><span class="line">&#x2F;&#x2F;pdev：要注册的 platform 设备。</span><br><span class="line">&#x2F;&#x2F;返回值：负数，失败；0，成功。</span><br><span class="line">void platform_device_unregister(struct platform_device *pdev)</span><br><span class="line">&#x2F;&#x2F;pdev：要注销的 platform 设备。</span><br></pre></td></tr></table></figure><p>platform 设备信息框架如下所示，在不支持设备树的 Linux 版本中使用的，当 Linux 内核支持了设备树以后就不需要用户手动去注册 platform 设备了。因为设备信息都放到了设备树中去描述，Linux 内核启动的时候会从设备树中读取设备信息，然后将其组织成 platform_device 形式，至于设备树到 platform_device 的具体过程就不去详细的追究了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;* 寄存器地址定义*&#x2F;</span><br><span class="line">#define PERIPH1_REGISTER_BASE (0X20000000) &#x2F;* 外设 1 寄存器首地址 *&#x2F; </span><br><span class="line">#define PERIPH2_REGISTER_BASE (0X020E0068) &#x2F;* 外设 2 寄存器首地址 *&#x2F;</span><br><span class="line">#define REGISTER_LENGTH 4</span><br><span class="line"></span><br><span class="line">&#x2F;* 资源 *&#x2F;</span><br><span class="line">static struct resource xxx_resources[] &#x3D; &#123; </span><br><span class="line">    [0] &#x3D; &#123;</span><br><span class="line">    .start &#x3D; PERIPH1_REGISTER_BASE,</span><br><span class="line">        .end &#x3D; (PERIPH1_REGISTER_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">        .flags &#x3D; IORESOURCE_MEM,</span><br><span class="line">    &#125;, </span><br><span class="line">    [1] &#x3D; &#123;</span><br><span class="line">        .start &#x3D; PERIPH2_REGISTER_BASE,</span><br><span class="line">        .end &#x3D; (PERIPH2_REGISTER_BASE + REGISTER_LENGTH - 1),</span><br><span class="line">        .flags &#x3D; IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* platform 设备结构体 *&#x2F;</span><br><span class="line">static struct platform_device xxxdevice &#x3D; &#123;</span><br><span class="line">    .name &#x3D; &quot;xxx-gpio&quot;,</span><br><span class="line">    .id &#x3D; -1,</span><br><span class="line">    .num_resources &#x3D; ARRAY_SIZE(xxx_resources),</span><br><span class="line">    .resource &#x3D; xxx_resources,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备模块加载 *&#x2F;</span><br><span class="line">static int __init xxxdevice_init(void)</span><br><span class="line">&#123;</span><br><span class="line">return platform_device_register(&amp;xxxdevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备模块注销 *&#x2F;</span><br><span class="line">static void __exit xxx_resourcesdevice_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">platform_device_unregister(&amp;xxxdevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组 xxx_resources 表示设备资源，一共有两个资源，分别为设备外设 1 和外设 2 的寄存器信息。因此 flags 都为 IORESOURCE_MEM，表示资源为内存类型的。 </p><p>platform 设备结构体变量，注意 name 字段要和所使用的驱动中的 name 字段一致，否则驱动和设备无法匹配成功。num_resources 表示资源大小，其实就是数组 xxx_resources的元素数量，这里用 ARRAY_SIZE 来测量一个数组的元素个数。 </p><p>设备模块加载函数，在此函数中调用 platform_device_register 向 Linux 内核注 册 platform 设备。 </p><p>设备模块卸载函数，在此函数中调用 platform_device_unregister 从 Linux 内核中卸载 platform 设备。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-驱动的分离与分层&quot;&gt;&lt;a href=&quot;#Linux-驱动的分离与分层&quot; class=&quot;headerlink&quot; title=&quot;Linux 驱动的分离与分层&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux&lt;/strong&gt; &lt;strong&gt;驱动的分离与分层&lt;/str</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-异步通知</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/</id>
    <published>2021-04-16T07:40:56.000Z</published>
    <updated>2021-04-16T08:28:15.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步通知简介"><a href="#异步通知简介" class="headerlink" title="异步通知简介"></a>异步通知简介</h1><p>Linux 应用程序可以通过阻塞或者非阻塞这两种方式来访问驱动设备，通过阻塞方式访问的话应用程序会处于休眠态，等待驱动设备可以使用，非阻塞方式的话会通过 poll 函数来不断的轮询，查看驱动设备文件是否可以使用。这两种方式都需要应用程序主动的去查询设备的使用情况。</p><p>最好的方式就是驱动程序能主动向应用程序发出通知，报告自己可以访问，然后应用程序在从驱动程序中读取或写入数据，类似中断的机制。Linux 提供了异步通知这个机制来完成此功能。</p><p>信号类似于我们硬件上使用的“中断”，只不过信号是软件层次上的。算是在软件层次上对中断的一种模拟，驱动可以通过主动向应用程序发送信号的方式来报告自己可以访问了，应用程序获取到信号以后就可以从驱动设备中读取或者写入数据了。整个过程就相当于应用程序收到了驱动发送过来了的一个中断，然后应用程序去响应这个中断，在整个处理过程中应用程序并没有去查询驱动设备是否可以访问，一切都是由驱动设备自己告诉给应用程序的。 </p><p>阻塞、非阻塞、异步通知，这三种是针对不同的场合提出来的不同的解决方法，没有优劣之分，根据自己的实际需求选择合适的处理方法即可。</p><p>异步通知的核心就是信号，在 arch/xtensa/include/uapi/asm/signal.h 文件中定义了 Linux 所支持的所有信号，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define SIGKILL 9 &#x2F;* 杀死、终止进程 *&#x2F;</span><br><span class="line">#define SIGSTOP 19 &#x2F;* 停止进程的执行，只是暂停 *&#x2F;</span><br></pre></td></tr></table></figure><p>除了 SIGKILL(9)和 SIGSTOP(19)这两个信号不能被忽略外，其他的信号都可以忽略。这些信号就相当于中断号，不同的中断号代表了不同的中断，不同的中断所做的处理不同，因此，驱动程序可以通过向应用程序发送不同的信号来实现不同的功能。 </p><h2 id="驱动中的信号处理"><a href="#驱动中的信号处理" class="headerlink" title="驱动中的信号处理"></a><strong>驱动中的信号处理</strong></h2><h3 id="1、fasync-struct-结构体"><a href="#1、fasync-struct-结构体" class="headerlink" title="1、fasync_struct 结构体"></a>1、fasync_struct 结构体</h3><p>首先我们需要在驱动程序中定义一个 fasync_struct 结构体指针变量，一般将 fasync_struct 结构体指针变量定义到设备结构体中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct fasync_struct &#123;</span><br><span class="line">     spinlock_t fa_lock;</span><br><span class="line">     int magic;</span><br><span class="line">     int fa_fd;</span><br><span class="line">     struct fasync_struct *fa_next;</span><br><span class="line">     struct file *fa_file;</span><br><span class="line">     struct rcu_head fa_rcu;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、fasync-函数"><a href="#2、fasync-函数" class="headerlink" title="2、fasync 函数"></a>2、fasync 函数</h3><p>如果要使用异步通知，需要在设备驱动中实现 file_operations 操作集中的 fasync 函数，此函数格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*fasync) (int fd, struct file *filp, int on)</span><br></pre></td></tr></table></figure><p>fasync 函数里面一般通过调用 fasync_helper 函数来初始化前面定义的 fasync_struct 结构体指针。在关闭驱动文件的时候需要在 file_operations 操作集中的 release 函数中使用释放fasync_helper函数 释放fasync_struct。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)</span><br><span class="line">&#x2F;&#x2F;前三个参数就是 fasync 函数的那三个参数，第四个参数就是要初始化的 fasync_struct 结构体指针变量。</span><br></pre></td></tr></table></figure><p>当应用程序通过“fcntl(fd, F_SETFL, flags | FASYNC)”改变fasync 标记的时候，驱动程序 file_operations 操作集中的 fasync 函数就会执行。</p><p>驱动程序中的 fasync 函数参考示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct xxx_dev &#123; </span><br><span class="line">    ......</span><br><span class="line">    struct fasync_struct *async_queue; &#x2F;* 异步相关结构体 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int xxx_fasync(int fd, struct file *filp, int on) </span><br><span class="line">&#123; </span><br><span class="line">    struct xxx_dev *dev &#x3D; (xxx_dev)filp-&gt;private_data; </span><br><span class="line"></span><br><span class="line">    if (fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue) &lt; 0)</span><br><span class="line">        return -EIO;</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int xxx_release(struct inode *inode, struct file *filp) </span><br><span class="line">&#123; </span><br><span class="line">return xxx_fasync(-1, filp, 0); &#x2F;* 删除异步通知 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct file_operations xxx_ops &#x3D; &#123;</span><br><span class="line">    ......</span><br><span class="line">    .fasync &#x3D; xxx_fasync,</span><br><span class="line">    .release &#x3D; xxx_release,</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3、kill-fasync-函数"><a href="#3、kill-fasync-函数" class="headerlink" title="3、kill_fasync 函数"></a>3、kill_fasync 函数</h3><p>当设备可以访问的时候，驱动程序需要向应用程序发出信号，相当于产生“中断”。kill_fasync函数负责发送指定的信号，kill_fasync 函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void kill_fasync(struct fasync_struct **fp, int sig, int band)</span><br><span class="line">&#x2F;&#x2F;fp：要操作的 fasync_struct。</span><br><span class="line">&#x2F;&#x2F;sig：要发送的信号。</span><br><span class="line">&#x2F;&#x2F;band：可读时设置为 POLL_IN，可写时设置为 POLL_OUT。</span><br></pre></td></tr></table></figure><h2 id="应用程序对异步通知的处理"><a href="#应用程序对异步通知的处理" class="headerlink" title="应用程序对异步通知的处理"></a><strong>应用程序对异步通知的处理</strong></h2><p>应用程序对异步通知的处理包括以下三步：</p><h3 id="1、注册信号处理函数"><a href="#1、注册信号处理函数" class="headerlink" title="1、注册信号处理函数"></a>1、注册信号处理函数</h3><p>我们使用中断的时候需要设置中断处理函数，同样的，如果要在应用程序中使用信号，那么就必须设置信号所使用的信号处理函数，<strong>在应用程序中使用 signal 函数</strong>来设置指定信号的处理函数，signal 函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sighandler_t signal(int signum, sighandler_t handler)</span><br><span class="line">&#x2F;&#x2F;signum：要设置处理函数的信号。</span><br><span class="line">&#x2F;&#x2F;handler：信号的处理函数。信号处理函数原型：typedef void (*sighandler_t)(int)</span><br><span class="line">&#x2F;&#x2F;返回值：设置成功的话返回信号的前一个处理函数，设置失败的话返回 SIG_ERR。</span><br></pre></td></tr></table></figure><h3 id="2、将本应用程序的进程号告诉给内核"><a href="#2、将本应用程序的进程号告诉给内核" class="headerlink" title="2、将本应用程序的进程号告诉给内核"></a>2、将本应用程序的进程号告诉给内核</h3><p>使用 fcntl(fd, F_SETOWN, getpid())将本应用程序的进程号告诉给内核。 </p><h3 id="3、开启异步通知"><a href="#3、开启异步通知" class="headerlink" title="3、开启异步通知"></a>3、开启异步通知</h3><p>使用如下两行程序开启异步通知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flags &#x3D; fcntl(fd, F_GETFL); &#x2F;* 获取当前的进程状态 *&#x2F;</span><br><span class="line">fcntl(fd, F_SETFL, flags | FASYNC); &#x2F;* 开启当前进程异步通知功能 *&#x2F;</span><br></pre></td></tr></table></figure><p>重点就是通过 fcntl 函数设置进程状态为 FASYNC，经过这一步，驱动程序中的 fasync 函数就会执行。</p><h1 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a>实验程序编写</h1><p>当按键按下以后驱动程序向应用程序发送 SIGIO 信号，应用程序获取到 SIGIO 信号以后 读取并且打印出按键值。</p><h2 id="驱动程序编写"><a href="#驱动程序编写" class="headerlink" title="驱动程序编写"></a><strong>驱动程序编写</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: asyncnoti.c</span><br><span class="line">描述   : 非阻塞IO访问</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* imx6uirq设备结构体 *&#x2F;</span><br><span class="line">struct imx6uirq_dev&#123;</span><br><span class="line">struct fasync_struct *async_queue;&#x2F;* 异步相关结构体 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct imx6uirq_dev imx6uirq;&#x2F;* irq设备 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* @description: 定时器服务函数，用于按键消抖，定时器到了以后</span><br><span class="line"> *  再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><br><span class="line"> * @param - arg: 设备结构变量</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">void timer_function(unsigned long arg)</span><br><span class="line">&#123;           </span><br><span class="line">if(atomic_read(&amp;dev-&gt;releasekey)) &#123;&#x2F;* 一次完整的按键过程 *&#x2F;</span><br><span class="line">if(dev-&gt;async_queue)</span><br><span class="line">kill_fasync(&amp;dev-&gt;async_queue, SIGIO, POLL_IN);&#x2F;* 释放SIGIO信号 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : fasync函数，用于处理异步通知</span><br><span class="line"> * @param - fd: 文件描述符</span><br><span class="line"> * @param - filp    : 要打开的设备文件(文件描述符)</span><br><span class="line"> * @param - on      : 模式</span><br><span class="line"> * @return          : 负数表示函数执行失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int imx6uirq_fasync(int fd, struct file *filp, int on)</span><br><span class="line">&#123;</span><br><span class="line">struct imx6uirq_dev *dev &#x3D; (struct imx6uirq_dev *)filp-&gt;private_data;</span><br><span class="line">return fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description     : release函数，应用程序调用close关闭驱动文件的时候会执行</span><br><span class="line"> * @param - inode: inode节点</span><br><span class="line"> * @param - filp    : 要打开的设备文件(文件描述符)</span><br><span class="line"> * @return          : 负数表示函数执行失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int imx6uirq_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">return imx6uirq_fasync(-1, filp, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备操作函数 *&#x2F;</span><br><span class="line">static struct file_operations imx6uirq_fops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; imx6uirq_open,</span><br><span class="line">.read &#x3D; imx6uirq_read,</span><br><span class="line">.fasync &#x3D; imx6uirq_fasync,</span><br><span class="line">.release &#x3D; imx6uirq_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在设备结构体 imx6uirq_dev 中添加 fasync_struct 指针变量。<br>如果是一次完整的按键过程，那么就通过 kill_fasync 函数发送 SIGIO 信号。<br>imx6uirq_fasync 函数，为 file_operations 操作集中的 fasync 函数，此函数内容很简单，就是调用一下 fasync_helper。 </p><p>release 函数，应用程序调用 close 函数关闭驱动设备文件的时候此函数就会执行，在此函数中释放掉 fasync_struct 指针变量。<br>设置 file_operations 操作集中的 fasync 和 release 这两个成员变量。</p><h2 id="编写测试-APP"><a href="#编写测试-APP" class="headerlink" title="编写测试 APP"></a>编写测试 APP</h2><p>测试 APP 要实现的内容很简单，设置 SIGIO 信号的处理函数为 sigio_signal_func，当驱动 </p><p>程序向应用程序发送 SIGIO 信号以后 sigio_signal_func 函数就会执行。sigio_signal_func 函数内 </p><p>容很简单，就是通过 read 函数读取按键值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: asyncnotiApp.c</span><br><span class="line">描述   : 异步通知测试APP</span><br><span class="line">使用方法：.&#x2F;asyncnotiApp &#x2F;dev&#x2F;asyncnoti 打开测试App</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">static int fd &#x3D; 0;&#x2F;* 文件描述符 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * SIGIO信号处理函数</span><br><span class="line"> * @param - signum : 信号值</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void sigio_signal_func(int signum)</span><br><span class="line">&#123;</span><br><span class="line">int err &#x3D; 0;</span><br><span class="line">unsigned int keyvalue &#x3D; 0;</span><br><span class="line"></span><br><span class="line">err &#x3D; read(fd, &amp;keyvalue, sizeof(keyvalue));</span><br><span class="line">if(err &lt; 0) &#123;</span><br><span class="line">&#x2F;* 读取错误 *&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">printf(&quot;sigio signal! key value&#x3D;%d\r\n&quot;, keyvalue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: main主程序</span><br><span class="line"> * @param - argc : argv数组元素个数</span><br><span class="line"> * @param - argv : 具体参数</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">filename &#x3D; argv[1];</span><br><span class="line">fd &#x3D; open(filename, O_RDWR);</span><br><span class="line"></span><br><span class="line">&#x2F;* 设置信号SIGIO的处理函数 *&#x2F;</span><br><span class="line">signal(SIGIO, sigio_signal_func);</span><br><span class="line"></span><br><span class="line">fcntl(fd, F_SETOWN, getpid());&#x2F;* 设置当前进程接收SIGIO信号 *&#x2F;</span><br><span class="line">flags &#x3D; fcntl(fd, F_GETFL);&#x2F;* 获取当前的进程状态 *&#x2F;</span><br><span class="line">fcntl(fd, F_SETFL, flags | FASYNC);&#x2F;* 设置进程启用异步通知功能 *&#x2F;</span><br><span class="line"></span><br><span class="line">while(1) &#123;</span><br><span class="line">sleep(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sigio_signal_func 函数，SIGIO 信号的处理函数，当驱动程序有效按键按下以后就会发送 SIGIO 信号，此函数就会执行。此函数通过 read 函数读取按键值，然后通过printf 函数打印在终端上。 </p><p>通过 signal 函数设置 SIGIO 信号的处理函数为 sigio_signal_func。 </p><p>设置当前进程的状态，开启异步通知的功能。 </p><p>while 循环，等待信号产生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异步通知简介&quot;&gt;&lt;a href=&quot;#异步通知简介&quot; class=&quot;headerlink&quot; title=&quot;异步通知简介&quot;&gt;&lt;/a&gt;异步通知简介&lt;/h1&gt;&lt;p&gt;Linux 应用程序可以通过阻塞或者非阻塞这两种方式来访问驱动设备，通过阻塞方式访问的话应用程序会处于休眠态</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-非阻塞IO</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9EIO/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9EIO/</id>
    <published>2021-04-16T06:31:11.000Z</published>
    <updated>2021-04-16T07:39:46.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a><strong>非阻塞 IO</strong></h1><p>对于非阻塞 IO，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。当使用非阻塞IO时，应用程序使用非阻塞访问方式从设备读取数据，当设备不可用或数据未准备好的时候会立即向内核返回一个错误码，表示数据读取失败。应用程序会再次重新读取数据，这样一直往复循环，直到数据读取成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用程序非阻塞读取数据</span><br><span class="line">int fd; </span><br><span class="line">int data &#x3D; 0; </span><br><span class="line">fd &#x3D; open(&quot;&#x2F;dev&#x2F;xxx_dev&quot;, O_RDWR | O_NONBLOCK); &#x2F;* 非阻塞方式打开 *&#x2F;</span><br><span class="line">ret &#x3D; read(fd, &amp;data, sizeof(data)); &#x2F;* 读取数据 *&#x2F;</span><br></pre></td></tr></table></figure><p>第 4 行使用 open 函数打开“/dev/xxx_dev”设备文件的时候添加了参数“O_NONBLOCK”，表示以非阻塞方式打开设备，这样从设备中读取数据的时候就是非阻塞方式的了。</p><h2 id="非阻塞机制-轮询"><a href="#非阻塞机制-轮询" class="headerlink" title="非阻塞机制(轮询)"></a><strong>非阻塞机制(轮询)</strong></h2><p>如果用户应用程序以非阻塞的方式访问设备，设备驱动程序就要提供非阻塞的处理方式，也就是轮询。poll、epoll 和 select 可以用于处理轮询，应用程序通过 select、epoll 或 poll 函数来查询设备是否可以操作，如果可以操作的话就从设备读取或者向设备写入数据。当<strong>应用程序调用 select、epoll 或 poll 函数</strong>的时候<strong>设备驱动程序中的 poll 函数</strong>就会执行，因此需要在设备驱动程序中编写 poll 函数。</p><h3 id="1、Linux-驱动下的-poll-操作函数"><a href="#1、Linux-驱动下的-poll-操作函数" class="headerlink" title="1、Linux 驱动下的 poll 操作函数"></a><strong>1、Linux</strong> <strong>驱动下的</strong> <strong>poll</strong> <strong>操作函数</strong></h3><p>当应用程序调用 select 或 poll 函数来对驱动程序进行非阻塞访问的时候，驱动程序file_operations 操作集中的 poll 函数就会执行。所以驱动程序的编写者需要提供对应的 poll 函数，poll 函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unsigned int (*poll) (struct file *filp, struct poll_table_struct *wait)</span><br><span class="line">&#x2F;&#x2F;filp：要打开的设备文件(文件描述符)。</span><br><span class="line">&#x2F;&#x2F;wait：结构体 poll_table_struct 类型指针，由应用程序传递进来的。一般将此参数传递给</span><br><span class="line">&#x2F;&#x2F;poll_wait 函数。</span><br><span class="line">&#x2F;&#x2F;返回值:向应用程序返回设备或者资源状态，可以返回的资源状态如下：</span><br><span class="line">    POLLIN 有数据可以读取。</span><br><span class="line">    POLLPRI 有紧急的数据需要读取。</span><br><span class="line">    POLLOUT 可以写数据。</span><br><span class="line">    POLLERR 指定的文件描述符发生错误。</span><br><span class="line">    POLLHUP 指定的文件描述符挂起。</span><br><span class="line">    POLLNVAL 无效的请求。</span><br><span class="line">    POLLRDNORM 等同于 POLLIN，普通数据可读</span><br></pre></td></tr></table></figure><p>需要在驱动程序的 poll 函数中调用 poll_wait 函数，poll_wait 函数不会引起阻塞，只是将应用程序添加到 poll_table 中，poll_wait 函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)</span><br><span class="line">&#x2F;&#x2F;wait_address 是要添加到 poll_table 中的等待队列头，</span><br><span class="line">&#x2F;&#x2F;p 就是 poll_table，就是file_operations 中 poll 函数的 wait 参数。</span><br></pre></td></tr></table></figure><h3 id="应用程序调用-select、epoll-或-poll-函数"><a href="#应用程序调用-select、epoll-或-poll-函数" class="headerlink" title="应用程序调用 select、epoll 或 poll 函数"></a><strong>应用程序调用 select、epoll 或 poll 函数</strong></h3><h4 id="1、select-函数"><a href="#1、select-函数" class="headerlink" title="1、select 函数"></a>1、select 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">fd_set *exceptfds, struct timeval *timeout)</span><br><span class="line">&#x2F;&#x2F;nfds：所要监视的这三类文件描述集合中，最大文件描述符加 1。</span><br><span class="line">&#x2F;&#x2F;readfds、writefds 和 exceptfds：这三个指针指向描述符集合，这三个参数指明了关心哪些描述符、需要满足哪些条件等等，</span><br><span class="line">&#x2F;&#x2F;timeout:超时时间，当 timeout 为 NULL 的时候就表示无限期的等待。</span><br><span class="line">&#x2F;&#x2F;返回值：0，表示的话就表示超时发生，但是没有任何文件描述符可以进行操作；-1，发生</span><br><span class="line">&#x2F;&#x2F;错误；其他值，可以进行操作的文件描述符个数。</span><br></pre></td></tr></table></figure><p>readfds、writefds 和 exceptfds：这三个指针指向描述符集合，这三个参数指明了关心哪些描述符、需要满足哪些条件等等，这三个参数都是 fd_set 类型的，fd_set 类型变量的每一个位都代表了一个文件描述符。readfds 用于监视指定描述符集的读变化，也就是监视这些文件是否可以读取，只要这些集合里面有一个文件可以读取那么 seclect 就会返回一个大于 0 的值表示文件可以读取。如果没有文件可以读取，那么就会根据 timeout 参数来判断是否超时。可以将 readfs设置为 NULL，表示不关心任何文件的读变化。 writefs 用于监视这些文件是否可以进行写操作。exceptfds 用于监视这些文件的异常。</p><p>比如我们现在要从一个设备文件中读取数据，那么就可以定义一个 fd_set 变量，这个变量要传递给参数 readfds。当我们定义好一个 fd_set 变量以后可以使用如下所示几个宏进行操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void FD_ZERO(fd_set *set)</span><br><span class="line">void FD_SET(int fd, fd_set *set)</span><br><span class="line">void FD_CLR(int fd, fd_set *set)</span><br><span class="line">int FD_ISSET(int fd, fd_set *set)</span><br></pre></td></tr></table></figure><p>FD_ZERO 用于将 fd_set 变量的所有位都清零，FD_SET 用于将 fd_set 变量的某个位置 1，也就是向 fd_set 添加一个文件描述符 fd 。FD_CLR 用户将 fd_set变量的某个位清零，也就是将一个文件描述符 fd 从 fd_set 中删除FD_ISSET 用于测试一个文件描述符 fd是否属于某个集合。 </p><p>timeout:超时时间，当我们调用 select 函数等待某些文件描述符可以设置超时时间，超时时间使用结构体 timeval 表示，结构体定义如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct timeval &#123;</span><br><span class="line">    long tv_sec; &#x2F;* 秒 *&#x2F;</span><br><span class="line">    long tv_usec; &#x2F;* 微妙 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 select 函数对某个设备驱动文件进行读非阻塞访问的操作示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void main(void) </span><br><span class="line">&#123; </span><br><span class="line">    int ret, fd; &#x2F;* 要监视的文件描述符 *&#x2F;</span><br><span class="line">    fd_set readfds; &#x2F;* 读操作文件描述符集 *&#x2F;</span><br><span class="line">    struct timeval timeout; &#x2F;* 超时结构体 *&#x2F;</span><br><span class="line"></span><br><span class="line">    fd &#x3D; open(&quot;dev_xxx&quot;, O_RDWR | O_NONBLOCK); &#x2F;* 非阻塞式访问 *&#x2F;</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;readfds); &#x2F;* 清除 readfds *&#x2F;</span><br><span class="line">    FD_SET(fd, &amp;readfds); &#x2F;* 将 fd 添加到 readfds 里面 *&#x2F;</span><br><span class="line"></span><br><span class="line">     &#x2F;* 构造超时时间 *&#x2F;</span><br><span class="line">    timeout.tv_sec &#x3D; 0;</span><br><span class="line">    timeout.tv_usec &#x3D; 500000; &#x2F;* 500ms *&#x2F;</span><br><span class="line"></span><br><span class="line">    ret &#x3D; select(fd + 1, &amp;readfds, NULL, NULL, &amp;timeout);</span><br><span class="line">    switch (ret) &#123;</span><br><span class="line">        case 0: &#x2F;* 超时 *&#x2F;</span><br><span class="line">            printf(&quot;timeout!\r\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case -1: &#x2F;* 错误 *&#x2F;</span><br><span class="line">            printf(&quot;error!\r\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default: &#x2F;* 可以读取数据 *&#x2F;</span><br><span class="line">            if(FD_ISSET(fd, &amp;readfds)) &#123; &#x2F;* 判断是否为 fd 文件描述符 *&#x2F;</span><br><span class="line">            &#x2F;* 使用 read 函数读取数据 *&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、poll-函数"><a href="#2、poll-函数" class="headerlink" title="2、poll 函数"></a>2、poll 函数</h4><p>在单个线程中，select 函数能够监视的文件描述符数量有最大的限制，一般为 1024，可以修改内核将监视的文件描述符数量改大，但是这样会降低效率！这个时候就可以使用 poll 函数，poll 函数本质上和 select 没有太大的差别，但是 poll 函数没有最大文件描述符限制，Linux 应用程序中 poll 函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout)</span><br><span class="line">&#x2F;&#x2F;fds：要监视的文件描述符集合以及要监视的事件,为一个数组，数组元素都是结构体 pollfd类型的，</span><br><span class="line">&#x2F;&#x2F;nfds：poll 函数要监视的文件描述符数量。</span><br><span class="line">&#x2F;&#x2F;timeout：超时时间，单位为 ms。</span><br><span class="line">&#x2F;&#x2F;返回值：返回 revents 域中不为 0 的 pollfd 结构体个数，也就是发生事件或错误的文件描述符数量；0，超时；-1，发生错误，并且设置 errno 为错误类型。</span><br></pre></td></tr></table></figure><p>fds：要监视的文件描述符集合以及要监视的事件,为一个数组，数组元素都是结构体 pollfd类型的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd; &#x2F;* 文件描述符 *&#x2F;</span><br><span class="line">    short events; &#x2F;* 请求的事件 *&#x2F;</span><br><span class="line">     short revents; &#x2F;* 返回的事件 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;fd 是要监视的文件描述符，如果 fd 无效的话那么 events 监视事件也就无效，并且 revents返回 0。events 是要监视的事件，可监视的事件类型如下所示：</span><br><span class="line">    POLLIN 有数据可以读取。</span><br><span class="line">    POLLPRI 有紧急的数据需要读取。</span><br><span class="line">    POLLOUT 可以写数据。</span><br><span class="line">    POLLERR 指定的文件描述符发生错误。</span><br><span class="line">    POLLHUP 指定的文件描述符挂起。</span><br><span class="line">    POLLNVAL 无效的请求。</span><br><span class="line">    POLLRDNORM 等同于 POLLIN</span><br><span class="line">&#x2F;&#x2F;revents 是返回参数，也就是返回的事件，由 Linux 内核设置具体的返回事件。</span><br></pre></td></tr></table></figure><p>使用 poll 函数对某个设备驱动文件进行读非阻塞访问的操作示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void main(void)  </span><br><span class="line">&#123; </span><br><span class="line">int ret; </span><br><span class="line">    int fd; &#x2F;* 要监视的文件描述符 *&#x2F;</span><br><span class="line">    struct pollfd fds; </span><br><span class="line"></span><br><span class="line">    fd &#x3D; open(filename, O_RDWR | O_NONBLOCK); &#x2F;* 非阻塞式访问 *&#x2F;</span><br><span class="line"></span><br><span class="line">     &#x2F;* 构造结构体 *&#x2F;</span><br><span class="line">    fds.fd &#x3D; fd;</span><br><span class="line">    fds.events &#x3D; POLLIN; &#x2F;* 监视数据是否可以读取 *&#x2F;</span><br><span class="line"></span><br><span class="line">    ret &#x3D; poll(&amp;fds, 1, 500); &#x2F;* 轮询文件是否可操作，超时 500ms *&#x2F;</span><br><span class="line">    if (ret) &#123; &#x2F;* 数据有效 *&#x2F;</span><br><span class="line">        ......</span><br><span class="line">        &#x2F;* 读取数据 *&#x2F;</span><br><span class="line">        ......</span><br><span class="line">    &#125; else if (ret &#x3D;&#x3D; 0) &#123; &#x2F;* 超时 *&#x2F;</span><br><span class="line">    ......</span><br><span class="line">    &#125; else if (ret &lt; 0) &#123; &#x2F;* 错误 *&#x2F;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、epoll-函数"><a href="#3、epoll-函数" class="headerlink" title="3、epoll 函数"></a>3、epoll 函数</h4><p>传统的 selcet 和 poll 函数都会随着所监听的 fd 数量的增加，出现效率低下的问题，而且poll 函数每次必须遍历所有的描述符来检查就绪的描述符，这个过程很浪费时间。为此，epoll应运而生，epoll 就是为处理大并发而准备的，一般常常在网络编程中使用 epoll 函数。应用程序需要先使用 epoll_create 函数创建一个 epoll 句柄，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)</span><br><span class="line">&#x2F;&#x2F;size：从 Linux2.6.8 开始此参数已经没有意义了，随便填写一个大于 0 的值就可以。</span><br><span class="line">&#x2F;&#x2F;返回值：epoll 句柄，如果为-1 的话表示创建失败。</span><br></pre></td></tr></table></figure><p>epoll 句柄创建成功以后使用 epoll_ctl 函数向其中添加要监视的文件描述符以及监视的事件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd,struct epoll_event *event)</span><br><span class="line">epfd：要操作的 epoll 句柄，也就是使用 epoll_create 函数创建的 epoll 句柄。</span><br><span class="line">op：表示要对 epfd(epoll 句柄)进行的操作，可以设置为：</span><br><span class="line">        EPOLL_CTL_ADD 向 epfd 添加文件参数 fd 表示的描述符。</span><br><span class="line">        EPOLL_CTL_MOD 修改参数 fd 的 event 事件。</span><br><span class="line">        EPOLL_CTL_DEL 从 epfd 中删除 fd 描述符。</span><br><span class="line">fd：要监视的文件描述符。</span><br><span class="line">event：要监视的事件类型，为 epoll_event 结构体类型指针，</span><br><span class="line">返回值：0，成功；-1，失败，并且设置 errno 的值为相应的错误码。</span><br></pre></td></tr></table></figure><p>event：要监视的事件类型，为 epoll_event 结构体类型指针，epoll_event 结构体类型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event &#123;</span><br><span class="line">    uint32_t events; &#x2F;* epoll 事件 *&#x2F;</span><br><span class="line">    epoll_data_t data; &#x2F;* 用户数据 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;events 成员变量表示要监视的事件，可选的事件如下所示，这些事件可以进行“或”操作，即可以设置监视多个事件。</span><br><span class="line">EPOLLIN 有数据可以读取。</span><br><span class="line">EPOLLOUT 可以写数据。</span><br><span class="line">EPOLLPRI 有紧急的数据需要读取。</span><br><span class="line">EPOLLERR 指定的文件描述符发生错误。</span><br><span class="line">EPOLLHUP 指定的文件描述符挂起。</span><br><span class="line">EPOLLET 设置 epoll 为边沿触发，默认触发模式为水平触发。</span><br><span class="line">EPOLLONESHOT 一次性的监视，当监视完成以后还需要再次监视某个fd，那么就需要将fd 重新添加到 epoll 里面。</span><br></pre></td></tr></table></figure><p>一切都设置好以后应用程序就可以通过 epoll_wait 函数来等待事件的发生，类似 select 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout)</span><br><span class="line">&#x2F;&#x2F;epfd：要等待的 epoll。</span><br><span class="line">&#x2F;&#x2F;events：指向 epoll_event 结构体的数组，当有事件发生的时候 Linux 内核会填写 events，调</span><br><span class="line">用者可以根据 events 判断发生了哪些事件。</span><br><span class="line">&#x2F;&#x2F;maxevents：events 数组大小，必须大于 0。</span><br><span class="line">&#x2F;&#x2F;timeout：超时时间，单位为 ms。</span><br><span class="line">&#x2F;&#x2F;返回值：0，超时；-1，错误；其他值，准备就绪的文件描述符数量。</span><br></pre></td></tr></table></figure><p>epoll 更多的是用在大规模的并发服务器上，因为在这种场合下 select 和 poll 并不适合。当设计到的文件描述符(fd)比较少的时候就适合用 selcet 和 poll，本章我们就使用 sellect 和 poll 这两个函数。</p><h2 id="非阻塞-IO-实验"><a href="#非阻塞-IO-实验" class="headerlink" title="非阻塞 IO 实验"></a>非阻塞 IO 实验</h2><p>Linux 中断中，我们直接在应用程序中通过 read 函数不断的读取按键状态，当按键有效的时候就打印出按键值。这种方法有个缺点，那就是 imx6uirqApp 这个测试应用程序拥有很高的 CPU 占用率，原因就在于我们是直接在 while 循环中通过 read 函数读取按键值，因此 imx6uirqApp 这个软件会一直运行，一直读取 按键值，CPU 使用率肯定就会很高。最好的方法就是在没有有效的按键事件发生的时候，imx6uirqApp 这个应用程序应该处于休眠状态，当有按键事件发生以后 imx6uirqApp 这个应用程序才运行，打印出按键值，这样就会降低 CPU 使用率。</p><h3 id="1、驱动程序编写"><a href="#1、驱动程序编写" class="headerlink" title="1、驱动程序编写"></a>1、驱动程序编写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: noblock.c</span><br><span class="line">描述   : 非阻塞IO访问</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* imx6uirq设备结构体 *&#x2F;</span><br><span class="line">struct imx6uirq_dev&#123;</span><br><span class="line">wait_queue_head_t r_wait;&#x2F;* 读等待队列头 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct imx6uirq_dev imx6uirq;&#x2F;* irq设备 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* @description: 定时器服务函数，用于按键消抖，定时器到了以后</span><br><span class="line"> *  再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><br><span class="line"> * @param - arg: 设备结构变量</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">void timer_function(unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 唤醒进程 *&#x2F;</span><br><span class="line">if(atomic_read(&amp;dev-&gt;releasekey)) &#123;&#x2F;* 完成一次按键过程 *&#x2F;</span><br><span class="line">&#x2F;* wake_up(&amp;dev-&gt;r_wait); *&#x2F;</span><br><span class="line">wake_up_interruptible(&amp;dev-&gt;r_wait);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 按键IO初始化</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int keyio_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 初始化等待队列头 *&#x2F;</span><br><span class="line">init_waitqueue_head(&amp;imx6uirq.r_wait);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : 从设备读取数据 </span><br><span class="line">  * @param - filp    : 要打开的设备文件(文件描述符)</span><br><span class="line">  * @param - buf     : 返回给用户空间的数据缓冲区</span><br><span class="line">  * @param - cnt     : 要读取的数据长度</span><br><span class="line">  * @param - offt    : 相对于文件首地址的偏移</span><br><span class="line">  * @return          : 读取的字节数，如果为负值，表示读取失败</span><br><span class="line">  *&#x2F;</span><br><span class="line">static ssize_t imx6uirq_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)</span><br><span class="line">&#123;</span><br><span class="line">if (filp-&gt;f_flags &amp; O_NONBLOCK)&#123; &#x2F;* 非阻塞访问 *&#x2F;</span><br><span class="line">if(atomic_read(&amp;dev-&gt;releasekey) &#x3D;&#x3D; 0)&#x2F;* 没有按键按下，返回-EAGAIN *&#x2F;</span><br><span class="line">return -EAGAIN;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : poll函数，用于处理非阻塞访问</span><br><span class="line">  * @param - filp    : 要打开的设备文件(文件描述符)</span><br><span class="line">  * @param - wait    : 等待列表(poll_table)</span><br><span class="line">  * @return          : 设备或者资源状态，</span><br><span class="line">  *&#x2F;</span><br><span class="line">unsigned int imx6uirq_poll(struct file *filp, struct poll_table_struct *wait)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">poll_wait(filp, &amp;dev-&gt;r_wait, wait);&#x2F;* 将等待队列头添加到poll_table中 *&#x2F;</span><br><span class="line"></span><br><span class="line">if(atomic_read(&amp;dev-&gt;releasekey)) &#123;&#x2F;* 按键按下 *&#x2F;</span><br><span class="line">mask &#x3D; POLLIN | POLLRDNORM;&#x2F;* 返回PLLIN *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">return mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备操作函数 *&#x2F;</span><br><span class="line">static struct file_operations imx6uirq_fops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; imx6uirq_open,</span><br><span class="line">.read &#x3D; imx6uirq_read,</span><br><span class="line">.poll &#x3D; imx6uirq_poll,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>判断是否为非阻塞式读取访问，如果是的话就判断按键是否有效，也就是判断一下有没有按键按下，如果没有的话就返回-EAGAIN。</p><p>mx6uirq_poll 函数就是 file_operations 驱动操作集中的 poll 函数，当应用 程序调用 select 或者 poll 函数的时候 imx6uirq_poll 函数就会执行。调用 poll_wait 函数 将等待队列头添加到 poll_table 中，判断按键是否有效，如果按键有效的话就向应用程序返回 POLLIN 这个事件，表示有数据可以读取。 </p><p>设置 file_operations 的 poll 成员变量为 imx6uirq_poll</p><h3 id="编写测试-APP"><a href="#编写测试-APP" class="headerlink" title="编写测试 APP"></a><strong>编写测试</strong> <strong>APP</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: noblockApp.c</span><br><span class="line">描述   : 非阻塞访问测试APP</span><br><span class="line">使用方法：.&#x2F;blockApp &#x2F;dev&#x2F;blockio 打开测试App</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: main主程序</span><br><span class="line"> * @param - argc : argv数组元素个数</span><br><span class="line"> * @param - argv : 具体参数</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">filename &#x3D; argv[1];</span><br><span class="line">fd &#x3D; open(filename, O_RDWR | O_NONBLOCK);&#x2F;* 非阻塞访问 *&#x2F;</span><br><span class="line">#if 0</span><br><span class="line">&#x2F;* 构造结构体 *&#x2F;</span><br><span class="line">fds.fd &#x3D; fd;</span><br><span class="line">fds.events &#x3D; POLLIN;</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">ret &#x3D; poll(&amp;fds, 1, 500);</span><br><span class="line">if (ret) &#123;&#x2F;* 数据有效 *&#x2F;</span><br><span class="line">ret &#x3D; read(fd, &amp;data, sizeof(data));</span><br><span class="line">if(ret &lt; 0) &#123;</span><br><span class="line">&#x2F;* 读取错误 *&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if(data)</span><br><span class="line">printf(&quot;key value &#x3D; %d \r\n&quot;, data);</span><br><span class="line">&#125; </span><br><span class="line">&#125; else if (ret &#x3D;&#x3D; 0) &#123; &#x2F;* 超时 *&#x2F;</span><br><span class="line">&#x2F;* 用户自定义超时处理 *&#x2F;</span><br><span class="line">&#125; else if (ret &lt; 0) &#123;&#x2F;* 错误 *&#x2F;</span><br><span class="line">&#x2F;* 用户自定义错误处理 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">FD_ZERO(&amp;readfds);</span><br><span class="line">FD_SET(fd, &amp;readfds);</span><br><span class="line">&#x2F;* 构造超时时间 *&#x2F;</span><br><span class="line">timeout.tv_sec &#x3D; 0;</span><br><span class="line">timeout.tv_usec &#x3D; 500000; &#x2F;* 500ms *&#x2F;</span><br><span class="line">ret &#x3D; select(fd + 1, &amp;readfds, NULL, NULL, &amp;timeout);</span><br><span class="line">switch (ret) &#123;</span><br><span class="line">case 0: &#x2F;* 超时 *&#x2F;</span><br><span class="line">&#x2F;* 用户自定义超时处理 *&#x2F;</span><br><span class="line">break;</span><br><span class="line">case -1:&#x2F;* 错误 *&#x2F;</span><br><span class="line">&#x2F;* 用户自定义错误处理 *&#x2F;</span><br><span class="line">break;</span><br><span class="line">default:  &#x2F;* 可以读取数据 *&#x2F;</span><br><span class="line">if(FD_ISSET(fd, &amp;readfds)) &#123;</span><br><span class="line">ret &#x3D; read(fd, &amp;data, sizeof(data));</span><br><span class="line">if (ret &lt; 0) &#123;</span><br><span class="line">&#x2F;* 读取错误 *&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if (data)</span><br><span class="line">printf(&quot;key value&#x3D;%d\r\n&quot;, data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别使用 poll 函数、select 函数来实现非阻塞访问，</p><p>在 while 循环中使用 poll 函数不 断的轮询，检查驱动程序是否有数据可以读取，如果可以读取的话就调用 read 函数读取按键 数据。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;非阻塞-IO&quot;&gt;&lt;a href=&quot;#非阻塞-IO&quot; class=&quot;headerlink&quot; title=&quot;非阻塞 IO&quot;&gt;&lt;/a&gt;&lt;strong&gt;非阻塞 IO&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;对于非阻塞 IO，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-阻塞IO</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-%E9%98%BB%E5%A1%9EIO/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-%E9%98%BB%E5%A1%9EIO/</id>
    <published>2021-04-16T06:31:02.000Z</published>
    <updated>2021-04-16T06:57:21.488Z</updated>
    
    <content type="html"><![CDATA[<p>这里的“IO”单片机的“GPIO”(也就是引脚)。 这里的 IO 指的是 Input/Output，也就是输入/输出，是应用程序对驱动设备的输入/输出操作。</p><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a><strong>阻塞IO</strong></h2><p>当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么阻塞式 IO 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。当使用阻塞IO时，应用程序调用 read 函数从设备中读取数据，当设备不可用或数据未准备好的时候就会进入到休眠态。等设备可用的时候就会从休眠态唤醒，然后从设备中读取数据返回给应用程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;应用程序阻塞读取数据</span><br><span class="line">int fd; </span><br><span class="line">int data &#x3D; 0; </span><br><span class="line">fd &#x3D; open(&quot;&#x2F;dev&#x2F;xxx_dev&quot;, O_RDWR); &#x2F;* 阻塞方式打开 *&#x2F;</span><br><span class="line">ret &#x3D; read(fd, &amp;data, sizeof(data)); &#x2F;* 读取数据 *&#x2F;</span><br></pre></td></tr></table></figure><p>可以看出，对于设备驱动文件的默认读取方式就是阻塞式的，所以前面所有的例程测试 APP 都是采用阻塞 IO。 </p><h3 id="阻塞IO机制"><a href="#阻塞IO机制" class="headerlink" title="阻塞IO机制"></a><strong>阻塞IO机制</strong></h3><p><strong>等待队列</strong> </p><p>1、等待队列头IO</p><p>阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU 资源让出来。但是，当设备文件可以操作的时候就必须唤醒进程，一般在中断函数里面完成唤醒工作。Linux 内核提供了等待队列(wait queue)来实现阻塞进程的唤醒工作，如果我们要在驱动中使用等待队列，必须创建并初始化一个等待队列头，等待队列头使用结构体wait_queue_head_t 表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __wait_queue_head &#123;</span><br><span class="line">    spinlock_t lock;</span><br><span class="line">    struct list_head task_list;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct __wait_queue_head wait_queue_head_t;</span><br></pre></td></tr></table></figure><p>定义好等待队列头以后需要初始化，使用 init_waitqueue_head 函数初始化等待队列头，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void init_waitqueue_head(wait_queue_head_t *q)&#x2F;&#x2F;参数 q 就是要初始化的等待队列头。</span><br></pre></td></tr></table></figure><p><strong>2、等待队列项</strong></p><p>等待队列头就是一个等待队列的头部，每个访问设备的进程都是一个队列项，当设备不可用的时候就要将这些进程对应的等待队列项添加到等待队列里面。结构体 wait_queue_t 表示等待队列项，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __wait_queue &#123;</span><br><span class="line">     unsigned int flags;</span><br><span class="line">     void *private;</span><br><span class="line">     wait_queue_func_t func;</span><br><span class="line">     struct list_head task_list;</span><br><span class="line"> &#125;;</span><br><span class="line">typedef struct __wait_queue wait_queue_t;</span><br></pre></td></tr></table></figure><p>使用宏 DECLARE_WAITQUEUE 定义并初始化一个等待队列项，宏的内容如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAITQUEUE(name, tsk) </span><br></pre></td></tr></table></figure><p>name ，等待队列项的名字，tsk 表示这个等待队列项属于哪个任务(进程)，一般设置为current ， 在 Linux 内核中 current 相 当 于一个全 局 变 量 ， 表 示当前 进 程 。 因 此 宏 DECLARE_WAITQUEUE 就是给当前正在运行的进程创建并初始化了一个等待队列项。 </p><p><strong>3、将队列项添加/移除等待队列头</strong></p><p>当设备不可访问的时候就需要将进程对应的等待队列项添加到前面创建的等待队列头中，只有添加到等待队列头中以后进程才能进入休眠态。当设备可以访问以后再将进程对应的等待队列项从等待队列头中移除即可，等待队列项添加、等待队列项移除  API 函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)</span><br><span class="line">void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)</span><br><span class="line">&#x2F;&#x2F;q：要删除的等待队列项所处的等待队列头。wait：要删除的等待队列项。返回值：无</span><br></pre></td></tr></table></figure><p><strong>4、等待唤醒</strong><br>当设备可以使用的时候就要唤醒进入休眠态的进程(<strong>主动唤醒</strong>)，唤醒可以使用如下两个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void wake_up(wait_queue_head_t *q)</span><br><span class="line">void wake_up_interruptible(wait_queue_head_t *q)</span><br></pre></td></tr></table></figure><p>参数 q 就是要唤醒的等待队列头，这两个函数会将这个等待队列头中的所有进程都唤醒。wake_up 函数可以唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 状态的进程，而 wake_up_interruptible 函数只能唤醒处于 TASK_INTERRUPTIBLE 状态的进程。</p><p><strong>5、等待事件</strong><br>除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就<strong>自动唤醒</strong>等待队列中的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wait_event(wq, condition) </span><br><span class="line">&#x2F;&#x2F;等待以wq 为等待队列头的等待队列被唤醒，前提是 condition 条件必须满足(为真)，否则一直阻塞。此函数会将 进程设置为TASK_UNINTERRUPTIBLE 状态</span><br><span class="line"></span><br><span class="line">wait_event_timeout(wq, condition, timeout) </span><br><span class="line">&#x2F;&#x2F;功能和 wait_event 类似，但是此函数可以添加超时时间，以 jiffies 为单位。此函数有返回值，如果返回 0 的话表示超时时间到，而且 condition 为假。为 1 的话表示 condition 为真，也就是条件满足了。 </span><br><span class="line"></span><br><span class="line">wait_event_interruptible(wq, condition) </span><br><span class="line">&#x2F;&#x2F;与 wait_event 函数类似，但是此函数将进程设置为 TASK_INTERRUPTIBLE，就是可以被信号打断。</span><br><span class="line"></span><br><span class="line">wait_event_interruptible_timeout(wq, condition, timeout) </span><br><span class="line">&#x2F;&#x2F;与 wait_event_timeout 函数类似，此函数也将进程设置为 TASK_INTERRUPTIBLE，可以被信号打断。  </span><br></pre></td></tr></table></figure><h2 id="阻塞-IO-实验"><a href="#阻塞-IO-实验" class="headerlink" title="阻塞 IO 实验"></a><strong>阻塞</strong> <strong>IO</strong> <strong>实验</strong></h2><p>Linux 中断中，我们直接在应用程序中通过 read 函数不断的读取按键状态，当按键有效的时候就打印出按键值。这种方法有个缺点，那就是 imx6uirqApp 这个测试应用程序拥有很高的 CPU 占用率，原因就在于我们是直接在 while 循环中通过 read 函数读取按键值，因此 imx6uirqApp 这个软件会一直运行，一直读取 按键值，CPU 使用率肯定就会很高。最好的方法就是在没有有效的按键事件发生的时候，imx6uirqApp 这个应用程序应该处于休眠状态，当有按键事件发生以后 imx6uirqApp 这个应用程序才运行，打印出按键值，这样就会降低 CPU 使用率。</p><p>使用等待队列实现阻塞访问重点注意两点： </p><p>①、将任务或者进程加入到等待队列头， </p><p>②、在合适的点唤醒等待队列，一般都是中断处理函数里面</p><h3 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a><strong>实验程序编写</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: block.c</span><br><span class="line">描述   : 阻塞IO访问</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* imx6uirq设备结构体 *&#x2F;</span><br><span class="line">struct imx6uirq_dev&#123;</span><br><span class="line">wait_queue_head_t r_wait;&#x2F;* 读等待队列头 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct imx6uirq_dev imx6uirq;&#x2F;* irq设备 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* @description: 定时器服务函数，用于按键消抖，定时器到了以后</span><br><span class="line"> *  再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><br><span class="line"> * @param - arg: 设备结构变量</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">void timer_function(unsigned long arg)</span><br><span class="line">&#123;        </span><br><span class="line">&#x2F;* 唤醒进程 *&#x2F;</span><br><span class="line">if(atomic_read(&amp;dev-&gt;releasekey)) &#123;&#x2F;* 完成一次按键过程 *&#x2F;</span><br><span class="line">&#x2F;* wake_up(&amp;dev-&gt;r_wait); *&#x2F;</span><br><span class="line">wake_up_interruptible(&amp;dev-&gt;r_wait);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 按键IO初始化</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int keyio_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 初始化等待队列头 *&#x2F;</span><br><span class="line">init_waitqueue_head(&amp;imx6uirq.r_wait);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line">  * @description     : 从设备读取数据 </span><br><span class="line">  * @param - filp    : 要打开的设备文件(文件描述符)</span><br><span class="line">  * @param - buf     : 返回给用户空间的数据缓冲区</span><br><span class="line">  * @param - cnt     : 要读取的数据长度</span><br><span class="line">  * @param - offt    : 相对于文件首地址的偏移</span><br><span class="line">  * @return          : 读取的字节数，如果为负值，表示读取失败</span><br><span class="line">  *&#x2F;</span><br><span class="line">static ssize_t imx6uirq_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)</span><br><span class="line">&#123;</span><br><span class="line">#if 0</span><br><span class="line">&#x2F;* 加入等待队列，等待被唤醒,也就是有按键按下 *&#x2F;</span><br><span class="line"> ret &#x3D; wait_event_interruptible(dev-&gt;r_wait, atomic_read(&amp;dev-&gt;releasekey)); </span><br><span class="line">if (ret) &#123;</span><br><span class="line">goto wait_error;</span><br><span class="line">&#125; </span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">DECLARE_WAITQUEUE(wait, current);&#x2F;* 定义一个等待队列 *&#x2F;</span><br><span class="line">if(atomic_read(&amp;dev-&gt;releasekey) &#x3D;&#x3D; 0) &#123;&#x2F;* 没有按键按下 *&#x2F;</span><br><span class="line">add_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);&#x2F;* 将等待队列添加到等待队列头 *&#x2F;</span><br><span class="line">__set_current_state(TASK_INTERRUPTIBLE);&#x2F;* 设置任务状态 *&#x2F;</span><br><span class="line">schedule();&#x2F;* 进行一次任务切换，当前进程就会进入到休眠态 *&#x2F;</span><br><span class="line">if(signal_pending(current))&#123;&#x2F;* 判断是否为信号引起的唤醒 *&#x2F;</span><br><span class="line">ret &#x3D; -ERESTARTSYS;</span><br><span class="line">goto wait_error;</span><br><span class="line">&#125;</span><br><span class="line">__set_current_state(TASK_RUNNING);      &#x2F;* 将当前任务设置为运行状态 *&#x2F;</span><br><span class="line">    remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);    &#x2F;* 将对应的队列项从等待队列头删除 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">keyvalue &#x3D; atomic_read(&amp;dev-&gt;keyvalue);</span><br><span class="line">releasekey &#x3D; atomic_read(&amp;dev-&gt;releasekey);</span><br><span class="line"></span><br><span class="line">if (releasekey) &#123; &#x2F;* 有按键按下 *&#x2F;</span><br><span class="line">if (keyvalue &amp; 0x80) &#123;</span><br><span class="line">keyvalue &amp;&#x3D; ~0x80;</span><br><span class="line">ret &#x3D; copy_to_user(buf, &amp;keyvalue, sizeof(keyvalue));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">goto data_error;</span><br><span class="line">&#125;</span><br><span class="line">atomic_set(&amp;dev-&gt;releasekey, 0);&#x2F;* 按下标志清零 *&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">goto data_error;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">wait_error:</span><br><span class="line">set_current_state(TASK_RUNNING);&#x2F;* 设置任务为运行态 *&#x2F;</span><br><span class="line">remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);&#x2F;* 将等待队列移除 *&#x2F;</span><br><span class="line">return ret;</span><br><span class="line"></span><br><span class="line">data_error:</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动入口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init imx6uirq_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 5、始化按键 *&#x2F;</span><br><span class="line">atomic_set(&amp;imx6uirq.keyvalue, INVAKEY);</span><br><span class="line">atomic_set(&amp;imx6uirq.releasekey, 0);</span><br><span class="line">keyio_init();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设备结构体中添加一个等待队列头 r_wait，因为在 Linux 驱动中处理阻塞 IO 需要用到等待队列。 </p><p>定时器中断处理函数执行，表示有按键按下，先判断一下是否是一次有效的按键，如果是的话就通过 wake_up 或者 wake_up_interruptible 函数来唤醒等待队列头r_wait。</p><p>调用 init_waitqueue_head 函数初始化等待队列头 r_wait</p><p>采用等待事件来处理 read 的阻塞访问，wait_event_interruptible 函数等待releasekey 有效，也就是有按键按下。如果按键没有按下的话进程就会进入休眠状态，因为采用了 wait_event_interruptible 函数，因此进入休眠态的进程可以被信号打断。</p><p>第 208~218 行，首先使用 DECLARE_WAITQUEUE 宏定义一个等待队列，如果没有按键按下的话就使用 add_wait_queue 函数将当前任务的等待队列添加到等待队列头 r_wait 中。随后调用 _set_current_state 函数设置当前进程的状态为 TASK_INTERRUPTIBLE，也就是可以被信号打断。接下来调用 schedule 函数进行一次任务切换，当前进程就会进入到休眠态。如果有按键按下，那么进入休眠态的进程就会唤醒，然后接着从休眠点开始运行。在这里也就是从第 213行开始运行，首先通过 signal_pending 函数判断一下进程是不是由信号唤醒的，如果是由信号唤醒的话就直接返回-ERESTARTSYS 这个错误码。如果不是由信号唤醒的(也就是被按键唤醒的) 那么就在 217 行调用__set_current_state 函数将任务状态设置为 TASK_RUNNING，然后在218 行调用 remove_wait_queue 函数将进程从等待队列中删除。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里的“IO”单片机的“GPIO”(也就是引脚)。 这里的 IO 指的是 Input/Output，也就是输入/输出，是应用程序对驱动设备的输入/输出操作。&lt;/p&gt;
&lt;h2 id=&quot;阻塞IO&quot;&gt;&lt;a href=&quot;#阻塞IO&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-Linux中断下半部机制</title>
    <link href="https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-Linux%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E6%9C%BA%E5%88%B6/"/>
    <id>https://guoqiang-gump.github.io/2021/04/16/Linux%E9%A9%B1%E5%8A%A8-Linux%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E6%9C%BA%E5%88%B6/</id>
    <published>2021-04-15T16:04:12.000Z</published>
    <updated>2021-04-15T16:46:15.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上半部与下半部"><a href="#上半部与下半部" class="headerlink" title="上半部与下半部"></a>上半部与下半部</h1><p>上半部和下半部也称为顶半部和底半部。在使用 request_irq 申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行。中断处理函数一定要快点执行完毕，越短越好，但是有些中断处理过程就是比较费时间，必须要对其进行处理，缩小中断处理函数的执行时间。</p><p>中断处理过程可分为了两部分： </p><p>上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。 </p><p>下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。 </p><p>因此，Linux 内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，那些对时间敏感、执行速度快的操作可以放到中断处理函数中，也就是上半部。剩下的所有工作都可以放到下半部去执行，</p><p>①、如果要处理的内容不希望被其他中断打断，那么可以放到上半部。</p><p>②、如果要处理的任务对时间敏感，可以放到上半部。 </p><p>③、如果要处理的任务与硬件有关，可以放到上半部 </p><p>④、除了上述三点以外的其他任务，优先考虑放到下半部。</p><h2 id="下半部机制"><a href="#下半部机制" class="headerlink" title="下半部机制"></a>下半部机制</h2><h3 id="1、软中断"><a href="#1、软中断" class="headerlink" title="1、软中断"></a><strong>1、软中断</strong></h3><p>Linux内核使用结构体softirq_action表示软中断，softirq_action结构体定义在文件include/linux/interrupt.h中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct softirq_action</span><br><span class="line">&#123;</span><br><span class="line">void (*action)(struct softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static struct softirq_action softirq_vec[NR_SOFTIRQS];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例代码softirq_vec 数组</span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">     HI_SOFTIRQ&#x3D;0, &#x2F;* 高优先级软中断 *&#x2F;</span><br><span class="line">     TIMER_SOFTIRQ, &#x2F;* 定时器软中断 *&#x2F;</span><br><span class="line">     NET_TX_SOFTIRQ, &#x2F;* 网络数据发送软中断 *&#x2F;</span><br><span class="line">     NET_RX_SOFTIRQ, &#x2F;* 网络数据接收软中断 *&#x2F;</span><br><span class="line">     BLOCK_SOFTIRQ, </span><br><span class="line">     BLOCK_IOPOLL_SOFTIRQ, </span><br><span class="line">     TASKLET_SOFTIRQ, &#x2F;* tasklet 软中断 *&#x2F;</span><br><span class="line">     SCHED_SOFTIRQ, &#x2F;* 调度软中断 *&#x2F;</span><br><span class="line">     HRTIMER_SOFTIRQ, &#x2F;* 高精度定时器软中断 *&#x2F;</span><br><span class="line">     RCU_SOFTIRQ, &#x2F;* RCU 软中断 *&#x2F;</span><br><span class="line">     NR_SOFTIRQS&#x2F;*  *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，一共有 10 个软中断，NR_SOFTIRQS 是枚举类型，NR_SOFTIRQS 为 10，softirq_action 结构体中的 action 成员变量就是软中断的服务函数，数组 softirq_vec 是个有 10 个 元素的全局数组，因此所有的 CPU(对于 SMP 系统而言)都可以访问到，每个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个 CPU 所执行的软中断服务函数确是相同的，都是数组 softirq_vec 中定义的 action 函数。</p><p>要使用软中断，必须先使用 open_softirq 函数注册对应的软中断处理函数，open_softirq 函数原型如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void open_softirq(int nr, void (*action)(struct softirq_action *))</span><br></pre></td></tr></table></figure><p>nr：要开启的软中断，在示例代码 51.1.2.3 中选择一个。<br>action：软中断对应的处理函数。<br>返回值：没有返回值。</p><p>注册好软中断以后需要通过 raise_softirq 函数触发，raise_softirq 函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void raise_softirq(unsigned int nr)&#x2F;&#x2F;nr：要触发的软中断。返回值：没有返回值。</span><br></pre></td></tr></table></figure><p>软中断必须在编译的时候静态注册！Linux内核使用 softirq_init 函数初始化软中断，softirq_init 函数定义在 kernel/softirq.c 文件里面，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void __init softirq_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int cpu;</span><br><span class="line"></span><br><span class="line">        for_each_possible_cpu(cpu) &#123;</span><br><span class="line">            per_cpu(tasklet_vec, cpu).tail &#x3D;</span><br><span class="line">            &amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line">            per_cpu(tasklet_hi_vec, cpu).tail &#x3D;</span><br><span class="line">            &amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">        open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>softirq_init 函数默认会打开 TASKLET_SOFTIRQ (tasklet 软中断)和 HI_SOFTIRQ(高优先级软中断)。 </p><h3 id="2、tasklet"><a href="#2、tasklet" class="headerlink" title="2、tasklet"></a><strong>2、tasklet</strong></h3><p>tasklet 是利用软中断来实现的另外一种下半部机制，在软中断和 tasklet 之间，建议使用 tasklet。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct tasklet_struct</span><br><span class="line">&#123;</span><br><span class="line">    struct tasklet_struct *next; &#x2F;* 下一个 tasklet *&#x2F;</span><br><span class="line">    unsigned long state; &#x2F;* tasklet 状态 *&#x2F;</span><br><span class="line">    atomic_t count; &#x2F;* 计数器，记录对 tasklet 的引用数 *&#x2F;</span><br><span class="line">    void (*func)(unsigned long); &#x2F;* tasklet 执行的函数 *&#x2F;</span><br><span class="line">    unsigned long data; &#x2F;* 函数 func 的参数 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>func 函数就是 tasklet 要执行的处理函数，用户定义函数内容，相当于中断处理函数。</p><p>如果要使用 tasklet，必须先定义一个 tasklet，然后使用 tasklet_init 函数初始化 tasklet，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void tasklet_init(struct tasklet_struct *t,void (*func)(unsigned long), </span><br><span class="line">unsigned long data); </span><br></pre></td></tr></table></figure><p>t：要初始化的 tasklet<br>func：tasklet 的处理函数。<br>data：要传递给 func 函数的参数<br>返回值：没有返回值。</p><p>也 可 以 使 用 宏 DECLARE_TASKLET 来 一 次 性 完 成 tasklet 的 定 义 和 初 始 化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET(name, func, data)</span><br></pre></td></tr></table></figure><p>其中 name 为要定义的 tasklet 名字，这个名字就是一个 tasklet_struct 类型的时候变量，func就是 tasklet 的处理函数，data 是传递给 func 函数的参数。 </p><p>在上半部，也就是中断处理函数中调用 tasklet_schedule 函数就能使 tasklet 在合适的时间运行，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void tasklet_schedule(struct tasklet_struct *t) </span><br></pre></td></tr></table></figure><p><strong>t</strong>：要调度的 tasklet，也就是 DECLARE_TASKLET 宏里面的 name。 <strong>返回值：</strong>没有返回值。 </p><p><strong>参考使用示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 定义 taselet *&#x2F;</span><br><span class="line">struct tasklet_struct testtasklet;</span><br><span class="line"></span><br><span class="line">&#x2F;* tasklet 处理函数 *&#x2F;</span><br><span class="line">void testtasklet_func(unsigned long data) &#123;</span><br><span class="line"> &#x2F;* tasklet 具体处理内容 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 中断处理函数 *&#x2F;</span><br><span class="line">irqreturn_t test_handler(int irq, void *dev_id) &#123;</span><br><span class="line">     ......</span><br><span class="line">     &#x2F;* 调度 tasklet *&#x2F;</span><br><span class="line">     tasklet_schedule(&amp;testtasklet);</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动入口函数 *&#x2F;</span><br><span class="line">static int __init xxxx_init(void) &#123;</span><br><span class="line">     ......</span><br><span class="line">     &#x2F;* 初始化 tasklet *&#x2F;</span><br><span class="line">     tasklet_init(&amp;testtasklet, testtasklet_func, data);</span><br><span class="line">     &#x2F;* 注册中断处理函数 *&#x2F;</span><br><span class="line">     request_irq(xxx_irq, test_handler, 0, &quot;xxx&quot;, &amp;xxx_dev);</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、工作队列"><a href="#3、工作队列" class="headerlink" title="3、工作队列"></a>3、工作队列</h3><p>工作队列是另外一种下半部执行方式，工作队列在进程上下文执行，工作队列将要推后的工作交给一个内核线程去执行，因为工作队列工作在进程上下文，因此工作队列允许睡眠或重新调度。因此如果你要推后的工作可以睡眠那么就可以选择工作队列，否则的话就只能选择软中断或 tasklet。</p><p>Linux 内核使用 work_struct 结构体表示一个<strong>工作</strong>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct work_struct &#123;</span><br><span class="line">     atomic_long_t data; </span><br><span class="line">     struct list_head entry;</span><br><span class="line">     work_func_t func; &#x2F;* 工作队列处理函数 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些工作组织成结构体workqueue_struct <strong>工作队列</strong>。</p><p>Linux 内核使用<strong>工作者线程</strong>(worker thread)来处理工作队列中的各个工作，Linux 内核使用worker 结构体表示工作者线程，worker 结构体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct worker &#123;</span><br><span class="line">………………</span><br><span class="line"> struct workqueue_struct *rescue_wq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个 worker 都有一个工作队列，工作者线程处理自己工作队列中的所有工作。在实际的驱动开发中，只需要定义工作(work_struct)即可，关于工作队列和工作者线程基本不用去管。</p><p>简单创建工作很简单，直接定义一个 work_struct 结构体变量即可，然后使用 INIT_WORK 宏来初始化工作.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define INIT_WORK(_work, _func)&#x2F;&#x2F;_work 表示要初始化的工作，_func 是工作对应的处理函数。</span><br></pre></td></tr></table></figure><p>也可以使用 DECLARE_WORK 宏一次性完成工作的创建和初始化，宏定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define DECLARE_WORK(n, f)&#x2F;&#x2F;n 表示定义的工作(work_struct)，f 表示工作对应的处理函数。</span><br></pre></td></tr></table></figure><p>和 tasklet 一样，工作也是需要调度才能运行的，工作的调度函数为 schedule_work</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool schedule_work(struct work_struct *work)&#x2F;&#x2F;work：要调度的工作。返回值：0 成功，其他值 失败。</span><br></pre></td></tr></table></figure><p><strong>参考使用示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 定义工作(work) *&#x2F;</span><br><span class="line">struct work_struct testwork;</span><br><span class="line"></span><br><span class="line">&#x2F;* work 处理函数 *&#x2F;</span><br><span class="line">void testwork_func_t(struct work_struct *work);</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;* work 具体处理内容 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 中断处理函数 *&#x2F;</span><br><span class="line">irqreturn_t test_handler(int irq, void *dev_id) &#123;</span><br><span class="line">     ......</span><br><span class="line">     &#x2F;* 调度 work *&#x2F;</span><br><span class="line">     schedule_work(&amp;testwork);</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 驱动入口函数 *&#x2F;</span><br><span class="line">static int __init xxxx_init(void) &#123;</span><br><span class="line">     ......</span><br><span class="line">     &#x2F;* 初始化 work *&#x2F;</span><br><span class="line">     INIT_WORK(&amp;testwork, testwork_func_t);</span><br><span class="line">     &#x2F;* 注册中断处理函数 *&#x2F;</span><br><span class="line">     request_irq(xxx_irq, test_handler, 0, &quot;xxx&quot;, &amp;xxx_dev);</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;上半部与下半部&quot;&gt;&lt;a href=&quot;#上半部与下半部&quot; class=&quot;headerlink&quot; title=&quot;上半部与下半部&quot;&gt;&lt;/a&gt;上半部与下半部&lt;/h1&gt;&lt;p&gt;上半部和下半部也称为顶半部和底半部。在使用 request_irq 申请中断的时候注册的中断服务函数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-Linux中断</title>
    <link href="https://guoqiang-gump.github.io/2021/04/15/Linux%E9%A9%B1%E5%8A%A8-Linux%E4%B8%AD%E6%96%AD/"/>
    <id>https://guoqiang-gump.github.io/2021/04/15/Linux%E9%A9%B1%E5%8A%A8-Linux%E4%B8%AD%E6%96%AD/</id>
    <published>2021-04-15T13:17:29.000Z</published>
    <updated>2021-04-15T16:47:07.384Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 内核提供了完善的中断框架，我们只需要申请中断，然后注册中断处理函数即可，使用非常方便，不需要一系列复杂的寄存器配置。</p><h1 id="Linux-中断-API-函数"><a href="#Linux-中断-API-函数" class="headerlink" title="Linux 中断 API 函数"></a><strong>Linux</strong> <strong>中断</strong> <strong>API</strong> <strong>函数</strong></h1><p><strong>1、中断号</strong></p><p>每个中断都有一个中断号，通过中断号即可区分不同的中断，有的资料也把中断号叫做中断线。在 Linux 内核中使用一个 int 变量表示中断号，关于中断号就是裸机学的中断号了。</p><p><strong>2、request_irq 函数</strong></p><p>在 Linux 内核中要想使用某个中断是需要申请的，request_irq 函数用于申请中断，request_irq函数可能会导致睡眠，因此不能在中断上下文或者其他禁止睡眠的代码段中使用 request_irq 函数。request_irq 函数会激活(使能)中断，所以不需要我们手动去使能中断，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,</span><br><span class="line"> const char *name, void *dev)</span><br></pre></td></tr></table></figure><p><strong>irq</strong>：要申请中断的中断号。 </p><p><strong>handler</strong>：中断处理函数，当中断发生以后就会执行此中断处理函数。 </p><p><strong>flags</strong>：中断标志。标志可以通过“|”来实现多种组合。</p><p>IRQF_ONESHOT ——单次中断，中断执行一次就结束。<br>IRQF_TRIGGER_NONE ——无触发。<br>IRQF_TRIGGER_RISING ——上升沿触发。<br>IRQF_TRIGGER_FALLING ——下降沿触发。<br>IRQF_TRIGGER_HIGH ——高电平触发。<br>IRQF_TRIGGER_LOW 低电平触发。</p><p><strong>name</strong>：中断名字，设置以后可以在/proc/interrupts 文件中看到对应的中断名字。 </p><p><strong>dev</strong>：如果将 flags 设置为 IRQF_SHARED 的话，dev 用来区分不同的中断，一般情况下将dev 设置为设备结构体，dev 会传递给中断处理函数 irq_handler_t 的第二个参数。 </p><p><strong>返回值：</strong>0 中断申请成功，其他负值 中断申请失败，如果返回-EBUSY 的话表示中断已经被申请了。 </p><p><strong>3、free_irq 函数</strong></p><p>使用中断的时候需要通过 request_irq 函数申请，使用完成以后就要通过 free_irq 函数释放掉相应的中断。如果中断不是共享的，那么 free_irq 会删除中断处理函数并且禁止中断。free_irq函数原型如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void free_irq(unsigned int irq, void *dev)</span><br></pre></td></tr></table></figure><p>irq：要释放的中断。<br>dev：如果中断设置为共享(IRQF_SHARED)的话，此参数用来区分具体的中断。共享中断只有在释放最后中断处理函数的时候才会被禁止掉。<br>返回值：无。</p><p><strong>4、中断处理函数</strong><br>使用 request_irq 函数申请中断的时候需要设置中断处理函数，中断处理函数格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irqreturn_t (*irq_handler_t) (int, void *)</span><br></pre></td></tr></table></figure><p>第一个参数是要中断处理函数要相应的中断号。第二个参数是一个指向 void 的指针，也就是个通用指针，需要与 request_irq 函数的 dev 参数保持一致。用于区分共享中断的不同设备，dev 也可以指向设备数据结构。中断处理函数的返回值为 irqreturn_t 类型。irqreturn_t 是个枚举类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum irqreturn &#123;</span><br><span class="line">    IRQ_NONE &#x3D; (0 &lt;&lt; 0),</span><br><span class="line">    IRQ_HANDLED &#x3D; (1 &lt;&lt; 0),</span><br><span class="line">    IRQ_WAKE_THREAD &#x3D; (1 &lt;&lt; 1),</span><br><span class="line">&#125;;</span><br><span class="line">typedef enum irqreturn irqreturn_t;</span><br></pre></td></tr></table></figure><p>一般中断服务函数返回值使用如 下形式： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return IRQ_RETVAL(IRQ_HANDLED)</span><br></pre></td></tr></table></figure><p><strong>5、中断使能与禁止函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void enable_irq(unsigned int irq)</span><br><span class="line">void disable_irq(unsigned int irq)</span><br><span class="line">void disable_irq_nosync(unsigned int irq) </span><br></pre></td></tr></table></figure><p>enable_irq 和 disable_irq 用于使能和禁止指定的中断，irq 就是要禁止的中断号。disable_irq函数要等到当前正在执行的中断处理函数执行完才返回，因此使用者需要保证不会产生新的中断，并且确保所有已经开始执行的中断处理程序已经全部退出。在这种情况下，可以使用disable_irq_nosync 函数，其调用以后立即返回，不会等待当前中断处理程序执行完毕。</p><p>开启或关闭全局中断，使用如下两个函数： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_irq_enable()&#x2F;&#x2F; 用于使能当前处理器中断系统</span><br><span class="line">local_irq_disable()&#x2F;&#x2F;用于禁止当前处理器中断系统。</span><br></pre></td></tr></table></figure><p>将中断状态恢复到以前的状态的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_irq_save(flags) &#x2F;&#x2F;local_irq_save 函数用于禁止中断，并且将中断状态保存在 flags 中。</span><br><span class="line">local_irq_restore(flags) &#x2F;&#x2F;用于恢复中断，将中断到 flags 状态。</span><br></pre></td></tr></table></figure><h1 id="设备树中断信息节点"><a href="#设备树中断信息节点" class="headerlink" title="设备树中断信息节点"></a>设备树中断信息节点</h1><p>如果使用设备树的话就需要在设备树中设置好中断属性信息，Linux 内核通过读取设备树中的中断属性信息来配置中断。打开 imx6ull.dtsi 文件，其中的 intc 节点就是I.MX6ULL 的中断控制器节点，节点内容如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intc: interrupt-controller@00a01000 &#123; </span><br><span class="line">    compatible &#x3D; &quot;arm,cortex-a7-gic&quot;; </span><br><span class="line">    #interrupt-cells &#x3D; &lt;3&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    reg &#x3D; &lt;0x00a01000 0x1000&gt;,</span><br><span class="line">    &lt;0x00a02000 0x100&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第 2 行，compatible 属性值为“arm,cortex-a7-gic”在 Linux 内核源码中搜索“arm,cortex-a7- gic”即可找到 GIC 中断控制器驱动文件。 </p><p>第 3 行，#interrupt-cells 和#address-cells、#size-cells 一样。表示此中断控制器下设备的 cells 大小，对于设备而言，会使用 interrupts 属性描述中断信息，#interrupt-cells 描述了 interrupts 属性的 cells 大小，也就是一条信息有几个 cells。每个 cells 都是 32 位整形值，对于 ARM 处理的GIC 来说，一共有 3 个 cells，这三个 cells 的含义如下： 第一个 cells：中断类型，0 表示 SPI 中断，1 表示 PPI 中断。 </p><p>第二个 cells：中断号，对于 SPI 中断来说中断号的范围为 0<del>987，对于 PPI 中断来说中断号的范围为 0</del>15。 </p><p>第三个 cells：标志，bit[3:0]表示中断触发类型，为 1 的时候表示上升沿触发，为 2 的时候表示下降沿触发，为 4 的时候表示高电平触发，为 8 的时候表示低电平触发。bit[15:8]为 PPI 中断的 CPU 掩码。 </p><p>第 4 行，interrupt-controller 节点为空，表示当前节点是中断控制器。</p><p>对于 gpio 来说，gpio 节点也可以作为中断控制器，比如 imx6ull.dtsi 文件中的 gpio5 节点内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gpio5: gpio@020ac000 &#123; </span><br><span class="line">    compatible &#x3D; &quot;fsl,imx6ul-gpio&quot;, &quot;fsl,imx35-gpio&quot;; </span><br><span class="line">    reg &#x3D; &lt;0x020ac000 0x4000&gt;;</span><br><span class="line">    interrupts &#x3D; &lt;GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">    &lt;GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    gpio-controller; 7 #gpio-cells &#x3D; &lt;2&gt;;</span><br><span class="line">    interrupt-controller; 9 #interrupt-cells &#x3D; &lt;2&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第 4 行，interrupts 描述中断源信息，对于 gpio5 来说一共有两条信息，中断类型都是 SPI，触发电平都是 IRQ_TYPE_LEVEL_HIGH。不同之处在于中断源，一个是 74，一个是 75，GPIO5 一共用了 2 个中断号，一个是 74，一个是 75。其中 74 对应 GPIO5_IO00<del>GPIO5_IO15 这低 16 个 IO，75 对应 GPIO5_IO16</del>GPIOI5_IO31 这高 16 位 IO。 </p><p>第 8 行，interrupt-controller 表明了 gpio5 节点也是个中断控制器，用于控制 gpio5 所有 IO的中断。 </p><p>第 9 行，将#interrupt-cells 修改为 2。 </p><p>简单总结一下与中断有关的设备树属性信息：<br>①、#interrupt-cells，指定中断源的信息 cells 个数。<br>②、interrupt-controller，表示当前节点为中断控制器。<br>③、interrupts，指定中断号，触发方式等。<br>④、interrupt-parent，指定父中断，也就是中断控制</p><h1 id="获取中断号"><a href="#获取中断号" class="headerlink" title="获取中断号"></a><strong>获取中断号</strong></h1><p>编写驱动的时候需要用到中断号，我们用到中断号，中断信息已经写到了设备树里面，因此可以通过 irq_of_parse_and_map 函数从 interupts 属性中提取到对应的设备号，函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned int irq_of_parse_and_map(struct device_node *dev, int index)</span><br></pre></td></tr></table></figure><p>dev：设备节点。<br>index：索引号，interrupts 属性可能包含多条中断信息，通过 index 指定要获取的信息。<br>返回值：中断号。</p><p>如果使用 GPIO 的话，可以使用 gpio_to_irq 函数来获取 gpio 对应的中断号，函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int gpio_to_irq(unsigned int gpio)&#x2F;&#x2F;gpio：要获取的 GPIO 编号。返回值：GPIO 对应的中断号。</span><br></pre></td></tr></table></figure><h1 id="实验程序编写"><a href="#实验程序编写" class="headerlink" title="实验程序编写"></a><strong>实验程序编写</strong></h1><p>驱动 I.MX6U-ALPHA 开发板上的 KEY0 按键，不过我们采用中断的方式， 并且采用定时器来实现按键消抖，应用程序读取按键值并且通过终端打印出来。</p><h2 id="修改设备树文件"><a href="#修改设备树文件" class="headerlink" title="修改设备树文件"></a><strong>修改设备树文件</strong></h2><p>使用到了按键 KEY0，按键 KEY0 使用中断模式，因此需要在“key”节点下添加 中断相关属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">key &#123;</span><br><span class="line">        #address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">        #size-cells &#x3D; &lt;1&gt;;</span><br><span class="line">        compatible &#x3D; &quot;atkalpha-key&quot;; </span><br><span class="line">        pinctrl-names &#x3D; &quot;default&quot;; </span><br><span class="line">        pinctrl-0 &#x3D; &lt;&amp;pinctrl_key&gt;;</span><br><span class="line">        key-gpio &#x3D; &lt;&amp;gpio1 18 GPIO_ACTIVE_LOW&gt;; &#x2F;* KEY0 *&#x2F;</span><br><span class="line">        interrupt-parent &#x3D; &lt;&amp;gpio1&gt;;</span><br><span class="line">        interrupts &#x3D; &lt;18 IRQ_TYPE_EDGE_BOTH&gt;; &#x2F;* FALLING RISING *&#x2F;</span><br><span class="line">        status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第 8 行，设置 interrupt-parent 属性值为“gpio1”，因为 KEY0 所使用的 GPIO 为GPIO1_IO18，也就是设置 KEY0 的 GPIO 中断控制器为 gpio1。 </p><p>第 9 行，设置 interrupts 属性，也就是设置中断源，第一个 cells 的 18 表示 GPIO1 组的 18号 IO。IRQ_TYPE_EDGE_BOTH 表示上升沿和下降沿同时有效， 相当于 KEY0 按下和释放都会触发中断。</p><h2 id="按键中断驱动程序编写"><a href="#按键中断驱动程序编写" class="headerlink" title="按键中断驱动程序编写"></a><strong>按键中断驱动程序编写</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: imx6uirq.c</span><br><span class="line">描述   : Linux中断驱动实验</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* 中断IO描述结构体 *&#x2F;</span><br><span class="line">struct irq_keydesc &#123;</span><br><span class="line">int gpio;&#x2F;* gpio *&#x2F;</span><br><span class="line">int irqnum;&#x2F;* 中断号     *&#x2F;</span><br><span class="line">unsigned char value;&#x2F;* 按键对应的键值 *&#x2F;</span><br><span class="line">char name[10];&#x2F;* 名字 *&#x2F;</span><br><span class="line">irqreturn_t (*handler)(int, void *);&#x2F;* 中断服务函数 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* imx6uirq设备结构体 *&#x2F;</span><br><span class="line">struct imx6uirq_dev&#123;</span><br><span class="line">atomic_t keyvalue;&#x2F;* 有效的按键键值 *&#x2F;</span><br><span class="line">atomic_t releasekey;&#x2F;* 标记是否完成一次完成的按键，包括按下和释放 *&#x2F;</span><br><span class="line">struct timer_list timer;&#x2F;* 定义一个定时器*&#x2F;</span><br><span class="line">struct irq_keydesc irqkeydesc[KEY_NUM];&#x2F;* 按键描述数组 *&#x2F;</span><br><span class="line">unsigned char curkeynum;&#x2F;* 当前的按键号 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct imx6uirq_dev imx6uirq;&#x2F;* irq设备 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* @description: 中断服务函数，开启定时器，延时10ms，</span><br><span class="line"> *    定时器用于按键消抖。</span><br><span class="line"> * @param - irq : 中断号 </span><br><span class="line"> * @param - dev_id: 设备结构。</span><br><span class="line"> * @return : 中断执行结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">static irqreturn_t key0_handler(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">struct imx6uirq_dev *dev &#x3D; (struct imx6uirq_dev *)dev_id;</span><br><span class="line"></span><br><span class="line">dev-&gt;curkeynum &#x3D; 0;</span><br><span class="line">dev-&gt;timer.data &#x3D; (volatile long)dev_id;</span><br><span class="line">mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(10));&#x2F;* 10ms定时 *&#x2F;</span><br><span class="line">return IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* @description: 定时器服务函数，用于按键消抖，定时器到了以后</span><br><span class="line"> *  再次读取按键值，如果按键还是处于按下状态就表示按键有效。</span><br><span class="line"> * @param - arg: 设备结构变量</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">void timer_function(unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char value;</span><br><span class="line">unsigned char num;</span><br><span class="line">struct irq_keydesc *keydesc;</span><br><span class="line">struct imx6uirq_dev *dev &#x3D; (struct imx6uirq_dev *)arg;</span><br><span class="line"></span><br><span class="line">num &#x3D; dev-&gt;curkeynum;</span><br><span class="line">keydesc &#x3D; &amp;dev-&gt;irqkeydesc[num];</span><br><span class="line"></span><br><span class="line">value &#x3D; gpio_get_value(keydesc-&gt;gpio); &#x2F;* 读取IO值 *&#x2F;</span><br><span class="line">if(value &#x3D;&#x3D; 0)&#123; &#x2F;* 按下按键 *&#x2F;</span><br><span class="line">atomic_set(&amp;dev-&gt;keyvalue, keydesc-&gt;value);</span><br><span class="line">&#125;</span><br><span class="line">else&#123; &#x2F;* 按键松开 *&#x2F;</span><br><span class="line">atomic_set(&amp;dev-&gt;keyvalue, 0x80 | keydesc-&gt;value);</span><br><span class="line">atomic_set(&amp;dev-&gt;releasekey, 1);&#x2F;* 标记松开按键，即完成一次完整的按键过程 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 按键IO初始化</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int keyio_init(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;* 初始化key所使用的IO，并且设置成中断模式 *&#x2F;</span><br><span class="line">for (i &#x3D; 0; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">memset(imx6uirq.irqkeydesc[i].name, 0, sizeof(name));&#x2F;* 缓冲区清零 *&#x2F;</span><br><span class="line">sprintf(imx6uirq.irqkeydesc[i].name, &quot;KEY%d&quot;, i);&#x2F;* 组合名字 *&#x2F;</span><br><span class="line">gpio_request(imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].name);</span><br><span class="line">gpio_direction_input(imx6uirq.irqkeydesc[i].gpio);</span><br><span class="line">imx6uirq.irqkeydesc[i].irqnum &#x3D; irq_of_parse_and_map(imx6uirq.nd, i);</span><br><span class="line">#if 0</span><br><span class="line">imx6uirq.irqkeydesc[i].irqnum &#x3D; gpio_to_irq(imx6uirq.irqkeydesc[i].gpio);</span><br><span class="line">#endif</span><br><span class="line">printk(&quot;key%d:gpio&#x3D;%d, irqnum&#x3D;%d\r\n&quot;,i, imx6uirq.irqkeydesc[i].gpio, </span><br><span class="line">                                         imx6uirq.irqkeydesc[i].irqnum);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 申请中断 *&#x2F;</span><br><span class="line">imx6uirq.irqkeydesc[0].handler &#x3D; key0_handler;</span><br><span class="line">imx6uirq.irqkeydesc[0].value &#x3D; KEY0VALUE;</span><br><span class="line"></span><br><span class="line">for (i &#x3D; 0; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">ret &#x3D; request_irq(imx6uirq.irqkeydesc[i].irqnum, imx6uirq.irqkeydesc[i].handler, </span><br><span class="line">                 IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, imx6uirq.irqkeydesc[i].name, &amp;imx6uirq);</span><br><span class="line">if(ret &lt; 0)&#123;</span><br><span class="line">printk(&quot;irq %d request failed!\r\n&quot;, imx6uirq.irqkeydesc[i].irqnum);</span><br><span class="line">return -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 创建定时器 *&#x2F;</span><br><span class="line">init_timer(&amp;imx6uirq.timer);</span><br><span class="line">imx6uirq.timer.function &#x3D; timer_function;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动入口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init imx6uirq_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 5、初始化按键 *&#x2F;</span><br><span class="line">atomic_set(&amp;imx6uirq.keyvalue, INVAKEY);</span><br><span class="line">atomic_set(&amp;imx6uirq.releasekey, 0);</span><br><span class="line">keyio_init();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动出口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __exit imx6uirq_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i &#x3D; 0;</span><br><span class="line">&#x2F;* 删除定时器 *&#x2F;</span><br><span class="line">del_timer_sync(&amp;imx6uirq.timer);&#x2F;* 删除定时器 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 释放中断 *&#x2F;</span><br><span class="line">for (i &#x3D; 0; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">free_irq(imx6uirq.irqkeydesc[i].irqnum, &amp;imx6uirq);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体 irq_keydesc 为按键的中断描述结构体，gpio 为按键 GPIO 编号，irqnum为按键 IO 对应的中断号，value 为按键对应的键值，name 为按键名字，handler 为按键中断服务函数。使用 irq_keydesc 结构体即可描述一个按键中断。</p><p>结构体 imx6uirq_dev 为本例程设备结构体，第 55 行的 keyvalue 保存按键值， releasekey 表示按键是否被释放，如果按键被释放表示发生了一次完整的按键过程。 timer 为按键消抖定时器，数组 irqkeydesc 为按键信息数组，数组元素个数就是开发板上的按键个数，I.MX6U-ALIPHA 开发板上只有一个按键，因此 irqkeydesc 数组只有一个元素。curkeynum 表示当前按键。</p><p>key0_handler 函数，按键 KEY0 中断处理函数，参数 dev_id 为设备结构体，也就是 imx6uirq。设置 curkeynum=0，表示当前按键为 KEY0，使用 mod_timer函数启动定时器，定时器周期为 10ms。</p><p>timer_function 函数，定时器定时处理函数，参数 arg 是设备结构体，也就是imx6uirq，在此函数中读取按键值。</p><p>keyio_init 函数，按键 IO 初始化函数，在驱动入口函数里面会调用 keyio_init来初始化按键 IO。轮流初始化所有的按键，包括申请 IO、设置 IO 为输入模式、 从设备树中获取 IO 的中断号等等。通过 irq_of_parse_and_map 函数从设备树中获取按键 IO 对应的中断号。也可以使用 gpio_to_irq 函数将某个 IO 设置为中断状态，并且返回其中断 号。设置 KEY0 按键对应的按键中断处理函数为 key0_handler、KEY0 的按键值为 KEY0VALUE。轮流调用 request_irq 函数申请中断号，设置中断触发模式为IRQF_TRIGGER_FALLING 和 IRQF_TRIGGER_RISING，也就是上升沿和下降沿都可以触发中断。最后，初始化定时器，并且设置定时器的定时处理函数。</p><p>驱动出口函数调用 del_timer_sync 函数删除定时器，轮流释放申请的所有按键中断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux 内核提供了完善的中断框架，我们只需要申请中断，然后注册中断处理函数即可，使用非常方便，不需要一系列复杂的寄存器配置。&lt;/p&gt;
&lt;h1 id=&quot;Linux-中断-API-函数&quot;&gt;&lt;a href=&quot;#Linux-中断-API-函数&quot; class=&quot;headerlin</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-内核定时器</title>
    <link href="https://guoqiang-gump.github.io/2021/04/15/Linux%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>https://guoqiang-gump.github.io/2021/04/15/Linux%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/</id>
    <published>2021-04-15T12:07:16.000Z</published>
    <updated>2021-04-15T13:17:09.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、内核时间管理简介"><a href="#1、内核时间管理简介" class="headerlink" title="1、内核时间管理简介"></a><strong>1、内核时间管理简介</strong></h1><p>Linux 要运行，需要一个系统时钟的，至于这个系统时钟是由哪个定时器提供的，这对于我们 Linux 驱动编写者来说，不需要深入研究这些具体的实现，只需要掌握相应的 API 函数即可。 </p><p>硬件定时器提供时钟源，时钟源的频率可以设置， 设置好以后就周期性的产生定时中断，系统使用定时中断来计时。中断周期性产生的频率就是系统频率， 也叫做节拍率(tick rate)(有的资料也叫系统频率)，比如 1000Hz，100Hz 等等说的就是系统节拍率。系统节拍率是可以设置的，单位是 Hz，</p><p>高节拍率和低节拍率的优缺点： </p><p>①、高节拍率会提高系统时间精度，如果采用 100Hz 的节拍率，时间精度就是 10ms，采用1000Hz 的话时间精度就是 1ms，精度提高了 10 倍。高精度时钟的好处有很多，对于那些对时 间要求严格的函数来说，能够以更高的精度运行，时间测量也更加准确。 </p><p>②、高节拍率会导致中断的产生更加频繁，频繁的中断会加剧系统的负担，1000Hz 和 100Hz 的系统节拍率相比，系统要花费 10 倍的“精力”去处理中断。中断服务函数占用处理器的时间 增加，但是现在的处理器性能都很强大，所以采用 1000Hz 的系统节拍率并不会增加太大的负载压力。</p><p>Linux 内核使用全局变量 jiffies 来记录系统从启动以来的系统节拍数，系统启动的时候会将 jiffies 初始化为 0，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern u64 __jiffy_data jiffies_64;&#x2F;&#x2F;定义了一个 64 位的 jiffies_64。</span><br><span class="line">extern unsigned long volatile __jiffy_data jiffies;&#x2F;&#x2F;定义一个unsigned long的32位jiffies。</span><br></pre></td></tr></table></figure><p>HZ 表示每秒的节拍数，jiffies 表示系统运行的 jiffies 节拍数，所以 jiffies/HZ 就是系统运行时间，单位为秒。不管是 32 位还是 64 位的 jiffies，都有溢出的风险，溢出以后会重新从 0 开始计数，相当于绕回来了，因此有些资料也将这个现象也叫做绕回。假如 HZ 为最大值 1000 的时候，32 位的 jiffies 只需要 49.7 天就发生了绕回，对于 64 位的 jiffies 来说大概需要5.8 亿年才能绕回，因此 jiffies_64 的绕回忽略不计。处理 32 位 jiffies 的绕回显得尤为重要， Linux 内核提供了如表 所示的几个 API 函数来处理绕回。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time_after(unkown, known)</span><br><span class="line">time_before(unkown, known)</span><br><span class="line">time_after_eq(unkown, known)</span><br><span class="line">time_before_eq(unkown, known)</span><br></pre></td></tr></table></figure><p>unkown通常为jiffies，known通常是需要对比的值。如果 unkown 超过 known 的话，time_after 函数返回真，否则返回假。如果 unkown 没有超过 known 的话 time_before 函数返回真，否则返回假。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unsigned long timeout;</span><br><span class="line">timeout &#x3D; jiffies + (2 * HZ); &#x2F;* 超时的时间点 *&#x2F;</span><br><span class="line">&#x2F;*************************************</span><br><span class="line">具体的代码</span><br><span class="line">************************************&#x2F;</span><br><span class="line">&#x2F;* 判断有没有超时 *&#x2F;</span><br><span class="line">if(time_before(jiffies, timeout)) &#123;</span><br><span class="line">&#x2F;* 超时未发生 *&#x2F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;* 超时发生 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timeout 就是超时时间点，如果 jiffies 大于 timeout 那就表示超时了，比如我们要判断代码执行时间是不是超过了 2 秒，那么超时时间点就是 jiffies+(2*HZ)。通过函数 time_before 来判断 jiffies 是否小于 timeout，如果小于的话就表示没有超时。 </p><p>Linux 内核提供了几个 jiffies 和 ms、us、ns 之间的转换函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将 jiffies 类型的参数 j 分别转换为对应的毫秒、微秒、纳秒。</span><br><span class="line">int jiffies_to_msecs(const unsigned long j)  </span><br><span class="line">int jiffies_to_usecs(const unsigned long j)</span><br><span class="line">u64 jiffies_to_nsecs(const unsigned long j)</span><br><span class="line">&#x2F;&#x2F;将毫秒、微秒、纳秒转换为 jiffies 类型。</span><br><span class="line">long msecs_to_jiffies(const unsigned int m)</span><br><span class="line">long usecs_to_jiffies(const unsigned int u)</span><br><span class="line">unsigned long nsecs_to_jiffies(u64 n)</span><br></pre></td></tr></table></figure><h1 id="2、内核定时器简介"><a href="#2、内核定时器简介" class="headerlink" title="2、内核定时器简介"></a><strong>2、内核定时器简介</strong></h1><p>定时器是一个很常用的功能，需要周期性处理的工作都要用到定时器。Linux 内核定时器采用系统时钟来实现，并不是 PIT 等硬件定时器。Linux 内核定时器使用很简单，只需要提供超时时间(相当于定时值)和定时处理函数即可，当超时时间到了以后设置的定时处理函数就会执行，使用内核定时器不需要做一大堆的寄存器初始化工作。</p><p>在使用内核定时器的时候要注意一点，内核定时器并不是周期性运行的，超时以后就会自动关闭，因此如果想要实现周期性定时，那么就需要在定时处理函数中重新开启定时器。</p><p>Linux 内核使用 timer_list 结构体表示内核定时器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct timer_list &#123;</span><br><span class="line">     struct list_head entry;</span><br><span class="line">     unsigned long expires; &#x2F;* 定时器超时时间，单位是节拍数 *&#x2F;</span><br><span class="line">     struct tvec_base *base;</span><br><span class="line">     void (*function)(unsigned long); &#x2F;* 定时处理函数 *&#x2F;</span><br><span class="line">     unsigned long data; &#x2F;* 要传递给 function 函数的参数 *&#x2F;</span><br><span class="line">     int slack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要使用内核定时器首先要先定义一个timer_list 变量，表示定时器，tiemr_list 结构体的expires 成员变量表示超时时间，单位为节拍数。需要定义一个周期为 2 秒的定时器，那么这个定时器的超时时间就是 jiffies+(2<em>HZ)，因此 expires=jiffies+(2</em>HZ)。function 就是定时器超时以后的定时处理函数。</p><h2 id="API-函数"><a href="#API-函数" class="headerlink" title="API 函数"></a><strong>API 函数</strong></h2><p><strong>1、init_timer 函数</strong><br>init_timer 函数负责初始化 timer_list 类型变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void init_timer(struct timer_list *timer)</span><br></pre></td></tr></table></figure><p>timer：要初始化定时器。<br>返回值：没有返回值。</p><p><strong>2、add_timer 函数</strong><br>用于向 Linux 内核注册定时器，使用 add_timer 函数向内核注册定时器以后，定时器就会开始运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void add_timer(struct timer_list *timer)</span><br></pre></td></tr></table></figure><p>timer：要注册的定时器。<br>返回值：没有返回值。</p><p><strong>3、del_timer 函数</strong></p><p>del_timer 函数用于删除一个定时器，不管定时器有没有被激活，都可以使用此函数删除。在多处理器系统上，定时器可能会在其他的处理器上运行，因此在调用 del_timer 函数删除定时器之前要先等待其他处理器的定时处理器函数退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int del_timer(struct timer_list * timer)</span><br></pre></td></tr></table></figure><p>timer：要删除的定时器。<br>返回值：0，定时器还没被激活；1，定时器已经激活。</p><p><strong>4、del_timer_sync 函数</strong></p><p>del_timer_sync 函数是 del_timer 函数的同步版，会等待其他处理器使用完定时器再删除，del_timer_sync 不能使用在中断上下文中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int del_timer_sync(struct timer_list *timer)</span><br></pre></td></tr></table></figure><p>timer：要删除的定时器。<br>返回值：0，定时器还没被激活；1，定时器已经激活。</p><p><strong>5、mod_timer 函数</strong><br>mod_timer 函数用于修改定时值，如果定时器还没有激活的话，mod_timer 函数会激活定时器！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mod_timer(struct timer_list *timer, unsigned long expires)</span><br></pre></td></tr></table></figure><p>timer：要修改超时时间(定时值)的定时器。<br>expires：修改后的超时时间。<br>返回值：0，调用 mod_timer 函数前定时器未被激活；1，调用 mod_timer 函数前定时器已被激活。</p><p><strong>使用流程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct timer_list timer; &#x2F;* 定义定时器 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 定时器回调函数 *&#x2F;</span><br><span class="line">void function(unsigned long arg)</span><br><span class="line"> &#123; </span><br><span class="line">&#x2F;&#x2F;定时器处理代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果需要定时器周期性运行的话就使用 mod_timer函数重新设置超时值并且启动定时器。</span><br><span class="line">mod_timer(&amp;dev-&gt;timertest, jiffies + msecs_to_jiffies(2000));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 初始化函数 *&#x2F;</span><br><span class="line">void init(void) </span><br><span class="line">&#123;</span><br><span class="line">    init_timer(&amp;timer); &#x2F;* 初始化定时器 *&#x2F;</span><br><span class="line">    timer.function &#x3D; function; &#x2F;* 设置定时处理函数 *&#x2F;</span><br><span class="line">    timer.expires&#x3D;jffies + msecs_to_jiffies(2000);&#x2F;* 超时时间 2 秒 *&#x2F;</span><br><span class="line">    timer.data &#x3D; (unsigned long)&amp;dev; &#x2F;* 将设备结构体作为参数 *&#x2F;</span><br><span class="line">    add_timer(&amp;timer); &#x2F;* 启动定时器 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 退出函数 *&#x2F;</span><br><span class="line">void exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    del_timer(&amp;timer); &#x2F;* 删除定时器 *&#x2F;</span><br><span class="line">    &#x2F;* 或者使用 *&#x2F;</span><br><span class="line">    del_timer_sync(&amp;timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Linux 内核短延时函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Linux 内核提供毫秒、微 秒和纳秒延时函数，</span><br><span class="line">void ndelay(unsigned long nsecs)</span><br><span class="line">void udelay(unsigned long usecs)</span><br><span class="line">void mdelay(unsigned long mseces)</span><br></pre></td></tr></table></figure><h1 id="3、实验程序编写"><a href="#3、实验程序编写" class="headerlink" title="3、实验程序编写"></a>3、实验程序编写</h1><p>使用内核定时器周期性的点亮和熄灭开发板上的 LED 灯，LED 灯的闪烁周期由内核定时器来设置，测试应用程序可以控制内核定时器周期。</p><p><strong>驱动程序编写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">#define CLOSE_CMD (_IO(0XEF, 0x1))&#x2F;* 关闭定时器 *&#x2F;</span><br><span class="line">#define OPEN_CMD(_IO(0XEF, 0x2))&#x2F;* 打开定时器 *&#x2F;</span><br><span class="line">#define SETPERIOD_CMD(_IO(0XEF, 0x3))&#x2F;* 设置定时器周期命令 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* timer设备结构体 *&#x2F;</span><br><span class="line">struct timer_dev&#123;</span><br><span class="line">dev_t devid;&#x2F;* 设备号  *&#x2F;</span><br><span class="line">struct cdev cdev;&#x2F;* cdev *&#x2F;</span><br><span class="line">struct class *class;&#x2F;* 类 *&#x2F;</span><br><span class="line">struct device *device;&#x2F;* 设备  *&#x2F;</span><br><span class="line">int major;&#x2F;* 主设备号  *&#x2F;</span><br><span class="line">int minor;&#x2F;* 次设备号   *&#x2F;</span><br><span class="line">struct device_node*nd; &#x2F;* 设备节点 *&#x2F;</span><br><span class="line">int led_gpio;&#x2F;* key所使用的GPIO编号*&#x2F;</span><br><span class="line">int timeperiod; &#x2F;* 定时周期,单位为ms *&#x2F;</span><br><span class="line">struct timer_list timer;&#x2F;* 定义一个定时器*&#x2F;</span><br><span class="line">spinlock_t lock;&#x2F;* 定义自旋锁 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct timer_dev timerdev;&#x2F;* timer设备 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 初始化LED灯IO，open函数打开驱动的时候</span><br><span class="line"> *   初始化LED灯所使用的GPIO引脚。</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_init(void)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">timerdev.nd &#x3D; of_find_node_by_path(&quot;&#x2F;gpioled&quot;);</span><br><span class="line">if (timerdev.nd&#x3D;&#x3D; NULL) &#123;</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timerdev.led_gpio &#x3D; of_get_named_gpio(timerdev.nd ,&quot;led-gpio&quot;, 0);</span><br><span class="line">if (timerdev.led_gpio &lt; 0) &#123;</span><br><span class="line">printk(&quot;can&#39;t get led\r\n&quot;);</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 初始化led所使用的IO *&#x2F;</span><br><span class="line">gpio_request(timerdev.led_gpio, &quot;led&quot;);&#x2F;* 请求IO *&#x2F;</span><br><span class="line">ret &#x3D; gpio_direction_output(timerdev.led_gpio, 1);</span><br><span class="line">if(ret &lt; 0) &#123;</span><br><span class="line">printk(&quot;can&#39;t set gpio!\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 打开设备</span><br><span class="line"> * @param - inode : 传递给驱动的inode</span><br><span class="line"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span><br><span class="line"> *   一般在open的时候将private_data指向设备结构体。</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int timer_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line">filp-&gt;private_data &#x3D; &amp;timerdev;&#x2F;* 设置私有数据 *&#x2F;</span><br><span class="line"></span><br><span class="line">timerdev.timeperiod &#x3D; 1000;&#x2F;* 默认周期为1s *&#x2F;</span><br><span class="line">ret &#x3D; led_init();&#x2F;* 初始化LED IO *&#x2F;</span><br><span class="line">if (ret &lt; 0) &#123;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: ioctl函数，</span><br><span class="line"> * @param - filp : 要打开的设备文件(文件描述符)</span><br><span class="line"> * @param - cmd : 应用程序发送过来的命令</span><br><span class="line"> * @param - arg : 参数</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static long timer_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">struct timer_dev *dev &#x3D;  (struct timer_dev *)filp-&gt;private_data;</span><br><span class="line">int timerperiod;</span><br><span class="line">unsigned long flags;</span><br><span class="line"></span><br><span class="line">switch (cmd) &#123;</span><br><span class="line">case CLOSE_CMD:&#x2F;* 关闭定时器 *&#x2F;</span><br><span class="line">del_timer_sync(&amp;dev-&gt;timer);</span><br><span class="line">break;</span><br><span class="line">case OPEN_CMD:&#x2F;* 打开定时器 *&#x2F;</span><br><span class="line">spin_lock_irqsave(&amp;dev-&gt;lock, flags);</span><br><span class="line">timerperiod &#x3D; dev-&gt;timeperiod;</span><br><span class="line">spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</span><br><span class="line">mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(timerperiod));</span><br><span class="line">break;</span><br><span class="line">case SETPERIOD_CMD: &#x2F;* 设置定时器周期 *&#x2F;</span><br><span class="line">spin_lock_irqsave(&amp;dev-&gt;lock, flags);</span><br><span class="line">dev-&gt;timeperiod &#x3D; arg;</span><br><span class="line">spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</span><br><span class="line">mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(arg));</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设备操作函数 *&#x2F;</span><br><span class="line">static struct file_operations timer_fops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; timer_open,</span><br><span class="line">.unlocked_ioctl &#x3D; timer_unlocked_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 定时器回调函数 *&#x2F;</span><br><span class="line">void timer_function(unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">struct timer_dev *dev &#x3D; (struct timer_dev *)arg;</span><br><span class="line">static int sta &#x3D; 1;</span><br><span class="line">int timerperiod;</span><br><span class="line">unsigned long flags;</span><br><span class="line"></span><br><span class="line">sta &#x3D; !sta;&#x2F;* 每次都取反，实现LED灯反转 *&#x2F;</span><br><span class="line">gpio_set_value(dev-&gt;led_gpio, sta);</span><br><span class="line"></span><br><span class="line">&#x2F;* 重启定时器 *&#x2F;</span><br><span class="line">spin_lock_irqsave(&amp;dev-&gt;lock, flags);</span><br><span class="line">timerperiod &#x3D; dev-&gt;timeperiod;</span><br><span class="line">spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</span><br><span class="line">mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(dev-&gt;timeperiod)); </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动入口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init timer_init(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 初始化自旋锁 *&#x2F;</span><br><span class="line">spin_lock_init(&amp;timerdev.lock);</span><br><span class="line"></span><br><span class="line">&#x2F;* 注册字符设备驱动 *&#x2F;</span><br><span class="line">&#x2F;* 1、创建设备号 *&#x2F;</span><br><span class="line">if (timerdev.major) &#123;&#x2F;*  定义了设备号 *&#x2F;</span><br><span class="line">timerdev.devid &#x3D; MKDEV(timerdev.major, 0);</span><br><span class="line">register_chrdev_region(timerdev.devid, TIMER_CNT, TIMER_NAME);</span><br><span class="line">&#125; else &#123;&#x2F;* 没有定义设备号 *&#x2F;</span><br><span class="line">alloc_chrdev_region(&amp;timerdev.devid, 0, TIMER_CNT, TIMER_NAME);&#x2F;* 申请设备号 *&#x2F;</span><br><span class="line">timerdev.major &#x3D; MAJOR(timerdev.devid);&#x2F;* 获取分配号的主设备号 *&#x2F;</span><br><span class="line">timerdev.minor &#x3D; MINOR(timerdev.devid);&#x2F;* 获取分配号的次设备号 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 2、初始化cdev *&#x2F;</span><br><span class="line">timerdev.cdev.owner &#x3D; THIS_MODULE;</span><br><span class="line">cdev_init(&amp;timerdev.cdev, &amp;timer_fops);</span><br><span class="line"></span><br><span class="line">&#x2F;* 3、添加一个cdev *&#x2F;</span><br><span class="line">cdev_add(&amp;timerdev.cdev, timerdev.devid, TIMER_CNT);</span><br><span class="line"></span><br><span class="line">&#x2F;* 4、创建类 *&#x2F;</span><br><span class="line">timerdev.class &#x3D; class_create(THIS_MODULE, TIMER_NAME);</span><br><span class="line">if (IS_ERR(timerdev.class)) &#123;</span><br><span class="line">return PTR_ERR(timerdev.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 5、创建设备 *&#x2F;</span><br><span class="line">timerdev.device &#x3D; device_create(timerdev.class, NULL, timerdev.devid, NULL, TIMER_NAME);</span><br><span class="line">if (IS_ERR(timerdev.device)) &#123;</span><br><span class="line">return PTR_ERR(timerdev.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 6、初始化timer，设置定时器处理函数,还未设置周期，所有不会激活定时器 *&#x2F;</span><br><span class="line">init_timer(&amp;timerdev.timer);</span><br><span class="line">timerdev.timer.function &#x3D; timer_function;</span><br><span class="line">timerdev.timer.data &#x3D; (unsigned long)&amp;timerdev; &#x2F;* 要传递给 function 函数的参数 *&#x2F;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动出口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void __exit timer_exit(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">gpio_set_value(timerdev.led_gpio, 1);&#x2F;* 卸载驱动的时候关闭LED *&#x2F;</span><br><span class="line">del_timer_sync(&amp;timerdev.timer);&#x2F;* 删除timer *&#x2F;</span><br><span class="line">#if 0</span><br><span class="line">del_timer(&amp;timerdev.tiemr);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 38~50 行，定时器设备结构体，在 48 行定义了一个定时器成员变量 timer。 </p><p>第 60~82 行，LED 灯初始化函数，从设备树中获取 LED 灯信息，然后初始化相应的 IO。 </p><p>第 91~102 行，函数 timer_open，对应应用程序的 open 函数，应用程序调用 open 函数打开/dev/timer 驱动文件的时候此函数就会执行。此函数设置文件私有数据为 timerdev，并且初始化定时周期默认为 1 秒，最后调用 led_init 函数初始化 LED 所使用的 IO。 </p><p>第 111~137 行，函数 timer_unlocked_ioctl，对应应用程序的 ioctl 函数，应用程序调用 ioctl函数向驱动发送控制信息，此函数响应并执行。此函数ioctl**(<strong>fd</strong>,** cmd**,** arg**);** 有三个参数：filp，cmd 和 arg，其中 filp是对应的设备文件，cmd 是应用程序发送过来的命令信息，arg 是应用程序发送过来的参数，在例程中 arg 参数表示定时周期。 </p><p>一共有三种命令 CLOSE_CMD，OPEN_CMD 和 SETPERIOD_CMD，这三个命令分别为关闭定时器、打开定时器、设置定时周期。这三个命令的左右如下： </p><p><strong>CLOSE_CMD</strong>：关闭定时器命令<strong>，</strong>调用 del_timer_sync 函数关闭定时器。 </p><p><strong>OPEN_CMD</strong>：打开定时器命令，调用 mod_timer 函数打开定时器，定时周期为 timerdev 的timeperiod 成员变量，定时周期默认是 1 秒。 </p><p><strong>SETPERIOD_CMD</strong>：设置定时器周期命令，参数 arg 就是新的定时周期，设置 timerdev 的timeperiod 成员变量为 arg 所表示定时周期指。并且使用 mod_timer 重新打开定时器，使定时器以新的周期运行。 </p><p>第 140~144 行，定时器驱动操作函数集 timer_fops。 </p><p>第 147~162 行，函数 timer_function，定时器服务函数，此函有一个参数 arg，在本例程中arg 参数就是 timerdev 的地址，这样通过 arg 参数就可以访问到设备结构体。当定时周期到了以后此函数就会被调用。在此函数中将 LED 灯的状态取反，实现 LED 灯闪烁的效果。因为内核定时器不是循环的定时器，执行一次以后就结束了，因此在 161 行又调用了 mod_timer 函数重新开启定时器。 </p><p>第 169~209 行，函数 timer_init，驱动入口函数。</p><p>在第 205~207 行初始化定时器，设置定时器的定时处理函数为 timer_function，另外设置要传递给 timer_function 函数的参数为 timerdev的地址。在此函数中并没有调用 timer_add 函数来开启定时器，因此定时器默认是关闭的，除非应用程序发送打开命令。 </p><p>第 216~231 行，驱动出口函数，在 219 行关闭 LED，也就是卸载驱动以后 LED 处于熄灭状态。第 220 行调用 del_timer_sync 函数删除定时器，也可以使用 del_timer 函数。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、内核时间管理简介&quot;&gt;&lt;a href=&quot;#1、内核时间管理简介&quot; class=&quot;headerlink&quot; title=&quot;1、内核时间管理简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、内核时间管理简介&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;Linux 要运行，需要一个系统时钟的，至</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-并发与竞争-自旋锁</title>
    <link href="https://guoqiang-gump.github.io/2021/04/15/Linux%E9%A9%B1%E5%8A%A8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89-%E8%87%AA%E6%97%8B%E9%94%81/"/>
    <id>https://guoqiang-gump.github.io/2021/04/15/Linux%E9%A9%B1%E5%8A%A8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89-%E8%87%AA%E6%97%8B%E9%94%81/</id>
    <published>2021-04-15T10:41:42.000Z</published>
    <updated>2021-04-15T11:36:09.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、自旋锁"><a href="#1、自旋锁" class="headerlink" title="1、自旋锁"></a>1、自旋锁</h2><p>当一个线程要访问某个共享资源的时候首先要先获取相应的锁，锁只能被一个线程持有，只要此线程不释放持有的锁，那么其他的线程就不能获取此锁。对于自旋锁而言，如果自旋锁正在被线程 A 持有，线程 B 想要获取自旋锁，那么线程 B 就会处于忙循环-旋转-等待状态，线程B不会进入休眠状态或者说去做其他的处理，而是会一直傻傻的在那里“转圈圈”的等待锁可用。(类别电话亭)</p><p>自旋锁的“自旋”也就是“原地打转”的意思，“原地打转”的目的是为了等待自旋锁可以用，可以访问共享资源。把自旋锁比作一个变量 a，变量 a=1 的时候表示共享资源可用，当 a=0 的时候表示共享资源不可用。现在线程 A 要访问共享资源，发现 a=0(自旋锁被其他线程持有)，那么线程 A 就会不断的查询 a 的值，直到 a=1。</p><p>从这里我们可以看到自旋锁的一个缺点：那就等待自旋锁的线程会一直处于自旋状态，这样会浪费处理器时间，降低系统性能，所以自旋锁的持有时间不能太长。所以自旋锁适用于短时期的轻量级加锁，如果遇到需要长时间持有锁的场景那就需要换其他的方法了。</p><p>Linux 内核使用结构体 spinlock_t 表示自旋锁，结构体定义如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct spinlock &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">    struct raw_spinlock rlock;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="line"># define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span><br><span class="line">        struct &#123;</span><br><span class="line">            u8 __padding[LOCK_PADSIZE];</span><br><span class="line">            struct lockdep_map dep_map;</span><br><span class="line">        &#125;;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line">&#125; spinlock_t;</span><br><span class="line"></span><br><span class="line">spinlock_t lock; &#x2F;&#x2F;定义自旋锁</span><br></pre></td></tr></table></figure><h3 id="自旋锁-API-函数"><a href="#自旋锁-API-函数" class="headerlink" title="自旋锁 API 函数"></a><strong>自旋锁</strong> <strong>API</strong> <strong>函数</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SPINLOCK(spinlock_t lock) &#x2F;&#x2F;定义并初始化一个自选变量。</span><br><span class="line">int spin_lock_init(spinlock_t *lock) &#x2F;&#x2F;初始化自旋锁。</span><br><span class="line">void spin_lock(spinlock_t *lock) &#x2F;&#x2F;获取指定的自旋锁，也叫做加锁。</span><br><span class="line">void spin_unlock(spinlock_t *lock) &#x2F;&#x2F;释放指定的自旋锁。</span><br><span class="line">int spin_trylock(spinlock_t *lock) &#x2F;&#x2F;尝试获取指定的自旋锁，如果没有获取到就返回 0</span><br><span class="line">int spin_is_locked(spinlock_t *lock)</span><br><span class="line">&#x2F;&#x2F;检查指定的自旋锁是否被获取，如果没有被获取就返回非0，否则返回 0。</span><br></pre></td></tr></table></figure><p>自旋锁API函数适用于SMP或支持抢占的单CPU下线程之间的并发访问，也就是用于线程与线程之间，被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API 函数，否则的话会可能会导致死锁现象的发生。</p><p><strong>死锁：</strong>自旋锁会自动禁止抢占，也就说当线程 A得到锁以后会暂时禁止内核抢占。如果线程 A 在持有锁期间进入了休眠状态，那么线程 A 会自动放弃 CPU 使用权。线程 B 开始运行，线程 B 也想要获取锁，但是此时锁被 A 线程持有，而 且内核抢占还被禁止了！线程 B 无法被调度出去，那么线程 A 就无法运行，锁也就无法释放，所以死锁发生了！ </p><p>API 函数用于线程之间的并发访问时，中断也想访问共享资源。中断里面可以使用自旋锁，但是在中断里面使用自旋锁的时候，在获取锁之前一定要先禁止本地中断(也就是本 CPU 中断，对于多核 SOC来说会有多个 CPU 核)，否则可能导致锁死现象的发生。线程 A 先运行，并且获取到了 lock 这个锁，当线程 A 运行 functionA 函数的时候中断发生了，中断抢走了 CPU 使用权。但是中断要执行的中断服务函数也要获取 lock 这个锁， 但是这个锁被线程 A 占有着，中断就会一直自旋，等待锁有效。但是在中断服务函数执行完之前，线程 A 是不可能执行的，线程 A 与中断僵持着，死锁发生！ 最好的解决方法就是获取锁之前关闭本地中断，Linux内核提供了相应的 API 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)</span><br><span class="line">&#x2F;&#x2F;保存中断状态，禁止本地中断，并获取自旋锁。</span><br><span class="line">void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)</span><br><span class="line">&#x2F;&#x2F;将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁。在释放锁的时候会恢复中断状态。</span><br></pre></td></tr></table></figure><p>下半部(BH)也会竞争共享资源，有些资料也会将下半部叫做底半部。如果要在下半部里面使用自旋锁，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void spin_lock_bh(spinlock_t *lock) &#x2F;&#x2F;关闭下半部，并获取自旋锁。</span><br><span class="line">void spin_unlock_bh(spinlock_t *lock) &#x2F;&#x2F;打开下半部，并释放自旋锁</span><br></pre></td></tr></table></figure><h3 id="其他类型的锁"><a href="#其他类型的锁" class="headerlink" title="其他类型的锁"></a><strong>其他类型的锁</strong></h3><p>在自旋锁的基础上还衍生出了其他特定场合使用的锁，这些锁在驱动中其实用的不多，更多的是在 <strong>Linux 内核</strong>中使用。</p><p><strong>1、读写自旋锁</strong></p><p>读写自旋锁为读和写操作提供了不同的锁，一次只能允许一个写操作，也就是只能一个线程持有写锁，而且不能进行读操作。但是当没有写操作的时候允许一个或多个线程持有读锁， 可以进行并发的读操作。也就是使用读写锁的时候读操作和写操作不能同时进行。</p><p><strong>2、顺序锁</strong></p><p>顺序锁在读写锁的基础上衍生而来的，使用顺序锁的话可以允许在写的时候进行读操作，也就是实现同时读写，但是不允许同时进行并发的写操作。虽然顺序锁的读和写操作可以同时进行，但是如果在读的过程中发生了写操作， 最好重新进行读取，保证数据完整性。</p><p>顺序锁保护的资源不能是指针，因为如果在写操作的时候可能会导致指针无效，而这个时候恰巧有读操作访问指针的话就可能导致意外发生，比如读取野指针导致系统崩溃。</p><h3 id="自旋锁使用注意事项"><a href="#自旋锁使用注意事项" class="headerlink" title="自旋锁使用注意事项"></a>自旋锁使用注意事项</h3><p>①、因为在等待自旋锁的时候处于“自旋”状态，因此锁的持有时间不能太长，一定要短，否则的话会降低系统性能。如果临界区比较大，运行时间比较长的话要选择其他的并发处理方式，比如稍后要讲的信号量和互斥体。</p><p>②、自旋锁保护的临界区内不能调用任何可能导致线程休眠的 API 函数，否则的话可能导致死锁。</p><p>③、不能递归申请自旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就必须“自旋”，等待锁被释放，然而你正处于“自旋”状态，根本没法释放锁。结果就是自己把自己锁死了！<br>④、在编写驱动程序的时候我们必须考虑到驱动的可移植性，因此不管你用的是单核的还是多核的 SOC，都将其当做多核 SOC 来编写驱动程序。</p><h2 id="2、实验程序编写"><a href="#2、实验程序编写" class="headerlink" title="2、实验程序编写"></a>2、<strong>实验程序编写</strong></h2><p>自旋锁保护的临界区要尽可能的短，因此在 open 函数中申请自旋锁，然后在 release 函 数中释放自旋锁的方法就不可取。我们可以使用一个变量来表示设备的使用情况，如果设备被使用了那么变量就加一，设备被释放以后变量就减 1，我们只需要使用自旋锁保护这个变量即可。 </p><p>下面通过定义一个变量 dev_stats 表示设备的使用情况，dev_stats为 0 的时候表示设备没有被使用，dev_stats 大于 0 的时候表示设备被使用。驱动 open 函数中先判断 dev_stats 是否为 0，也就是判断设备是否可用，如果为 0 的话就使用设备，并且将 dev_stats加 1，表示设备被使用了。使用完以后在 release 函数中将 dev_stats 减 1，表示设备没有被使用 了。因此真正实现设备互斥访问的是变量 dev_stats，但是我们要使用自旋锁对 dev_stats 来做保护。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: spinlock.c</span><br><span class="line">描述   : 自旋锁实验，使用自旋锁来实现对实现设备的互斥访问</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* gpioled设备结构体 *&#x2F;</span><br><span class="line">struct gpioled_dev&#123;</span><br><span class="line">int dev_stats;&#x2F;* 设备使用状态，0，设备未使用;&gt;0,设备已经被使用 *&#x2F;</span><br><span class="line">spinlock_t lock;&#x2F;* 自旋锁 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">struct gpioled_dev gpioled;&#x2F;* led设备 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 打开设备</span><br><span class="line"> * @param - inode : 传递给驱动的inode</span><br><span class="line"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span><br><span class="line"> *   一般在open的时候将private_data指向设备结构体。</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long flags;</span><br><span class="line">filp-&gt;private_data &#x3D; &amp;gpioled; &#x2F;* 设置私有数据 *&#x2F;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;gpioled.lock, flags);&#x2F;* 上锁 *&#x2F;</span><br><span class="line">if (gpioled.dev_stats) &#123;&#x2F;* 如果设备被使用了 *&#x2F;</span><br><span class="line">spin_unlock_irqrestore(&amp;gpioled.lock, flags);&#x2F;* 解锁 *&#x2F;</span><br><span class="line">return -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line">gpioled.dev_stats++;&#x2F;* 如果设备没有打开，那么就标记已经打开了 *&#x2F;</span><br><span class="line">spin_unlock_irqrestore(&amp;gpioled.lock, flags);&#x2F;* 解锁 *&#x2F;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 关闭&#x2F;释放设备</span><br><span class="line"> * @param - filp : 要关闭的设备文件(文件描述符)</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long flags;</span><br><span class="line">struct gpioled_dev *dev &#x3D; filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">&#x2F;* 关闭驱动文件的时候将dev_stats减1 *&#x2F;</span><br><span class="line">spin_lock_irqsave(&amp;dev-&gt;lock, flags);&#x2F;* 上锁 *&#x2F;</span><br><span class="line">if (dev-&gt;dev_stats) &#123;</span><br><span class="line">dev-&gt;dev_stats--;</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);&#x2F;* 解锁 *&#x2F;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动入口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init led_init(void)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;*  初始化自旋锁 *&#x2F;</span><br><span class="line">spin_lock_init(&amp;gpioled.lock);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 43 行，dev_stats 表示设备状态，如果为 0 的话表示设备还没有被使用，如果大于 0 的话就表示设备已经被使用了。 </p><p>第 44 行，定义自旋锁变量 lock。 </p><p>第 61~67 行，使用自旋锁实现对设备的互斥访问，第 61 行调用 spin_lock_irqsave 函数获取锁，为了考虑到驱动兼容性，这里并没有使用 spin_lock 函数来获取锁。第 62 行判断dev_stats 是否大于 0，如果是的话表示设备已经被使用了，那么就调用 spin_unlock_irqrestore函数释放锁，并且返回-EBUSY。如果设备没有被使用的话就在第 66 行将 dev_stats 加 1，表 示设备要被使用了，然后调用 spin_unlock_irqrestore 函数释放锁。自旋锁的工作就是保护dev_stats 变量，真正实现对设备互斥访问的是 dev_stats。 </p><p>第 126~131 行，在 release 函数中将 dev_stats 减 1，表示设备被释放了，可以被其他的应用 程序使用。将 dev_stats 减 1 的时候需要自旋锁对其进行保护。 </p><p>第 155 行，在驱动入口函数 led_init 中调用 spin_lock_init 函数初始化自旋锁。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、自旋锁&quot;&gt;&lt;a href=&quot;#1、自旋锁&quot; class=&quot;headerlink&quot; title=&quot;1、自旋锁&quot;&gt;&lt;/a&gt;1、自旋锁&lt;/h2&gt;&lt;p&gt;当一个线程要访问某个共享资源的时候首先要先获取相应的锁，锁只能被一个线程持有，只要此线程不释放持有的锁，那么其他的线</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-并发与竞争-信号量</title>
    <link href="https://guoqiang-gump.github.io/2021/04/15/Linux%E9%A9%B1%E5%8A%A8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89-%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>https://guoqiang-gump.github.io/2021/04/15/Linux%E9%A9%B1%E5%8A%A8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89-%E4%BF%A1%E5%8F%B7%E9%87%8F/</id>
    <published>2021-04-15T10:41:22.000Z</published>
    <updated>2021-04-15T11:41:32.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、信号量"><a href="#1、信号量" class="headerlink" title="1、信号量"></a>1、信号量</h1><p>信号量是同步的一种方式。Linux 内核也提供了信号量机制，信号量常常用于控制对共享资源的访问。相比于自旋锁，信号量可以使线程进入休眠状态。</p><p>A 与 B、C 合租了一套房子，这个房子只有一个厕所，一次只能一个人使用。某一天早上 A 去上厕所了，过了一会 B 也想用厕所，因为 A 在厕所里面，所以 B 只能等到 A 用来了才能进去。B 要么就一直在厕所门口等着， 等 A 出来，这个时候就相当于自旋锁。B 也可以告诉 A，让 A 出来以后通知他一下，然后 B 继续回房间睡觉，这个时候相当于信号量。</p><p>可以看出，使用信号量会提高处理器的使用效率，毕竟不用一直傻乎乎的在那里“自旋”等待。但是，信号量的开销要比自旋锁大，因为信号量使线程进入休眠状态以后会切换线程，切换线程就会有开销。总结一下信号量的特点：  </p><p>①、因为信号量可以使等待资源线程进入休眠状态，因此适用于那些占用资源比较久的场合。 </p><p>②、因此信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。 </p><p>③、如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势。</p><p>信号量有一个信号量值，相当于一个房子有 10 把钥匙，这 10 把钥匙就相当于信号量值为10。因此，可以通过信号量来控制访问共享资源的访问数量，如果要想进房间，那就要先获取一把钥匙，信号量值减 1，直到 10 把钥匙都被拿走，信号量值为 0，这个时候就不允许任何人 进入房间了，因为没钥匙了。如果有人从房间出来，那他要归还他所持有的那把钥匙，信号量值加 1，此时有 1 把钥匙了，那么可以允许进去一个人。相当于通过信号量控制访问资源的线程数，在初始化的时候将信号量值设置的大于 1，那么这个信号量就是计数型信号量，计数型信号量不能用于互斥访问，因为它允许多个线程同时访问共享资源。如果要互斥的访问共享资源那么信号量的值就不能大于 1，此时的信号量就是一个二值信号量。</p><h2 id="信号量-API-函数"><a href="#信号量-API-函数" class="headerlink" title="信号量 API 函数"></a><strong>信号量</strong> <strong>API</strong> <strong>函数</strong></h2><p>Linux 内核使用 semaphore 结构体表示信号量，结构体内容如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct semaphore &#123;</span><br><span class="line">     raw_spinlock_t lock;</span><br><span class="line">     unsigned int count;</span><br><span class="line">     struct list_head wait_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SEAMPHORE(name) &#x2F;&#x2F;定义一个信号量，并且设置信号量的值为 1。</span><br><span class="line">void sema_init(struct semaphore *sem, int val) &#x2F;&#x2F;初始化信号量 sem，设置信号量值为 val。</span><br><span class="line">void down(struct semaphore *sem)&#x2F;&#x2F;获取信号量，因为会导致休眠，因此不能在中断中使用。</span><br><span class="line">int down_trylock(struct semaphore *sem)</span><br><span class="line">&#x2F;&#x2F;尝试获取信号量，如果能获取到信号量就获取，并且返回 0。如果不能就返回非 0，并且不会进入休眠。</span><br><span class="line">int down_interruptible(struct semaphore *sem)</span><br><span class="line">&#x2F;&#x2F;获取信号量，使用down进入休眠状态的线程不能被信号打断。而使用此函数进入休眠以后是可以被信号打断的。</span><br><span class="line">void up(struct semaphore *sem) &#x2F;&#x2F;释放信号量</span><br></pre></td></tr></table></figure><p>信号量的使用如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct semaphore sem; &#x2F;* 定义信号量 *&#x2F;</span><br><span class="line">sema_init(&amp;sem, 1)； &#x2F;* 初始化信号量 *&#x2F;</span><br><span class="line">down(&amp;sem); &#x2F;* 申请信号量 *&#x2F;</span><br><span class="line">&#x2F;* 临界区 *&#x2F;</span><br><span class="line">up(&amp;sem); &#x2F;* 释放信号量 *&#x2F;</span><br></pre></td></tr></table></figure><h1 id="2、实验程序编写"><a href="#2、实验程序编写" class="headerlink" title="2、实验程序编写"></a>2、实验程序编写</h1><p>使用信号量实现了一次只能有一个应用程序访问 LED 灯，信号量可以导致休眠，因此信号量保护的临界区没有运行时间限制，可以在驱动的 open 函数申请信号量，然后在release 函数中释放信号量。但是信号量不能用在中断中，本节实验我们不会在中断中使用信号量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***************************************************************</span><br><span class="line">文件名: semaphore.c</span><br><span class="line">描述   : 信号量实验，使用信号量来实现对实现设备的互斥访问</span><br><span class="line">***************************************************************&#x2F;</span><br><span class="line">&#x2F;* gpioled设备结构体 *&#x2F;</span><br><span class="line">struct gpioled_dev&#123;</span><br><span class="line">struct semaphore sem;&#x2F;* 信号量 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct gpioled_dev gpioled;&#x2F;* led设备 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 打开设备</span><br><span class="line"> * @param - inode : 传递给驱动的inode</span><br><span class="line"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span><br><span class="line"> *   一般在open的时候将private_data指向设备结构体。</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_open(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data &#x3D; &amp;gpioled; &#x2F;* 设置私有数据 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 获取信号量 *&#x2F;</span><br><span class="line">if (down_interruptible(&amp;gpioled.sem)) &#123; &#x2F;* 获取信号量,进入休眠状态的进程可以被信号打断 *&#x2F;</span><br><span class="line">return -ERESTARTSYS;</span><br><span class="line">&#125;</span><br><span class="line">#if 0</span><br><span class="line">down(&amp;gpioled.sem);&#x2F;* 不能被信号打断 *&#x2F;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 关闭&#x2F;释放设备</span><br><span class="line"> * @param - filp : 要关闭的设备文件(文件描述符)</span><br><span class="line"> * @return : 0 成功;其他 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int led_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">struct gpioled_dev *dev &#x3D; filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">up(&amp;dev-&gt;sem);&#x2F;* 释放信号量，信号量值加1 *&#x2F;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * @description: 驱动入口函数</span><br><span class="line"> * @param : 无</span><br><span class="line"> * @return : 无</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int __init led_init(void)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;* 初始化信号量 *&#x2F;</span><br><span class="line">sema_init(&amp;gpioled.sem, 1);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 43 行，在设备结构体中添加一个信号量成员变量 sem。 第 60~65行，在 open函数中申请信号量，可以使用 down 函数，也可以使用 down_interruptible函数。如果信号量值大于等于 1 就表示可用，那么应用程序就会开始使用 LED 灯。如果信号量值为 0 就表示应用程序不能使用 LED 灯，此时应用程序就会进入到休眠状态。等到信号量值大于 1 的时候应用程序就会唤醒，申请信号量，获取 LED 灯使用权。</p><p>第 123 行，在 release 函数中调用 up 函数释放信号量，这样其他因为没有得到信号量而进入休眠状态的应用程序就会唤醒，获取信号量。</p><p>第 147 行，在驱动入口函数中调用 sema_init 函数初始化信号量 sem 的值为 1，相当于 sem是个二值信号量。</p><p>总结一下，当信号量 sem 为 1 的时候表示 LED 灯还没有被使用，如果应用程序 A 要使用LED 灯，先调用 open 函数打开/dev/gpioled，这个时候会获取信号量 sem，获取成功以后 sem 的值减 1 变为 0。如果此时应用程序 B 也要使用 LED 灯，调用 open 函数打开/dev/gpioled 就会因为信号量无效(值为 0)而进入休眠状态。当应用程序 A 运行完毕，调用 close 函数关闭/dev/gpioled的时候就会释放信号量 sem，此时信号量 sem 的值就会加 1，变为 1。信号量 sem 再次有效，表示其他应用程序可以使用 LED 灯了，此时在休眠状态的应用程序 A 就会获取到信号量 sem，获取成功以后就开始使用 LED 灯。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、信号量&quot;&gt;&lt;a href=&quot;#1、信号量&quot; class=&quot;headerlink&quot; title=&quot;1、信号量&quot;&gt;&lt;/a&gt;1、信号量&lt;/h1&gt;&lt;p&gt;信号量是同步的一种方式。Linux 内核也提供了信号量机制，信号量常常用于控制对共享资源的访问。相比于自旋锁，信号量</summary>
      
    
    
    
    
  </entry>
  
</feed>
